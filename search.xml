<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[79. Word Search]]></title>
    <url>%2F2018%2F07%2F24%2F79.%20Word%20Search%2F</url>
    <content type="text"><![CDATA[Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example: board = [ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;] ] Given word = &quot;ABCCED&quot;, return true. Given word = &quot;SEE&quot;, return true. Given word = &quot;ABCB&quot;, return false. 思路：还算是比较明显的dfs的题。 首先需要找到word首字母的位置，才能接着判断 接下来就是递归的过程，上下左右都有可能 同时为了避免当前再被递归到，需要将当前值先修改再恢复 代码 1234567891011121314151617181920212223242526class Solution &#123; public boolean exist(char[][] board, String word) &#123; if(word == null || word.length() == 0) return true; if(board == null || board.length == 0) return false; for(int i = 0;i &lt; board.length; i++)&#123; for(int j = 0;j &lt; board[0].length; j++)&#123; if(board[i][j] == word.charAt(0) &amp;&amp; exists(board, word, i, j, 0))&#123; return true; &#125; &#125; &#125; return false; &#125; public boolean exists(char[][] board, String word, int i, int j, int start)&#123; if(word.length() == start) return true; if(i &gt;= 0 &amp;&amp; i &lt; board.length &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].length &amp;&amp; board[i][j] == word.charAt(start))&#123; board[i][j] = '$'; boolean res = exists(board, word, i-1, j, start+1) || exists(board, word, i+1, j, start+1) || exists(board, word, i, j-1, start+1) || exists(board, word, i, j+1, start+1); board[i][j] = word.charAt(start); return res; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>算法</category>
        <category>刷题打卡</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>BackTracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第四范式]]></title>
    <url>%2F2018%2F07%2F19%2F%E7%AC%AC%E5%9B%9B%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[第四范式 Java 开发实习生 面试 一面 自我介绍 介绍一下项目 Exception &amp;&amp; Error synchronized关键字static修饰和没有static修饰 比如synchronized修饰方法，让循环输出1-10，new两个类，调用该线程 作用域不同，static修饰指同步类，输出两次1-10 非static修饰，是同步局部变量，不能确定结果 final修饰字段，方法，类 字段不可变 方法不可override 类不能被继承 String,StringBuilder,StringBuffer String不可变，源码是用final修饰的private数组，同时方法等没改变数组的值 StringBuilder，StringBuffer都可变，StringBuffer线程安全 ArrayList和LinkedList 同：实现List接口 异：ArrayList查 O(1),增删 O(n) LinkedList查 O(n),增删 O(1) 知不知道Dequeue? 实现最小栈GetMin() leetcode原题155.Min Stack Q: Exception &amp;&amp; Error A: Error和Exception都继承自Throwable； Exception： RuntimeException 类及其子类表示“JVM 常用操作”引发的错误 可以是可被控制（checked）或者不可控制（unchecked）； unchecked exception（非检查异常）: 运行时异常,比如常见的NullPointerException、IndexOutOfBoundsException。对于运行时异常，java编译器不要求必须进行异常捕获处理或者抛出声明，由程序员自行决定。 checked exception（检查异常，编译异常）: 非运行时异常,java编译器强制程序员必须进行捕获处理，比如常见的IOExeption和SQLException。对于非运行时异常如果不进行捕获或者抛出声明处理，编译都不会通过。 表示一个由程序员导致的错误； 应该在应用程序级被处理； Error： 大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。 总是不可控制的（unchecked）； 经常用来表示系统错误或者底层资源错误； 如果可能的话，应该在系统级被捕捉； 二面 自我介绍 项目介绍比较详细 问了下熟悉的技术]]></content>
      <categories>
        <category>面试经历</category>
        <category>2018</category>
        <category>实习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPS通信过程]]></title>
    <url>%2F2018%2F07%2F19%2FHTTPS%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取。所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。 HTTPS简介HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。具体是如何进行加密，解密，验证的，且看下图。 客户端发起HTTPS请求 这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。 服务端的配置 采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。 传送证书 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。 客户端解析证书 这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值。然后用*8证书对该随机值进行加密**。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。 传送加密信息 这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 服务段解密信息 服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 传输加密后的信息 这部分信息是服务段用私钥加密后的信息，可以在客户端被还原 客户端解密信息 客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。]]></content>
      <categories>
        <category>Java面试</category>
        <category>HTTPS</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸟一面]]></title>
    <url>%2F2018%2F07%2F19%2F%E8%8F%9C%E9%B8%9F%E4%B8%80%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[说了下午有事，就简单聊了半个小时 为什么要用多线程 线程是不是越多效率越快？ 怎么控制线程，尽可能减少上下文切换？或者说有没有一种方式达到了多线程的效果，但是避免了上下文切换？ 提示concurrent包里有 讲一下Spring IOC，为什么要控制反转？目的是啥？IOC的过程？ 两个int型的set求交集？ 求交集的同时，还要给出相同的数字的个数？ 如果set特别大，大到无法在内存处理，怎么办？ Linux的了解？ 问微软的pipeline导入为什么能提高效率？ 问了下职业规划]]></content>
      <categories>
        <category>面试经历</category>
        <category>2018</category>
        <category>秋招</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keep]]></title>
    <url>%2F2018%2F07%2F17%2FKeep%2F</url>
    <content type="text"><![CDATA[Keep Java 开发实习生 面试 一面 自我介绍 问项目 int[]数组长度为n，问数组中连续m个数的最大值 链表反转 20w条ip地址的数据，给一个ip地址，怎么找到？ 设计用户发微博的数据库，以及查看首页功能 首页时间线表，但对于大V发微博，告知关注者的时间线处理有问题 微博用户群组问题，怎么做到分群组？ 图的BFS 对设计的微博的表，怎么建索引？建索引为什么会快？ http和https的区别？https的加密过程？ Q：哪些情况需要加索引？ 在经常需要搜索的列上，可以加快搜索的速度； 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构； 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度； 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的； 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间； 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 Q：哪些情况不需要加索引？ 第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。 第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。 Q：数据库建立索引为什么会加快查询速度？ 首先明白为什么索引会增加速度，DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。 HTTPS通信过程 二面 介绍项目 垃圾回收策略 HotSpot垃圾收集器，G1的特点，优缺点… 垃圾收集器与内存分配策略 为什么Eden: Survivor: Survivor是8:1:1 ? IOC，IOC的初始化过程？ AOP，AOP的动态代理怎么做？ InvocationHandler接口 concurrent包里有些啥？ ThreadPoolExecutor类得看源码 Java锁机制，Java怎么实现CAS的？多线程i++问题？AtomicInteger？UnSafe类？]]></content>
      <categories>
        <category>面试经历</category>
        <category>2018</category>
        <category>实习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对Spring IOC和AOP的理解]]></title>
    <url>%2F2018%2F07%2F15%2FSpring%20IOC%20AOP%2F</url>
    <content type="text"><![CDATA[在面试中，经常会问，说说你对Spring IOC和AOP的理解，问题很宽泛，似乎不知道从何说起。 回答思路： 先用通俗易懂的话解释下何为IOC和AOP 各自的实现原理 自己的项目中如何使用 以下是个人的一些总结，仅供参考。 IOC许多应用都是通过彼此间的相互合作来实现业务逻辑的，如类A要调用类B的方法，以前我们都是在类A中，通过自身new一个类B，然后在调用类B的方法，现在我们把new类B的事情交给Spring来做，在我们调用的时候，容器会为我们实例化。 IOC容器的初始化过程 资源定位，即定义bean的xml 载入 IOC容器注册，注册beanDefinition IOC容器的初始化过程，一般不包含bean的依赖注入的实现，在Spring IOC设计中，bean的注册和依赖注入是两个过程，依赖注入一般发生在应用第一次索取bean的时候，但是也可以在xm中配置，在容器初始化的时候，这个bean就完成了初始化。 三种注入方式： 构造器 接口 set注入(常用) bean是如何创建——工厂模式 数据是如何注入——反射 IOC的定义及实现原理 AOP面向切面编程，在我们的应用中，经常需要做一些事情，但是这些事情与核心业务无关，比如，要记录所有update*方法的执行时间时间，操作人等等信息，记录到日志， 通过Spring的AOP技术，就可以在不修改update*的代码的情况下完成该需求。 AOP的好处就是你只需要干你的正事，其它事情别人帮你干。 从Spring的角度看，AOP最大的用途就在于提供了事务管理的能力。事务管理就是一个关注点，你的正事就是去访问数据库，而你不想管事务（太烦），所以，Spring在你访问数据库之前，自动帮你开启事务，当你访问数据库结束之后，自动帮你提交/回滚事务！ AOP的实现原理——代理 AOP的应用的三种实现方式]]></content>
      <categories>
        <category>Java面试</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AOP的应用的三种实现方式]]></title>
    <url>%2F2018%2F07%2F15%2FAOP%E7%9A%84%E5%BA%94%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Spring有两大核心，IOC和AOP。IOC在java web项目中无时无刻不在使用。然而AOP用的比较少，的确也是一般的项目用的场所不多。事务控制基本都用，但却是Spring封装的不需要我们再去实现，但Spring的AOP远不止这些。 概念术语 在开始之前，需要理解Spring AOP的一些基本的概念术语(总结的个人理解，并非Spring官方定义)： 切面(aspect)：用来切插业务方法的类。 连接点(joinpoint)：是切面类和业务类的连接点，其实就是封装了业务方法的一些基本属性，作为通知的参数来解析。 通知(advice)：在切面类中，声明对业务方法做额外处理的方法。 切入点(pointcut)：业务类中指定的方法，作为切面切入的点。其实就是指定某个方法作为切面切的地方。 目标对象(target object)：被代理对象。 AOP代理(aop proxy)：代理对象。 AOP通知类型： 前置通知(before advice)：在切入点之前执行。 后置通知(after returning advice)：在切入点执行完成后，执行通知。 环绕通知(around advice)：包围切入点，调用方法前后完成自定义行为。 异常通知(after throwing advice)：在切入点抛出异常后，执行通知。 Spring AOP环境要在项目中使用Spring AOP则需要在项目中导入除了spring jar包之外，还有aspectjweaver.jar，aopalliance.jar，asm.jar和cglib.jar 。 好了，前提工作准备完成，Spring提供了很多的实现AOP的方式，在学习过程中，循序渐进。进行Spring接口方式，Schema配置方式和注解的三种方式进行学习。好了废话不多说了，开始Spring AOP学习之旅： AOP接口利用Spring AOP接口实现AOP，主要是为了指定自定义通知来供Spring AOP机制识别。主要接口：前置通知 MethodBeforeAdvice，后置通知：AfterReturningAdvice，环绕通知：MethodInterceptor，异常通知：ThrowsAdvice 。见例子代码： 业务接口：1234567891011121314151617181920212223242526272829303132333435/** * 代理类接口，也是业务类接口 * * 利用接口的方式，spring aop 将默认通过jdk 动态代理来实现代理类 * 不利用接口，则spring aop 将通过cglib 来实现代理类 * * */public interface IBaseBusiness &#123; /** * 用作代理的切入点方法 * * @param obj * @return */ public String delete(String obj); /** * 这方法不被切面切 * * @param obj * @return */ public String add(String obj); /** * 这方法切不切呢？可以设置 * * @param obj * @return */ public String modify(String obj);&#125; 业务类：1234567891011121314151617181920212223242526/** * 业务类，也是目标对象 * * */public class BaseBusiness implements IBaseBusiness &#123; /** * 切入点 */ public String delete(String obj) &#123; System.out.println("==========调用切入点：" + obj + "说：你敢删除我！===========\n"); return obj + "：瞄～"; &#125; public String add(String obj) &#123; System.out.println("================这个方法不能被切。。。============== \n"); return obj + "：瞄～ 嘿嘿！"; &#125; public String modify(String obj) &#123; System.out.println("=================这个也设置加入切吧====================\n"); return obj + "：瞄改瞄啊！"; &#125;&#125; 通知类： 前置通知： 123456789101112131415161718192021222324/** * 前置通知。 * * */public class BaseBeforeAdvice implements MethodBeforeAdvice &#123; /** * method : 切入的方法 * args ：切入方法的参数 * target ：目标对象 */ @Override public void before(Method method, Object[] args, Object target) throws Throwable &#123; System.out.println("===========进入beforeAdvice()============ \n"); System.out.print("准备在" + target + "对象上用"); System.out.print(method + "方法进行对 '"); System.out.print(args[0] + "'进行删除！\n\n"); System.out.println("要进入切入点方法了 \n"); &#125;&#125; 后置通知： 12345678910111213141516171819202122232425/** * 后置通知 * * */public class BaseAfterReturnAdvice implements AfterReturningAdvice &#123; /** * returnValue ：切入点执行完方法的返回值，但不能修改 * method ：切入点方法 * args ：切入点方法的参数数组 * target ：目标对象 */ @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123; System.out.println("==========进入afterReturning()=========== \n"); System.out.println("切入点方法执行完了 \n"); System.out.print(args[0] + "在"); System.out.print(target + "对象上被"); System.out.print(method + "方法删除了"); System.out.print("只留下：" + returnValue + "\n\n"); &#125;&#125; 环绕通知： 123456789101112131415161718192021222324252627282930313233343536/** * 环绕通知 * * */public class BaseAroundAdvice implements MethodInterceptor &#123; /** * invocation ：连接点 */ @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; System.out.println("===========进入around环绕方法！=========== \n"); // 调用目标方法之前执行的动作 System.out.println("调用方法之前: 执行！\n"); // 调用方法的参数 Object[] args = invocation.getArguments(); // 调用的方法 Method method = invocation.getMethod(); // 获取目标对象 Object target = invocation.getThis(); // 执行完方法的返回值：调用proceed()方法，就会触发切入点方法执行 Object returnValue = invocation.proceed(); System.out.println("===========结束进入around环绕方法！=========== \n"); System.out.println("输出：" + args[0] + ";" + method + ";" + target + ";" + returnValue + "\n"); System.out.println("调用方法结束：之后执行！\n"); return returnValue; &#125;&#125; 异常通知： 123456789101112131415161718192021222324/** * 异常通知，接口没有包含任何方法。通知方法自定义 * * */public class BaseAfterThrowsAdvice implements ThrowsAdvice &#123; /** * 通知方法，需要按照这种格式书写 * * @param method * 可选：切入的方法 * @param args * 可选：切入的方法的参数 * @param target * 可选：目标对象 * @param throwable * 必填 : 异常子类，出现这个异常类的子类，则会进入这个通知。 */ public void afterThrowing(Method method, Object[] args, Object target, Throwable throwable) &#123; System.out.println("删除出错啦"); &#125;&#125; 定义指定切点：12345678910111213141516171819202122232425262728/** * 定义一个切点，指定对应方法匹配。来供切面来针对方法进行处理&lt;br&gt; * * 继承NameMatchMethodPointcut类，来用方法名匹配 * * */public class Pointcut extends NameMatchMethodPointcut &#123; private static final long serialVersionUID = 3990456017285944475L; @SuppressWarnings("rawtypes") @Override public boolean matches(Method method, Class targetClass) &#123; // 设置单个方法匹配 this.setMappedName("delete"); // 设置多个方法匹配 String[] methods = &#123; "delete", "modify" &#125;; //也可以用“ * ” 来做匹配符号 // this.setMappedName("get*"); this.setMappedNames(methods); return super.matches(method, targetClass); &#125;&#125; 配置：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd" default-autowire="byName"&gt; &lt;!-- ==============================利用spring自己的aop配置================================ --&gt; &lt;!-- 声明一个业务类 --&gt; &lt;bean id="baseBusiness" class="aop.base.BaseBusiness" /&gt; &lt;!-- 声明通知类 --&gt; &lt;bean id="baseBefore" class="aop.base.advice.BaseBeforeAdvice" /&gt; &lt;bean id="baseAfterReturn" class="aop.base.advice.BaseAfterReturnAdvice" /&gt; &lt;bean id="baseAfterThrows" class="aop.base.advice.BaseAfterThrowsAdvice" /&gt; &lt;bean id="baseAround" class="aop.base.advice.BaseAroundAdvice" /&gt; &lt;!-- 指定切点匹配类 --&gt; &lt;bean id="pointcut" class="aop.base.pointcut.Pointcut" /&gt; &lt;!-- 包装通知，指定切点 --&gt; &lt;bean id="matchBeforeAdvisor" class="org.springframework.aop.support.DefaultPointcutAdvisor"&gt; &lt;property name="pointcut"&gt; &lt;ref bean="pointcut" /&gt; &lt;/property&gt; &lt;property name="advice"&gt; &lt;ref bean="baseBefore" /&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 使用ProxyFactoryBean 产生代理对象 --&gt; &lt;bean id="businessProxy" class="org.springframework.aop.framework.ProxyFactoryBean"&gt; &lt;!-- 代理对象所实现的接口 ，如果有接口可以这样设置 --&gt; &lt;property name="proxyInterfaces"&gt; &lt;value&gt;aop.base.IBaseBusiness&lt;/value&gt; &lt;/property&gt; &lt;!-- 设置目标对象 --&gt; &lt;property name="target"&gt; &lt;ref local="baseBusiness" /&gt; &lt;/property&gt; &lt;!-- 代理对象所使用的拦截器 --&gt; &lt;property name="interceptorNames"&gt; &lt;list&gt; &lt;value&gt;matchBeforeAdvisor&lt;/value&gt; &lt;value&gt;baseAfterReturn&lt;/value&gt; &lt;value&gt;baseAround&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类：123456789public class Debug &#123;public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext("aop/schema_aop.xml"); IBaseBusiness business = (IBaseBusiness ) context.getBean("businessProxy"); business.delete("猫"); &#125;&#125; 具体的代码实现可以从代码注释中很容易理解接口方式的实现。结果也可想而知，前置方法会在切入点方法之前执行，后置会在切入点方法执行之后执行，环绕则会在切入点方法执行前执行同时方法结束也会执行对应的部分。主要是调用proceed()方法来执行切入点方法。来作为环绕通知前后方法的分水岭。然后在实现的过程中，有几点却是可以细揣摩一下的。 可以看出在xml配置businessProxy这个bean的时候，ProxyFactoryBean类中指定了，proxyInterfaces参数。这里我把他配置了IBaseBusiness接口。因为在项目开发过程中，往往业务类都会有对应的接口，以方便利用IOC解耦。但Spring AOP却也能支持没有接口的代理。这就是为什么需要导入cglib.jar的包。看过spring的源码，知道在目标切入对象如果有实现接口，spring会默认走jdk动态代理来实现代理类。如果没有接口，则会通过cglib来实现代理类。 这个业务类现在有前置通知，后置通知，环绕三个通知同时作用，可能以及更多的通知进行作用。那么这些通知的执行顺序是怎么样的？就这个例子而言，同时实现了三个通知。在例子xml中，则显示执行before通知，然后执行around的前处理，执行切点方法，再执行return处理。最后执行around的后处理。经过测试，知道spring处理顺序是按照xml配置顺序依次处理通知，以队列的方式存放前通知，以压栈的方式存放后通知。所以是前通知依次执行，后通知到切入点执行完之后，从栈里在后进先出的形式把后通知执行。 在实现过程中发现通知执行对应目标对象的整个类中的方法，如何精确到某个方法，则需要定义一个切点匹配的方式：spring提供了方法名匹配或正则方式来匹配。然后通过DefaultPointcutAdvisor来包装通知，指定切点. 利用方式一的配置起来，可见代码还是非常的厚重的，定义一个切面就要定义一个切面类，然而切面类中，就一个通知方法，着实没有必要。所以Spring提供了，依赖aspectj的schema配置和基于aspectj 注解方式。这两种方式非常简介方便使用，也是项目中普遍的使用方式。梳理之： schema配置业务类：1234567891011121314151617181920212223242526/** * 业务类 * * */public class AspectBusiness &#123; /** * 切入点 */ public String delete(String obj) &#123; System.out.println("==========调用切入点：" + obj + "说：你敢删除我！===========\n"); return obj + "：瞄～"; &#125; public String add(String obj) &#123; System.out.println("================这个方法不能被切。。。============== \n"); return obj + "：瞄～ 嘿嘿！"; &#125; public String modify(String obj) &#123; System.out.println("=================这个也设置加入切吧====================\n"); return obj + "：瞄改瞄啊！"; &#125;&#125; 切面类：切面类中，包含了所有的通知 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * 定义一个切面 * * */public class AspectAdvice &#123; /** * 前置通知 * * @param jp */ public void doBefore(JoinPoint jp) &#123; System.out.println("===========进入before advice============ \n"); System.out.print("准备在" + jp.getTarget().getClass() + "对象上用"); System.out.print(jp.getSignature().getName() + "方法进行对 '"); System.out.print(jp.getArgs()[0] + "'进行删除！\n\n"); System.out.println("要进入切入点方法了 \n"); &#125; /** * 后置通知 * * @param jp * 连接点 * @param result * 返回值 */ public void doAfter(JoinPoint jp, String result) &#123; System.out.println("==========进入after advice=========== \n"); System.out.println("切入点方法执行完了 \n"); System.out.print(jp.getArgs()[0] + "在"); System.out.print(jp.getTarget().getClass() + "对象上被"); System.out.print(jp.getSignature().getName() + "方法删除了"); System.out.print("只留下：" + result + "\n\n"); &#125; /** * 环绕通知 * * @param pjp * 连接点 */ public void doAround(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println("===========进入around环绕方法！=========== \n"); // 调用目标方法之前执行的动作 System.out.println("调用方法之前: 执行！\n"); // 调用方法的参数 Object[] args = pjp.getArgs(); // 调用的方法名 String method = pjp.getSignature().getName(); // 获取目标对象 Object target = pjp.getTarget(); // 执行完方法的返回值：调用proceed()方法，就会触发切入点方法执行 Object result = pjp.proceed(); System.out.println("输出：" + args[0] + ";" + method + ";" + target + ";" + result + "\n"); System.out.println("调用方法结束：之后执行！\n"); &#125; /** * 异常通知 * * @param jp * @param e */ public void doThrow(JoinPoint jp, Throwable e) &#123; System.out.println("删除出错啦"); &#125;&#125; 配置文件：12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd" default-autowire="byName"&gt; &lt;!-- ==============================利用spring 利用aspectj来配置AOP================================ --&gt; &lt;!-- 声明一个业务类 --&gt; &lt;bean id="aspectBusiness" class="aop.schema.AspectBusiness" /&gt; &lt;!-- 声明通知类 --&gt; &lt;bean id="aspectAdvice" class="aop.schema.advice.AspectAdvice" /&gt; &lt;aop:config&gt; &lt;aop:aspect id="businessAspect" ref="aspectAdvice"&gt; &lt;!-- 配置指定切入的对象 --&gt; &lt;aop:pointcut id="point_cut" expression="execution(* aop.schema.*.*(..))" /&gt; &lt;!-- 只匹配add方法作为切入点 &lt;aop:pointcut id="except_add" expression="execution(* aop.schema.*.add(..))" /&gt; --&gt; &lt;!-- 前置通知 --&gt; &lt;aop:before method="doBefore" pointcut-ref="point_cut" /&gt; &lt;!-- 后置通知 returning指定返回参数 --&gt; &lt;aop:after-returning method="doAfter" pointcut-ref="point_cut" returning="result" /&gt; &lt;aop:around method="doAround" pointcut-ref="point_cut"/&gt; &lt;aop:after-throwing method="doThrow" pointcut-ref="point_cut" throwing="e"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试类：123456789public class Debug &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext("aop/schema_aop.xml"); AspectBusiness business = (AspectBusiness) context.getBean("aspectBusiness"); business.delete("猫"); &#125;&#125; aspectj注解注解在项目中已经到处都是了，撇开一些优劣不提，开发的便利性和可读性是非常的方便的。用来配置Spring AOP也非常简单便利 业务类：123456789101112131415161718192021222324252627/** * 业务类 * * */@Componentpublic class Business &#123; /** * 切入点 */ public String delete(String obj) &#123; System.out.println("==========调用切入点：" + obj + "说：你敢删除我！===========\n"); return obj + "：瞄～"; &#125; public String add(String obj) &#123; System.out.println("================这个方法不能被切。。。============== \n"); return obj + "：瞄～ 嘿嘿！"; &#125; public String modify(String obj) &#123; System.out.println("=================这个也设置加入切吧====================\n"); return obj + "：瞄改瞄啊！"; &#125;&#125; 切面类：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * 定义切面 * * @Aspect : 标记为切面类 * @Pointcut : 指定匹配切点 * @Before : 指定前置通知，value中指定切入点匹配 * @AfterReturning ：后置通知，具有可以指定返回值 * @AfterThrowing ：异常通知 * * */@Component@Aspectpublic class AspectAdvice &#123; /** * 指定切入点匹配表达式，注意它是以方法的形式进行声明的。 */ @Pointcut("execution(* aop.annotation.*.*(..))") public void anyMethod() &#123; &#125; /** * 前置通知 * * @param jp */ @Before(value = "execution(* aop.annotation.*.*(..))") public void doBefore(JoinPoint jp) &#123; System.out.println("===========进入before advice============ \n"); System.out.print("准备在" + jp.getTarget().getClass() + "对象上用"); System.out.print(jp.getSignature().getName() + "方法进行对 '"); System.out.print(jp.getArgs()[0] + "'进行删除！\n\n"); System.out.println("要进入切入点方法了 \n"); &#125; /** * 后置通知 * * @param jp * 连接点 * @param result * 返回值 */ @AfterReturning(value = "anyMethod()", returning = "result") public void doAfter(JoinPoint jp, String result) &#123; System.out.println("==========进入after advice=========== \n"); System.out.println("切入点方法执行完了 \n"); System.out.print(jp.getArgs()[0] + "在"); System.out.print(jp.getTarget().getClass() + "对象上被"); System.out.print(jp.getSignature().getName() + "方法删除了"); System.out.print("只留下：" + result + "\n\n"); &#125; /** * 环绕通知 * * @param pjp * 连接点 */ @Around(value = "execution(* aop.annotation.*.*(..))") public void doAround(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println("===========进入around环绕方法！=========== \n"); // 调用目标方法之前执行的动作 System.out.println("调用方法之前: 执行！\n"); // 调用方法的参数 Object[] args = pjp.getArgs(); // 调用的方法名 String method = pjp.getSignature().getName(); // 获取目标对象 Object target = pjp.getTarget(); // 执行完方法的返回值：调用proceed()方法，就会触发切入点方法执行 Object result = pjp.proceed(); System.out.println("输出：" + args[0] + ";" + method + ";" + target + ";" + result + "\n"); System.out.println("调用方法结束：之后执行！\n"); &#125; /** * 异常通知 * * @param jp * @param e */ @AfterThrowing(value = "execution(* aop.annotation.*.*(..))", throwing = "e") public void doThrow(JoinPoint jp, Throwable e) &#123; System.out.println("删除出错啦"); &#125;&#125; 配置：12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd" default-autowire="byName"&gt; &lt;context:component-scan base-package="aop.annotation" /&gt; &lt;!-- 打开aop 注解 --&gt; &lt;aop:aspectj-autoproxy /&gt;&lt;/beans&gt; 测试类：123456789101112131415/** * 测试类 * * */public class Debug &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext("aop/annotation_aop.xml"); Business business = (Business) context.getBean("business"); business.delete("猫"); &#125;&#125;]]></content>
      <categories>
        <category>Java面试</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AOP的定义实现原理——代理]]></title>
    <url>%2F2018%2F07%2F13%2F%E7%90%86%E8%A7%A3AOP%2F</url>
    <content type="text"><![CDATA[Aspect Oriented Programming面向切面编程。解耦是程序员编码开发过程中一直追求的。AOP也是为了解耦所诞生。 具体思想是：定义一个切面，在切面的纵向定义处理方法，处理完成之后，回到横向业务流。 AOP在Spring框架中被作为核心组成部分之一，的确Spring将AOP发挥到很强大的功能。最常见的就是事务控制。 AOP 主要是利用代理模式的技术来实现的。 静态代理 就是设计模式中的proxy模式 业务接口 12345678/** * 抽象主题角色：声明了真实主题和代理主题的共同接口 */public interface ITalk &#123; public void talk(String msg);&#125; 业务实现 12345678910111213141516171819202122232425262728293031323334/** * 真实主题角色：定义真实的对象 */public class PeopleTalk implements ITalk &#123; public String username; public String age; public PeopleTalk(String username, String age) &#123; this.username = username; this.age = age; &#125; public void talk(String msg) &#123; System.out.println(msg + "!你好,我是" + username + "，我年龄是" + age); &#125; public String getName() &#123; return username; &#125; public void setName(String name) &#123; this.username = name; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = age; &#125;&#125; 代理对象 1234567891011121314151617181920212223242526/** * 代理主题角色：内部包含对真实主题的引用，并且提供和真实主题角色相同的接口 */public class TalkProxy implements ITalk &#123; private ITalk talker; public TalkProxy(ITalk talker) &#123; // super(); this.talker = talker; &#125; public void talk(String msg) &#123; talker.talk(msg); &#125; public void talk(String msg, String singname) &#123; talker.talk(msg); sing(singname); &#125; private void sing(String singname) &#123; System.out.println("唱歌：" + singname); &#125;&#125; 测试类 1234567891011121314151617/** * 代理测试类，使用代理 */public class ProxyPattern &#123; public static void main(String[] args) &#123; // 不需要执行额外方法的。 ITalk people = new PeopleTalk("AOP", "18"); people.talk("No ProXY Test"); System.out.println("-----------------------------"); // 需要执行额外方法的（切面） TalkProxy talker = new TalkProxy(people); talker.talk("ProXY Test", "代理"); &#125;&#125; 从这段代码可以看出来，代理模式其实就是AOP的雏形。上端代码中talk(String msg, String singname)是一个切面。在代理类中的sing(singname)方法是个后置处理方法。 这样就实现了，其他的辅助方法和业务方法的解耦。业务不需要专门去调用，而是走到talk方法，顺理成章的调用sing方法 再从这段代码看： 要实现代理方式，必须要定义接口。 每个业务类，需要一个代理类。 动态代理 jdk1.5中提供，利用反射。实现InvocationHandler接口。 业务接口还是必须得，业务接口，业务类同上。 代理类 12345678910111213141516171819202122232425262728293031323334353637383940/** * 动态代理类 */public class DynamicProxy implements InvocationHandler &#123; /** 需要代理的目标类 */ private Object target; /** * 写法固定，aop专用:绑定委托对象并返回一个代理类 * * @param delegate * @return */ public Object bind(Object target) &#123; this.target = target; return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; /** * @param Object * target：指被代理的对象。 * @param Method * method：要调用的方法 * @param Object * [] args：方法调用时所需要的参数 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result = null; // 切面之前执行 System.out.println("切面之前执行"); // 执行业务 result = method.invoke(target, args); // 切面之后执行 System.out.println("切面之后执行"); return result; &#125;&#125; 测试类 1234567891011/** * 测试类 */public class Test &#123; public static void main(String[] args) &#123; // 绑定代理，这种方式会在所有的方法都加上切面方法 ITalk iTalk = (ITalk) new DynamicProxy().bind(new PeopleTalk()); iTalk.talk("业务说明"); &#125;&#125; 输出结果会是： 切面之前执行 people talk业务说明 切面之后执行 说明只要在业务调用方法切面之前，是可以动态的加入需要处理的方法。 从代码来看，如果再建立一个业务模块，也只需要一个代理类。ITalk iTalk = (ITalk) new DynamicProxy().bind(new PeopleTalk()); 将业务接口和业务类绑定到动态代理类。 但是这种方式：还是需要定义接口。 利用cglib CGLIB是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强。采用的是继承的方式。 业务类 12345678910/** * 业务类 */public class PeopleTalk &#123; public void talk(String msg) &#123; System.out.println("people talk" + msg); &#125;&#125; cglib代理类 12345678910111213141516171819202122232425262728293031323334/** * 使用cglib动态代理 * */public class CglibProxy implements MethodInterceptor &#123; private Object target; /** * 创建代理对象 * * @param target * @return */ public Object getInstance(Object target) &#123; this.target = target; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(this.target.getClass()); // 回调方法 enhancer.setCallback(this); // 创建代理对象 return enhancer.create(); &#125; @Override public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; Object result = null; System.out.println("事物开始"); result = methodProxy.invokeSuper(proxy, args); System.out.println("事物结束"); return result; &#125;&#125; 测试类 12345678910111213/** * 测试类 * */public class Test &#123; public static void main(String[] args) &#123; PeopleTalk peopleTalk = (PeopleTalk) new CglibProxy().getInstance(new PeopleTalk()); peopleTalk.talk("业务方法"); peopleTalk.spreak("业务方法"); &#125;&#125; 最后输出结果： 事物开始 people talk业务方法 事物结束 事物开始 spreak chinese业务方法 事物结束]]></content>
      <categories>
        <category>Java面试</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOC的定义及实现原理——反射]]></title>
    <url>%2F2018%2F07%2F13%2FSpring%20IOC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[IOC(DI)Java程序员都知道：Java程序中的每个业务逻辑至少需要两个或以上的对象来协作完成，通常，每个对象在使用他的合作对象时，自己均要使用像new object()这样的语法来完成合作对象的申请工作。你会发现，对象间的耦合度高了。而IOC的思想是: Spring容器来实现这些相互依赖对象的创建、协调工作。对象只需要关系业务逻辑本身就可以了。从这方面来说，对象如何得到他的协作对象的责任被反转了(IOC、DI)。 DI其实就是IOC的另外一种说法。DI是由Martin Fowler 在2004年初的一篇论文中首次提出的。他总结：控制的什么被反转了？就是：获得依赖对象的方式反转了。 IOC与DI首先想说说IOC(Inversion of Control，控制倒转)。这是Spring的核心，贯穿始终。所谓IOC，对于Spring框架来说，就是由Spring来负责控制对象的生命周期和对象间的关系。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。 那么IOC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，所有的类都会在Spring容器中登记，告诉Spring你是个什么东西，你需要什么东西，然后Spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由Spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是Spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被Spring控制，所以这叫控制反转。 IOC的一个重点是在系统运行中，动态地向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了Spring我们就只需要告诉Spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，Spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖Connection才能正常运行，而这个Connection是由Spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢? Java 1.3之后一个重要特征是反射(reflection)，它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，Spring就是通过反射来实现注入的。 Spring是怎么运行的123456public static void main(String[] args) &#123; ApplicationContext context = new FileSystemXmlApplicationContext( "applicationContext.xml"); Animal animal = (Animal) context.getBean("animal"); animal.say();&#125; applicationContext.xml: 123&lt;bean id="animal" class="phz.springframework.test.Cat"&gt; &lt;property name="name" value="kitty" /&gt;&lt;/bean&gt; 类phz.springframework.test.Cat: 123456789public class Cat implements Animal &#123; private String name; public void say() &#123; System.out.println("I am " + name + "!"); &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 实现了phz.springframework.test.Animal接口: 123public interface Animal &#123; public void say();&#125; 很明显上面的代码输出I am kitty! 实现Spring那么到底Spring是如何做到的呢？ 接下来就让我们自己写个Spring来看看Spring到底是怎么运行的吧！ 首先，我们定义一个Bean类，这个类用来存放一个Bean拥有的属性 123456 /* Bean Id */private String id;/* Bean Class */private String type;/* Bean Property */private Map&lt;String, Object&gt; properties = new HashMap&lt;String, Object&gt;(); 一个Bean包括id,type,和Properties。 接下来Spring就开始加载我们的配置文件了，将我们配置的信息保存在一个HashMap中，HashMap的key就是Bean的Id，HasMap的value是这个Bean，只有这样我们才能通过context.getBean(“animal”)这个方法获得Animal这个类。我们都知道Spirng可以注入基本类型，而且可以注入像List，Map这样的类型，接下来就让我们以Map为例看看Spring是怎么保存的。 Map配置可以像下面的 123456789101112&lt;bean id="test" class="Test"&gt; &lt;property name="testMap"&gt; &lt;map&gt; &lt;entry key="a"&gt; &lt;value&gt;1&lt;/value&gt; &lt;/entry&gt; &lt;entry key="b"&gt; &lt;value&gt;2&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; Spring是怎样保存上面的配置呢？代码如下： 12345678910111213141516171819202122232425if(beanProperty.element("map") != null) &#123; Map&lt;String, Object&gt; propertiesMap = new HashMap&lt;String, Object&gt;(); Element propertiesListMap = (Element) beanProperty .elements().get(0); Iterator&lt;?&gt; propertiesIterator = propertiesListMap .elements().iterator(); while (propertiesIterator.hasNext()) &#123; Element vet = (Element) propertiesIterator.next(); if (vet.getName().equals("entry")) &#123; String key = vet.attributeValue("key"); Iterator&lt;?&gt; valuesIterator = vet.elements() .iterator(); while (valuesIterator.hasNext()) &#123; Element value = (Element) valuesIterator.next(); if (value.getName().equals("value")) &#123; propertiesMap.put(key, value.getText()); &#125; if (value.getName().equals("ref")) &#123; propertiesMap.put(key, new String[] &#123; value.attributeValue("bean") &#125;); &#125; &#125; &#125; &#125; bean.getProperties().put(name, propertiesMap);&#125; 接下来就进入最核心部分了，让我们看看Spring到底是怎么依赖注入的吧，其实依赖注入的思想也很简单，它是通过反射机制实现的，在实例化一个类时，它通过反射调用类中set方法将事先保存在HashMap中的类属性注入到类中。让我们看看具体它是怎么做的吧。 首先实例化一个类，像这样 123456789101112131415public static Object newInstance(String className) &#123; Class&lt;?&gt; cls = null; Object obj = null; try &#123; cls = Class.forName(className); obj = cls.newInstance(); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125; catch (InstantiationException e) &#123; throw new RuntimeException(e); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; return obj;&#125; 接着它将这个类的依赖注入进去，像这样 123456789101112131415161718192021222324public static void setProperty(Object obj, String name, String value) &#123; Class&lt;? extends Object&gt; clazz = obj.getClass(); try &#123; String methodName = returnSetMthodName(name); Method[] ms = clazz.getMethods(); for (Method m : ms) &#123; if (m.getName().equals(methodName)) &#123; if (m.getParameterTypes().length == 1) &#123; Class&lt;?&gt; clazzParameterType = m.getParameterTypes()[0]; setFieldValue(clazzParameterType.getName(), value, m,obj); break; &#125; &#125; &#125; &#125; catch (SecurityException e) &#123; throw new RuntimeException(e); &#125; catch (IllegalArgumentException e) &#123; throw new RuntimeException(e); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; catch (InvocationTargetException e) &#123; throw new RuntimeException(e); &#125;&#125; 最后它将这个类的实例返回给我们，我们就可以用了。我们还是以Map为例看看它是怎么做的，我写的代码里面是创建一个HashMap并把该HashMap注入到需要注入的类中，像这样， 123456789101112if (value instanceof Map) &#123; Iterator&lt;?&gt; entryIterator = ((Map&lt;?, ?&gt;) value).entrySet().iterator(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); while (entryIterator.hasNext()) &#123; Entry&lt;?, ?&gt; entryMap = (Entry&lt;?, ?&gt;) entryIterator.next(); if (entryMap.getValue() instanceof String[]) &#123; map.put((String) entryMap.getKey(), getBean(((String[]) entryMap.getValue())[0])); &#125; &#125; BeanProcesser.setProperty(obj, property, map);&#125; 好了，这样我们就可以用Spring给我们创建的类了，是不是也不是很难啊？当然Spring能做到的远不止这些，这个示例程序仅仅提供了Spring最核心的依赖注入功能中的一部分。 本文参考了大量文章无法一一感谢，在这一起感谢，如果侵犯了你的版权深表歉意，很希望对大家有帮助！]]></content>
      <categories>
        <category>Java面试</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String]]></title>
    <url>%2F2018%2F07%2F11%2FString%2F</url>
    <content type="text"><![CDATA[38.Count and SayThe count-and-say sequence is the sequence of integers with the first five terms as following: 1. 1 2. 11 3. 21 4. 1211 5. 111221 1 is read off as “one 1” or 11. 11 is read off as “two 1s” or 21. 21 is read off as “one 2, then one 1” or 1211. Given an integer n, generate the nth term of the count-and-say sequence. Note: Each term of the sequence of integers will be represented as a string. Example 1: Input: 1 Output: &quot;1&quot; Example 2: Input: 4 Output: &quot;1211&quot; 题目有些晦涩，就以上面的例子解释，“1”读出来是“一个1”，因此第二行就是“11”，“11”读出来是“两个1”,因此第三行就是“21”,“21”读出来是“一个2一个1”，因此第四行就是“1211”，以此类推 思路 如果我们要获得第n个字符串，那我们首先要获得第n-1个字符串的值。所以我们设置一个prev变量来保存每一次操作的到的字符串的值，从而进行下一次操作。 操作其实就是从前到后对每一个字符(say)连续出现的次数计数(count)，如果字符变了，那么就将刚才count和say的值加入curr字符串中。 代码 1234567891011121314151617181920212223242526class Solution &#123; public String countAndSay(int n) &#123; StringBuilder cur = new StringBuilder("1"); StringBuilder pre; for(int i = 1;i &lt; n;i++)&#123; pre = cur; cur = new StringBuilder(); char say = pre.charAt(0); int count = 1; for(int j = 1;j &lt; pre.length();j++)&#123; if(pre.charAt(j) != say)&#123; cur.append(count).append(say); count = 1; say = pre.charAt(j); &#125;else&#123; count++; &#125; &#125; cur.append(count).append(say); &#125; return cur.toString(); &#125;&#125; 6.Zigzag ConversionThe string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H N A P L S I I G Y I R And then read line by line: “PAHNAPLSIIGYIR” Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows); Example 1: Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3 Output: &quot;PAHNAPLSIIGYIR&quot; Example 2: Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4 Output: &quot;PINALSIGYAHRPI&quot; Explanation: P I N A L S I G Y A H R P I 重要是找准规律！ 代码 12345678910111213141516171819202122class Solution &#123; public String convert(String s, int numRows) &#123; char[] c = s.toCharArray(); int length = c.length; StringBuilder[] sb = new StringBuilder[numRows]; for(int i = 0;i &lt; numRows;i++) sb[i] = new StringBuilder(); int i = 0; while(i &lt; length)&#123; for(int j = 0;j &lt; numRows &amp;&amp; i &lt; length;j++)&#123; sb[j].append(c[i++]);//垂直往下 &#125; for(int j = numRows-2;j &gt; 0 &amp;&amp; i &lt; length;j--)&#123; sb[j].append(c[i++]);//斜着向上 &#125; &#125; for(int j = 1;j &lt; numRows;j++)&#123; sb[0].append(sb[j]); &#125; return sb[0].toString(); &#125;&#125; 58.Length of Last wordGiven a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. Example: Input: &quot;Hello World&quot; Output: 5 比较简单 记得trim(),再进行split操作 165.Compare Version NumberCompare two version numbers version1 and version2.If version1 &gt; version2 return 1; if version1 &lt; version2 return -1;otherwise return 0. You may assume that the version strings are non-empty and contain only digits and the . character.The . character does not represent a decimal point and is used to separate number sequences.For instance, 2.5 is not “two and a half” or “half way to version three”, it is the fifth second-level revision of the second first-level revision. Example 1: Input: version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot; Output: -1 Example 2: Input: version1 = &quot;1.0.1&quot;, version2 = &quot;1&quot; Output: 1 Example 3: Input: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot; Output: -1 还是挺简单的，但是要注意split的时候”.”的表示 在java中“\”代表转义字符，而“.”代表一个元字符，要表示一个“.”就需要用“.”，所以”\.” 在实际编译中就代表“.” 代码 123456789101112131415161718192021class Solution &#123; public int compareVersion(String version1, String version2) &#123; String[] ver1 = version1.split("\\."); String[] ver2 = version2.split("\\."); int length = Math.max(ver1.length,ver2.length); for(int i = 0;i &lt; length;i++)&#123; int num1 = i &lt; ver1.length ? Integer.parseInt(ver1[i]):0; int num2 = i &lt; ver2.length ? Integer.parseInt(ver2[i]):0; if(num1 &gt; num2)&#123; return 1; &#125;else if(num1 &lt; num2)&#123; return -1; &#125;else&#123; continue; &#125; &#125; return 0; &#125;&#125; 151.Reverse Words in a StringGiven an input string, reverse the string word by word. Example: Input: &quot;the sky is blue&quot;, Output: &quot;blue is sky the&quot;. Note: A word is defined as a sequence of non-space characters. Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces. You need to reduce multiple spaces between two words to a single space in the reversed string. 注意两个单词之间可能有多个空格 123456789101112public class Solution &#123; public String reverseWords(String s) &#123; String[] arr = s.trim().split(" +");//处理一个或多个空格 StringBuilder sb = new StringBuilder(); for(int i = arr.length - 1;i &gt;= 0;i--)&#123; sb.append(arr[i] + " "); &#125; return sb.toString().trim(); &#125;&#125; 186.Reverse Words in a String IIGiven an input string, reverse the string word by word. A word is defined as a sequence of non-space characters. The input string does not contain leading or trailing spaces and the words are always separated by a single space. For example, Given s = “the sky is blue”, return “blue is sky the”. Could you do it in-place without allocating extra space? 先反转整个数组，再对每个单词进行反转 代码 1234567891011121314151617181920212223public class Solution &#123; public void reverseWords(char[] s) &#123; reverse(s, 0, s.length - 1); int start = 0; for(int i = 0; i &lt; s.length; i++)&#123; if(s[i] == ' ')&#123; reverse(s, start, i - 1); start = i + 1; &#125; &#125; reverse(s, start, s.length - 1); &#125; public void reverse(char[] s, int start, int end)&#123; while(start &lt; end)&#123; char tmp = s[start]; s[start] = s[end]; s[end] = tmp; start++; end--; &#125; &#125;&#125; Palindrome5.Longest Palindromic SubstringGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: &quot;babad&quot; Output: &quot;bab&quot; Note: &quot;aba&quot; is also a valid answer. Example 2: Input: &quot;cbbd&quot; Output: &quot;bb&quot; 暴力枚举 穷举所有子字符串的可能，然后依次按位判断其是否是回文，并更新结果。虽然其时间复杂度很高，但它对空间的要求很低。 代码 12345678910111213141516171819202122232425262728293031class Solution &#123; public String longestPalindrome(String s) &#123; int maxStart = 0; int maxLen = 0; int len = s.length(); for(int i = 0;i &lt; len;i++)&#123; for(int j = 0;j &lt; len - i;j++)&#123; if(isPalindrome(s,i,j) &amp;&amp; (i+1) &gt; maxLen)&#123; maxLen = i+1; maxStart = j; &#125; &#125; &#125; return s.substring(maxStart,maxStart+maxLen); &#125; private boolean isPalindrome(String s,int i,int j)&#123; int left = j; int right = i+j; while(left &lt; right)&#123; if(s.charAt(left) != s.charAt(right))&#123; return false; &#125; left++; right--; &#125; return true; &#125;&#125; 动态规划 dp[i][j]代表字符串从i到j是否为回文串 当s.charAt(i)==s.charAt(j)并且dp[i+1][j-1]为true时，dp[i][j] = true 需要注意上述i,j相邻以及i,j中间有别的字符时，上式也成立 代码 12345678910111213141516171819202122232425class Solution &#123; public String longestPalindrome(String s) &#123; int len = s.length(); if(len &lt;= 1) return s; int maxLength = 0; int maxStart = 0; boolean[][] dp = new boolean[len][len]; for(int i = len-1; i &gt;= 0; i--)&#123; for(int j = i; j &lt; len; j++)&#123; if(s.charAt(j)==s.charAt(i) &amp;&amp; (j-2 &lt;= i || dp[i+1][j-1]))&#123; dp[i][j] = true; if(maxLength &lt; j-i+1)&#123; maxLength = j -i + 1; maxStart = i; &#125; &#125; &#125; &#125; return s.substring(maxStart,maxStart + maxLength); &#125;&#125; 中心扩散法 从小到大连续以某点为个中心的所有子字符串进行计算 外层循环遍历的是子字符串的中心点，内层循环则是从中心扩散 中心对称有两种情况，一是奇数个字母以某个字母对称，而是偶数个字母以两个字母中间为对称 代码 12345678910111213141516171819202122232425262728public class Solution &#123; String longest = ""; public String longestPalindrome(String s) &#123; for(int i = 0; i &lt; s.length(); i++)&#123; //计算奇数子字符串 helper(s, i, 0); //计算偶数子字符串 helper(s, i, 1); &#125; return longest; &#125; private void helper(String s, int idx, int offset)&#123; int left = idx; int right = idx + offset; while(left&gt;=0 &amp;&amp; right&lt;s.length() &amp;&amp; s.charAt(left)==s.charAt(right))&#123; left--; right++; &#125; // 截出当前最长的子串 String currLongest = s.substring(left + 1, right); // 判断是否比全局最长还长 if(currLongest.length() &gt; longest.length())&#123; longest = currLongest; &#125; &#125;&#125; 214.Shortest PalindromeGiven a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation. Example 1: Input: &quot;aacecaaa&quot; Output: &quot;aaacecaaa&quot; Example 2: Input: &quot;abcd&quot; Output: &quot;dcbabcd&quot; 暴力求解 补充之后的回文字符串的中心肯定在原字符串中 从原字符的第一个字符为起点至少存在一个回文串，找到原字符串中以第一个字符为起点最长的回文串，找到之后剩下的工作就是把剩余部分的翻转补充到原字符串头部 代码 123456789101112131415161718192021222324class Solution &#123; public String shortestPalindrome(String s) &#123; if (s == null || s.length() == 0 || s.length() == 1) return s; int len = s.length(), tail = len; StringBuilder builder = new StringBuilder(); while (tail &gt; 0) &#123; if (isPalindrome(s.substring(0, tail))) &#123; builder = builder.append(s.substring(tail, len)).reverse();//substring()从beginIndex开始取，到endIndex结束，从0开始数，其中不包括endIndex位置的字符 break; &#125; tail--; &#125; return builder.append(s).toString(); &#125; private boolean isPalindrome(String str) &#123; int len = str.length(); for (int i = 0; i &lt; len / 2; i++) &#123; if (str.charAt(i) != str.charAt(len - i - 1)) return false; &#125; return true; &#125;&#125; KMP: O(n) 242.Valid AnagramGiven two strings s and t , write a function to determine if t is an anagram of s. Example 1: Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot; Output: true Example 2: Input: s = &quot;rat&quot;, t = &quot;car&quot; Output: false Note: You may assume the string contains only lowercase alphabets. Follow up: What if the inputs contain unicode characters? How would you adapt your solution to such case? 代码 1234567891011121314public class Solution &#123; public boolean isAnagram(String s, String t) &#123; if(s.length()!=t.length())&#123; return false; &#125;else&#123; char[] s1 = s.toCharArray(); char[] s2 = t.toCharArray(); Arrays.sort(s1); Arrays.sort(s2); return Arrays.equals(s1,s2); &#125; &#125;&#125; 49.Group AnagramGiven an array of strings, group anagrams together. Example: Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;], Output: [ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;] ] Note: All inputs will be in lowercase. The order of your output does not matter. 代码 123456789101112131415class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; Map&lt;String,List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for(String s:strs)&#123; char[] c = s.toCharArray();//String转char数组 Arrays.sort(c); String key = String.valueOf(c);//char数组转String if(!map.containsKey(key)) map.put(key,new ArrayList()); map.get(key).add(s); &#125; return new ArrayList(map.values());//返回一个HashMap的值的Collection &#125;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>算法</category>
        <category>LeetCode Category</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程安全与锁优化]]></title>
    <url>%2F2018%2F07%2F08%2F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[线程安全Brian Goetz对线程安全的定义：当多个线程访问一个对象时，如果不考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调度方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。 Java语言中的线程安全按照线程安全的“安全程度”由强至弱来排序，java里面各种操作共享的数据分为以下5类：不可变，绝对线程安全，相对线程安全，线程兼容，线程对立。 不可变：可以是基本类型的final；可以是final对象，但对象的行为不会对其状态产生任何影响，比如String的subString就是new一个String对象，枚举类型，各种Number类型如BigInteger和BigDecimal等大数据类型都是不可变的，但是同为Number子类型的AtomicInteger和AtomicLong则并非不可变我觉得原因是它里面状态对象是unsafe对象，所做的操作都是CAS操作，可以保证原子性。 绝对线程安全：他是完全满足Brian Goetz给出的线程安全的定义，一个类要达到这种程度，需要付出很大的，甚至不切实际的代价。 相对线程安全：这就是我们通常意义上的线程安全。需要保证对象单独的操作时线程安全的。比如Vector，HashTable，synchronizedCollection包装集合等。 线程兼容：对象本身不是线程安全的，但可以通过同步手段实现。一般我们说的不是线程安全的，绝大多数是指这个。比如ArrayList，HashMap等。 线程对立：不管调用端是否采用了同步的措施，都无法在并发中使用的代码。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。 线程安全的实现方法 互斥同步 在多线程访问的时候，保证同一时间只有一条线程使用。而互斥是实现同步的一种手段，临界区(Critical Section)，互斥量(Mutex)，信号量(Semaphore)都是主要的互斥实现方式。java里最基本的互斥同步手段是synchronized，编译之后会形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象，还有个锁的计数器，来记录拥有锁的次数 其实在“Java与线程”里已经提到，java的线程是映射到操作系统的原生线程之上的，不管阻塞还是唤醒都需要操作系统的帮忙完成，都需要从用户态转换到核心态，这是很耗费时间的，是java语言中的一个重量级(Heavyweight)操作，虽然虚拟机本身会做一点优化的操作，比如通知操作系统阻塞之前会加一段自旋等待的过程，避免频繁切换到核心态。 还可以使用java.util.concurrent包中的重入锁（ReentrantLock）来实现同步，ReentrantLock比synchronized增加了一些高级功能：等待可中断、可实现公平锁以及锁可以绑定多个条件。 非阻塞同步（Non-Blocking Synchronization） 互斥和同步最主要的问题就是阻塞和唤醒所带来的性能问题，所以这通常叫阻塞同步(悲观的并发策略)。随着硬件指令集的发展，我们有另外的选择：基于冲突检测的乐观并发策略，通俗讲就是先操作，如果没有其他线程争用共享的数据，操作就成功，如果有，则进行其他的补偿(最常见就是不断的重试)，这种乐观的并发策略许多实现都不需要把线程挂起，这种同步操作被称为非阻塞同步。 无同步方案 有一些代码天生就是线程安全的，不需要同步。其中有如下两类： 可重入代码(Reentrant Code): 纯代码，具有不依赖存储在堆上的数据和公用的系统资源，用到的状态量都由参数中传入，不调用非可重入的方法等特征，它的返回结果是可以预测的。 线程本地存储(Thread Local Storage): 把共享数据的可见范围限制在同一个线程之内，这样就无须同步也能保证线程之间不出现数据争用问题。可以通过java.lang.ThreadLocal类来实现线程本地存储的功能。 锁优化为了在线程之间更高效的共享数据，以及解决竞争问题，从而提高程序的执行效率，创建了各种锁优化技术：适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、 锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）等。 自旋锁与自适应自旋： 线程挂起和恢复的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力，在许多应用中，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得，可以让后请求锁的线程等待一会儿，但不放弃处理器的执行时间，让线程执行一个忙循环(自旋)。 自旋锁默认的自旋次数值是10次，可以使用参数-XX:PreBlockSpin更改。 自适应自旋意味着自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。 锁消除： 虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。 锁粗化： 如果虚拟机探测到有一系列连续操作都对同一个对象反复加锁和解锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。 轻量级锁： 使用对象头的Mark Word中锁标志位代替操作系统互斥量实现的锁。轻量级锁并不是用来代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。 轻量级锁是在无竞争的情况下使用CAS（Compare-and-Swap）操作去消除同步使用的互斥量。 偏向锁： 和轻量级锁原理基本一致，但偏向锁在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。]]></content>
      <categories>
        <category>Java基础</category>
        <category>读书笔记</category>
        <category>深入理解Java虚拟机</category>
        <category>高效并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
        <tag>Lock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型与线程]]></title>
    <url>%2F2018%2F07%2F06%2FJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[衡量一个服务性能的高低好坏，每秒事物处理数(TPS)是最重要的指标之一，它代表着一秒内服务端平均能响应的请求总数，而TPS的值与程序的并发能力又有密切的关系。对于计算量相同的任务，程序线程并发协调越有条不紊，效率自然就越高；反之，线程之间频繁阻塞甚至死锁，将会大大降低程序的并发能力。 硬件的效率与一致性物理机并发问题与虚拟机的情况有不少相似之处。 计算机的存储设备与处理器的运算速度有几个数量级的差距，因而加入高速缓存来作为内存与处理器之间的缓冲，引入新的问题：缓存一致性。 Java内存模型主内存与工作内存Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量，包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然没有竞争问题。 Java内存模型规定了所有的变量都存储在主内存中。每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成。 内存间交互操作关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的(对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外)： lock(锁定): 作用于主内存的变量，它把一个变量标识为一条线程独占的状态 unlock(解锁): 作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read(读取): 作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。 load(载入): 作用于工作内存的变量，它把read操作从主内存中得到的变量值放入到工作内存的变量副本中。 use(使用): 作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令的时候将会执行这个操作。 assign(赋值): 作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作。 store(存储): 作用于工作内存变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。 write(写入): 作用于主内存变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。 Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则： 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。 不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步会主内存中。 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use和store操作之前，必须先执行过assign和load操作。 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock之后，只有执行相同次数的unlock操作，变量才会被解锁。 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定住的变量。 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store和write操作）。 对于volatile型变量的特殊规则关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制。当一个变量被定义成volatile之后，它将具备两种特性，第一是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。 由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性。 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。 变量不需要与其他的状态变量共同参与不变约束。 第二个特性是禁止指令重排序优化。普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这样就是Java内存模型中描述的所谓的“线程内表现为串行的语义”。 对于long和double型变量的特殊规则Java内存模型要求lock、unlock、read、load、assign、use、store和write这8个操作都具有原子性，但是对于64位的数据类型long和double，在模型中特别定义了一条宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这四个操作的原子性，这点就是所谓的long和double的非原子性协定。 如果有多个线程共享一个未被声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读到一个既非原值，也非其他线程修改值的代表了“半个变量”的数值。 不过这种读取到“半个变量”的情况非常罕见，因为Java内存模型虽然允许虚拟机不把long和double变量的读写实现成原子操作，但允许虚拟机选择把这些操作实现为具有原子性的操作，而且还“强烈建议”虚拟机这样实现。目前各种平台下的商用虚拟机几乎都选择吧64位数据的读写操作作为原子操作来对待，因此在编码时，不需要将long和double变量专门声明为volatile。 原子性、可见性与有序性Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的： 原子性(Atomicity): 由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，我们大致可以认为基本数据类型的访问读写是具备原子性的。 在synchronized块之间的操作也具备原子性。 可见性(Visibility): 指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。 Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介实现可见性的 普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。 除了volatile之外，synchronized和final也能实现可见性。同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中”这条规则获得的，而final关键字的可见性是指：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去，那在其他线程中就能看见final字段的值 有序性(Ordering): Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。 Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行地进入 先行发生原则先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了小写、调用了方法等。 下面是Java内存模型下一些“天然的”先行发生关系，这些先行发送关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，他们就没有顺序性保障，虚拟机可以对它们进行随意重新排序。 程序次序规则(Program Order Rule): 在一个线程内，按照程序代码顺序，书写在钱吗的操作先于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。 管程锁定规则(Monitor Lock Rule): 一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。 volatile变量规则(Volatile Variable Rule): 对一个volatile变量的写操作先行发生于后面对这个变量的读操作。“后面”是指时间上的先后顺序。 线程启动规则(Thread Start Rule): Thread对象的start()方法先行发生于此线程的每一个动作。 线程终止规则(Thread Termination Rule): 线程中所有操作都先行发生于此线程的终止检测。 线程中断规则(Thread Interruption Rule): 对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。 对象终结规则(Finalizer Rule): 一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。 传递性(Transitivity): 如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得到操作A先行发生于操作C。 Java与线程线程的实现 使用内核线程实现 内核线程(Kernel Thread，KLT)就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程都可以看做是内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就叫多线程内核。 程序一般不会直接使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程(Light Weight Process，LWP)，轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。 由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作，但轻量级进程具有它的局限性：基于线程内核实现，各种线程操作都需要进行系统调用，系统调用代价高，需要在用户态和内核态中来回切换；轻量级进程都需要有一个内核线程的支持，消耗内核资源 使用用户线程实现 广义上，一个线程只要不是内核线程，那就可以认为是用户线程(User Thread，UT)。 狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到线程存在的实现。 使用用户线程的优势劣势都在于没有系统内核的支援，所有线程操作都需要用户程序自己处理，困难，实现复杂，放弃使用 使用用户线程加轻量级进程混合实现 线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式。在这种混合实现下，既存在用户线程，也存在轻量级进程。 Java线程调度线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度(Cooperative Threads-Scheduling)和抢占式线程调度(Preemptive Threads-Scheduling)。 如果使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完毕后，要主动通知系统切换到另一个线程上去。 如果使用抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定(在Java中，Thread.yield()可以让出执行时间，但要获取执行时间的话，线程本身是没有什么办法)。Java使用抢占式调度。线程优先级 状态转换Java语言定义了5种线程状态，在任意一个时间点，一个线程只能有且只有其中的一种状态，这5种状态分别是： 新建(New): 创建后尚未启动 运行(Runable): Runable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待CPU为它分配执行时间 无期限等待(Waiting): 不会被分配CPU执行时间，需要等待被其他线程显式地唤醒 期限等待(Timed Waiting): 不会被分配CPU执行时间，无须等待被其他线程显式地唤醒，在一定时间之后会由系统自动唤醒 阻塞(Blocked): 线程被阻塞了，“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是等待一段时间，或者唤醒动作的发生 结束(Terminated): 已终止线程的线程状态，线程已经结束执行 上述5种状态在遇到特定事件发生的时候会相互转换。]]></content>
      <categories>
        <category>Java基础</category>
        <category>读书笔记</category>
        <category>深入理解Java虚拟机</category>
        <category>高效并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[晚期(运行期)优化]]></title>
    <url>%2F2018%2F07%2F05%2F%E6%99%9A%E6%9C%9F(%E8%BF%90%E8%A1%8C%E6%9C%9F)%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[在部分商用虚拟机(HotSpot、IBM J9)中，Java程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”。为了提高热点代码的执行效率，在运行时，虚拟机会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器。 HotSpot虚拟机内的即时编译器解释器与编译器并不是所有的Java虚拟机都采用解释器与编译器并存的架构，但许多主流的商用虚拟机，如HotSpot、J9等，都同时包含解释器与编译器。解释器与编译器两者各有优势： 当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行 程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多代码编译成本地代码之后，可以获取更高的执行效率 当程序运行环境中内存资源限制较大，可以使用解释执行节约内存，反之可以使用编译执行提升效率 解释器还可以作为编译器激进优化时的一个“逃生门”，让编译器根据概率选择一些大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立时可以通过逆优化退回到解释状态继续执行。 无论采用的编译器是Client Compiler还是Server Compiler，解释器与编译器搭配使用的方式在虚拟机中称为“混合模式”，用户可以使用参数“-Xint”强制虚拟机运行于“解释模式”，这时编译器完全不介入工作，全部代码都使用解释方式执行。另外，也可以使用参数“-Xcomp”强制虚拟机运行于“编译模式”，这时优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程。 为了在程序启动相应速度与运行效率之间达到最佳平衡，HotSpot虚拟机还会逐渐启用分层编译的策略，分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次： 第0层，程序解释执行，解释器不开启性能监控功能，可触发第1层编译 第1层，也称为C1编译，将字节码编译为本地代码，进行简单、可靠的优化，如有必要加入性能监控的逻辑 第2层，也称为C2编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。 实施分层编译后，Client Compiler和Server Compiler将会同时工作，许多代码可能会被多次编译，用Client Compiler获取更高的编译速度，用Server Compiler来获取更好的编译质量，在解释执行的时候也无须再承担收集性能监控信息的任务。 编译对象与触发条件“热点代码”有两类： 被多次调用的方法 被多次执行的循环体 “多次”的概念？ 判断一段代码是不是热点代码，是不是需要触发即时编译，这样的行为称为热点探测，判定方式有两种： 基于采样的热点探测 周期性检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，那这个方法就是“热点方法” 实现简单、高效，容易获取方法调用关系 很难精确地确认一个方法的热度，容易因为收到线程阻塞或别的外界因素的影响而扰乱热点探测 基于计数器的热点探测(HotSpot采用) 为每个方法建立计数器，统计方法的执行次数，如果执行次数超过了一定的阈值就认为它是“热点方法” 实现麻烦，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系 更加精准和严谨 HotSpot为每个方法准备了两类计数器：方法调用计数器和回边计数器 方法调用计数器 统计方法被调用的次数，Client模式下默认阈值1500，Server默认10000 交互过程如下图： 如果不做任何设置，方法调用计数器统计的是一个相对的执行频率，即一段时间内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减，而这段时间称为此方法统计的半衰周期。进行热度衰减的动作在虚拟机进行垃圾收集时顺便进行。 回边计数器 统计一个方法中循环体代码执行的次数，为了触发OSR编译 虚拟机运行在Client模式下，回边计数器阈值计算公式为：方法调用计数器阈值 X OSR比率 /100 虚拟机运行在Server模式下，回边计数器阈值计算公式为：方法调用计数器阈值 X (OSR比率 - 解释器监控比率) /100 执行过程如下图： 编译过程默认设置下，无论是方法调用产生的即时编译请求，还是OSR编译请求，虚拟机在代码编译器还未完成之前，都仍然按照解释方式继续进行，而编译动作则在后台的编译线程中进行。 在后台编译的过程中，Client Compiler是一个简单快速的三段式编译器，主要的关注点在于局部性的优化，而放弃了许多耗时较长的全局优化手段。 而Server Compiler则是专门面向服务端的典型应用并为服务端的性能配置特别调整过的编译器，也是一个充分优化过的高级编译器，它会执行所有经典的优化动作，如无用代码消除、循环展开、循环表达式外提、消除公共子表达式、常量传播、基本块重排序等，还会实施一些与Java语言特性密切相关的优化技术，如范围检查消除、空值检查消除等。 以即时编译的标准来看，Server Compiler比较缓慢，但它的编译速度依然远远超过传统的静态优化编译器，而且它相对于Client Compiler编译输出的代码质量有所提高，可以减少本地代码的执行时间，从而抵消了额外的编译时间开销，所以也有很多非服务端的应用选择使用Server模式的虚拟机运行。 编译优化技术以编译方式执行本地代码比解释方式更快，除去虚拟机解释执行字节码需要额外消耗时间的原因外，还有一个很重要的原因就是虚拟机设计团队几乎把对代码的所有优化措施都集中在了即时编译器之中。 公共子表达式消除 数组边界检查消除 方法内联 非虚方法，直接内联 虚方法，会向“类型继承关系分析”(CHA)查询此方法在当前程序下是否有多个目标版本可选择，如果只有一个版本，也可以进行内联，不过这种内联属于激进优化，需要预留一个“逃生门”，称为守护内联。如果程序的后续执行过程中，虚拟机一直没有加载到会令这个方法的接受者继承关系发生变化的类，那这个内联优化的代码可以一直用下去。但如果加载了导致继承关系发生变化的新类，那就需要抛弃已经编译的代码，退回到解释状态执行，或者重新进行编译 如果向CHA查询出来的结果是有多个版本的目标方法可供选择，则编译器还将会尝试使用内联缓存来完成方法内联，这是一个建立在方法正常入口之前的缓存，它的工作原理大致是：在未发生方法调用之前，内联缓存为空，当第一次调用发生后，缓存记录下方法接收者的版本信息，并且每次进行方法调用时都比较接受者版本，如果以后进来的每次调用的方法接收者版本都是一样的，那这个内联还可以一直用下去。如果发生了方法接收者版本不一致的情况，就说明程序真正使用了虚方法的多态特性，这时才会取消内联，查找虚方法表进行方法分派。 逃逸分析 分析对象的作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，称为方法逃逸。甚至还有可能被外部线程访问到，称为线程逃逸 如果能证明一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问到这个对象，则可能为这个变量进行一些高效的优化 栈上分配 同步消除 标量替换(标量指一个数据已经无法再分解成更小的数据来表示了，与之对应的称为聚合量)]]></content>
      <categories>
        <category>Java基础</category>
        <category>读书笔记</category>
        <category>深入理解Java虚拟机</category>
        <category>程序编译与代码优化</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[早期(编译期)优化]]></title>
    <url>%2F2018%2F07%2F04%2F%E6%97%A9%E6%9C%9F(%E7%BC%96%E8%AF%91%E6%9C%9F)%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Java语言的“编译期”是一段“不确定”的操作过程，因为它可能指： 前端编译器（编译器的“前端”）把*.java文件转变成*.class文件的过程: Javac 后端运行期编译器(JIT)把字节码转变成机器码的过程:HotSpot VM的C1、C2 静态提前编译器(AOT)直接把*.java文件编译成本地机器码的过程 本章讨论的“编译期”和“编译器”都仅限于第一类编译过程。 Javac对代码的运行效率几乎没有任何优化措施，但做了许多针对Java语言编码过程的优化措施来改善程序员的编码风格和提高编码效率。相当多新生的Java语法特性，都是靠编译器的“语法糖”来实现。 Javac编译器Javac编译过程大致可以分为3个过程： 解析和填充符号表过程 插入式注解处理器的注解处理过程 分析与字节码生成过程 Javac的源码与调试 解析和填充符号表 词法、语法分析 词法分析将源代码的字符流转变为标记(Token)集合 语法分析根据Token序列构造抽象语法树 填充符号表 符号表是由一组符号地址和符号信息构成的表格 注解处理器注解在运行期间发生作用。 如果注解处理器在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round(上图10-4的循环过程)。 语义分析与字节码生成语法分析后，编译器获得了程序代码的抽象语法树表示，语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。 标注检查 检查变量使用前是否已被声明、变量与赋值之间的数据类型能否匹配等 数据及控制流分析 能检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被处理了等问题 将局部变量声明为final，对运行期没有影响，变量的不变性仅仅由编译器在编译期间保障。 解语法糖 使用语法糖能增加程序的可读性，从而减少程序代码出错的机会 字节码生成 把前面各个步骤所生成的信息转化成字节码写到磁盘中，进行少量的代码添加和转换工作 Java语法糖的味道泛型与类型擦除Java中的泛型只在程序源码中存在，在编译后的字节码文件中，会替换成原来的原生类型，并在相应的地方插入强制转型代码。ArrayList和ArrayList对Java来说就是同一个类。Java中泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。 引入Signature、LocalVariableTypeTable等属性用于解决伴随泛型而来的参数类型的识别问题。擦除法所谓的擦除，只是对方法的Code属性中的字节码进行擦除，元数据中还是保留了泛型信息。 自动装箱、拆箱与遍历循环遍历循环会把代码还原成迭代器的实现，这就是遍历的类需要实现Iterable接口的原因。 这是关于Java中自动装箱与拆箱的一段代码： 123456789101112131415161718public class BoxingTest &#123; public static void main(String[] args) &#123; Integer a = 1; Integer b = 2; Integer c = 3; Integer d = 3; Integer e = 321; Integer f = 321; Long g = 3L; System.out.println(c == d); //true System.out.println(e == f); //false System.out.println(c == (a + b)); //true System.out.println(c.equals(a + b)); //true System.out.println(g == (a + b)); //true System.out.println(g.equals(a + b)); //false &#125;&#125; 装箱代码，注意IntegerCache的存在： 12345 public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 拆箱代码： 123 public int intValue() &#123; return value;&#125; 编译完的class文件，再重新反编译后的代码: 1234567891011121314151617public class BoxingTest&#123; public static void main(String[] args)&#123; Integer a = Integer.valueOf(1); Integer b = Integer.valueOf(2); Integer c = Integer.valueOf(3); Integer d = Integer.valueOf(3); Integer e = Integer.valueOf(321); Integer f = Integer.valueOf(321); Long g = Long.valueOf(3L); System.out.println(c == d); System.out.println(e == f); System.out.println(c.intValue() == a.intValue() + b.intValue()); System.out.println(c.equals(Integer.valueOf(a.intValue() + b.intValue()))); System.out.println(g.longValue() == a.intValue() + b.intValue()); System.out.println(g.equals(Integer.valueOf(a.intValue() + b.intValue()))); &#125;&#125; System.out.println(c == d) =&gt; System.out.println(c == d)：类型一致，不涉及装箱与拆箱，变量c、d保存于线程私有栈中，c和d是保存的是一个地址引用，指向内存堆中的某个地址，对于值在【-128，127】Integer类型，由于IntegerCache.cache[]的存在，所以c、d指向的是堆中同一个地址，故执行结果为true System.out.println(e == f) =&gt; System.out.println(e == f): 类型一致，不涉及装箱与拆箱操作，判定规则参照上面的分析，因为321不在【-128，127】内，故e和f指向的是内存堆中两个不同的地址，故执行结果为false System.out.println(c == (a + b)) =&gt; System.out.println(c.intValue() == a.intValue() + b.intValue())：通过反编译字节码我们可以看到，这里涉及了包装类型的拆箱操作，只有基础类型才可以进行加法操作，实际比较的是存于Java私有线程栈中两个int类型的数值比较，执行结果为true System.out.println(c.equals(a + b)) =&gt; System.out.println(c.equals(Integer.valueOf(a.intValue() + b.intValue())))：这里涉及了先拆箱，然后再装箱的操作，a+b先执行拆箱操作，然后再对结果执行装箱操作，最后执行equals方法，我们看下Integer类中equals方法的定义如下，很明显，执行结果为true 123456 public boolean equals(Object obj) &#123; if (obj instanceof Integer) &#123; return value == ((Integer)obj).intValue(); &#125; return false;&#125; System.out.println(g == (a + b)) =&gt; System.out.println(g.longValue() == a.intValue() + b.intValue())：类型不一致，拆箱操作，g和a、b分别执行了拆箱操作，然后比较结果，执行结果为true System.out.println(g.equals(a + b)) =&gt; System.out.println(g.equals(Integer.valueOf(a.intValue() + b.intValue())))：与第四条规则一致，先拆箱执行加法操作，然后加法结果执行装箱操作，最后执行Long类型的equals方法，Long中equals方法定义如下，故执行结果为false 123456 public boolean equals(Object obj) &#123; if (obj instanceof Long) &#123; return value == ((Long)obj).longValue(); &#125; return false;&#125; 集合中只能包含对象，不能包含基础数据类型，如果将基础数据类型的数据添加到集合操作，JVM（JDK1.5之后）会自动进行装箱操作，将基础数据类型封装为对应的封装类 条件编译使用条件为常量的if语句]]></content>
      <categories>
        <category>Java基础</category>
        <category>读书笔记</category>
        <category>深入理解Java虚拟机</category>
        <category>程序编译与代码优化</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机字节码执行引擎]]></title>
    <url>%2F2018%2F07%2F02%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[从概念模型的角度讲解虚拟机的方法调用和字节码执行。 运行时栈帧结构栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。 编译时，栈帧需要多大的局部变量表，多深的操作数栈都已经完全确定，并且写入到方法表的Code属性中，因此一个栈帧需要分配多少内存，仅仅取决于具体的虚拟机实现。 对执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如下图所示： 局部变量表局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。 局部变量表的容量以变量槽(Slot)为最小单位，一个Slot可以存放一个32位以内的数据类型(boolean、byte、char、short、int、float、reference和returnAddress)。而对于64位的数据类型，虚拟机会以高位对齐的方式为其分配两个连续的Slot空间。 虚拟机通过索引定位的方式使用局部变量表。 如果一个局部变量定义了但没有赋初始值是不能被使用的。 操作数栈操作数栈也常称为操作栈，它是一个后入先出栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意的Java数据类型。 在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的。但在大多数虚拟机的实现都会做一些优化处理，令两个栈帧出现一部分重叠。让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用时就可以共用一部分数据，无须进行额外的参数复制传递。 Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。 动态连接每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。 Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。 方法返回地址方法开始执行后，有两种方式可以退出这个方法 执行引擎遇到任意一个方法返回的字节码指令，可能会有返回值传递给上层方法调用者(正常完成出口) 执行过程遇到异常，并且该异常在方法体内没有被处理(异常完成出口) 方法退出后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。 方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器的值。方法异常退出时，返回地址是要通过异常处理器表来确定的。 附加信息例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。 方法调用确定被调用方法的版本 解析所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析。 在Java中符合“编译期可知，运行期不可变”的，包括静态方法和私有方法两大类，适合在类加载阶段进行解析。 与之对应的是，在Java虚拟机里提供了5条方法调用字节码指令： invokestatic：静态方法 invokespecial：调用实例构造器\方法、私有方法和父类方法 invokevirtual：虚方法 invokeinterface：接口方法，会在运行时再确定一个实现该接口的对象 invokedynamic：现在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法 只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、实例构造器、私有方法和父类方法4类(非虚方法，非虚方法还包含被final修饰的方法)。其他都称为虚方法。 解析调用是静态的过程。 分派揭示多态性特征的一些最基本的体现。 静态分派 重载(同名函数，不同参数个数/类型)相关，虚拟机重载时通过参数的静态类型作为判断依据 动态分派 重写(子类父类之间)有关，根据实际类型确定方法执行版本 单分派与多分派 方法的接收者与方法的参数统称为方法的宗量 单分派根据一个宗量对目标方法进行选择 多分派根据多于一个宗量对目标方法进行选择 Java的静态分派属于多分派类型，动态分派属于单分派类型 虚拟动态分派的实现 虚方法表 内联缓存 基于“类型继承关系分析”技术的守护内联 动态类型语言支持 动态类型语言 动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期 “变量无类型而变量值才有类型” JDK1.7与动态类型 java.lang.invoke包 MethodHandle invokedynamic指令 掌控方法分派规则 Son类中调用祖父类thinking()方法： 基于栈的字节码解释执行引擎解释执行 上图中下面那条分支，是传统编译原理中程序代码到目标机器代码的生成过程，而中间那条分支，就是解释执行的过程。 Java程序编译半独立。Javac编译器完成程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机内部。 基于栈的指令集与基于寄存器的指令集基于栈的指令集的优点： 可移植 代码相对更加紧凑 编译器实现更简单 基于栈的指令集的缺点：执行速度相对较慢]]></content>
      <categories>
        <category>Java基础</category>
        <category>读书笔记</category>
        <category>深入理解Java虚拟机</category>
        <category>虚拟机执行子系统</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机类加载机制]]></title>
    <url>%2F2018%2F06%2F29%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[虚拟机的类加载机制: 虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。 Java语言运行期类加载的特性 类加载的时机类的生命周期：加载，验证，准备，解析，初始化，使用和卸载。其中验证，准备，解析3个部分统称为连接，发生顺序如下： 其中，加载、验证、准备、初始化和卸载顺序是确定的，类的加载过程必须按照这个顺序按部就班地开始，但是解析阶段则不一定(动态绑定，多态) 那什么时候开始类加载的第一个过程“加载”呢？ 虚拟机规范严格规定了有且只有5种情况必须立即对类进行“初始化”（加载、验证、准备自然在这之前），以下五种情况称为对一个类的主动引用： 遇到new、getstatic、putstatic或invokestati这4条字节码指令时，如果类没有进行初始化，则需要先初始化 生成这4条指令最常见的场景是：new 实例化对象时，读取、设置一个类的静态字段(被final修饰，常量除外)，调用一个类的静态方法 使用java.lang.reflect包的方法对类进行反射调用时，如果类没有进行初始化，则需要先初始化 初始化类时，如果父类还没有初始化，则需要先初始化父类 虚拟机启动时，用户需要指定一个主类（包含main()方法的类），虚拟机会先初始化主类 使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REE_getStatic、REE_putStatic、REE_invokeStatic的方法句柄，并且该句柄所对应的类没有进行初始化，则需要先初始化 除此之外，所有引用类的方式不会触发初始化，称为被动引用 接口的加载过程与类加载过程稍有不同，只是第3条，一个接口在初始化时，不要求其父类接口全部完成了初始化，只有在真正用到父接口的时候才会初始化。 类加载的过程加载在加载阶段，虚拟机需要完成以下3件事情： 通过一个类的全限定名来获取此类的二进制流 将该字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 “通过一个类的全限定名来获取此类的二进制流”，没有指明从哪里获取，怎么获取： 从ZIP包获取，JAR、WAR、EAR 网络获取，Applet 运算时生成，动态代理技术 其他文件生成，JSP 数据库读取 …… 相对于类加载过程中的其他阶段，一个非数组类的加载阶段（加载过程中获取类的二进制字节流的动作）可控性最强，既可以用系统提供的引导类加载器，也可以由用户自定义的类加载器来完成（重写类加载器的loadClass()） 而数组类，是由Java虚拟机直接创建的，但是数组类的元素类型，最终还是需要类加载器来创建，一个数组类的创建过程遵循以下规则： 如果数组的组件类型是引用类型，递归非数组类加载过程加载，数组将在加载该组件类型的类加载器的类名称空间上被标识 不是引用类型，将数组标记为与引导类加载器关联 数组类的可见性与它的组件类型的可见性一致，如果不是引用类型，默认为public 加载阶段与连接阶段的部分内容交叉进行，加载阶段尚未完成，连接阶段可能已经开始。但这两个阶段开始的时间仍然保持先后顺序。 验证确保Class文件的字节流包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全 验证阶段大致会完成以下4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证 文件格式验证 保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求 验证魔数、主次版本号、常量池中的常量类型… 基于字节流进行验证，后面3个验证都是基于方法区的存储结构进行的 元数据验证 对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息 是否有父类、父类是否继承不允许被继承的类，类中的字段、方法是否与父类矛盾… 字节码验证 通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的 在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件 保证方法体中的类型转换有效、跳转指令不会跳转到方法体以外的字节码指令上… 为了优化，Code属性中“StackMapTable“，描述方法体中所有基本块开始时本地变量表和操作栈该有的状态，在字节码验证期间，就不用推导合法性，直接查该属性中的记录即可。将字节码验证的类型推导转变为类型检查。 符号引用验证 发生在虚拟机将符号引用转化为直接引用时，在解析阶段发生，确保解析动作能正常执行 对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验 符号引用中通过字符串描述的全限定名能否找到对应的类，符号引用中的类、方法、字段的访问行是否可被当前类所访问… 准备正式为类变量分配内存并设置类变量初始值，内存都在方法区中分配。 进行内存分配的只是类变量(被static修饰)，不包含实例变量 初始化，一般指赋0值，但如果是常量(static final)，则是常量具体的值 解析虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用在Class文件中以CONSTANT_Class_info等类型的常量出现。 解析阶段符号引用和直接引用的关联: 符号引用：以一组符号来描述所引用的目标，符号形式不限，只要在使用时能无歧义地定位到目标即可。与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。虚拟机实现的内存布局可以各不相同，但它们能接受的符号引用都是一致的。 直接引用：可以是直接指向目标的指针、相对偏移量或者能间接定位到目标的句柄。和与虚拟机实现的内存布局相关，同一个符号引用在不同虚拟机翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中。 解析阶段发生的具体时间不确定，只要求了在16个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。 因此，虚拟机实现可以按需判断是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用时才去解析它。 对一个符号引用的多次解析很常见，除了invokedynamic指令外，虚拟机实现可以对第一次解析进行缓存。需要保证的是在同一个实体中，如果一个符号引用之前被成功解析过，那么后续的解析也应该一直成功；同样的，如果第一次失败，那么之后也应该收到相同的异常。 而对于invokedynamic指令用于动态语言支持，必须等到程序实际运行到这条指令的时候，解析动作才能进行。 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用店限定符7类符号引用进行，以下是前4种： 类或接口的解析假设当前代码所处的类为D，要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，虚拟机完成整个解析需要3个步骤： 如果C不是数组类型，虚拟机会把代表N的全限定名传递给D的类加载器去加载类C，加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作。一旦加载过程出现异常则宣告失败 如果C是数组类型，并且数组的元素类型为对象，那将会按照第1点的规则加载数组元素类型，接着由虚拟机生成一个代表词数组维度和元素的数组对象 如果上述步骤没有出现异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还需要进行符号引用验证，确认D是否具备对C的访问权限，如果没有，则抛出java.lang.IllegalAccessError异常。 字段解析要解析一个未被解析过的字段符号引用，首先会对字段所属的类或接口的符号引用进行解析。如果在解析的过程中出现异常，则解析失败。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索： 如果C本身包含了简单名称和字段描述符都与目标相匹配的字段，则直接返回该字段的直接引用，查找结束 否则，如果C实现了接口，则按照继承关系从下往上递归搜索各个接口以及父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回该字段的直接引用，查找结束 否则，如果C不是java.lang.Object的话，按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回该字段的直接引用，查找结束 否则，查找失败，抛出java.lang.NoSuchFieldError异常 如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果没有访问权限，则抛出java.lang.IllegalAccessError异常。 如果有一个同名字段同时出现在C的接口和父类中，或者同时在自己或父类的多个接口中出现，那编译器可能拒绝编译。 类方法解析第一个步骤和字段解析一样，也需要先解析出类方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C表示这个类，接下来虚拟机会按照如下步骤进行后续的类方法搜索： 类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是接口，直接抛出java.lang.IncompatibleClassChangeError异常 如果通过第1步，在类C中查找是否有简单名称和字段描述符都与目标相匹配的方法，如果有则直接返回这个方法的直接引用，查找结束 否则，在C的父类中递归查找是否有简单名称和字段描述符都与目标相匹配的方法，如果有则直接返回这个方法的直接引用，查找结束 否则，在C实现的接口列表及它们的父接口之中递归查找是否有简单名称和字段描述符都与目标相匹配的方法，如果有，说明C是个抽象类，这时查找结束，抛出java.lang.AbstractMethodError异常 否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError 最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备权限，将抛出java.lang.IllegalAccessError异常。 接口方法解析接口方法也需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C表示这个接口，接下来虚拟机会按照如下步骤进行后续的接口方法搜索： 与类方法解析不同，如果在接口方法表中发现class_index中索引的C是类，直接抛出java.lang.IncompatibleClassChangeError异常 否则，在接口C中查找是否有简单名称和字段描述符都与目标相匹配的方法，如果有则直接返回这个方法的直接引用，查找结束 否则，在的父接口之中递归查找，直到java.lang.Object类，看是否有简单名称和字段描述符都与目标相匹配的方法，如果有则直接返回这个方法的直接引用，查找结束 否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常 接口中所有方法默认都是public的，因此不需要进行权限验证。 初始化真正开始执行类中定义的Java代码，初始化阶段是执行类构造器clinit()方法的过程。 clinit()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，只能赋值不能访问。 虚拟机保证子类的clinit()方法执行前，父类的clinit()方法已经执行完毕 父类中定义的静态语句块要优先于子类的变量赋值操作 接口中不能使用静态语句块，但仍有变量初始化赋值操作，因此也会生成clinit()方法。但接口的clinit()方法，不需要先执行父类的clinit()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的clinit()方法 虚拟机会保证一个类的clinit()方法在多线程环境中被正确地加锁、同步 类加载器虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取此类的二进制流”这个动作放到Java虚拟机的外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。 类与类加载器类加载器用于实现类的加载动作。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。也就是说，比较两个类是否“相等”，只有这两个类是由同一个类加载器加载的前提下才有意义。 双亲委派模型从Java虚拟机的角度来讲，只存在两种不同类型的类加载器： 启动类加载器，C++语言实现，虚拟机自身的一部分 其他所有的类加载器，Java语言实现，独立于虚拟机外部，全都继承自抽象类java.lang.ClassLoader 从Java开发人员的角度来看，绝大部分Java程序都会使用到以下3种系统提供的类加载器： 启动类加载器：负责将存放在\&lt;JAVA_HOME&gt;\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用 扩展类加载器：负责加载\&lt;JAVA_HOME&gt;\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器 应用程序类加载器：负责加载用户类路径(Classpath)上所指定的类库，开发者可以直接使用这个类加载器。程序的默认类加载器。 双亲委派模型要求顶层是启动类加载器，其余的类加载器应该有自己的父类加载器。类加载器之间的父子关系是使用组合关系来复用父加载器的代码。 双亲委派模型的工作过程： 如果一个类加载器收到了类加载请求，它不会自己去尝试加载这个类，而是将这个请求委派给父类加载器去完成，每一个层次的类加载器都这样，因此所有的加载请求最终都应该传送到顶层的启动类中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己加载。 破坏双亲委派模型 向前兼容 模型自身缺陷 双亲委派模型很好地解决了各个类加载器的基础类的统一问题(越基础的类由越上层的类加载器进行加载) 基础类又要调回用户的代码，比如JNDI，可以使用线程上下文类加载器 用户对程序动态性的追求，热部署等]]></content>
      <categories>
        <category>Java基础</category>
        <category>读书笔记</category>
        <category>深入理解Java虚拟机</category>
        <category>虚拟机执行子系统</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stack]]></title>
    <url>%2F2018%2F06%2F26%2FStack%2F</url>
    <content type="text"><![CDATA[Stack实际上也是通过数组去实现的。 执行push时(即，将元素推入栈中)，是通过将元素追加的数组的末尾中。 执行peek时(即，取出栈顶元素，不执行删除)，是返回数组末尾的元素。 执行pop时(即，取出栈顶元素，并将该元素从栈中删除)，是取出数组末尾的元素，然后将该元素从数组中删除。 Stack继承于Vector，意味着Vector拥有的属性和功能，Stack都拥有。 225.Implement Stack with QueueImplement the following operations of a stack using queues. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. empty() – Return whether the stack is empty. Example: 123456MyStack stack = new MyStack();stack.push(1);stack.push(2); stack.top(); // returns 2stack.pop(); // returns 2stack.empty(); // returns false Notes: You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty operations are valid. Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue. You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack). 维护两个队列 Push O(n),Pop O(1) Push: q2存放新元素，q1元素逐个添加到q2队尾，q1，q2互换 Pop: q1.poll() Top: q1.peek() Empty: q1.isEmpty() Push O(1),Pop O(n) Push: q1直接存,并更新top值 Pop: q1的大小大于1时，更新top值，并移到q2;删除q1的值，交换q1,q2 Top: 直接返回top Empty: q1.isEmpty() 维护一个队列 1234567891011private LinkedList&lt;Integer&gt; q1 = new LinkedList&lt;&gt;();// Push element x onto stack.public void push(int x) &#123; q1.add(x); int sz = q1.size(); while (sz &gt; 1) &#123; q1.add(q1.remove()); sz--; &#125;&#125; 232.Implement Queue with stacksImplement the following operations of a queue using stacks. push(x) – Push element x to the back of queue. pop() – Removes the element from in front of queue. peek() – Get the front element. empty() – Return whether the queue is empty. Example: MyQueue queue = new MyQueue(); queue.push(1); queue.push(2); queue.peek(); // returns 1 queue.pop(); // returns 1 queue.empty(); // returns false Notes: You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack. You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue). (Two Stacks) Push - O(1) per operation, Pop - Amortized O(1) per operation. Push: s1直接存,记录下最开始s1为空时的peek值 Pop: s2为空时，把s1中的值pop到s2,再返回s2.pop() Peek: s2为空直接返回peek,否则返回s2.peek() Empty: s1.isEmpty()&amp;&amp;s2.isEmpty() 155.Min StackDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. Example: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --&gt; Returns -3. minStack.pop(); minStack.top(); --&gt; Returns 0. minStack.getMin(); --&gt; Returns -2. 使用两个栈(借助辅助栈，存储min) Push: s1直接push，当s2为空或者新入栈的元素小于等于栈顶元素时，s2也入栈 Pop: s1直接pop，如果s1中pop的元素和s2栈顶元素相同，s2也pop Top: s1.peek() GetMin: s2.peek() String20.Valid ParenthesesGiven a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example 1: Input: &quot;()&quot; Output: true Example 2: Input: &quot;()[]{}&quot; Output: true Example 3: Input: &quot;(]&quot; Output: false Example 4: Input: &quot;([)]&quot; Output: false Example 5: Input: &quot;{[]}&quot; Output: true 典型Stack的题，符号匹配 是左括号，则入栈 判断是否是对应的右括号，同时栈不为空 都不满足，则返回false 最后判断栈是否为空 代码 12345678910111213141516171819class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for(char c : s.toCharArray())&#123; if(c == '(' || c == '[' || c == '&#123;')&#123; stack.push(c); &#125;else if(c == ')' &amp;&amp; !stack.empty() &amp;&amp; stack.peek() == '(')&#123; stack.pop(); &#125;else if(c == ']' &amp;&amp; !stack.empty() &amp;&amp; stack.peek() == '[')&#123; stack.pop(); &#125;else if(c == '&#125;' &amp;&amp; !stack.empty() &amp;&amp; stack.peek() == '&#123;')&#123; stack.pop(); &#125;else&#123; return false; &#125; &#125; return stack.empty(); &#125;&#125; 更简洁的解法 1234567891011121314public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (char c : s.toCharArray()) &#123; if (c == '(') stack.push(')'); else if (c == '&#123;') stack.push('&#125;'); else if (c == '[') stack.push(']'); else if (stack.isEmpty() || stack.pop() != c) return false; &#125; return stack.isEmpty();&#125; 150.Evaluate Reverse Polish NotationEvaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. Note: Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation. Example 1: Input: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;] Output: 9 Explanation: ((2 + 1) * 3) = 9 Example 2: Input: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;] Output: 6 Explanation: (4 + (13 / 5)) = 6 Example 3: Input: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;] Output: 22 Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 解题思路 用栈解决 遇到数字直接入栈 遇到操作符，则pop出两个数字，进行计算，计算后的值接着入栈 需要注意的是除法的时候，是后pop出来的除以先pop出来的 84.Largest Rectangel in Histrogram 在DP专题总结过 Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area = 10 unit. 栈，存放数组的index 栈为空或者数组是递增状态，则直接push 小于则pop，并计算当前的最大面积 代码 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int largestRectangleArea(int[] height) &#123; int len = height.length; Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); int maxArea = 0; for(int i = 0; i &lt;= len; i++)&#123; int h = (i == len ? 0 : height[i]); if(s.isEmpty() || h &gt;= height[s.peek()])&#123; s.push(i); &#125;else&#123; int tp = s.pop(); maxArea = Math.max(maxArea, height[tp] * (s.isEmpty() ? i : i - 1 - s.peek())); i--; &#125; &#125; return maxArea; &#125;&#125;//或者class Solution &#123; public int largestRectangleArea(int[] height) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); int index = 0, largestArea = 0; while (index &lt; height.length || (index == height.length &amp;&amp; !stack.isEmpty())) &#123; if (index != height.length &amp;&amp; (stack.isEmpty() || height[stack.peek()] &lt; height[index])) &#123; stack.push(index++); &#125; else &#123; int h = height[stack.pop()]; int w = stack.isEmpty() ? index : index - stack.peek() - 1; largestArea = Math.max(largestArea, h * w); &#125; &#125; return largestArea; &#125;&#125; 85.Maximal Rectangle 在DP专题总结过 Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing all 1’s and return its area. 要求最大的矩形，实际上可以将矩阵的每一行，转化为上一题的直方图， 而直方图的每个竖条的数字，就是该行对应坐标正上方，向上方向有多少个连续的1。 要转化为直方图，方法是每一行的数值都累加上一行计算出来的数值，而第一行的数值就是本身。如果原始矩阵中遇到0，则累加中断，重新置0。 12340 0 1 1 0 -&gt; 0 0 1 1 00 0 1 1 0 -&gt; 0 0 2 2 01 1 0 0 0 -&gt; 1 1 0 0 01 1 1 0 0 -&gt; 2 2 1 0 0 dp[i][j]化为直方图的值 接着对dp[i][j]进行Largest Rectangle in Histogram计算即可 1234i == 0 --&gt; dp[i][j] = matrix[i][j] - &apos;0&apos;i != 0 --&gt; matrix[i][j] == 1 --&gt; dp[i][j] = dp[i-1][j] + matrix[i][j] - &apos;0&apos;matrix[i][j] != 1 --&gt; dp[i][j] = 0 代码 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public int maximalRectangle(char[][] matrix) &#123; int max = 0; if(matrix.length == 0) return 0; int[][] dp = new int[matrix.length][matrix[0].length]; for(int i = 0; i &lt; matrix.length; i++)&#123; for(int j = 0; j &lt; matrix[0].length; j++)&#123; // 如果是第一行就是自身，如果遇到0则停止累加 dp[i][j] = i == 0 ? matrix[i][j] - '0' : matrix[i][j] == '1' ? dp[i-1][j] + matrix[i][j] - '0' : 0; &#125; &#125; for(int i = 0; i &lt; dp.length; i++)&#123; //找每行的最大矩形 int tmp = findRowMax(i, dp); max = Math.max(max, tmp); &#125; return max; &#125; private int findRowMax(int row, int[][] matrix)&#123; if(matrix[row].length== 0) return 0; Stack&lt;Integer&gt; stk = new Stack&lt;Integer&gt;(); int i = 1, max = matrix[row][0]; stk.push(0); while(i &lt; matrix[row].length || (i == matrix[row].length &amp;&amp; !stk.isEmpty()))&#123; if(i != matrix[row].length &amp;&amp; ( stk.isEmpty() || matrix[row][i] &gt;= matrix[row][stk.peek()] ))&#123; stk.push(i); i++; &#125; else &#123; int top = matrix[row][stk.pop()]; int currMax = !stk.isEmpty() ? top * (i - stk.peek() - 1) : top * i; max = Math.max(currMax, max); &#125; &#125; return max; &#125;&#125; 71.Simplify PathGiven an absolute path for a file (Unix-style), simplify it. For example, path = “/home/“, =&gt; “/home” path = “/a/./b/../../c/“, =&gt; “/c” Corner Cases: Did you consider the case where path = “/../“?In this case, you should return “/“. Another corner case is the path might contain multiple slashes ‘/‘ together, such as “/home//foo/“.In this case, you should ignore redundant slashes and return “/home/foo”. 题目意思 .可忽略，..需要pop掉上一个，比如/b/../c/ -&gt; /c 代码 1234567891011class Solution &#123; public String simplifyPath(String path) &#123; Stack&lt;String&gt; stack = new Stack(); for(String cur: path.split("/"))&#123; if(cur.equals("..")) &#123; if(!stack.empty()) stack.pop(); &#125;else if(cur.length()&gt;0 &amp;&amp; !cur.equals(".")) stack.push(cur); &#125; return "/"+String.join("/",stack); &#125;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>算法</category>
        <category>LeetCode Category</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类文件结构]]></title>
    <url>%2F2018%2F06%2F25%2F%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Class类文件的结构 Class文件的头4个字节称为魔数(magic),用于确定文件是否是能被虚拟机接收的Class文件。0xCAFEBABE 代表Java 紧接着的是Class文件的版本号：第5和第6字节是次版本号(minor_version),第7和第8字节是主版本号(major_version) 紧接着主次版本号之后的是常量池入口，由于常量数量不固定，需要放置常量池容量计数值(constant_pool_count), 计数从1开始, (0用来表示“不引用任何一个常量池项目”) 常量池中存放两大类常量：字面量和符号引用。字面量接近Java中常量的概念，而符号引用则属于编译原理方面的概念，包含三大类： 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 JDK的bin目录中，javap工具-verbose可用于输出常量表 常量池结束之后，是访问标志(access_flags), 用于识别一些类或者接口的访问信息。包括是否public、final、abstract等 类索引(this_class)、父类索引(super_class)分别确定类、父类的全限定名。接口索引集合(interfaces), 由这三项数据确定类的继承关系。 字段表(field_info)用于描述接口或者类中声明的变量，字段包括类级变量以及实例级变量。 方法表和字段表相似，结构也包含上述的4个部分，仅在访问标志和属性表集合的可选项中有些区别，方法里面的代码存放在属性表集合中“Code”属性中。 属性表集合，不需要严格顺序，几个常用属性讲解： Code属性 使用位置：方法表，Java代码编译成的字节码指令 Exceptions属性 列出方法中可能抛出的异常，即throws关键字后列举的异常 LineNumberTable属性 描述Java源码行号和字节码行号之间的对应关系，选择不生成，则抛出异常时没有出错行号 LocalVariableTable属性 描述栈帧中局部变量表中的变量和Java源代码中定义的变量之间的关系，如果不生成，当别人引用该方法时，参数名称会丢失，IDE使用args1等占位符替代，带来不便 SourceFile属性 记录生成这个Class文件的源码文件名称，选择不生成，则抛出异常时，不显示出错代码的文件名 ConstantValue属性 通知虚拟机为静态变量赋值 非static变量，在实例构造器init中进行 类变量，类构造器clinit中/使用ConstantValue Sun Javac中，如果同时使用static和final修饰，并且是基本数据类型或者String时，生成ConstantValue来进行初始化，如果没有被final修饰或者类型不符，则在clinit中初始化 InnerClasses属性 记录内部类和宿主类之间的关联。如果一个类中定义了内部类，编译器会为它以及它所包含的内部类生成该属性 Deprecated及Synthetic属性 标志类型的布尔类型 Deprecated表示类、字段或方法，已经被程序作者定为不再推荐使用，可以使用@ deprecated注解设置 Synthetic表示字段或者方法不是由Java源码直接产生的，而是由编译器添加的。所有由非用户生成的类、方法及字段都应该至少设置Synthetic属性或者ACC_SYNTHETIC标志位，但是实例构造器init和类构造器clinit除外 StackMapTable属性 位于Code属性的属性表中，在虚拟机类加载的字节码验证阶段被新类型检查验证器使用，用于代替之前比较消耗性能的基于数据流分析的类型推导验证器 一个方法的Code属性醉倒只能有一个StackMapTable Signature属性 记录泛型类型，Java采用的是擦除法实现的伪泛型，泛型信息编译之后会被擦除，比如运行前做反射时无法得到泛型类型 字节码指令简介Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字(操作码)以及紧随其后的零至多个代表此操作所需参数(操作数)而构成。Java虚拟机采用操作数栈，大多数质量都不包含操作数。 加载和存储指令 将数据在栈帧中的局部变量表和操作数栈之间来回传输 运算指令 用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入操作栈顶 类型转换指令 将两种不同的数值类型进行转换，显式类型转换 对象创建与访问指令 针对类实例和数组 操作数栈管理指令 直接操作操作数栈，类似操作数据结构中的堆栈 控制转移指令 让Java虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的下一条指令继续执行程序。(条件分支ifeq、复合条件分支、无条件分支goto) 方法调用和返回指令 方法调用(分派、执行过程)指令与数据类型无关，方法返回指令根据返回值的类型区分 异常处理指令 Java中显式抛出异常的操作(throw)都由athrow来实现，很多运行时异常会在检测到时自动抛出 Java虚拟机中，处理异常(catch)，采用异常表来完成 同步指令 支持方法级的同步和方法内部一段指令序列的同步，都使用管程(Monitor)来支持 方法级同步时隐式的，实现在方法调用和返回操作之中。虚拟机得知是否为同步方法，方法调用时，检查ACC_SYNCHRONIZED访问标志是否被设置，设置则要求成功持有管程，然后才能执行方法，方法完成(成功/失败)时释放管程。方法执行期间，其他线程无法获得该管程。如果同步期间抛出异常，并在内部无法处理，则管程会在异常抛出到同步方法之外时释放 同步一段指令序列通过synchronized语句块来表示，Java指令集中monitorenter和monitorexit来支持synchronized语义]]></content>
      <categories>
        <category>Java基础</category>
        <category>读书笔记</category>
        <category>深入理解Java虚拟机</category>
        <category>虚拟机执行子系统</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP中GET与POST的区别]]></title>
    <url>%2F2018%2F06%2F20%2FHTTP%2F</url>
    <content type="text"><![CDATA[GET和POST是HTTP请求的两种基本方法，最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。 你轻轻松松的给出了一个“标准答案”： GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST没有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。 GET和POST是什么? HTTP协议中的两种发送请求的方法。 HTTP是什么? HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。 HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 那么，“标准答案”里的那些区别是怎么回事? 在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签(设置method为GET)，而且要求把传送的数据放在车顶上(url中)以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩;也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。但是，我们只看到HTTP对GET和POST参数的传送渠道(url还是requrest body)提出了要求。“标准答案”里关于参数大小的限制又是从哪来的呢? 在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器(发起http请求)和服务器(接受http请求)就是不同的运输公司。虽然理论上，你可以在车顶上无限的堆货物(url中无限加参数)。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，(大多数)浏览器通常都会限制url长度在2K个字节，而(大多数)服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。好了，现在你知道，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 GET和POST还有一个重大区别，简单的说： GET产生一个TCP数据包;POST产生两个TCP数据包。 长的说： 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。 也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。 因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑!跳入需谨慎。为什么? GET与POST都有自己的语义，不能随便混用。 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。 本文参考地址]]></content>
      <categories>
        <category>Java面试</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络 -- 传输层]]></title>
    <url>%2F2018%2F06%2F19%2F%E4%BC%A0%E8%BE%93%E5%B1%82%2F</url>
    <content type="text"><![CDATA[知识架构图如下: 传输层提供的服务传输层的功能面向通信部分的最高层，用户功能中的最低层。传输层提供可靠服务（尽管网络层不可靠） 传输层的功能： 传输层为运行在不同主机上的进程提供逻辑通信（端到端通信），而网络层提供主机之间的逻辑通信。 复用和分用 传输层：（复用）不同进程可用同一传输协议，（分用）可剥离给不同进程 网络层：（复用）不同协议数据可封装成IP数据报发送出去，（分用）可剥离给不同协议 传输层对收到的报文进行差错检测（首部和数据部分），网络层只检测IP数据报的首部，不检验数据部分是否出错 提供两种不同的传输协议，面向连接的TCP和无连接的UDP，网络层无法同时实现两种 传输层的寻址与端口 端口的作用 让应用进程将数据通过端口交付给传输层 让传输层知道讲数据交付给应用层对于进程 端口号：只有本地意义 服务端使用的端口号 客户端使用的端口号，短暂端口号 套接字：组合识别端点 IP地址标识和区别不同主机，端口号标识和区别主机众不同应用进程，套接字组合识别端点 套接字 = （主机IP地址，端口号） 无连接服务与面向连接服务 面向连接服务就是在通信之前，必须建立连接，通信过程中，实时监控和管理连接情况。通信结束后，应该释放连接。 TCP不提供广播或组播服务，适合可靠性更重要的场合，如FTP，HTTP，TELNET（远程登录） 无连接的服务，通信不需要先建立连接，需要通信时，直接将信息发送到“网络”中，让信息的传递尽力往目的地传送 UDP在IP之上提供多路复用和对数据的错误检查，执行速度快，实时性好，TFTP（小文件传送协议），DNS，SNMP（简单网络管理协议）和RTP（实时协议） UDP协议UDP数据报UDP = IP + 复用/分用 + 差错检测 UDP优点： UDP无需建立连接，没有建立连接的时延 无连接状态，能支持更多的活动客户机 首部开销小，8字节开销 应用层能更好地控制要发送的数据和发送时间，无拥塞控制，发送发自由 UDP用于一次性传输少量数据的网络应用，也用于多媒体应用，不保证可靠性交付但要求低延迟，应用层可灵活设计可靠性机制保证可靠性。 UDP面向报文，发送方UDP对应用层交下来的报文，添加首部后直接给IP层，不合并，不拆分；接收方UDP对IP层交上来的数据报，去除首部后直接给应用进程，一次交付一个完整的报文。（以报文为操作单位） UDP数据报 = UDP首部（8B） + 用户数据 源端口：需要对方回信时用，不用则为0 目的端口 长度：最小值为8（仅首部） 校验和：检验UDP数据报在传输中是否出错，有错则丢弃。源主机不想计算校验和，则为0 UDP校验采用首部、伪首部、数据进行二进制反码运算求和再取反 TCP协议TCP协议的特点 面向连接 点对点（一对一） 可靠的交付，无差错、不丢失、不重复且有序 全双工通信，通信双方都可发送数据 面向字节流 TCP报文段(TCP传送的数据单元)TCP报文段分为首部和数据两部分，整个TCP段作为IP数据报的数据部分封装在IP数据报中。首部前20字节是固定的，后面有4N字节是根据需要而增加的选项。 TCP报文段既可以用来运载数据，也可以用来建立/释放连接，应答。 序号字段：4字节，指的是本报文段所发送的数据的第一个字节的序号 确认号字段：4字节，期望收到对方的下一个报文段的数据的第一个字节的序号。若确认号为N，则表示到序号N-1为止的数据都已正确收到 数据偏移：首部长度，4位 保留字段：6位，目前置0 紧急位URG：URG = 1时，表示紧急指针有效，表明有紧急数据，需要尽快送达。URG需要和紧急指针配套使用，数据从第一个字节到紧急指针所指字节就是紧急数据 确认位ACK：ACK = 1时确认号字段才有效。连接建立后所有传送的报文段都必须把ACK置1 推送位PSH：（PSH = 1）尽快交付接收应用进程，不用等到缓冲区满了再交付 复位位RST：（RST = 1）连接出现严重差错，必须释放连接，然后再重新建立运输连接 同步位SYN：SYN = 1表示这是一个连接请求或连接接收报文 SYN = 1，ACK = 0，连接请求报文 SYN = 1，ACK = 1，连接接收报文 终止位FIN：（FIN = 1）发送方数据发送完毕，要求释放连接 窗口字段：2字节，指出允许对方发送的数据量 检验和：2字节，检验首部和数据，计算时和UDP相似，也要加12字节的伪首部，将UDP中的17 -&gt; 6 紧急指针字段：16位，指出本报文段中紧急数据的字节总数（紧急数据放在报文段数据的最前面） 选项字段：最大报文段长度（MSS），MSS是TCP报文段中的数据字段的最大长度 填充字段：为了使整个首部长度是4字节的整数倍 TCP连接管理TCP连接的端口叫套接字，每一条TCP连接唯一地被通信两端的两个端点所确定。 TCP连接的建立（三次握手） 最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。 TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态； TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。 TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。 TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。 当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。 TCP是全双工通信，通信双方的应用进程在任何时候都能发送数据。 服务器的资源是在完成第二次握手时分配的，客户端资源是在完成第三次握手时分配的。这使服务器易于受到SYN洪泛攻击。 Q:为什么TCP客户端最后还要发送一次确认呢？ A:防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。 TCP连接的释放（四次挥手） 数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。*这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。* 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2[Math Processing Error]MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 为什么客户端最后还要等待2MSL？ 保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。 防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。 为什么建立连接是三次握手，关闭连接确是四次挥手呢？ 建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。 TCP可靠传输保证接收方进程从缓冲区读出的字节流与发送方发出的字节流是完全一样的 使用了校验、序号、确认和重传等机制来达到目的 序号：TCP 数据段以字节为单位对数据段中的“数据”部分进行一一编号，确保每个字节的数据都可以有序传送和接受 确认：TCP 要求每接受一个数据段都必须由接收端向发送端返回一个确认数据段，其中的“确认号”表明接收端已正确接受的数据段序号（“确认号”前面的所有数据段，确认号表示将要接收的下一个数据段编号）。 重传 超时：超出计时器的重传时间还未收到确认则重传，RTT 冗余：TCP规定每当比期望序号大的失序报文段到达时，发送一个冗余ACK，指明下一个期待字节的序列号。TCP规定当发送方收到对同一个报文段的3个冗余ACK时，可以认为跟在这个被确认的报文段之后的报文段已经丢失（快重传）。 TCP流量控制在确认报文中设置窗口字段rwnd来限制发送速率，发送方可也根据当前网络拥塞程度设置拥塞窗口cwnd。发送窗口的实际大小取rwnd和cwnd的最小值 TCP拥塞控制根据自己估算的网络拥塞程度设置cwnd来限制发送速率 慢开始算法：刚连接的TCP，令cwnd = 1（一个最大报文段长度），每收到一个确认后加1。每经过一个RTT，cwnd加倍，直到慢开始门限（ssthresh），改用拥塞避免算法 拥塞避免算法：cwnd每经过一个RTT就加1（加法增大），当出现一次超时，令慢开始门限等于当前cwnd的一半（乘法减小） 根据cwnd的大小执行不同算法： cwnd &lt; ssthresh,慢开始算法 cwnd &gt; ssthresh,停止慢开始，使用拥塞避免算法 cwnd = ssthresh,都可以（通常使用拥塞避免算法） 一旦网络出现拥塞时，都要把ssthresh设为cwnd的一半（但不能小于2），然后把cwnd设为1，执行慢开始算法。 快重传、快恢复是对慢开始算法和拥塞避免算法的改进。 快重传：发送方连续收到三个重复的ACK时，直接重传对方尚未收到的报文段 快恢复：发送方连续收到三个重复的ACK时，就执行“乘法减小”，将ssthresh设置为cwnd的一半。把cwnd设为ssthresh改变后的值，然后开始执行拥塞避免算法（“加法增大”）]]></content>
      <categories>
        <category>Java基础</category>
        <category>读书笔记</category>
        <category>计算机网络</category>
        <category>传输层</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络 -- 网络层]]></title>
    <url>%2F2018%2F06%2F13%2F%E7%BD%91%E7%BB%9C%E5%B1%82%2F</url>
    <content type="text"><![CDATA[知识架构图如下: 网络层的功能异构网络互联网络的互联，指的是将两个以上的计算机网络，通过一定的方法，用一种或多种通信处理设备(即中间设备/中间系统/中继系统)相互连接起来，以构成更大的网络系统。 四种不同的中继系统： 物理层中继系统: 中继器，集线器(Hub) 数据链路层中继系统: 网桥或交换机 网络层中继系统: 路由器 网络层以上的中继系统: 网关 物理层、数据链路层中继系统，只是扩大网络，但仍然是同一个网络，称不上互联。 网络互联通常是指用路由器进行网络互联和路由选择，路由器就是一台专用计算机，用于在互联网中进行路由选择。 虚拟(逻辑)互联网络，互联起来的各种物理网络的异构行本来是客观存在的，但使用IP协议可以看起来是一个统一的网络。 使用虚拟(逻辑)互联网络的好处：当互联网的主机进行通信时，就好像在一个网络上通信一样，而看不见互联的具体的网络异构细节。 路由与转发路由器主要完成两个功能： 路由选择(确定哪一条路径): 按照分布式算法，根据从相邻路由器所得到的关于整个网络拓扑的变化情况，动态改变所选路由 分组转发(当一个分组到达时所采取的动作): 根据转发表将用户的IP数据报从合适的端口转发出去 路由表是根据路由选择算法得出的，转发表从路由表得出。转发表的结构应该使查找过程最优化，路由表则需要对网络拓扑变化的计算最优化。 拥塞控制在通信子网中，由于出现过量的分组而引起网络性能下降的现象称为拥塞。 判断网络是否进入拥塞状态的方法是观察网络的吞吐量和网络负载的关系： 网络负载增加: 吞吐量小于正常: “轻度拥塞” 吞吐量下降: 拥塞 吞吐量将为0: 死锁 流量控制与拥塞控制的区别: 流量控制指在发送端和接收端之间的点对点通信量的控制。流量控制所要做的就是抑制发送端发送端发送数据的速率，以便接收端来得及接收。而拥塞控制必须确保通信子网能够传送待传送的数据，是一个全局性的问题，设计网络中所有主机、路由器以及导致网络传输能力下降的所有因素。 拥塞控制的方法： 开环控制: 静态预防，视线尽可能考虑好，启动后不修改，不考虑当前网络状态 闭环控制: 事先不管，动态监控，启动后监视检测，及时解决，基于反馈环路概念 路由算法静态路由与动态路由从能否随网络的通信量货拓扑自适应地进行调整变化来划分，可分为两大类： 静态路由算法(非自适应): 网络管理员手工配置的路由信息。网络拓扑或链路状态变化时，需要手工修改路由表中相关的静态路由信息。 简便、可靠，适合负荷稳定、拓扑变化不大的网络 不适合大型、复杂网络环境 动态路由算法(自适应): 路由器上的路由表项是通过相互连接的路由器之间彼此交换信息，然后按照一定的算法优化出来的，这些信息是在一定时间间隙里不断更新，以适应不断变化的网络，以随时获得最优的寻路效果 改善网络性能并有助于流量控制 算法复杂，增加网络负担，有时因对动态变化的反应太快而引起振荡，或反应太慢而影响网络路由的一致性 距离-向量路由算法（最常见RIP算法）所有结点都定期将它们的整个路由选择表传送给所有与之直接相邻的结点。这种路由选择表包括： 每条路径的目的地（另一结点） 路径的代价（也称距离） 当被通告有新的路由或者到达某一个目的地的距离更小时，会发生更新 链路状态路由算法（典型OSPF算法）链路状态路由算法要求每个参与该算法的结点都有完全的网络拓扑信息。执行两项任务： 主动测试所有邻接结点的状态 定期将链路状态传播给所有其他的结点 在一个链路状态路由选择中，一个结点检查所有直接链路的状态，并将所得的状态信息发送给网上所有其他结点。 当链路报文到达时，路由结点根据信息去更新网络拓扑和状态“视野图”，一旦链路状态变化，结点对更新了的网络图利用Dijsktra最短路径算法重新计算路由。 三点特征： 泛洪法，路由器通过所有端口向所有相邻的路由器发送信息。而每一个相邻路由器又将此信息发往其所有相邻路由器（不包含刚发来信息的路由器） 发送的信息就是与路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息 只有当链路状态变化时，才向所有路由器发送此消息 优点： 结点使用同样的原始状态数据独立计算路径，不依赖中间结点 链路状态报文不加改变地传播，易于查找故障 链路状态报文只包含单个结点关于直接链路的信息，与网络中路由结点的数量无关 适用于大型的或路由信息变化聚敛的互联网环境 名称 特点 优缺点 距离-向量路由算法 仅与直接邻居交谈，为邻居提供从自己到所有其他结点的费用 路由环路 链路状态路由算法 广播方式与所有其他结点交谈，仅告诉与之直接相连链路的费用 更好的规模可伸展性 层次路由将互联网划分为许多自治系统，每个自治系统自主决定内部使用何种路由选择协议。 路由选择协议： 内部网关协议(域内路由选择)：自治系统内部使用，RIP和OSFP 外部网关协议(域间路由选择)：自治系统之间使用，BGP 采用层次划分区域虽然使交换信息种类增多，使OSPF协议更复杂，但能使每个区域内交换路由信息的通信量大大减小，因而使OSPF能够用于规模更大的自治系统中。 IPV4IPV4分组 总长度：首部+数据，以太网帧最大传送单元MTU为1500字节，数据报总长度不能超过 标识：每产生一个数据报就加1，并赋值给标识字段。当数据报长度超过MTU时必须分片，数据报片都复制一次标识号以便能正确组装原来的数据报 标志：是否有片，最低位MF，MF=1表示后面还有分片；MF=0表示最后一个分片。标志字段中间的一位是DF，DF=0才允许分片，片在目的地的网络层被重新组装 片偏移：较长的分组在分片后，某片在原分组中的相对位置 首部检验和：只校验分组首部，不校验数据部分 生存时间TTL：数据报在网络中可通过的路由器数的最大值，标识分组在网络中的寿命，确保分组不会永远在网络中循环 协议：分组携带的数据使用何种协议 固定部分20B，首部长度、总长度、片偏移的基本单位分别为4B、1B、8B IPV4地址与NATIPV4地址IP地址由网络号和主机号两部分组成 网络地址转换将专用网络地址转换为公用地址，从而对外隐藏内部管理的IP地址 子网划分与子网掩码、CIDR子网划分&amp;子网掩码采用子网掩码对物理子网再一次进行子网划分。 计算机只需将IP地址和其对应子网掩码逐位相“与”，就可得出相应子网的网络地址 无分类编址CIDR无分类域间路由选择(CIDR)是在变长子网掩码的基础上提出的一种消除传统A、B、C类网络划分，并且可以在软件的支持下实现超网构造的一种IP地址的划分方法。 主要特点： 消除传统A、B、C类地址以及划分子网的概念，IP地址的无分类两级编址为：IP::{&lt;网络前缀&gt;,&lt;主机号&gt;} 斜线记法，IP地址/网络前缀所占比特数 例如128.14.32.5/20，掩码是20个连续的1和后续12个连续的0，逐位相“与”可以得到该地址的网络前缀（或直接截取前20位） 将网络前缀都相同的连续IP地址组成“CIDR”地址块，这种地址的聚合称为路由聚合或称为构成超网，使得路由表中的一个项目可以表示很多个原来传统分类地址的路由，减少路由器之间路由选择信息的交换。二进制表示的IP地址取最长公共前缀作为网络号。 ARP协议、DHCP协议与ICMP协议IP地址与硬件地址地址解析协议ARPIP地址到MAC地址的映射，每个主机设有一个ARP高速缓存，存放本局域网上各主机和路由器的IP地址到MAC地址的映射表(ARP表) ARP工作在网络层，4中典型情况： 发送方是主机，把数据报发送到本网络另一个主机。用ARP找到目的主机的硬件地址 发送方是主机，把数据报发送到另一个网络的一个主机。用ARP找到本网络的一个路由器的硬件地址，剩下的工作由路由器完成 发送方是路由器，把数据报发送到本网络的一个主机。用ARP找到目的主机的硬件地址 发送方是路由器，把数据报发送到另一个网络的一个主机。用ARP找到本网络的一个路由器的硬件地址，剩下的工作由路由器完成 动态主机配置协议DHCP动态主机配置协议常用于给主机动态分配IP地址，提供了即插即用的联网机制。应用层协议，基于UDP DHCP服务器和DHCP客户端的交换过程如下： DHCP客户机广播“DHCP发现”消息，试图找到网络中的DHCP服务器，以便从DHCP服务器获得一个IP地址。由于DHCP客户机还未配置IP地址，它只能使用广播方式发送消息，并且源IP地址设置为0.0.0.0。 DHCP服务器收到“DHCP发现”消息后，就向网络中广播“DHCP供给”消息，其中包括提供给DHCP客户机的IP地址和相关配置信息。 DHCP客户机收到“DHCP供给”消息，如果接受DHCP服务器所提供的相关参数，就通过广播“DHCP请求”向DHCP服务器请求提供IP地址。 DHCP服务器广播“DHCP确认”消息，将IP地址分配给DHCP客户机。 网际控制报文协议ICMP用来给主机或路由器报告差错和异常情况。 ICMP报文作为IP层数据报的数据，加上数据报首部，组成IP数据包发送出去。ICMP协议是IP层协议 ICMP的报文种类有ICMP差错报告报文和ICMP询问报文： 差错报告报文有5种： 终点不可以到达：当路由器和主机不能交付的时候 源点抑制：当路由器由于网络拥塞而丢弃的时候，源点把数据报发送速率减慢 时间超过：当路由器收到生存时间为0的数据报的时候 参数问题：当目的主机发现收到的数据报首部有问题的时候 改变路由：路由器把改变你的路由交付主机，告诉下一次的主机 不应发送ICMP差错报告报文： 对ICMP差错报告报文不再发送ICMP差错报告报文 若数据报进行了分片,只有第一个分片能发送ICMP报文 组播地址的数据报,不发送ICMP报文 特殊地址(如127.0.0.0或0.0.0.0)不发送ICMP报文 ICMP询问报文： 回送请求和回答报文(PING,应用层，直接使用ICMP)、时间戳请求和回答报文(Traceroute/tracert)、掩码地址请求和回答报文、路由器询问和通告报文，最常用的是前两类 IPV6IPV6的主要特点 IPv6具有更大的地址空间。32-&gt;128 扩展的地址层次结构 灵活的首部格式 改进的选项。 允许协议继续扩充。如果新的技术或应用需要时，IPV6允许协议进行扩充 支持即插即用，IPv6加入了对自动配置（Auto Configuration）的支持。 支持资源预分配 不允许分片，只有在包的源结点才能分片 首部长度必须是8B的整数倍 IPv6具有更高的安全性。身份验证和保密功能 与IPV4不兼容，兼容TCP、UDP、ICMP、IGMP、BGP和DNS IPV6地址IPv6协议主要定义了三种地址类型：单播地址（Unicast Address）、组播地址（Multicast Address）和任播地址（Anycast Address）。与原来在IPv4地址相比，新增了“任播地址”类型，取消了原来IPv4地址中的广播地址，因为在IPv6中的广播功能是通过组播来完成的。 单播地址：用来唯一标识一个接口，类似于IPv4中的单播地址。发送到单播地址的数据报文将被传送给此地址所标识的一个接口。点对点 组播地址：用来标识一组接口（通常这组接口属于不同的节点），类似于IPv4中的组播地址。发送到组播地址的数据报文被传送给此地址所标识的所有接口。一点对多点 任播地址：用来标识一组接口（通常这组接口属于不同的节点）。发送到任播地址的数据报文被传送给此地址所标识的一组接口中距离源节点最近（根据使用的路由协议进行度量）的一个接口。 路由协议 自治系统一个自治系统内的所有网络属于一个行政单位来管辖，一个自治系统的所有路由器在本自治系统内都必须是连通的。 域内路由与域间路由路由选择协议： 内部网关协议(IGP)：自治系统内部使用，RIP和OSFP 外部网关协议(EGP)：自治系统之间使用，BGP-4 RIP路由协议(距离-向量)路由信息协议，分布式的机遇距离向量的路由选择协议 RIP的特点 仅和相邻的路由器交换信息。如果两个路由器之间的通信不经过另外一个路由器，那么这两个路由器是相邻的。RIP协议规定，不相邻的路由器之间不交换信息。 路由器交换的信息是当前本路由器所知道的全部信息。即自己的路由表。 按固定时间交换路由信息，如，每隔30秒，然后路由器根据收到的路由信息更新路由表。（也可进行相应配置使其触发更新） 最大优点就是实现简单，开销较小，收敛过程快 缺点： 限制了网络的规模，能使用的最大距离为15（16表示不可达） 路由器交换的信息是路由器的完整路由表，因而随着网络规模的扩大，开销也就增加。 “坏消息传播得慢”，使更新过程的收敛时间过长。 RIP是应用层协议，使用UDP传送数据，RIP选择的一定是具有最少路径路由器的路径。 OSPF路由协议OSPF协议的基本特点开放最短路径优先协议使用分布式链路状态路由算法。 OSPF与RIP相比有4点主要区别： OSPF使用泛洪法向本自治系统中所有路由器发信息，而RIP只向和自己相邻的路由器发送信息 发送的信息是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。“链路状态”就是说明本路由器和哪些路由器相邻，以及该链路的“度量”（或代价）。而在RIP中发送的信息是本路由器所知道的全部信息，即整个路由表 只有当链路状态发生变化时，才用泛洪法向所有路由器发送此信息，并且更新过程收敛得快，不会出现RIP“消息传播得慢”的问题。RIP中，不管网络拓扑是否变化，都会定期交换路由表信息 OSPF是网络层协议，直接使用IP数据报传送。RIP是应用层协议，在传输层使用UDP协议 除以上区别外，OSPF还有如下特点： OSPF对不同链路可根据IP分组的不同服务类型而设置成不同的代价，对不同类型业务计算出不同路由 如果到同一目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫多路径间的负载平衡 所有在OSPF路由器之间交换的分组都具有鉴别功能，保证仅在可信赖路由之间交换链路状态信息 支持可变长度的子网划分和CIDR 每一个链路状态都带上一个32位的序号，序号越大状态越新 OSPF的基本工作原理全网的拓扑结构图 利用“区域”减少整个网络负荷 OSPF的五种分组类型 BGP路由协议边界网关协议是不同自治系统的路由器之间交换路由信息的协议。 路径向量路由选择协议，BGP协议是应用层协议，基于TCP，寻找的并非最佳路由 IP组播在发送者和每一接受者之间实现点对多点网络连接，仅应用于UDP，使用D类地址格式 构造组播转发树以避免路由环路 移动IP移动结点以固定的网络IP地址，实现跨越不同网段的漫游功能，并保证了基于网络IP的网络权限在漫游过程中不发生改变。 基于IPv4的移动IP定义三种功能实体：移动节点（mobile node）、归属代理（home agent）和外部代理（foreign agent）。归属代理和外部代理又统称为移动代理。 网络层设备路由器的组成和功能特点：连接异构网络，完成路由转发，隔离冲突和广播域 组成： 控制部分（路由选择部分）：路由选择处理机，根据路由协议构造和维护路由表 分组转发部分：交换结构、一组输入端口、一组输出端口 路由表与路由转发路由表根据路由选择算法得出，主要用于路由选择，标准的路由表具有四个项目：目的网络IP地址、子网掩码、下一跳IP地址、接口 “转发”根据转发表把IP数据报从合适的端口转发出去，只涉及一个路由器。“路由选择”涉及很多路由器，路由表是很多路由器协同工作的结果]]></content>
      <categories>
        <category>Java基础</category>
        <category>读书笔记</category>
        <category>计算机网络</category>
        <category>网络层</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Heap]]></title>
    <url>%2F2018%2F06%2F12%2FHeap%2F</url>
    <content type="text"><![CDATA[272.Closest Binary Search Tree Value IIGiven a non-empty binary search tree and a target value, find k values in the BST that are closest to the target. Note: Given target value is a floating point. You may assume k is always valid, that is: k ≤ total nodes. You are guaranteed to have only one unique set of k values in the BST that are closest to the target. Follow up: Assume that the BST is balanced, could you solve it in less than O(n) runtime (where n = total nodes)? Hint: Consider implement these two helper functions: getPredecessor(N), which returns the next smaller node to N. getSuccessor(N), which returns the next larger node to N. 中序遍历法 二叉搜索树的中序遍历就是顺序输出二叉搜索树 中序遍历二叉搜索树，同时维护一个大小为K的队列 前K个数直接加入队列 之后每来一个新的数（较大的数），如果该数和目标的差，相比于队头的数离目标的差来说，更小，则将队头拿出来，将新数加入队列 更大，则直接退出并返回这个队列 代码 123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; public List&lt;Integer&gt; closestKValues(TreeNode root, double target, int k) &#123; Queue&lt;Integer&gt; klist = new LinkedList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stk = new Stack&lt;TreeNode&gt;(); // 迭代中序遍历二叉搜索树的代码 while(root != null)&#123; stk.push(root); root = root.left; &#125; while(!stk.isEmpty())&#123; TreeNode curr = stk.pop(); // 维护一个大小为k的队列 // 队列不到k时直接加入 if(klist.size() &lt; k)&#123; klist.offer(curr.val); &#125; else &#123; // 队列到k时，判断下新的数是否更近，更近就加入队列并去掉队头 int first = klist.peek(); if(Math.abs(first - target) &gt; Math.abs(curr.val - target))&#123; klist.poll(); klist.offer(curr.val); &#125; else &#123; // 如果不是更近则直接退出，后面的数只会更大 break; &#125; &#125; // 中序遍历的代码 if(curr.right != null)&#123; curr = curr.right; while(curr != null)&#123; stk.push(curr); curr = curr.left; &#125; &#125; &#125; // 强制转换成List，是用LinkedList实现的所以可以转换 return (List&lt;Integer&gt;)klist; &#125;&#125; 相似的题：270.Closest Binary Search Tree Value Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target. Note: Given target value is a floating point. You are guaranteed to have only one unique value in the BST that is closest to the target. 递归 当遍历到某个根节点时，最近的那个节点要么是在子树里面，要么就是根节点本身 根据这个递归，返回子树中最近的节点，和根节点中更近的那个 代码 123456789101112public class Solution &#123; public int closestValue(TreeNode root, double target) &#123; // 选出子树的根节点 TreeNode kid = target &lt; root.val ? root.left : root.right; // 如果没有子树，也就是递归到底时，直接返回当前节点值 if(kid == null) return root.val; // 找出子树中最近的那个节点 int closest = closestValue(kid, target); // 返回根节点和子树最近节点中，更近的那个节点 return Math.abs(root.val - target) &lt; Math.abs(closest - target) ? root.val : closest; &#125;&#125; 迭代 记录一个最近的值，然后沿着二叉搜索的路径一路比较下去，并更新这个最近值 代码 123456789101112public class Solution &#123; public int closestValue(TreeNode root, double target) &#123; int closest = root.val; while(root != null)&#123; // 如果该节点的离目标更近，则更新到目前为止的最近值 closest = Math.abs(closest - target) &lt; Math.abs(root.val - target) ? closest : root.val; // 二叉搜索 root = target &lt; root.val ? root.left : root.right; &#125; return closest; &#125;&#125; 239.Sliding Window MaximumGiven an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example: Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Note:You may assume k is always valid, 1 ≤ k ≤ input array’s size for non-empty array. Follow up:Could you solve it in linear time? 思路与代码 就看题目中的例子，[1 3 -1] -3 5 3 6 7，我们知道这个窗口中的最大值为3。我们同时也可以确定，3之前的数字无需加入后面大小的比较，因为它们一定比3小。 按照这种规则，我们可以维护一个存储了可比较数字的链表。这个链表中的数字可以和当前准备加入链表的值进行比较。那么我们看一下将一个值加入该链表有什么场景： 链表为空，直接加入 链表的数量大于窗口，则删除最左侧的值 链表中有值，且有些值小于即将加入的值，则这些小于的值都被抛弃 链表中的值均大于即将加入的值，则不进行任何操作 代码： 可以用deque 12345678910111213141516171819public int[] maxSlidingWindow(int[] nums, int k) &#123; if(nums.length == 0 || k == 0) return new int[0]; LinkedList&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;(); int[] result = new int[nums.length - k + 1]; for(int i = 0 ; i&lt;nums.length ; i++)&#123; while(list.size() != 0 &amp;&amp; list.getFirst() &lt; i-k+1)&#123; list.remove(0);//deq.poll() &#125; while(list.size()!=0 &amp;&amp; nums[list.getLast()] &lt; nums[i])&#123; list.remove(list.size()-1);//deq.pollLast() &#125; list.addLast(i); if(i - k + 1 &gt;= 0)&#123; result[i-k+1] = nums[list.getFirst()];//deq.peek() &#125; &#125; return result;&#125; 480.Sliding Window Median 与上一题不同的是这次找的是中位数 For example,Given nums = [1,3,-1,-3,5,3,6,7], and k = 3. Window position Median --------------- ----- [1 3 -1] -3 5 3 6 7 1 1 [3 -1 -3] 5 3 6 7 -1 1 3 [-1 -3 5] 3 6 7 -1 1 3 -1 [-3 5 3] 6 7 3 1 3 -1 -3 [5 3 6] 7 5 1 3 -1 -3 5 [3 6 7] 6 Therefore, return the median sliding window as [1,-1,-1,3,5,6]. minHeap和maxHeap，maxHeap在保存较小的一半元素，minHeap保存较大的一半元素 然后调整最大堆和最小堆的大小。根据k值可以分两种情况讨论： 若k为偶数，则需要最大堆中元素和最小堆中元素数量相等 若k为奇数，此时最小堆的堆顶元素即为此时窗口元素的median 代码 1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; PriorityQueue&lt;Integer&gt; minHeap; PriorityQueue&lt;Integer&gt; maxHeap; public double[] medianSlidingWindow(int[] nums, int k) &#123; int n = nums.length; double[] result = new double[n - k + 1]; maxHeap = new PriorityQueue&lt;&gt;(k/2 + 1, (a, b) -&gt; b.compareTo(a)); minHeap = new PriorityQueue&lt;&gt;(k/2 + 1); for(int i = 0; i &lt; n; i++) &#123; // delete the element beyond the window if(maxHeap.size() + minHeap.size() == k) slide(nums[i - k]); // add new element to the window add(nums[i]); if(i &gt;= k - 1) &#123; result[i - k + 1] = getMedian(); &#125; &#125; return result; &#125; private void slide(int target) &#123; if(minHeap.contains(target)) minHeap.remove(target); else maxHeap.remove(target); &#125; private void add(int num) &#123; maxHeap.add(num); minHeap.add(maxHeap.poll()); if(maxHeap.size() + 1 &lt; minHeap.size()) maxHeap.add(minHeap.poll()); &#125; private double getMedian() &#123; // window size is even if(minHeap.size() == maxHeap.size()) return minHeap.peek()/2.0 + maxHeap.peek()/2.0; else return minHeap.peek(); &#125;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>算法</category>
        <category>LeetCode Category</category>
      </categories>
      <tags>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashTable]]></title>
    <url>%2F2018%2F06%2F09%2FHashTable%2F</url>
    <content type="text"><![CDATA[Array217.Contains DuplicateGiven an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Example 1: Input: [1,2,3,1] Output: true Example 2: Input: [1,2,3,4] Output: false Example 3: Input: [1,1,1,3,3,4,3,2,4,2] Output: true 直接使用hashset 排序，对相邻的做比较 219.Contains Duplicate II 判断数组是否存在i,j位置相同的数，同时j-i &lt;= k hashmap key: nums[i], value: i 判断是否存在key,，存在则接着比较index 无论存在与否，都需要put，相同key被覆盖 hashset i&gt;k则删除nums[i-k-1] 判断!set.add(nums[i]) 220.Contains Duplicate III 判断数组是否存在i,j位置，num[j]-nums[i] &lt;= t，同时j-i &lt;= k 类似sliding window,移动的时候增加和减少element，但对每一个value,需要考察[value-t,value+t]，时间复杂度太高… 利用Bucket Sort 构建一个大小为t+1的bucket, 比如[0, 1, 2, 3, … , t], 最大绝对值差的两个数就是t和0. 如果两个数字出现在同一个Bucket内，说明我们已经找到了。 如果不是，则在相邻的两个bucket内再找。 如果相邻的bucket内元素绝对值只差在t以内，说明我们知道到了，返回true. 为了保证j - i &lt;= k，我们在i&gt;=k时，删除 nums[i-k]对应的Bucket. 代码 1234567891011121314151617181920212223public class Solution &#123; public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123; if( k &lt; 1 || t &lt; 0) return false; Map&lt;Long, Long&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i &lt; nums.length; i++)&#123; // [-t, 0] [0, t] 的元素都会落在bucket[0]里。 // 为了解决这个问题，所有元素横移Integer.MIN_VALUE。 long remappedNum = (long) nums[i] - Integer.MIN_VALUE; long bucket = remappedNum / ((long)t + 1); if(map.containsKey(bucket) ||(map.containsKey(bucket-1) &amp;&amp; remappedNum - map.get(bucket-1) &lt;= t) || (map.containsKey(bucket+1) &amp;&amp; map.get(bucket+1) - remappedNum &lt;= t) ) return true; if(i &gt;= k) &#123; long lastBucket = ((long) nums[i-k] - Integer.MIN_VALUE) / ((long)t + 1); map.remove(lastBucket); &#125; map.put(bucket,remappedNum); &#125; return false; &#125;&#125; 使用treeset 代码 123456789101112131415161718192021222324public class Solution &#123; public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123; if( k &lt; 1 || t &lt; 0) return false; TreeSet&lt;Long&gt; tree = new TreeSet&lt;&gt;(); for(int i = 0; i &lt; nums.length; i++)&#123; //floor() 小于等于 Long floor = tree.floor((long)nums[i] + t); //ceiling() 大于等于 Long ceil = tree.ceiling((long)nums[i] - t); if((floor != null &amp;&amp; floor &gt;= nums[i]) || (ceil != null &amp;&amp; ceil &lt;= nums[i]) ) return true; tree.add((long)nums[i]); if(i &gt;= k)&#123; tree.remove((long)nums[i-k]); &#125; &#125; return false; &#125;&#125; 243.Shortest Word DistanceGiven a list of words and two words word1 and word2, return the shortest distance between these two words in the list. For example, Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”]. Given word1 = “coding”, word2 = “practice”, return 3. Given word1 = “makes”, word2 = “coding”, return 1. Note: You may assume that word1 does not equal to word2, and word1 and word2 are both in the list. 双指针法 分别记录word1和word2的位置 更新distance 代码 123456789101112131415161718public class Solution &#123; public int shortestDistance(String[] words, String word1, String word2) &#123; int ind1 = -1, ind2 = -1; int distance = Integer.MAX_VALUE; for(int i = 0;i &lt; words.length;i++)&#123; if(words[i].equals(word1))&#123; ind1 = i; if(ind2 != -1) distance = Math.min(distance, ind1 - ind2); &#125; if(words[i].equals(word2))&#123; ind2 = i; if(ind1 != -1) distance = Math.min(distance, ind2 - ind1); &#125; &#125; return distance; &#125;&#125; 244.Shortest Word Distance IIThis is a follow up of Shortest Word Distance. The only difference is now you are given the list of words and your method will be called repeatedly many times with different parameters. How would you optimize it? Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list. 多次call, 那就需要记录下所有的word的下标 同时，一个word可能出现多次，应该是个list 比较的时候，类似merge two sorted list的做法, 先比较最小的，然后把较小的去掉，接着比较 代码 123456789101112131415161718192021222324252627282930313233public class WordDistance &#123; HashMap&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;String, List&lt;Integer&gt;&gt;(); public WordDistance(String[] words) &#123; // 统计每个单词出现的下标存入哈希表中 for(int i = 0; i &lt; words.length; i++)&#123; List&lt;Integer&gt; cnt = map.get(words[i]); if(cnt == null)&#123; cnt = new ArrayList&lt;Integer&gt;(); &#125; cnt.add(i); map.put(words[i], cnt); &#125; &#125; public int shortest(String word1, String word2) &#123; List&lt;Integer&gt; idx1 = map.get(word1); List&lt;Integer&gt; idx2 = map.get(word2); int distance = Integer.MAX_VALUE; int i = 0, j = 0; // 每次比较两个下标列表最小的下标，然后把跳过较小的那个 while(i &lt; idx1.size() &amp;&amp; j &lt; idx2.size())&#123; distance = Math.min(Math.abs(idx1.get(i) - idx2.get(j)), distance); if(idx1.get(i) &lt; idx2.get(j))&#123; i++; &#125; else &#123; j++; &#125; &#125; return distance; &#125;&#125; 245.Shortest Word Distance IIIThis is a follow up of Shortest Word Distance. The only difference is now word1 could be the same as word2. Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list. word1 and word2 may be the same and they represent two individual words in the list. For example, Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”]. Given word1 = “makes”, word2 = “coding”, return 1. Given word1 = “makes”, word2 = “makes”, return 3. Note: You may assume word1 and word2 are both in the list. 和I相似，区别就在于两个词可能相同 需要区分第一次遇到和第二次遇到这个词。加入一个turns，如果是相同单词的话，每次遇到一个单词turn加1，这样可以根据turn来判断是否要switch 代码 123456789101112131415161718192021public class Solution &#123; public int shortestDistance(String[] words, String word1, String word2) &#123; int ind1 = -1, ind2 = -1; int distance = Integer.MAX_VALUE; int turns = 0; int inc = word1.equals(word2) ? 1:0; for(int i = 0;i &lt; words.length;i++)&#123; if(words[i].equals(word1) &amp;&amp; turns % 2 == 0)&#123; ind1 = i; if(ind2 != -1) distance = Math.min(distance, ind1 - ind2); turns += inc; &#125;else if(words[i].equals(word2))&#123; ind2 = i; if(ind1 != -1) distance = Math.min(distance, ind2 - ind1); turns += inc; &#125; &#125; return distance; &#125;&#125; Number202.Happy NumberWrite an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example: Input: 19 Output: true Explanation: 1^2 + 9^2 = 82 8^2 + 2^2 = 68 6^2 + 8^2 = 100 1^2 + 0^2 + 0^2 = 1 用set记录在计算过程中出现的值 如果再次出现，说明不行 否则一直计算直到结果为1 123456789101112131415161718192021class Solution &#123; public boolean isHappy(int n) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); while(set.add(n))&#123; int res = 0; while(n != 0)&#123; int digit = n%10; res += digit * digit; n /= 10; &#125; if(res == 1)&#123; return true; &#125;else&#123; n = res; &#125; &#125; return false; &#125; &#125; String3.Longest Substring without repeat charactersGiven a string, find the length of the longest substring without repeating characters. Examples: Given “abcabcbb”, the answer is “abc”, which the length is 3. Given “bbbbb”, the answer is “b”, with the length of 1. Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. sliding window + set解法 两个指针p1,p2，p1是window的左边界，p2是右边界 左边界不动时，右边界尽可能往右扩展，直到不能满足条件 左边界移动，删除set中左边的元素 代码 1234567891011121314151617class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if(s == null || s.length() == 0) return 0; int length = s.length(); int p1 = 0, p2 = 0, max = 0; Set&lt;String&gt; set = new HashSet&lt;&gt;(); while(p1 &lt; length)&#123; while(p2 &lt; length &amp;&amp; set.add(s.substring(p2, p2+1)))&#123; max = Math.max(max, p2-p1+1); p2++; &#125; set.remove(s.substring(p1, p1+1)); p1++; &#125; return max; &#125;&#125; 159.Longest Substring with at most Two Distinct CharactersGiven a string, find the length of the longest substring T that contains at most 2 distinct characters. For example, Given s = “eceba”, T is “ece” which its length is 3. 两个指针，一个map来记录字符及其出现次数。 一个右指针先移动，不断更新map, 当发现map里的字符个数大于规定个数的时候，开始移动左指针，同时更新map, 直到map里的字符个数等于规定个数， 中间不断更新包含规定字符个数的最大长度。 代码 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public int lengthOfLongestSubstringTwoDistinct(String s) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int left = 0; int i = 0; int maxLen = 0; while (i &lt; s.length()) &#123; // 根据右指针指的当前字符更新map char c = s.charAt(i); if (!map.containsKey(c)) &#123; map.put(c, 1); &#125; else &#123; map.put(c, map.get(c) + 1); &#125; // 移动左指针，直到map中字符数量降至规定数量 while (map.size() &gt; 2) &#123; char leftChar = s.charAt(left); if (map.containsKey(leftChar)) &#123; // 注意会有重复元素，所以先减小次数，只有次数降至0，才删除元素 map.put(leftChar, map.get(leftChar) - 1); if (map.get(leftChar) == 0) &#123; map.remove(leftChar); &#125; &#125; left++; &#125; maxLen = Math.max(maxLen, i - left + 1); i++; &#125; return maxLen; &#125;&#125; Follow up: 340.Longest Substring with at most k Distinct Characters 最多允许k个字符 上面的代码直接把2改成k即可。 76.Minimum Window SubstringGiven a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: Input: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot; Output: &quot;BANC&quot; Note: If there is no such window in S that covers all characters in T, return the empty string “”. If there is such window, you are guaranteed that there will always be only one unique minimum window in S. 类似于Longest Substring with At Most Two Distinct Characters。 此类window题型，我们都需要用两个指针，用一个map记录字符及其出现次数， 不同的是由于这里题目要求是覆盖字符串T中所有字符，所以我们需要用一个变量如count来记录window中覆盖字符串T中有效字符的个数。 只要count == T.length(), 便可更新window的最短长度。 同时，我们必须移动左指针，直到window中包含的字符个数小于规定的数量，我们才开始移动右指针。另外要注意何时更新count的值。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Solution &#123; public String minWindow(String s, String t) &#123; // 建map, 记录被包含字符串中字符及其个数 Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; t.length(); i++) &#123; char c = t.charAt(i); if (!map.containsKey(c)) &#123; map.put(c, 1); &#125; else &#123; map.put(c, map.get(c) + 1); &#125; &#125; int l = 0; int minStart = 0; int minLen = s.length() + 1; int count = 0; for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); if (map.containsKey(c)) &#123; if (map.get(c) &gt; 0) count++; // 注意count++的条件 map.put(c, map.get(c) - 1); &#125; while (count == t.length()) &#123; // 不断更新最值 if (i - l + 1 &lt; minLen) &#123; minLen = i - l + 1; minStart = l; &#125; // 移动左指针 char leftChar = s.charAt(l); if (map.containsKey(leftChar)) &#123; map.put(leftChar, map.get(leftChar) + 1); if (map.get(leftChar) &gt; 0) &#123; count--; // 注意count--条件 &#125; &#125; l++; &#125; &#125; if (minLen == s.length() + 1) &#123; return ""; &#125; return s.substring(minStart, minLen + minStart); &#125;&#125; 30.Substring with Concatenation of All WordsYou are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: Input: s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively. The output order does not matter, returning [9,0] is fine too. Example 2: Input: s = &quot;wordgoodstudentgoodword&quot;, words = [&quot;word&quot;,&quot;student&quot;] Output: [] 输入一个字符串s和一个字符串数组words，其中words中的每个word的长度都相等。在字符串中找到所有子字符串的起始下标，只要该子字符串满足words中所有单词的连接结果（顺序无关） 把每个词当作一个字母来看待，但是要遍历K次，K是单词的长度，因为我们要分别统计从下标0开头，从下标1开头。。。直到下标K-1开头的字符串。 通过哈希表维护一个窗口，比如foo|bar|foo中，我们先拿出foo。如果foo都不在数组中，那说明根本不能拼进去，则哈希表全部清零，从下一个词开始重新匹配。 但是foo是在数组中的，所以给当前搜索的哈希表计数器加上1，如果发现当前搜索中foo出现的次数已经比给定数组中foo出现的次数多了，我们就要把上一次出现foo之前的所有词都从窗口中去掉 如果没有更多，则看下一个词bar，不过在这之前，我们还要看看窗口中有多少个词了，如果词的个数等于数组中词的个数，说明我们找到了一个结果。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Solution &#123; public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; List&lt;Integer&gt; res = new LinkedList&lt;Integer&gt;(); if(words == null || words.length == 0 || s == null || s.equals("")) return res; HashMap&lt;String, Integer&gt; freq = new HashMap&lt;String, Integer&gt;(); // 统计数组中每个词出现的次数，放入哈希表中待用 for(String word : words)&#123; freq.put(word, freq.containsKey(word) ? freq.get(word) + 1 : 1); &#125; // 得到每个词的长度 int len = words[0].length(); // 错开位来统计 for(int i = 0; i &lt; len; i++)&#123; // 建一个新的哈希表，记录本轮搜索中窗口内单词出现次数 HashMap&lt;String, Integer&gt; currFreq = new HashMap&lt;String, Integer&gt;(); // start是窗口的开始，count表明窗口内有多少词 int start = i, count = 0; for(int j = i; j &lt;= s.length() - len; j += len)&#123; String sub = s.substring(j, j + len); // 看下一个词是否是给定数组中的 if(freq.containsKey(sub))&#123; // 窗口中单词出现次数加1 currFreq.put(sub, currFreq.containsKey(sub) ? currFreq.get(sub) + 1 : 1); count++; // 如果该单词出现次数已经超过给定数组中的次数了，说明多来了一个该单词，所以要把窗口中该单词上次出现的位置及之前所有单词给去掉 while(currFreq.get(sub) &gt; freq.get(sub))&#123; String leftMost = s.substring(start, start + len); currFreq.put(leftMost, currFreq.get(leftMost) - 1); start = start + len; count--; &#125; // 如果窗口内单词数和总单词数一样，则找到结果 if(count == words.length)&#123; String leftMost = s.substring(start, start + len); currFreq.put(leftMost, currFreq.get(leftMost) - 1); res.add(start); start = start + len; count--; &#125; // 如果截出来的单词都不在数组中，前功尽弃，重新开始 &#125; else &#123; currFreq.clear(); start = j + len; count = 0; &#125; &#125; &#125; return res; &#125;&#125; 249.Group Shift StringsGiven a string, we can “shift” each of its letter to its successive letter, for example: “abc” -&gt; “bcd”. We can keep “shifting” which forms the sequence: &quot;abc&quot; -&gt; &quot;bcd&quot; -&gt; ... -&gt; &quot;xyz&quot; Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence. For example, given: [“abc”, “bcd”, “acef”, “xyz”, “az”, “ba”, “a”, “z”], A solution is: [ [&quot;abc&quot;,&quot;bcd&quot;,&quot;xyz&quot;], [&quot;az&quot;,&quot;ba&quot;], [&quot;acef&quot;], [&quot;a&quot;,&quot;z&quot;] ] 同一组string, 他们的间隔是一样的 判断间隔，以间隔为key value为相同间隔的string的list 代码 1234567891011121314151617181920public static List&lt;List&lt;String&gt;&gt; groupStrings(String[] strings) &#123; List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;List&lt;String&gt;&gt;(); Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;(); for (String str : strings) &#123; String key = ""; for (int i = 1; i &lt; str.length(); i++) &#123; int offset = str.charAt(i) - str.charAt(i - 1); //在为负数的时候，当经过z, a的时候，数值大小会很大得反转 key += offset &lt; 0 ? offset + 26 : offset; &#125; if (!map.containsKey(key)) map.put(key, new ArrayList&lt;String&gt;()); map.get(key).add(str); &#125; for (List&lt;String&gt; list : map.values()) &#123; result.add(list); &#125; return result;&#125; 288.Unique Word AbbreviationAn abbreviation of a word follows the form . Below are some examples of word abbreviations: a) it --&gt; it (no abbreviation) 1 b) d|o|g --&gt; d1g 1 1 1 1---5----0----5--8 c) i|nternationalizatio|n --&gt; i18n 1 1---5----0 d) l|ocalizatio|n --&gt; l10n Assume you have a dictionary and given a word, find whether its abbreviation is unique in the dictionary.A word abbreviation is unique if no other word from the dictionary has the same abbreviation. Example: Given dictionary = [ &quot;deer&quot;, &quot;door&quot;, &quot;cake&quot;, &quot;card&quot; ] isUnique(&quot;dear&quot;) -&gt; false isUnique(&quot;cart&quot;) -&gt; true isUnique(&quot;cane&quot;) -&gt; false isUnique(&quot;make&quot;) -&gt; true 首字母+中间str长度+尾字母 判断是否唯一 代码 123456789101112131415161718192021222324252627282930public class ValidWordAbbr &#123; Map&lt;String, Set&lt;String&gt; &gt; map = new HashMap&lt;&gt;(); public ValidWordAbbr(String[] dictionary) &#123; for(int i=0; i&lt;dictionary.length; i++) &#123; String s = dictionary[i]; if(s.length() &gt; 2 ) &#123; s = s.charAt(0) + Integer.toString(s.length()-2) + s.charAt(s.length()-1); &#125; if(map.containsKey(s) ) &#123; map.get(s).add(dictionary[i]); &#125; else &#123; Set&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add(dictionary[i]); map.put(s, set); &#125; &#125; &#125; public boolean isUnique(String word) &#123; //input check String s = word; if(s.length() &gt; 2 ) &#123; s = s.charAt(0) + Integer.toString(s.length()-2) + s.charAt(s.length()-1); &#125; if(!map.containsKey(s)) return true; else return map.get(s).contains(word) &amp;&amp; map.get(s).size()&lt;=1; &#125;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>算法</category>
        <category>LeetCode Category</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>String</tag>
        <tag>HashTable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾收集器与内存分配策略]]></title>
    <url>%2F2018%2F06%2F06%2F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[垃圾回收主要是对Java堆、方法区内存的回收 对象已死吗堆中存放着几乎所有的对象实例，回收前，需要对对象是否存活进行确定，判断是否能进行回收 引用计数算法 给对象添加一个引用计数器 引用则加1 引用失效，则减1 计数器为0的对象就可以被回收 优点：实现简单，效率高 缺点：Java中不用，很难解决循环引用问题 可达性分析算法 “GC Roots”对象为起点，开始向下搜索 搜索走过的路径称为引用链 当一个对象到“GC Roots”没有引用链相连时，该对象不可用 Java和C#中都是采用该算法来判定对象是否存活的。 Java中，可作为GC Roots的对象如下: 虚拟机栈（栈桢中的本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI引用的对象 再谈引用强引用、软引用、弱引用、虚引用，强度依次减弱 强引用，类似Object obj = new Object(), 只要强引用还在，系统不会回收 软引用，还有用但非必需的对象，会在内存不足的时候释放 弱引用，非必需对象，被弱引用关联的对象只能生存到下一次垃圾回收之前 虚应用，不能用虚引用获得一个实例对象，存在是为了在对象被回收后获得系统反馈 生存还是死亡 可达性分析算法中不可达，也不一定是“非死不可” 真正被回收，至少要经历两次标记过程： 进行可达性分析后没有与GC Roots相连接的引用链，第一次标记并筛选，筛选的条件是对象是否有必要执行finalize()方法（对象未覆盖finalize()方法或者该方法已经被调用过，视为“没有必要执行”） 如果判定为有必要，则该对象会被放置在F-Queue队列中，会有低优先级的线程去触发 稍后GC对F-Queue中对象进行二次标记，如果对象在finalize()方法中重新产生引用链，则被移出“即将回收”集合 一个对象的finalize()方法最多只会被系统自动调用一次 回收方法区方法区（HotSpot中的永久代）垃圾回收率很低。 永久代垃圾回收收集废弃常量和无用的类。 回收常量：没有引用即可 回收类，无用的类的判定： 类的所有实例被回收，Java堆中不存在该类的任何实例 加载该类的ClassLoader被回收 该类对应的java.lang.Class对象没有被引用，无法通过反射访问该类的方法 虚拟机可以对符合上述条件的类回收 是否对类回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息 垃圾收集算法标记-清除算法标记需要回收对象，统一回收，不作处理 优点：不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效。 缺点： 标记和清除过程的效率都不高（这种方法需要使用一个空闲列表来记录所有的空闲区域以及大小。对空闲列表的管理会增加分配对象时的工作量） 标记清除后会产生大量不连续的内存碎片。虽然空闲区域的大小是足够的，但是可能没有足够大的连续空间。 复制算法 内存等量分为两块，每次只使用一块 当一块用完时，将存活对象复制到另一块上 把再把已使用过的内存空间一次清理掉 复制算法比较适合于新生代（短生存期的对象），在老年代（长生存期的对象）中，对象存活率比较高，如果执行较多的复制操作，效率将会变低，所以老年代一般会选用其他算法，如标记—整理算法。 优点： 标记阶段和复制阶段可以同时进行。 每次只对一块内存进行回收，运行高效。 只需移动栈顶指针，按顺序分配内存即可，实现简单。 内存回收时不用考虑内存碎片的出现（得活动对象所占的内存空间之间没有空闲间隔）。 缺点：需要一块能容纳下所有存活对象的额外的内存空间。因此，可一次性分配的最大内存缩小了一半。 HotSpot虚拟机默认Eden和Survivor的大小比例是8:1, 当Survivor内存不够时，需要依赖其他内存（老年代）进行分配担保。 标记-整理算法将所有对象内存向一端移动，清除端外的。 优点： 经过整理之后，新对象的分配只需要通过指针碰撞便能完成（Pointer Bumping），相当简单。 使用这种方法空闲区域的位置是始终可知的，也不会再有碎片的问题了。 缺点：GC暂停的时间会增长，因为你需要将所有的对象都拷贝到一个新的地方，还得更新它们的引用地址。 分代收集算法新生代：复制老年代：标记-清除、标记-整理算法 HotSpot的算法实现GC Roots找引用链，需要消耗很多时间 GC停顿需要在保持一致性的快照中进行（分析期间，对象引用关系不变），GC停顿指GC进行时停顿所有Java执行线程。 使用准确式GC，直接得知哪些地方存放着对象引用。HotSpot使用OopMap来达到这一目的，在类加载完成时，HotSpot把对象内什么偏移量时什么类型数据计算出来，在JIT编译过程中，在安全点记录下栈和寄存器中哪些位置是引用。 程序执行时在安全点才会停下来GC，安全点的选定是以程序“是否具有让程序长时间执行的特征”为标准进行选定的，“长时间执行”最明显的特征是指令序列复用，例如方法调用、循环跳转、异常跳转等。 GC发生时有两种方案让所有线程都“跑”到最近的安全点才停顿下来： 抢先式中断(几乎不用)：GC发生时，把线程全部中断，如果线程不在安全点，就恢复，让它“跑”在安全点上 主动式中断：设置标志，线程去轮询，标志为真时就中断挂起。轮询标志和安全点是重合的，另外再加上创建对象需要分配内存的地方。 安全点保证了程序运行时，能在不太长时间内遇到可进入GC的安全点。但程序“不执行”、没有分配CPU时，比如线程处于sleep或blocked时，就需要安全区域。 执行到Safe Region中的代码时，首先标识进入了Safe Region，线程要离开Safe Region时，检查系统是否已经完成根节点枚举（or整个GC过程）,如果完成，线程继续执行，否则必须等待知道收到可以离开的信号。 垃圾收集器讨论的收集器基于JDK 1.7 Update 14之后的HotSpot虚拟机，虚拟机包含的所有收集器如下图： 如果两个收集器之前存在连线，则说明可以搭配使用。虚拟机所处的区域，表示它属于新生代还是老年代。 Serial收集器单线程收集器，只使用一个CPU或一条收集线程去完成垃圾收集工作，收集时，暂停其他所有工作线程，直至收集结束。 优点：简单而高效（与其他收集器的单线程比） 缺点：Stop The World，其它工作线程在用户不可见时全部停掉 使用场景：运行在Client模式下的虚拟机 ParNew收集器（并行）Serial收集器的多线程版本，进行垃圾收集时也会停止工作线程 是许多运行在Server模式下的虚拟机中首选的新生代收集器，很大原因在于，只有Serial收集器和ParNew收集器能与CMS收集器配合工作 注意 并行（parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态； 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。 Parallel Scavenge收集器（并行）新生代收集器、使用复制算法、并行的多线程收集器 不能与CMS收集器配合使用，目标达到一个可控制的吞吐量（Throughput）。吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间) 停顿时间越短越适合需要与用户交互的程序，良好的响应时间速度能提升用户体验，而高吞吐量可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 控制最大垃圾收集停顿时间：-XX:MaxGCPauseMillis，直接设置吞吐量大小参数：-XX: GCTimeRatio（0-100）。 -XX：+UseAdaptiveSizePlicvy，开关参数，当参数打开之后，就不需要手工指定新生代大小-Xmn、Eden与Survivor区的比例-XX:SurviviorRatio、晋升到老年代对象年龄-XX:PretenureSizeThreshold等细节参数了，虚拟机会根据当前系统运行情况收集性能监控信息，动态调整这些参数以提供合适的停顿时间或者最大吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。 Serial Old收集器Serial收集器老年代版本，也是用于给Client模式下的虚拟机使用 在Server模式下，两大用途： 在JDK1.5及以上，与Parallel Scavenge收集器搭配使用（Parallel Scavenge收集器架构中本身有PS MarkSweep收集器进行老年代的收集，并非直接使用Serial Old，但Serial Old与PS MarkSweep实现非常接近） 作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用 Parallel Old收集器Parallel Scavenge老年代版本，使用多线程和“标记-整理”算法 使用场景：注重高吞吐量以及CPU资源敏感的场合，可以考虑Parallel Scavenge加Parallel Old CMS收集器一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上。基于“标记-清除”算法实现。 初始标记：Stop the World，只是标记一下GC Roots能直接关联到的对象，用户进程停顿 并发标记：进行GC Roots Tracing（追踪）的过程，并发用户进程 重新标记：Stop the World，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，用户进程停顿 并发删除：并发用户进程 优点：并发收集、低停顿 缺点： 对CPU资源敏感，并发阶段，占用线程（CPU资源）导致应用程序变慢，总吞吐量降低 无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。“浮动垃圾”指在并发清理过程中用户进程仍在运行，自然会产生垃圾，这部分垃圾出现在标记过程之后，CMS无法当次集中处理，只好留到下一次GC. 基于“标记-清除”算法，空间碎片过多，但无法找到足够大的连续空间用以分配，触发Full GC G1收集器面向服务端的垃圾收集器 特点： 并行与并发：缩短Stop the World停顿时间 分代收集：采用不同方式处理新对象和存活一段时间的对象 空间整合：与CMS的标记-清理算法不同，整体基于标记-整理算法，从局部（两个Region之间）基于复制算法。不会产生空间碎片。 可预测的停顿，之所以能做到，是因为能有计划避免在整个堆中进行全区域的垃圾收集 将堆划分为等大小的独立区域（Region），跟踪各个Region里垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。 使用Remembered Set避免全堆扫描，处于不同的Region，则记录到被引用对象的Region中，在GC根节点枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。 不计算维护Remembered Set操作，大致分为以下步骤： 初始标记：标记一下GC Roots能直接关联到的对象，并修改TAMS(Next Top at Mark Start)的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，停顿线程 并发标记：进行GC Roots Tracing（追踪）的过程，并发用户进程 最终标记：修正在并发标记期间因用户程序继续运作而导致标记表动的那一部分标记记录，虚拟机将并发标记期间的对象变化记录在Remembered Set Logs中，在这阶段将这部分数据合并到Remembered Set中，停顿线程，但可并行执行 筛选回收：对各Region的回收价值和成本排序，根据用户所期望的GC停顿来制定回收计划，可以做到并发，但意义不大 理解GC日志 “33.125”和“100.667”代表GC发生的时间，是从Java虚拟机启动以来经过的秒数 “[GC”和”[Full GC”说明垃圾收集的停顿类型，如果有”Full”说明是发生了Stop-The-World，如果是调用System.gc()触发的收集，则显示”[Full GC(System)” “[DefNew”(Default New Generation)、”[ParNew”(Parallel New Generation)、”[PSYoungGen”(Parallel Scavenge)表示GC发生的区域 方括号内部的”3324K-&gt;152(3712K)”指“GC前该内存区域已使用容量-&gt;GC后该内存区域已使用容量(该内存区域总容量)”;方括号之外的“3324K-&gt;152(11904K)”表示“GC前Java堆已使用容量-&gt;GC后Java堆已使用容量(Java堆总容量)” “0.0025925secs”表示该内存区域GC所占用的时间 垃圾收集器参数总结 内存分配与回收策略 对象优先在Eden分配，当Eden区没有足够空间进行分配时，虚拟机发起Minor GC，分配担保机制提前将原占用Eden的资源转移到老年代中 新生代GC(Minor GC): 发生在新生代的垃圾收集行为，频繁，回收速度快 老年代GC(Major GC/Full GC): 发生在老年代的GC,经常伴随至少一次的Minor GC(非绝对),比Minor GC慢10倍以上 大对象(需要大量连续内存空间的对象)直接进入老年代 长期存活的对象将进入老年代 虚拟机采用分代收集思想管理内存，那么内存回收时就必须能识别对象放在哪。虚拟机给每个对象定义了一个对象年龄(Age)计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Surviror容纳得话，将被移到Surviror空间中，并且对象年龄设为1。对象在Surviror区每熬过一次Minor GC, 年龄就增加1岁，当年龄增加到一定程度(默认15岁)，就会被晋升到老年代中。 虚拟机并不是永远要求对象年龄必须达到了MaxTenuringThreshold才能晋升到老年代，如果在Surviror空间中相同年龄的所有对象大小总和大于Surviror空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold要求的年龄。 发生Minor GC前，先检查老年代最大可用连续空间是否能够存放新生代所有对象，能则确保Minor GC安全。否则，则看HandlePromotionFailure是否允许担保失败。如果允许，则继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，大于则进行Minor GC；如果小于，或者HandlePromotionFailure设置不允许冒险，则进行Full GC。 在JDK 6 Update 24后，只要老年代的联系空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则Full GC。]]></content>
      <categories>
        <category>Java基础</category>
        <category>读书笔记</category>
        <category>深入理解Java虚拟机</category>
        <category>自动内存管理机制</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存区域与内存溢出异常]]></title>
    <url>%2F2018%2F06%2F05%2FJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Java技术体系Java程序设计语言、Java虚拟机、Java API类库三部分统称为JDK，JDK是用于支持Java程序开发的最小环境。Java API类库中的Java SE API子集和Java虚拟机这两个部分统称为JRE，JRE是支持Java程序运行的标准环境。 运行时数据区域 程序计数器线程独立，唯一没有规定OutOfMemoryError的区域 Java虚拟机栈 线程私有，生命周期和线程相同 平时所谓的堆、栈、方法区，栈就是指虚拟机栈，或者说是其中的局部变量表部分 两种异常状况 StackOverflowError: 线程请求栈深度大于所允许 OutOfMemoryError: 扩展无法申请足够内存 本地方法栈和虚拟机栈发挥作用相似 Java堆 线程共享，虚拟机启动时创建，存放对象实例 GC管理的主要区域 内存空间不连续 OutOfMemoryError: 堆中没有内存完成实例分配并且无法扩展时 方法区 线程共享 存放类信息、常量、静态变量、即时编译器编译后的代码 OutOfMemoryError: 无法满足内存分配需求时 JVM实例 HotSpot虚拟机对象揭秘HotSpot虚拟机在Java堆中对象分配、布局、访问的全过程 对象创建 虚拟机遇到new指令，检查指令的参数能否在常量池中定位到一个类的符号引用 检查所代表的类是否已被加载、解析和初始化过 没有，则先执行类加载过程 虚拟机为新生对象分配内存，对象所需内存大小在类加载完成后便可确定 指针碰撞: 假设Java堆内存绝对规整，用过的内存和没用过的严格分开，有一个指针作为分界点的指示器，移动指针即可 空闲列表: 内存不规整，维护列表，记录是否可用，需要在列表中找一块足够大的区域 对象创建频繁，可能会导致在并发情况下线程不安全 对分配内存动作加上同步处理: CAS+失败重试 按线程划分在不同空间，每个线程预先分配本地线程分配缓冲(TLAB)，哪个线程需要分配内存，就在哪个线程的TLAB分配，只有在用完并分配新的TLAB时才同步锁定 将分配到的内存空间初始化为零值 根据对象头对对象进行必要的设置 执行方法 对象的内存布局HotSpot中分3块区域: 对象头、实例数据、对齐填充 对象头 存储对象自身运行时数据: 哈希码、GC分代年龄… 类型指针，对象指向其类原数据的指针，确定对象是哪个类的实例（不是所有虚拟机实现都必须保留该指针） 实例数据: 在代码中定义的各种类型的字段内容 HotSpot默认相同宽度字段被分配到一起，比如shorts/chars，父类的变量在子类之前 对齐填充(不一定存在，占位作用) 对象的访问定位使用对象需要通过栈上的reference来操作堆上的具体对象，引用如何去定位，主流有两种： 句柄（稳定） reference存储对象的句柄地址，句柄中包含对象实例数据和类型数据的具体信息 直接指针（速度快，HotSpot） reference存储对象的地址]]></content>
      <categories>
        <category>Java基础</category>
        <category>读书笔记</category>
        <category>深入理解Java虚拟机</category>
        <category>自动内存管理机制</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quick Select]]></title>
    <url>%2F2018%2F06%2F04%2FQuickSelect%2F</url>
    <content type="text"><![CDATA[说明Quick Select是由quick sort而来，只是它只用了quick sort前面partition的部分 平均时间复杂度：O(n),最差: O(n^2) 模板思路选最后一个 每次选一个pivot，可以选最后一个 两个变量，一个存比pivot小的数left，一个存比pivot大的数right 初始化: left = 0, right = length - 1 left == right则break 核心代码 123456789101112while(true)&#123; while(nums[left] &lt; pivot &amp;&amp; left &lt; right)&#123; left++; &#125; while(nums[right] &gt;= pivot &amp;&amp; left &lt; right)&#123; right--; &#125; if(left == right) &#123; break; &#125; swap(nums, left, right);&#125; 选第一个 每次选一个pivot，可以选第一个 两个变量，一个存比pivot小的数left，一个存比pivot大的数right 初始化: left = 0, right = length - 1 p从0开始遇到right结束 核心代码 while(p &lt;= right){ if(nums[left] &lt; pivot){ swap(nums, left, p); left++; p++; }else if(nums[right] == pivot){ p++; }else{ swap(nums, right, p); right--; } } 215.Kth Largest Element in an ArrayFind the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Example 1: Input: [3,2,1,5,6,4] and k = 2 Output: 5 Example 2: Input: [3,2,3,1,2,4,5,5,6] and k = 4 Output: 4 Note:You may assume k is always valid, 1 ≤ k ≤ array’s length. 直接排序，返回排序后nums[nums.length-k] 建小顶堆(默认)，size大于k则poll，最后返回堆顶元素 QuickSelect QuickSelect方法代码 123456789101112131415161718public int findKth(int[] nums, int k, int start, int end) &#123; int pivot = nums[end]; int left = start, right = end; while(true)&#123; while(nums[left] &lt; pivot &amp;&amp; left &lt; right)&#123; left++; &#125; while(nums[right] &gt;= pivot &amp;&amp; left &lt; right)&#123; right--; &#125; if(left == right) break; swap(nums,left,right); &#125; swap(nums,left,end); if(left+1 == k) return pivot; else if(left+1 &lt; k) return findKth(nums, k, left+1, end); else return findKth(nums, k, start, left-1);&#125; 75.Sort Color 3种颜色(0,1,2)，排序使得相同颜色相邻 直接使用模板方法即可 143.Sort Color II(Lintcode) k种颜色(1-k)，排序使得相同颜色相邻 可以仍然使用以上模板方法，变化的只是需要每次找数组中的最大最小值 123456789101112131415161718192021222324252627public void sortColors2(int[] colors, int k) &#123; // write your code here int count = 0,start = 0,end = colors.length-1; while(count &lt; k)&#123; int min = Integer.MAX_VALUE,max = Integer.MIN_VALUE; for(int i = start;i &lt;= end;i++)&#123; min = Math.min(min,colors[i]); max = Math.max(max,colors[i]); &#125; int left = start,right = end, p = start; while(p &lt;= right)&#123; if(colors[p] == min)&#123; swap(colors,p,left); p++; left++; &#125;else if(colors[p] &gt; min &amp;&amp; colors[p] &lt; max)&#123; p++; &#125;else&#123; swap(colors,p,right); right--; &#125; &#125; count += 2; start = left; end = right; &#125; &#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>算法</category>
        <category>LeetCode Category</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>QuickSelect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Two Pointer]]></title>
    <url>%2F2018%2F05%2F31%2FTwoPointer%2F</url>
    <content type="text"><![CDATA[双指针法的常见应用所谓双指针，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向或者相反方向的指针进行扫描，从而达到相应的目的。 换言之，双指针法充分使用了数组有序这一特征，从而在某些情况下能够简化一些运算。 (注：这里的指针，并非专指c中指针的概念，而是指索引，游标或指针，可迭代对象等) 209.Minimum Size Subarray SumGiven an array of n positive integers and a positive integer s, find the minimal length of a subarray of which the sum ≥ s. If there isn’t one, return 0 instead. For example, given the array [2,3,1,2,4,3] and s = 7, the subarray [4,3] has the minimal length under the problem constraint. 最短子串和 思路一 Two Pointer 是用两个指针形成一个移动窗口 当sum的值小于s时，将右边界向右扩张，sum += arr[right++] 当sum的值大于s时，则将左边届右移，判断取较小的count 循环条件是right &lt;= length, left &lt;= right 代码 12345678910111213141516171819class Solution &#123; public int minSubArrayLen(int s, int[] nums) &#123; if(nums == null || nums.length == 0 ) return 0; int left = 0, right = 0, sum = 0, count = nums.length + 1; while(right &lt;= nums.length &amp;&amp; left &lt;= right)&#123; if(sum &lt; s)&#123; if(right &lt; nums.length)&#123; sum += nums[right]; &#125; right++; &#125;else&#123; count = Math.min(count,right - left); sum -= nums[left]; left++; &#125; &#125; return count &lt;= nums.length? count:0; &#125;&#125; 思路二 二分法(适用subarray sum问题) 构造sum数组，sum[i+1] = sum[i]+nums[i] sum数组递增 遍历数组sum，对每一个i，寻找j(右边界)，使得i～j区间的值大于s 不断更新找出最小值 代码 12345678910111213141516171819202122232425262728class Solution &#123; public int minSubArrayLen(int s, int[] nums) &#123; int sum = 0, min = Integer.MAX_VALUE; int[] sums = new int[nums.length]; for (int i = 0; i &lt; nums.length; i++) sums[i] = nums[i] + (i == 0 ? 0 : sums[i - 1]); for (int i = 0; i &lt; nums.length; i++) &#123; int j = findWindowEnd(i, sums, s); if (j == nums.length) break; min = Math.min(j - i + 1, min); &#125; return min == Integer.MAX_VALUE ? 0 : min; &#125; private int findWindowEnd(int start, int[] sums, int s) &#123; int i = start, j = sums.length - 1, offset = start == 0 ? 0 : sums[start - 1]; while (i &lt;= j) &#123; int m = (i + j) / 2; int sum = sums[m] - offset; if (sum &gt;= s) j = m - 1; else i = m + 1; &#125; return i; &#125;&#125; Valid Palindrome125.IGiven a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Note: For the purpose of this problem, we define empty string as valid palindrome. Example 1: Input: &quot;A man, a plan, a canal: Panama&quot; Output: true Example 2: Input: &quot;race a car&quot; Output: false 双指针，首尾 注意大小写转换 isValid(char c)判断是否是a-z||A-Z||0-9 680.IIGiven a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome. Example 1: Input: &quot;aba&quot; Output: True Example 2: Input: &quot;abca&quot; Output: True Explanation: You could delete the character &apos;c&apos;. String的题 一个用于判断是否是回文的方法 主函数判断start和end的值是否相等 不相等，则判断start+1和end||start和end-1的值是否相等 123456789101112131415161718192021222324class Solution &#123; public boolean validPalindrome(String s) &#123; int start = 0, end = s.length() - 1; while(start &lt;= end)&#123; if(s.charAt(start) != s.charAt(end))&#123; return isValid(s, start+1, end) || isValid(s, start, end-1); &#125; start++; end--; &#125; return true; &#125; public boolean isValid(String s, int i, int j) &#123; while(i &lt;= j)&#123; if(s.charAt(i) != s.charAt(j))&#123; return false; &#125; i++; j--; &#125; return true; &#125;&#125; 11.Container with Most WaterGiven n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. 问题转换成数列中选两个值使得中间的面积最大 首尾指针，遍历 求局部面积 如果左边较低，则将左边向中间移一点 如果右边较低，则将右边向中间移一点 代码 1234567891011121314class Solution &#123; public int maxArea(int[] height) &#123; int maxArea = 0, left = 0, right = height.length - 1; while(left &lt; right)&#123; maxArea = Math.max(maxArea,Math.min(height[left],height[right]) * (right-left)); if(height[left] &gt; height[right])&#123; right--; &#125;else&#123; left++; &#125; &#125; return maxArea; &#125;&#125; 42.Trapping Rain WaterGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! Example: Input: [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 解题方法 从两边开始灌水，总是从低的一边开始灌，高的地方保持不动，同时记录下可以灌的水的总量，不断更新 代码 123456789101112131415161718192021222324252627282930class Solution &#123; public int trap(int[] height) &#123; if(height == null || height.length &lt; 3) return 0; int left = 0, right = height.length - 1; int leftbound = height[left], rightbound = height[right]; int res = 0; while(left &lt; right)&#123; if(leftbound &lt; rightbound)&#123; //左边低，从左边开始灌 left++; if(height[left] &lt;= leftbound)&#123; //比现有的bound低，可以灌 res += leftbound - height[left]; &#125;else&#123; //比现有的bound高，更新左边的bound leftbound = height[left]; &#125; &#125;else&#123; right--; if(height[right] &lt;= rightbound)&#123; res += rightbound - height[right]; &#125;else&#123; rightbound = height[right]; &#125; &#125; &#125; return res; &#125;&#125; 61.Rotate ListGiven a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2 Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL Explanation: rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL Example 2: Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4 Output: 2-&gt;0-&gt;1-&gt;NULL Explanation: rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL 获得链表的长度n，k%n才是需要移动的 找到最后结果的链表的tail:first,循环n-k-1次找next即可 遍历找到原链表的tail:second second.next = head result = first.next first.next = null]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>算法</category>
        <category>LeetCode Category</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>TwoPointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[商汤]]></title>
    <url>%2F2018%2F05%2F18%2F%E5%95%86%E6%B1%A4%2F</url>
    <content type="text"><![CDATA[商汤Java实习生面试 Collections框架体系 HashSet的特性 基于HashMap实现 无序不重复 HashMap结构 哈希表，数组+链表 HashMap和ConcurrentHashMap区别 锁的了解 线程池有哪些？ 怎么实现线程？ 并发包… SpringBoot中@ReseController注解对应哪两个 @ResponseBody和@Controller的组合注解。 Redis支持哪些类型？ Strings Lists Sets 求交集、并集 Sorted Set hashes]]></content>
      <categories>
        <category>面试经历</category>
        <category>2018</category>
        <category>实习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简历相关准备]]></title>
    <url>%2F2018%2F04%2F30%2F%E7%AE%80%E5%8E%86%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[简单的自我介绍 自我介绍我叫姜栋煜，现在在北京大学软件与微电子学院读研究生二年级，预计2019年6月份毕业，本科就读于北京交通大学。3月中旬结束在微软亚洲研究院的实习，主要做了课程数据的收集、维护，pipeline的日常导入以及一些数据的简单分析。此外，还做过一些导师和企业合作的项目，主要就是智慧教室，都是java web的一些项目。 实习经历简单介绍在小英组，主要产品是微软小英和Microsoft Learning Chinese，都是一些教授中小学生以及外国人学英语/中文的app，这些app会有一些对应的课程信息（json文本），课程信息的录入工具是由我去维护开发的，包括对文本、音频、视频、图片等的录入，存储主要是用了Azure Blob，音频、视频、图片存在对应的mooncake中国镜像上。 小英的用户量在200-300万左右，每天的数据量大，而且之前的pipeline导入方式费时，不易监控，就改为使用data factory,还会完成一些简单的分析工作，比如活跃用户、日留存、周留存、月留存等。。。 效果 用于录入数据的网站，可以自动merge数据，减少人工干预 pipeline导入做到了高效，速度比原来快了3倍多，出错会发邮件 分析信息用于确定用户使用情况 难点 内部网站数据混乱，会出现直接修改merge之后文件，而导致不一致问题的出现 data factory全靠自己看英文文档，教程少 项目经历智慧教室 简单而言，就是一个课堂直播的一个平台，主要分为三个端，web/phone端，树莓派，PC。web/phone端和树莓派通过websocket通信，主要传输一些控制指令，树莓派和PC通过串口直接相连。 web端主要完成教室设备的CRUD，权限控制，还有就是给树莓派发送指令，具体的操作，比如操作教室推流真正还是由PC去完成。这个项目已经在河北邢台的一些中小学开始试用了。 难点（问题） SpringBoot和websocket无法注入bean的问题，其实不是不能注入，是已经注入了，但是客户端每建立一个链接就会创建一个对象，这个对象没有任何的bean注入操作,最后使用静态变量 websocket不稳定，异常处理机制，树莓派定时心跳，异常重连 即时通讯类似于朋友圈，可发布状态，点赞、评论等 使用MongoDB是因为便于存储点赞/评论list，非结构化Redis用于缓存朋友圈动态信息，前N条经常被浏览 比赛经历Google Girl Hackthon 主题是机器学习，给了一些新闻的数据，让自己从中分析出自己想要的信息,主要是做了数据的处理，对train得到的数据，处理成前端可展示的json格式]]></content>
      <categories>
        <category>Java面试</category>
        <category>简历</category>
      </categories>
      <tags>
        <tag>简历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BackTracking]]></title>
    <url>%2F2018%2F04%2F29%2FBackTracking%2F</url>
    <content type="text"><![CDATA[思想 试错 分步解决问题 不符合则取消上一步或上几步 BackTracking可大致分为全排列问题、数独等问题 全排列问题类型1 subsets subset II permutations permutations II Combinations Combinations Sum Combinations Sum II N Queen N Queen II letter combination of a phone number 类型2（基于全排列的问题） Next Permutation Previous Permutation􏰍􏴤􏴥􏴓􏲌(与next permutation类似) Permutation Sequence Permutation Index Permutation Index II (hard) permuataions有序，subsets无序 Subsets Sort原数组 dfs 判断是否取这个数 12345678910111213141516171819class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(nums); subset(results, result, nums, 0); return results; &#125; public void subset(List&lt;List&lt;Integer&gt;&gt; results, List&lt;Integer&gt; result, int[] num, int index)&#123; results.add(new ArrayList&lt;Integer&gt;(result)); for (int i = index; i &lt; num.length; i++) &#123; result.add(num[i]); subset(results, result, num, i + 1); result.remove(result.size()-1); &#125; &#125; &#125; Subsets II contain duplicates, nums 1if(i != index &amp;&amp; num[i] == num[i-1]) continue; PermutationsGiven a collection of distinct integers, return all possible permutations. Example: Input: [1,2,3] Output: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 用一个数组记录是否被使用过 12345678910111213141516171819202122232425class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); if(nums == null || nums.length == 0) return results; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); boolean[] used = new boolean[nums.length]; permute(results, result, nums, used); return results; &#125; public void permute(List&lt;List&lt;Integer&gt;&gt; results, List&lt;Integer&gt; result, int[] num, boolean[] used)&#123; if(num.length == result.size()) results.add(new ArrayList&lt;Integer&gt;(result)); for (int i = 0; i &lt; num.length; i++) &#123; if(!used[i])&#123; result.add(num[i]); used[i] = true; permute(results, result, num, used); result.remove(result.size()-1); used[i] = false; &#125; &#125; &#125;&#125; Permutation II might contain duplicates 对数组排序 判断num[i] == num[i-1] &amp;&amp; !used[i-1] 如果前一个已经用了，当前值相同再被用，不会重复 1if(i !=0 &amp;&amp; num[i] == num[i-1] &amp;&amp; !used[i-1]) continue; CombinationsGiven two integers n and k, return all possible combinations of k numbers out of 1 … n. Example: Input: n = 4, k = 2 Output: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] 类似subset Combination SumGiven a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: candidates = [2,3,6,7], target = 7, A solution set is: [ [7], [2,2,3] ] Example 2: Input: candidates = [2,3,5], target = 8, A solution set is: [ [2,2,2,2], [2,3,3], [3,5] ] 求sum 12345678910111213141516171819202122class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); if(candidates == null || candidates.length == 0) return results; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); combinationSum(results, result, candidates, target, 0, 0); return results; &#125; public void combinationSum(List&lt;List&lt;Integer&gt;&gt; results, List&lt;Integer&gt; result, int[] candidate, int target, int index, int sum)&#123; if(sum == target) results.add(new ArrayList&lt;Integer&gt;(result)); if(sum &gt; target) return; for (int i = index; i &lt; candidate.length; i++) &#123; result.add(candidate[i]); sum += candidate[i]; combinationSum(results, result, candidate, target, i, sum); result.remove(result.size()-1); sum -= candidate[i]; &#125; &#125;&#125; Combination Sum IIEach number in candidates may only be used once in the combination. 增加sort 增加去重 1if(i != index &amp;&amp; candidate[i] == candidate[i-1]) continue; Combination Sum IIIFind all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Note: All numbers will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: k = 3, n = 7 Output: [[1,2,4]] Example 2: Input: k = 3, n = 9 Output: [[1,2,6], [1,3,5], [2,3,4]] 同时考虑sum和list长度 Letter Combinations of a Phone Number 存储对应关系 像subset那样处理即可 12345678910111213141516171819202122class Solution &#123; public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); String[] map = &#123;"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"&#125;; char[] resultStr= new char[digits.length()]; letterCombinations(result, digits, map, resultStr, 0); return result; &#125; public void letterCombinations(List&lt;String&gt; result, String digits, String[] map, char[] resultStr, int count)&#123; if(digits.length() == count)&#123; result.add(new String(resultStr)); return; &#125; String str = map[digits.charAt(count)-'0']; for(int i = 0;i &lt; str.length();i++)&#123; resultStr[count] = str.charAt(i); letterCombinations(result, digits, map, resultStr, count+1); &#125; &#125;&#125; Generate ParenthesesGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: [ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot; ] 如果左括号数量小于n，则可以再有左括号 如果左括号数量大于右括号数量，则可以再有右括号 Next Permutation输入一个整数数组，该整数数组按照下标顺序代表一个数字，例如[1,2,3]代表整数123，要求改变数组中元素的顺序，找到比当前数字大的生成数中的最小值。如果当前数字代表的整数值已经是所有排列组合中的最大值，则返回当前数字组成的最小值。 从右往左扫，找到第一个满足：nums[i-1] &lt; nums[i]条件的， 再找到从右到左第一个比nums[i-1]大的数，把它们swap， 再把所有i-1之后的数字swap即可。 12345678910111213141516171819202122232425262728class Solution &#123; public void nextPermutation(int[] nums) &#123; int i = nums.length - 1; while(i &gt; 0) &#123; if(nums[i-1] &lt; nums[i]) break; i--; &#125; // i = 0, decreasing if(i != 0) &#123; int j = nums.length - 1; while(j &gt;= 0) &#123; if(nums[j] &gt; nums[i-1]) break; j--; &#125; swap(nums, i-1, j); &#125; // swap all elements after i-1 int end = nums.length - 1; while(i &lt; end) swap(nums, i++, end--); &#125; private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125; Permutation SequenceThe set [1,2,3,…,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3: “123” “132” “213” “231” “312” “321” Given n and k, return the kth permutation sequence. Note: Given n will be between 1 and 9 inclusive. Given k will be between 1 and n! inclusive. Example 1: Input: n = 3, k = 3 Output: &quot;213&quot; Example 2: Input: n = 4, k = 9 Output: &quot;2314&quot; 找规律！！！ 复杂度 时间 O(N) 空间 O(1) 思路 由于我们只要得到第K个全排列，而不是所有全排列，我们不一定要将所有可能都搜索一遍。根据全排列顺序的性质，我们可以总结出一个规律：假设全排列有n个数组成，则第k个全排列的第一位是k/(n-1)!。为了更形象一点，举例如下： 123 132 213 231 312 321 在这种情况下，第一个数字每2!=2个情况就改变一次，假设求第6个排列，我们先将其减1，方便整除运算，然后5/2=2。对于第一位，我们有三种可选数字1、2、3，所以5/2=2意味着我们选择第3个数字，也就是3（如果商是s，则选第s+1个数字）。然后将5%2得到1，这个1就是下一轮的k。 注意 这里有一个技巧，就是用一个列表将1到n存起来，每选用一个数就是移出那个数，就能保证不选重复数字的同时，其顺序也是一样的。 代码 1234567891011121314151617181920212223public static String getPermutation(int n, int k) &#123; int mod = 1; List&lt;Integer&gt; candidates = new ArrayList&lt;Integer&gt;(); // 先得到n!和候选数字列表 for(int i = 1; i &lt;= n; i++)&#123; mod = mod * i; candidates.add(i); &#125; // 将k先减1方便整除 k--; StringBuilder sb = new StringBuilder(); for(int i = 0; i &lt; n ; i++)&#123; mod = mod / (n - i); // 得到当前应选数字的序数 int first = k / mod; // 得到用于计算下一位的k k = k % mod; sb.append(candidates.get(first)); // 在列表中移出该数字 candidates.remove(first); &#125; return sb.toString();&#125; Permutation Index 给定一个排列数，每位都不重复，返回它在全排列中的index,index从1开始 对于某一个给定的位数A[i],需要判断在它后面有几个小于它的数，记下这个数字和A[i]所在的位置。 比如对于一个四位数，5316，第一位后面有2小于它的数，如果这两个数排在第一位，那么（1和3）各有3！的排列组合数小于（5316）. 同理，对于第二位，其后有1个小于它的数，如果它放在第二位，那么有2！种排列。 因此判断一个给定数位于排列组合的第几位，则可以按照以下公式进行 count1*(A.length-1)!+count2*(A.length-2)!+……+countn*(0)! 为方便计算，从右往左遍历 123456789101112131415public class Solution &#123; public long permutationIndex(int[] A) &#123; if (A == null || A.length == 0) return 0; long fact = 1, index = 0; for (int i = A.length-1; i &gt;= 0; i--) &#123; int rank = 0; for (int j = i+1; j &lt; A.length; j++) &#123; if (A[j] &lt; A[i]) rank++; &#125; index += rank * fact; fact *= (A.length-i); &#125; return index+1; &#125;&#125; Permutation Index II 存在重复 与上一题的不同之处时会有重复的数。 在发现是重复数的那一位用(rank * fact)/dup+index即可。 当然，每个重复数的dup都要阶乘，例如有3个2，4个8，dup就是3! * 4! = 144。 index是所有previous排列的次数和，返回下一次index+1。 代码 1234567891011121314151617181920public class Solution &#123; public long permutationIndexII(int[] A) &#123; long index = 0, fact = 1, dup = 1; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i = A.length-1; i &gt;= 0; i--) &#123; if (!map.containsKey(A[i])) map.put(A[i], 1); else &#123; map.put(A[i], map.get(A[i])+1); dup *= map.get(A[i]); &#125; int rank = 0; for (int j = i+1; j &lt; A.length; j++) &#123; if (A[j] &lt; A[i]) rank++; &#125; index += rank * fact / dup; fact *= (A.length - i); &#125; return index+1; &#125;&#125; SudokuValid SudokuDetermine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. A partially filled sudoku which is valid. The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’. Example 1: Input: [ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;] ] Output: true Example 2: Input: [ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;] ] Output: false Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8&apos;s in the top left 3x3 sub-box, it is invalid. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. The given board contain only digits 1-9 and the character ‘.’. The given board size is always 9x9. 解题思路 9行9列 每行1-9，每列1-9，9个3*3的小数独，也是1-9，均不重复 方法 遍历每个格子判断是否合法 如果格子的值相同且不是”.”，但是行，列不同则不合法 代码 123456789101112131415161718192021222324class Solution &#123; public boolean isValidSudoku(char[][] board) &#123; for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[0].length; j++) &#123; if (board[i][j] != '.' &amp;&amp; !isvalid(board, i, j)) return false; &#125; &#125; return true; &#125; public boolean isvalid(char[][] board, int row, int col) &#123; for (int i = 0; i &lt; board.length; i++) &#123; if (board[row][col] == board[i][col] &amp;&amp; row != i) return false; &#125; for (int i = 0; i &lt; board[0].length; i++) &#123; if (board[row][col] == board[row][i] &amp;&amp; col != i) return false; &#125; for (int i = row/3*3; i &lt; row/3*3+3; i++) &#123; for (int j = col/3*3; j &lt; col/3*3+3; j++) &#123; if (board[i][j] == board[row][col] &amp;&amp; !(i == row &amp;&amp; j == col)) return false; &#125; &#125; return true; &#125;&#125; Sudoku SolverWrite a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. Empty cells are indicated by the character ‘.’. dfs 对”.”的位置尝试填入1-9，待下次判断 可使用上一题的isvalid(char[][] board, int row, int col)方法剪枝 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Solution &#123; public void solveSudoku(char[][] board) &#123; if (board == null || board.length != 9 || board[0].length != 9) return; solve(board, 0, 0); &#125; private boolean solve(char[][] board, int i, int j) &#123; if (j &gt;= 9) return solve(board, i + 1, 0); if (i == 9) return true; if (board[i][j] == '.') &#123; for (int k = 1; k &lt;= 9; k++) &#123; board[i][j] = (char) (k + '0'); if (isValid(board, i, j)) &#123; if (solve(board, i, j + 1)) return true; &#125; board[i][j] = '.'; &#125; &#125; else &#123; return solve(board, i, j + 1); &#125; return false; &#125; private boolean isValid(char[][] board, int i, int j) &#123; for (int k = 0; k &lt; 9; k++) &#123; if (k != i &amp;&amp; board[k][j] == board[i][j]) return false; &#125; for (int k = 0; k &lt; 9; k++) &#123; if (k != j &amp;&amp; board[i][k] == board[i][j]) return false; &#125; for (int row = i / 3 * 3; row &lt; i / 3 * 3 + 3; row++) &#123; for (int col = j / 3 * 3; col &lt; j / 3 * 3 + 3; col++) &#123; if (row != i &amp;&amp; col != j &amp;&amp; board[i][j] == board[row][col]) return false; &#125; &#125; return true; &#125;&#125; Flip GameIYou are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip twoconsecutive “++” into “–”. The game ends when a person can no longer make a move and therefore the other person will be the winner. Write a function to compute all possible states of the string after one valid move. For example, given s = “++++”, after one move, it may become one of the following states: [ &quot;--++&quot;, &quot;+--+&quot;, &quot;++--&quot; ] If there is no valid move, return an empty list []. 直接遍历 12345678910111213public static List&lt;String&gt; generatePossibleNextMoves(String s) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); if(s == null || s.length() == 0 || s.length() == 1)&#123; return res; &#125; for(int i = 0; i &lt; s.length();i++)&#123; if(i+1 &lt; s.length() &amp;&amp; s.substring(i,i+2).equals("++"))&#123; res.add(s.substring(0,i)+"--"+s.substring(i+2)); &#125; &#125; return res;&#125; II 需要确保开始的人能赢 和I的做法类似 增加下一步替换后不能赢的判断即可 代码 123456789101112public static boolean canWin(String s) &#123; if(s == null || s.length() == 0 || s.length() == 1)&#123; return false; &#125; for(int i = 0; i &lt; s.length();i++)&#123; if(i+1 &lt; s.length() &amp;&amp; s.substring(i,i+2).equals("++") &amp;&amp; !canWin(s.substring(0,i)+"--"+s.substring(i+2)))&#123; return true; &#125; &#125; return false;&#125; Nim GameYou are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. Example: Input: 4 Output: false Explanation: If there are 4 stones in the heap, then you will never win the game; No matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend. 找规律的题 如果是4的倍数就输 N Queen Queen不能在同一行，同一列，对角线上 也就是说可以将N Queen放置在数组中，一个数组下标表示行值，数组下标对应的数组值可表示其所属列 I 给出所有解 类似用一个全局static的list存储结果 II 给出解的数量 用一个全局static变量计数 12345678910111213141516171819202122232425262728public void solveNQueens(int i, int n, List&lt;Integer&gt; matrix)&#123; if(i == n)&#123; if(isValid(matrix)) count++; else return; &#125; for(int k = 0; k &lt; n;k++)&#123; matrix.add(k); if(isValid(matrix))&#123; solveNQueens(i+1, n, matrix); &#125; matrix.remove(matrix.size() - 1); &#125;&#125;//判断queen是否合法public boolean isValid(List&lt;Integer&gt; matrix)&#123; int row = matrix.size() - 1; int col = matrix.get(row); for(int i = 0;i &lt; row;i++)&#123; int row1 = i; int col1 = matrix.get(i); if(col1 == col) return false; if(row - row1 == col - col1) return false; if(row - row1 == col1 - col) return false; &#125; return true;&#125; Palindrome PartitioningIGiven a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. Example: Input: &quot;aab&quot; Output: [ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;] ] dfs+判断回文回溯 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); List&lt;String&gt; list = new ArrayList&lt;&gt;(); helper(result, list, s); return result; &#125; private void helper(List&lt;List&lt;String&gt;&gt; result, List&lt;String&gt; list, String s) &#123; if(s.length() == 0)&#123; result.add(new ArrayList&lt;&gt;(list)); return; &#125; for(int i = 1;i &lt;= s.length();i++)&#123; if(!isPalindrome(s.substring(0,i)))&#123; continue; &#125; list.add(s.substring(0, i)); helper(result, list, s.substring(i)); list.remove(list.size() - 1); &#125; &#125; private boolean isPalindrome(String s) &#123; int l = 0, r = s.length()-1; while (l &lt; r) &#123; if(s.charAt(l) != s.charAt(r))&#123; return false; &#125; l++; r--; &#125; return true; &#125;&#125; IIGiven a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s. Example: Input: &quot;aab&quot; Output: 1 Explanation: The palindrome partitioning [&quot;aa&quot;,&quot;b&quot;] could be produced using 1 cut. DFS + backtracking 按照I求出所有解，再找出长度最少的 DP 用cuts[i]表示当前位置最少需要切几次使每个部分都是回文。 如果s(j,i)这部分是回文，就有cuts[i] = cuts[j-1] + 1。 matrix[j] [i]表示j到i这部分是回文。 如果s.charAt(i) == s.charAt(j) &amp;&amp; isPalindrome[j+1] [i-1]是回文，则不需重复该部分的搜索。isPalindrome[j] [i]也是回文。 1234567891011121314151617181920class Solution &#123; public int minCut(String s) &#123; int n = s.length(); int[] cuts = new int[n]; // cuts[i] = cut[j-1] + 1 if [j,i] is panlindrome boolean[][] isPalindrome = new boolean[n][n]; // isPalindrome[j][i] means [j,i] is panlidrome for(int i=0; i&lt;n; i++)&#123; int min = i; // maximun cuts for position i, each panlidrome only length of one for(int j=0; j&lt;=i; j++)&#123; if(s.charAt(i) == s.charAt(j) &amp;&amp; ( j + 1 &gt; i - 1 || isPalindrome[j+1][i-1]) )&#123; isPalindrome[j][i] = true; min = j == 0 ? 0 : Math.min(min, cuts[j-1] + 1); &#125; &#125; cuts[i] = min; &#125; return cuts[n-1]; &#125;&#125; Palindrome PermutationIGiven a string, determine if a permutation of the string could form a palindrome. For example, “code” -&gt; False, “aab” -&gt; True, “carerac” -&gt; True. 根据回文性质，只有出现在中心的数是奇数 思路 HashMap计数，判断奇数是否最多出现了一次 HashSet消除，出现第偶数次消除，第奇数次加入Set，最后判断set的size是否不大于1 IIGiven a string s, return all the palindromic permutations (without duplicates) of it. Return an empty list if no palindromic permutation could be form. For example: Given s = &quot;aabb&quot;, return [&quot;abba&quot;, &quot;baab&quot;]. Given s = &quot;abc&quot;, return []. Hint: If a palindromic permutation exists, we just need to generate the first half of the string. To generate all distinct permutations of a (half of) string, use a similar approach from: Permutations II or Next Permutation. 思路 回文分为三部分，在s中出现了偶数次的一半+奇数次的+一半的reverse 对在s中出现了偶数次的一半找全排列类似Permutations II 1234567891011121314151617181920212223242526272829303132333435363738public static List&lt;String&gt; generatePalindromes(String s) &#123; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); String mid = ""; List&lt;Character&gt; list = new ArrayList&lt;Character&gt;(); Map&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;(); int odd = 0; for(char c:s.toCharArray())&#123; map.put(c,map.containsKey(c)?map.get(c)+1:1); odd=odd+(map.get(c)%2==1?1:-1); &#125; if(odd&gt;1) return res; for(Map.Entry&lt;Character,Integer&gt; entry:map.entrySet())&#123; char key = entry.getKey(); int val = entry.getValue(); if(val%2==1) mid=mid+key; for(int i=0;i&lt;val/2;i++)&#123; list.add(key); &#125; &#125; backtracking(res,mid,list,new StringBuilder(),new boolean[list.size()]); return res;&#125; public static void backtracking(List&lt;String&gt; res,String mid,List&lt;Character&gt; list,StringBuilder sb,boolean[] used)&#123; if(sb.length()==list.size())&#123; res.add(sb.toString()+mid+sb.reverse().toString()); sb.reverse(); &#125;else&#123; for(int i=0;i&lt;list.size();i++)&#123; if(used[i]||i&gt;0&amp;&amp;list.get(i)==list.get(i-1)&amp;&amp;!used[i-1]) continue; used[i] = true; sb.append(list.get(i)); backtracking(res,mid,list,sb,used); used[i] = false; sb.deleteCharAt(sb.length()-1); &#125; &#125;&#125; Additive NumberAdditive number is a string whose digits can form additive sequence. A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two. Given a string containing only digits ‘0’-‘9’, write a function to determine if it’s an additive number. Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid. Example 1: Input: &quot;112358&quot; Output: true Explanation: The digits can form an additive sequence: 1, 1, 2, 3, 5, 8. 1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8 Example 2: Input: &quot;199100199&quot; Output: true Explanation: The additive sequence is: 1, 99, 100, 199. 1 + 99 = 100, 99 + 100 = 199 Follow up:How would you handle overflow for very large input integers? 123456789101112131415161718192021222324import java.math.BigInteger;public class Solution &#123; public boolean isAdditiveNumber(String num) &#123; int n = num.length(); for (int i = 1; i &lt;= n / 2; ++i) &#123; if (num.charAt(0) == '0' &amp;&amp; i &gt; 1) return false; BigInteger x1 = new BigInteger(num.substring(0, i)); for (int j = 1; Math.max(j, i) &lt;= n - i - j; ++j) &#123; if (num.charAt(i) == '0' &amp;&amp; j &gt; 1) break; BigInteger x2 = new BigInteger(num.substring(i, i + j)); if (isValid(x1, x2, j + i, num)) return true; &#125; &#125; return false; &#125; private boolean isValid(BigInteger x1, BigInteger x2, int start, String num) &#123; if (start == num.length()) return true; x2 = x2.add(x1); x1 = x2.subtract(x1); String sum = x2.toString(); return num.startsWith(sum, start) &amp;&amp; isValid(x1, x2, start + sum.length(), num); &#125;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>算法</category>
        <category>LeetCode Category</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>BackTracking</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dynamic Programming]]></title>
    <url>%2F2018%2F04%2F29%2FDynamicProgramming%2F</url>
    <content type="text"><![CDATA[利用存储历史信息来减少重复计算，以空间换时间 DP四要素 function 方程，如何从子问题到父问题 state 状态，存储子问题的结果 init 初始化，最小问题 result 结果，最大问题 标记函数要先想好标记数组到底标记的是什么。最标准的：问的什么就标记什么。 常见的四种DP类型 Sequence DP 2 Sequence DP Matrix DP Others 背包类 区间类 什么时候可能使用DP 求max/min yes/no 求能否达到 count(*) 求数量 注意事项多空一位0. 一维DP题目列表 Climbing Stairs Decode Ways Unique Binary Search Trees Maximum Subarray Maximum Product Subarray Best Time to Buy and Sell Stock 什么时候可能不是DP 要求给出具体解决方案 输入的是集合而不是序列 类型一 climbing chairs jump game decode ways unique binary search trees 类型二 global,local maximum subarray maximum product subarray best time to but and sell stock 思路 当看到题目是选择包含还是不包含当前value[i]时 需要维护两个DP，global(全局最优，不一定包含当前值)，local(包含当前值的局部最优) 找出递推关系 TriangleGiven a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle [ [2], [3,4], [6,5,7], [4,1,8,3] ] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. dp[i][j] 以 tri[i][j]为终点的path sum的最小值 state function: dp[i][j] = min(dp[i-1][j],dp[i-1][j-1])+tri[i][j] init state result 漂亮的代码：省去二维，不断更新，自底向上 123456789public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; int[] A = new int[triangle.size()+1]; for(int i=triangle.size()-1;i&gt;=0;i--)&#123; for(int j=0;j&lt;triangle.get(i).size();j++)&#123; A[j] = Math.min(A[j],A[j+1])+triangle.get(i).get(j); &#125; &#125; return A[0];&#125; Pascal’s Triangle I &amp; II I：给定行数，输出三角 每一层元素是它上面两个元素的和 II:给定某一行行号，输出这一行 1234567891011121314class Solution &#123; public List&lt;Integer&gt; getRow(int rowIndex) &#123; List&lt;Integer&gt; cur = new ArrayList&lt;&gt;(); cur.add(1); for(int i = 1;i &lt;= rowIndex;i++)&#123; for(int j = i-1;j &gt; 0;j--)&#123; cur.set(j,cur.get(j-1)+cur.get(j)); &#125; cur.add(1); &#125; return cur; &#125;&#125; House Robber 相邻房子不能抢，global，local问题 dp[i]打劫到第i间时的最大值 state function: dp[i] = max(dp[i-1],dp[i-2]+nums[i-1]) init state: dp[0] = nums[0],dp[1] = max(nums[0],nums[1]) result: dp[length-1] House Robber II 房子是一个环，也就是说第一间和最后一间不能同时抢 拆分成两个数组 一个包含第一间，一个包含最后一间 代码： 1234567891011121314151617181920class Solution &#123; public int rob(int[] nums) &#123; if(nums == null || nums.length == 0) return 0; int n = nums.length; if(n == 1) return nums[0]; if(n == 2) return Math.max(nums[0],nums[1]); return Math.max(rob(nums,0,n-2),rob(nums,1,n-1)); &#125; public int rob(int[] nums,int lo,int hi)&#123; int rob = 0,notRob = 0,preNot = 0,preYes = 0; for(int i = lo;i &lt;= hi;i++)&#123; rob = preNot + nums[i]; notRob = Math.max(preYes,preNot); preNot = notRob; preYes = rob; &#125; return Math.max(rob,notRob); &#125;&#125; Best Time to Buy and Sell StockI 交易一次 略 II 不限交易次数，买入前必须不持有 贪心 方法一 计算局部的峰值，谷值 求和 方法二 循环，只要prices[i] &gt; prices[i-1],求差值 求和 III 最多交易两次，买入前必须不持有 思路1：双向动态规划 构造两个数组，left和right，left[i]表示从0到i天的最大获益，right[i]表示从i到最后一天的最大获益。 求left时，记录前i天的最低价minPrice与最大获益max，求left[i]：考虑要在第i天卖出，那么买进的时间必然是在0到i之间（闭区间），这个时候只需要比较prices[i]-minPrice和max就可以求出截止到第i天的最大获益，然后根据需要更新minPrice。 求right时，记录从第i天往后的最高价maxPrice与最大获益max，求right[i]：考虑要再第i天买进，那么卖出时间必然是在i到最后一天之间（闭区间），这个时候只需要比较maxPrice-prices[i]和max就可以求出从第i天开始的最大获益，然后根据需要更新maxPrice。 对于left和right的构造算法复杂度都是O(n)。 构造完left和right之后，只要求left[i]+right[i]的最大值就行了。 思路2：滚动扫描法 1234567891011121314151617public class Solution &#123; public int maxProfit(int[] prices) &#123; int hold1 = Integer.MIN_VALUE, hold2 = Integer.MIN_VALUE; int release1 = 0, release2 = 0; for(int i = 0; i &lt; prices.length; i++)&#123; //在该价格点卖出第二笔股票后手里剩的钱，等于上一轮买入第二笔股票后手里剩的钱加上卖出当前股票价格的钱，或者上一轮卖出第二笔股票后手里剩的钱两者中较大的 release2 = Math.max(release2, hold2 + prices[i]); //在该价格点买入第二笔股票后手里剩的钱，等于上一轮卖出第一笔股票后手里剩的钱减去买入当前股票价格的钱，或者上一轮买入第二笔股票后手里剩的钱两者中较大的 hold2 = Math.max(hold2, release1 - prices[i]); //在该价格点卖出第一笔股票后手里剩的钱，等于上一轮买入第一笔股票后手里剩的钱加上卖出当前股票价格的钱，或者上一轮卖出第一笔股票后手里剩的钱两者中较大的 release1 = Math.max(release1, hold1 + prices[i]); //在该价格点买入第一笔股票后手里剩的钱，等于初始资金减去买入当前股票价格的钱或者初始资金（不买）中较大的 hold1 = Math.max(hold1, -prices[i]); &#125; return release2; &#125;&#125; IV 最多k次交易，III的延伸 动态规划 复杂度 时间 O(Nk) 空间 O(Nk) 思路 第i天已经执行j笔交易的最大收益作为全局变量global，将第i天正好完成第j笔交易的最大收益作为局部变量local。 int diff = prices[i] - prices[i-1]; global[i][j] = max(global[i-1][j], local[i][j]) local[i][j] = max(global[i-1][j-1]+max(0, diff), local[i-1][j]+diff) 对于local，第i天正好完成第j笔交易的最大收益，可以基于第i-1天正好完成第j-1笔交易的最大收益加上当天交易的差值，还有第i-1天正好完成第j笔交易的最大收益加上当天交易的差值。 要注意的是，第i-1天正好完成第j-1笔交易这种情况，当前交易的差值取0和实际昨天今天差价中较大的，因为我们还有一次自由交易的余地，所以如果亏的话完全可以当天买卖避免损失。 但第i-1天正好完成第j笔交易这种情况来推导第i天正好完成第j笔交易时，相当于第i天已经要连着第i-1天交易，使得第i-1天正好完成的第j笔交易和第i天正好完成的第j笔交易是同一个交易。 注意 对于k &gt; prices.length / 2的情况，我们可以用II的解法来节省空间。因为按照题意必须先买后卖，那么对于n天交易，能够产生有效收益的交易次数是小于等于n/2的，只有不同天买卖才能产生差价。对于大于n/2的那部分交易，必定是当天买卖没有任何收益的，无论交易多少次都是一样的。所以如果k &gt; prices.length / 2，就相当于无限次交易。 数组的第二维初始化长度是k+1，因为我们要预留完成0笔交易的收益，是0。 代码 1234567891011121314151617181920212223242526public class Solution &#123; public int maxProfit(int k, int[] prices) &#123; if(prices.length == 0) return 0; //用II的解法优化k &gt; prices.length / 2的情况 if(k &gt; prices.length / 2)&#123; int sum = 0; for(int i = 1; i &lt; prices.length; i++)&#123; if(prices[i]&gt;prices[i-1]) sum += prices[i] - prices[i-1]; &#125; return sum; &#125; //初始化全局变量和局部变量 int[][] global = new int[prices.length][k+1]; int[][] local = new int[prices.length][k+1]; for(int i = 1; i &lt; prices.length; i++)&#123; int diff = prices[i] - prices[i-1]; for(int j = 1; j &lt; k + 1; j++)&#123; //更新局部变量 local[i][j] = Math.max(global[i-1][j-1]+Math.max(0, diff), local[i-1][j]+diff); //更新全局变量 global[i][j] = Math.max(global[i-1][j], local[i][j]); &#125; &#125; return global[prices.length - 1][k]; &#125;&#125; 滚动扫描法 时间 O(N) 空间 O(k) 需要2k个变量来记录k次交易。 123456789101112131415161718192021222324252627public class Solution &#123; public int maxProfit(int k, int[] prices) &#123; //用II的解法优化k &gt; prices.length / 2的情况 if(k &gt; prices.length / 2)&#123; int sum = 0; for(int i = 1; i &lt; prices.length; i++)&#123; if(prices[i]&gt;prices[i-1]) sum += prices[i] - prices[i-1]; &#125; return sum; &#125; //初始化买卖股票后剩余金钱的数组 int[] release = new int[k+1]; int[] hold = new int[k+1]; for(int i = 0; i &lt; k+1; i++)&#123; hold[i]=Integer.MIN_VALUE; &#125; for(int i = 0; i &lt; prices.length; i++)&#123; for(int j = 1; j &lt; k+1; j++)&#123; //卖出第j笔交易，所剩余的钱 release[j] = Math.max(release[j], hold[j]+prices[i]); //买入第j笔交易，所剩余的钱 hold[j] = Math.max(hold[j], release[j-1]-prices[i]); &#125; &#125; return release[k]; &#125;&#125; Best time to buy and sell stock with cool down 不限交易次数，卖出后需要一天冷却 动态规划 股票有三种状态: buy, sell, cooldown, sell与cooldown我们可以合并成一种状态，因为手里最终都没股票，最终需要的结果是sell，即手里股票卖了获得最大利润。所以我们可以用两个DP数组分别记录当前持股跟未持股的状态。然后根据题目中的限制条件，理清两个DP数组的表达式。 对于当天最终未持股的状态，最终最大利润有两种可能，一是今天没动作跟昨天未持股状态一样，二是昨天持股了，今天卖了。所以我们只要取这两者之间最大值即可，表达式如下： sellDp[i] = Math.max(sellDp[i - 1], buyDp[i - 1] + prices[i]); 对于当天最终持股的状态，最终最大利润有两种可能，一是今天没动作跟昨天持股状态一样，二是前天还没持股，今天买了股票，这里是因为cooldown的原因，所以今天买股要追溯到前天的状态。我们只要取这两者之间最大值即可，表达式如下： buyDp[i] = Math.max(buyDp[i - 1], sellDp[i - 2] - prices[i]); 最终我们要求的结果是 sellDp[n - 1] 表示最后一天结束时手里没股票时的累积最大利润 代码 12345678910111213141516171819202122232425public class Solution &#123; public int maxProfit(int[] prices) &#123; if (prices == null || prices.length == 0) &#123; return 0; &#125; // 表示当天最终未持股的情况下，当天结束后的累计最大利润 int[] sellDp = new int[prices.length]; // 表示当天最终持股的情况下，当天结束后的累计最大利润 int[] buyDp = new int[prices.length]; // 考虑初始情况 buyDp[0] = -prices[0]; sellDp[0] = 0; for (int i = 1; i &lt; prices.length; i++) &#123; sellDp[i] = Math.max(sellDp[i - 1], buyDp[i - 1] + prices[i]); if (i &gt;= 2) &#123; buyDp[i] = Math.max(buyDp[i - 1], sellDp[i - 2] - prices[i]); &#125; else &#123; buyDp[i] = Math.max(buyDp[i - 1], -prices[i]); &#125; &#125; return sellDp[prices.length - 1]; &#125;&#125; 滚动扫描法 123456789101112131415161718public class Solution &#123; public int maxProfit(int[] prices) &#123; if(prices.length == 0) return 0; /* sell[i] = Math.max(sell[i-1], buy[i-1] + prices[i]) * buy[i] = Math.max(sell[i-2]-prices[i], buy[i-1]) */ int preBuy = Integer.MIN_VALUE, curBuy = Integer.MIN_VALUE; int preSell = 0, curSell = 0; for(int price : prices) &#123; preBuy = curBuy; curBuy = Math.max(preSell - price, preBuy); preSell = curSell; curSell = Math.max(preSell, preBuy + price); &#125; return curSell; &#125;&#125; Word BreakIGiven a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. Note: The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Example 1: Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;] Output: true Explanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;. Example 2: Input: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;] Output: true Explanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.Note that you are allowed to reuse a dictionary word. Example 3: Input: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;] Output: false state dp[i] 表示前i个字符能否做Word Break function canBreak[i] = True if canBreak[j] and dict.contains(s.substring(j, i)) j from 0 to i result canBreak[len(s)] 代码 123456789101112131415161718192021class Solution &#123; public boolean wordBreak(String s, List&lt;String&gt; dicts) &#123; Set&lt;String&gt; dict = new HashSet&lt;&gt;(); for(String str: dicts)&#123; dict.add(str); &#125; int len = s.length(); boolean[] dp = new boolean[len + 1]; dp[0] = true; for(int i = 1; i &lt;= len; i++) &#123; for(int j = 0; j &lt; i; j++) &#123; if(dp[j] &amp;&amp; dict.contains(s.substring(j, i))) &#123; dp[i] = true; break; &#125; &#125; &#125; return dp[len]; &#125;&#125; IIGiven a string s and a dictionary of words dict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. For example, given s = &quot;catsanddog&quot;, dict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]. A solution is [&quot;cats and dog&quot;, &quot;cat sand dog&quot;]. 如果要返回所有组合的话，我们可以考虑两种方法， 一种是DP，时间复杂度较低，但是比较耗内存，意味着对于每个Index, 我们可能都要存其对应所有解。 另一种是DFS，空间复杂度较低，但是时间时间复杂度较高，我们可以采用memorization优化时间复杂度。 复杂度 DP: time: O(n^2*k), space: O(nk), 假设k表示平均每个长度对应解的个数 DFS: time: O(2^n), space: O(n) 动态规划 12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123; public List&lt;String&gt; wordBreak(String s, Set&lt;String&gt; wordDict) &#123; // 判断是否能够分解 if (!helper(s, wordDict)) &#123; return new ArrayList&lt;String&gt;(); &#125; // 记录字符串s.substring(0, i)对应的解 HashMap&lt;Integer, List&lt;String&gt;&gt; map = new HashMap&lt;Integer, List&lt;String&gt;&gt;(); map.put(0, new ArrayList&lt;&gt;()); map.get(0).add(""); for (int i = 1; i &lt;= s.length(); i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (map.containsKey(j) &amp;&amp; wordDict.contains(s.substring(j, i))) &#123; if (!map.containsKey(i)) map.put(i, new ArrayList&lt;&gt;()); for (String str : map.get(j)) &#123; map.get(i).add(str + (str.equals("") ? "" : " ") + s.substring(j, i)); &#125; &#125; &#125; &#125; return map.get(s.length()); &#125; private boolean helper(String s, Set&lt;String&gt; wordDict) &#123; boolean dp[] = new boolean[s.length() + 1]; dp[0] = true; for (int i = 1; i &lt;= s.length(); i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (dp[j] &amp;&amp; wordDict.contains(s.substring(j, i))) &#123; dp[i] = true; &#125; &#125; &#125; return dp[s.length()]; &#125; &#125; DFS 从头开始扫描，dict包含则对接下来的递归dfs 直至返回的str的长度等于s 接着返回上一层递归 代码 123456789101112131415161718192021222324252627public static List&lt;String&gt; wordBreak(String s, Set&lt;String&gt; wordDict) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); // 用来记录s.substring(i)这个字符串能否分解 boolean[] possible = new boolean[s.length() + 1]; Arrays.fill(possible, true); dfs(res, "", s, wordDict, 0, possible); return res; &#125; public static void dfs(List&lt;String&gt; res, String cur, String s, Set&lt;String&gt; wordDict, int start, boolean[] possible) &#123; if (start == s.length()) &#123; res.add(cur); return; &#125; for (int i = start + 1; i &lt;= s.length(); i++) &#123; String str = s.substring(start, i); if (wordDict.contains(str) &amp;&amp; possible[i]) &#123; int prevSize = res.size(); dfs(res, cur + (cur.equals("") ? "" : " ") + str, s, wordDict, i, possible); // DFS后面部分结果没有变化，说明后面是没有解的 if (res.size() == prevSize) possible[i] = false; &#125; &#125;&#125; 二维DPDungeon GameThe demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0’s) or contain magic orbs that increase the knight’s health (positive integers). In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. Write a function to determine the knight’s minimum initial health so that he is able to rescue the princess. Notes: The knight’s health has no upper bound. Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned. 动态规划 state : dp[i][j] 表示从i,j出发到终点所需要的最少的体力值 init: dp[m-1][n-1] = max(-dungeon[m-1][n-1],0)+1 function : dp[i][j] = min(dp[i+1][j],dp[i][j+1]) - dungeon[i][j] 代码 1234567891011121314151617181920212223class Solution &#123; public int calculateMinimumHP(int[][] dungeon) &#123; int m = dungeon.length; int n = dungeon[0].length; int[][] dp = new int[m][n]; dp[m-1][n-1] = Math.max(- dungeon[m-1][n-1], 0) + 1; for (int i = m-1; i &gt;= 0; i--) &#123; for (int j = n-1; j &gt;= 0; j--) &#123; if (i + 1 &lt;= m-1 &amp;&amp; j + 1 &lt;= n-1) &#123; dp[i][j] = Math.min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j];; &#125; else if ( i + 1 &lt;= m-1) &#123; dp[i][j] = dp[i+1][j] - dungeon[i][j]; &#125; else if (j + 1 &lt;= n-1) &#123; dp[i][j] = dp[i][j+1] - dungeon[i][j]; &#125; if (dp[i][j] &lt;= 0) dp[i][j] = 1; &#125; &#125; return dp[0][0]; &#125;&#125; Maximal Rectangle是Largest Rectangle in Histogram的晋升题 Largest Rectangle in HistogramGiven n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area = 10 unit. 栈，存放数组的index 判断遍历的数是否大于等于栈顶元素，大于则直接push 小于则pop，直到数组的下一个元素大于栈顶元素 把数组中的每个元素都作为矩形高度，计算了一遍该高度下矩形的最大面积。只是每次都贪心最大，避免了重复计算，所以效率高。 12345678910111213141516class Solution &#123; public int largestRectangleArea(int[] height) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); int index = 0, largestArea = 0; while (index &lt; height.length || (index == height.length &amp;&amp; !stack.isEmpty())) &#123; if (index != height.length &amp;&amp; (stack.isEmpty() || height[stack.peek()] &lt; height[index])) &#123; stack.push(index++); &#125; else &#123; int h = height[stack.pop()]; int w = stack.isEmpty() ? index : index - stack.peek() - 1; largestArea = Math.max(largestArea, h * w); &#125; &#125; return largestArea; &#125;&#125; Maximal RectangleGiven a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing all 1’s and return its area. 要求最大的矩形，实际上可以将矩阵的每一行，转化为上一题的直方图， 而直方图的每个竖条的数字，就是该行对应坐标正上方，向上方向有多少个连续的1。 要转化为直方图，方法是每一行的数值都累加上一行计算出来的数值，而第一行的数值就是本身。如果原始矩阵中遇到0，则累加中断，重新置0。 12340 0 1 1 0 -&gt; 0 0 1 1 00 0 1 1 0 -&gt; 0 0 2 2 01 1 0 0 0 -&gt; 1 1 0 0 01 1 1 0 0 -&gt; 2 2 1 0 0 dp[i][j]化为直方图的值 接着对dp[i][j]进行Largest Rectangle in Histogram计算即可 1234i == 0 --&gt; dp[i][j] = matrix[i][j] - &apos;0&apos;i != 0 --&gt; matrix[i][j] == 1 --&gt; dp[i][j] = dp[i-1][j] + matrix[i][j] - &apos;0&apos;matrix[i][j] != 1 --&gt; dp[i][j] = 0 代码 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public int maximalRectangle(char[][] matrix) &#123; int max = 0; if(matrix.length == 0) return 0; int[][] dp = new int[matrix.length][matrix[0].length]; for(int i = 0; i &lt; matrix.length; i++)&#123; for(int j = 0; j &lt; matrix[0].length; j++)&#123; // 如果是第一行就是自身，如果遇到0则停止累加 dp[i][j] = i == 0 ? matrix[i][j] - '0' : matrix[i][j] == '1' ? dp[i-1][j] + matrix[i][j] - '0' : 0; &#125; &#125; for(int i = 0; i &lt; dp.length; i++)&#123; //找每行的最大矩形 int tmp = findRowMax(i, dp); max = Math.max(max, tmp); &#125; return max; &#125; private int findRowMax(int row, int[][] matrix)&#123; if(matrix[row].length== 0) return 0; Stack&lt;Integer&gt; stk = new Stack&lt;Integer&gt;(); int i = 1, max = matrix[row][0]; stk.push(0); while(i &lt; matrix[row].length || (i == matrix[row].length &amp;&amp; !stk.isEmpty()))&#123; if(i != matrix[row].length &amp;&amp; ( stk.isEmpty() || matrix[row][i] &gt;= matrix[row][stk.peek()] ))&#123; stk.push(i); i++; &#125; else &#123; int top = matrix[row][stk.pop()]; int currMax = !stk.isEmpty() ? top * (i - stk.peek() - 1) : top * i; max = Math.max(currMax, max); &#125; &#125; return max; &#125;&#125; Maximal SquareGiven a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area. Example: Input: 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 Output: 4 构造传递方程：用dp[i][j]存储以当前点matrix[i][j]作为正方形右下角顶点，所存在的最大正方形的边长，由matrix[i][j]左、上、左上三点的dp值共同判定； 初始化边界：matrix的第一列和第一行； 自顶向下递推dp并更新max，找到max的最大值求平方得最优解。 代码 1234567891011121314151617181920public class Solution &#123; //State: dp[i][j] is max length of matrix until (i, j); //Function: dp[i][j] = min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + 1 if matrix[i - 1][j - 1] == '1'; //Initialize: dp[0][0] = 0; //Result: dp[matrix.length][matrix[0].length]; public int maxSquare(int[][] matrix) &#123; int mLen = 0; int m = matrix.length, n = matrix[0].length; int[][] dp = new int[m+1][n+1]; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (matrix[i-1][j-1] == 1) &#123; dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1]))+1; mLen = Math.max(mLen, dp[i][j]); &#125; &#125; &#125; return mLen * mLen; &#125;&#125; Edit DistanceGiven two words word1 and word2, find the minimum number of operations required to convert word1 to word2. You have the following 3 operations permitted on a word: Insert a characterDelete a characterReplace a character Example 1: Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot; Output: 3 Explanation: horse -&gt; rorse (replace &apos;h&apos; with &apos;r&apos;) rorse -&gt; rose (remove &apos;r&apos;) rose -&gt; ros (remove &apos;e&apos;) Example 2: Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot; Output: 5 Explanation: intention -&gt; inention (remove &apos;t&apos;) inention -&gt; enention (replace &apos;i&apos; with &apos;e&apos;) enention -&gt; exention (replace &apos;n&apos; with &apos;x&apos;) exention -&gt; exection (replace &apos;n&apos; with &apos;c&apos;) exection -&gt; execution (insert &apos;u&apos;) 典型的动态规划题目。 维护一个二维数组dis[][]，dis[i][j]表示：word1的前i个元素与word2的前j个元素的edit distance值。递推关系为： 12word1[i] == word2[j] --&gt; dis[i][j] = dis[i][j - 1]。word1[i] != word2[j] --&gt; dis[i][j] = min(dis[i - 1][j - 1], dis[i] [j - 1], dis[i - 1][j]) + 1。 解释一下第二种情况下的递推公式： 123dis[i][j] = dis[i - 1][j - 1] + 1意味着替换字符dis[i][j] = dis[i - 1][j] + 1意味着删除字符dis[i][j] = dis[i][j - 1] + 1意味着插入字符 代码 1234567891011121314151617class Solution &#123; public int minDistance(String word1, String word2) &#123; int l1 = word1.length() + 1; int l2 = word2.length() + 1; int[][] dis = new int[l1][l2]; for (int j = 0; j &lt; l2; j++) &#123; dis[0][j] = j; &#125; // 插入 for (int i = 0; i &lt; l1; i++) &#123; dis[i][0] = i; &#125; // 删除 char[] arr1 = word1.toCharArray(); char[] arr2 = word2.toCharArray(); for (int i = 1; i &lt; l1; i++) &#123; for (int j = 1; j &lt; l2; j++) &#123; dis[i][j] = Math.min(Math.min(dis[i-1][j]+1, dis[i][j-1]+1), dis[i-1][j-1] + (arr1[i-1] == arr2[j-1] ? 0 : 1)); &#125; &#125; return dis[l1-1][l2-1]; &#125;&#125; Hard problemsRegular Expression Matching 动态规划 1234567891, If p.charAt(j) == s.charAt(i) : dp[i][j] = dp[i-1][j-1];2, If p.charAt(j) == '.' : dp[i][j] = dp[i-1][j-1];3, If p.charAt(j) == '\*': here are two sub conditions: 1 if p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2] //in this case, a* only counts as empty 2 if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == '.': dp[i][j] = dp[i-1][j] //in this case, a* counts as multiple a or dp[i][j] = dp[i][j-1] // in this case, a* counts as single a or dp[i][j] = dp[i][j-2] // in this case, a* counts as empty 代码 12345678910111213141516171819202122232425262728293031public boolean isMatch(String s, String p) &#123; if (s == null || p == null) &#123; return false; &#125; boolean[][] dp = new boolean[s.length()+1][p.length()+1]; dp[0][0] = true; for (int i = 0; i &lt; p.length(); i++) &#123; if (p.charAt(i) == '*' &amp;&amp; dp[0][i-1]) &#123; dp[0][i+1] = true; &#125; &#125; for (int i = 0 ; i &lt; s.length(); i++) &#123; for (int j = 0; j &lt; p.length(); j++) &#123; if (p.charAt(j) == '.') &#123; dp[i+1][j+1] = dp[i][j]; &#125; if (p.charAt(j) == s.charAt(i)) &#123; dp[i+1][j+1] = dp[i][j]; &#125; if (p.charAt(j) == '*') &#123; if (p.charAt(j-1) != s.charAt(i) &amp;&amp; p.charAt(j-1) != '.') &#123; dp[i+1][j+1] = dp[i+1][j-1]; &#125; else &#123; dp[i+1][j+1] = (dp[i+1][j] || dp[i][j+1] || dp[i+1][j-1]); &#125; &#125; &#125; &#125; return dp[s.length()][p.length()];&#125; 递归 1234567891011121314class Solution &#123; public boolean isMatch(String text, String pattern) &#123; if (pattern.isEmpty()) return text.isEmpty(); boolean first_match = (!text.isEmpty() &amp;&amp; (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.')); if (pattern.length() &gt;= 2 &amp;&amp; pattern.charAt(1) == '*')&#123; return (isMatch(text, pattern.substring(2)) || (first_match &amp;&amp; isMatch(text.substring(1), pattern))); &#125; else &#123; return first_match &amp;&amp; isMatch(text.substring(1), pattern.substring(1)); &#125; &#125;&#125; Wildcard MatchingGiven an input string (s) and a pattern (p), implement wildcard pattern matching with support for ‘?’ and ‘*’. 12&apos;?&apos; Matches any single character.&apos;*&apos; Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like ? or *. 动态规划 123456789101112131415161718192021222324252627282930public boolean isMatch(String s, String p) &#123; /* boolean dp[len(s) + 1][len(p) + 1] * dp[i+1][j+1] means if s[0, i] match p[0, j] * function: dp[i+1][j+1] * a. p[j] = * =&gt; 1. empty: dp[i+1][j] * 2. one: dp[i][j] * 3. multiple: dp[i][j+1] * b. p[j] = s[i] | p[j] = ? =&gt; dp[i][j] * start: dp[0][0] = true, dp[0][j+1] = dp[0][j] &amp; p[j] = * * result: dp[len(s)][len(p)] */ boolean[][] dp = new boolean[s.length() + 1][p.length() + 1]; // start dp[0][0] = true; for(int j = 0; j &lt; p.length(); j++) dp[0][j+1] = dp[0][j] &amp; (p.charAt(j) == '*'); // loop for(int i = 0; i &lt; s.length(); i++) &#123; for(int j = 0; j &lt; p.length(); j++) &#123; if(p.charAt(j) == '*') &#123; dp[i+1][j+1] = dp[i+1][j] | dp[i][j] | dp[i][j+1]; &#125; else if(p.charAt(j) == s.charAt(i) || p.charAt(j) == '?') dp[i+1][j+1] = dp[i][j]; &#125; &#125; return dp[s.length()][p.length()]; &#125; 贪心 star符号和前面的character没有关系 用两个指针i和j分别扫描s和p，loop过程中有以下几种情况： 成功匹配：s[i] == p[j] or p[j] == ‘?’ =&gt; i++, j++ 出现星号：p[j] == ‘*’ p[j]匹配0个 =&gt; j++； p[j]匹配1个 =&gt; j++, i += 1； p[j]匹配2个 =&gt; j++, i += 2；…… 匹配不上：return false 12345678910111213141516171819202122232425262728public boolean isMatch(String s, String p) &#123; int i = 0, j = 0; int stari = -1, starj = -1; while(i &lt; s.length()) &#123; // 1. match if(j &lt; p.length() &amp;&amp; (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?')) &#123; i++; j++; &#125; // 2. star else if(j &lt; p.length() &amp;&amp; p.charAt(j) == '*') &#123; // first match 0 stari = i; starj = ++j; &#125; // different number that '*' matches else if(stari != -1) &#123; // match number +1 i = ++stari; j = starj; &#125; // 3. not match and no star else return false; &#125; // remove last '*' in p while(j &lt; p.length() &amp;&amp; p.charAt(j) == '*') j++; return j == p.length(); &#125; 递归 思路 12345678if(s[l] == p[r] || p[r] == '?') match(l, r) = match(l + 1, r + 1) 。if(p[r] == '*') &#123; while(l &lt; s.length()) &#123; if(match(l, r)) return true; l++; &#125;&#125; 代码 12345678910111213boolean isMatch(String s, String p, int l, int r) &#123; if(r == p.length()) return l == s.length(); if(p.charAt(r) == '*') &#123; while(r &lt; p.length() &amp;&amp; p.charAt(r) == '*') r++; // Move the index at p to a non-start char. while(l &lt; s.length()) &#123; if(isMatch(s, p, l, r)) return true; // Find one match, return true. l++; // Try the next one. &#125; return isMatch(s, p, l, r); &#125; else if(l &lt; s.length() &amp;&amp; (p.charAt(r) == '?' || s.charAt(l) == p.charAt(r))) return isMatch(s, p, l + 1, r + 1); return false; &#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>算法</category>
        <category>LeetCode Category</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>DynamicProgramming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微软Office STCA]]></title>
    <url>%2F2018%2F04%2F24%2F%E5%BE%AE%E8%BD%AFOffice%20STCA%2F</url>
    <content type="text"><![CDATA[微软Office STCA暑期实习面试 一面 介绍azure table为什么能做到一个用户的数据在一台机器上 介绍datafactory入hive的过程，如果将copy和hive分开，怎么做？用socket？为什么websocket能做到双方发消息？ 多态是在编译时知道？还是运行时？ B extends A; A a = new A() 编译时 A a = new B() 运行时 给定一个正整数，求阶乘？ 越界？ 非递归？ n较小时 public static long getNFactorial(int n){ if(n==0){ return 1l; } return n*getNFactorial1(n-1); } public static long getNFactorial1(int n){ if(n==0){ return 1l; } long sum=1l; for(int i=1;i&lt;=n;i++){ sum=sum*i; } return sum; } n较大时 public static void getNFactorial(int n) { int num[] = new int[1000]; int i, j; if (n == 1 || n == 0) { System.out.println(1); } else { int p, h;// p 存放当前结果的位数，h为进位； p = 1; h = 0; num[1] = 1; for (i = 2; i &lt;= n; i++) { // 使得a[]的每位与i相乘 for (j = 1; j &lt;= p; j++) { num[j] = num[j] * i + h; h = num[j] / 10; num[j] = num[j] % 10; } // 表示向新的位置进位 while (h &gt; 0) { num[j] = h % 10; h = h / 10; j++; } p = j - 1; } for (i = p; i &gt;= 1; i--) { System.out.print(num[i]); } } } 二面 2 Sum &amp; 3 Sum int parse(String str)的测试用例 为什么用azure？]]></content>
      <categories>
        <category>面试经历</category>
        <category>2018</category>
        <category>暑期</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Sort]]></title>
    <url>%2F2018%2F04%2F22%2FSort%2F</url>
    <content type="text"><![CDATA[Sort可分为基于比较和非基于比较两大类排序 非基于比较的排序基于比较的排序是不可能突破O(NlogN)􏰑的 计数排序 直接看教学吧 适合数的范围比较小的情况 桶排序 尽量增大桶的数量，但是不能有太多无效桶）（将所有的元素分到一定区间条件的桶里，在桶里执行其他排序方法 基数排序 拓展的桶排序 多关键字 基本排序算法 Algorithm Average Time Worst Time Space Stable 冒泡排序 n^2 n^2 1 Y 选择排序 n^2 n^2 1 N 插入排序 n^2 n^2 Y 快速排序 nlog(n) n^2 N 归并排序 nlog(n) nlog(n) Y 堆排序 nlog(n) nlog(n) N 快速排序public static void sort(int[] nums, int left,int right){ if(left &lt; right){ int mid = partition(nums,left,right); sort(nums,left,mid-1); sort(nums,mid+1,right); } } public static int partition(int[] nums,int low,int high){ int pivot = nums[low]; while(low &lt; high){ while(nums[high] &gt;= pivot &amp;&amp; low &lt; high){ high--; } nums[low] = nums[high]; while(nums[low] &lt;= pivot &amp;&amp; low &lt; high){ low++; } nums[high] = nums[low]; } nums[low] = pivot; return low; } 归并排序public static void sort(int[] nums, int left,int right){ int mid = (left + right)/2; if(left &lt; right){ sort(nums,left,mid); sort(nums,mid+1,right); merge(nums,left,mid,right); } } public static void merge(int[] nums,int low,int mid,int high){ int[] tem = new int[high-low+1]; int i = low; int j = mid+1; int k = 0; while(i &lt;= mid &amp;&amp; j &lt;= high){ if(nums[i] &lt; nums[j]) tem[k++] = nums[i++]; else tem[k++] = nums[j++]; } while(i &lt;= mid) tem[k++] = nums[i++]; while(j &lt;= high) tem[k++] = nums[j++]; for(int m = 0;m &lt; tem.length;m++){ nums[m+low] = tem[m]; } } 堆排序12345678910111213141516171819202122232425262728293031323334353637public static void sort(int[] nums)&#123; int n = nums.length; for(int i = n/2 -1;i &gt;= 0;i--)&#123; heapify(nums,n,i); &#125; for(int i = n-1;i&gt;=0;i--)&#123; swap(nums,0,i); heapify(nums,i,0); &#125; &#125; public static void heapify(int[] nums,int n,int i)&#123; int largest = i; int l = 2*i+1; int r = 2*i+2; if(l &lt; n &amp;&amp; nums[l] &gt; nums[largest])&#123; largest = l; &#125; if(r &lt; n &amp;&amp; nums[r] &gt; nums[largest])&#123; largest = r; &#125; if(largest != i)&#123; swap(nums,i,largest); heapify(nums,n,largest); &#125; &#125; public static void swap(int[] nums,int i,int j)&#123; int tem = nums[i]; nums[i] = nums[j]; nums[j] = tem;&#125; Wiggle Sort Given an unsorted array nums, reorder it in-place such that nums[0] &lt;= nums[1] &gt;= nums[2] &lt;= nums[3]…. For example, given nums = [3, 5, 2, 1, 6, 4], one possible answer is [1, 6, 2, 5, 3, 4]. 排序法 先将数组排序， 这时候从第3个元素开始，将第3个元素和第2个元素交换。 然后再从第5个元素开始，将第5个元素和第4个元素交换， 以此类推。 123456789101112public class Solution &#123; public void wiggleSort(int[] nums) &#123; // 先将数组排序 Arrays.sort(nums); // 将数组中一对一对交换 for(int i = 2; i &lt; nums.length; i+=2)&#123; int tmp = nums[i-1]; nums[i-1] = nums[i]; nums[i] = tmp; &#125; &#125;&#125; 交换法 如果i是奇数，nums[i] &gt;= nums[i - 1] 如果i是偶数，nums[i] &lt;= nums[i - 1] 遍历一遍数组，把不符合的情况交换一下就行了。 具体来说，如果nums[i] &gt; nums[i - 1]， 则交换以后肯定有nums[i] &lt;= nums[i - 1]。 123456789101112public class Solution &#123; public void wiggleSort(int[] nums) &#123; for(int i = 1; i &lt; nums.length; i++)&#123; // 需要交换的情况：奇数时nums[i] &lt; nums[i - 1]或偶数时nums[i] &gt; nums[i - 1] if((i % 2 == 1 &amp;&amp; nums[i] &lt; nums[i-1]) || (i % 2 == 0 &amp;&amp; nums[i] &gt; nums[i-1]))&#123; int tmp = nums[i-1]; nums[i-1] = nums[i]; nums[i] = tmp; &#125; &#125; &#125;&#125; Sort Colors 给定一组分别具有红白蓝颜色的对象，重新排序他们使得相同颜色的对象相邻。排序后的顺序是红白蓝。 这里我们用 0, 1, and 2 来分别表示红白蓝三个颜色。 注意：不能用库中的排序函数。 遍历，计数 类似快排的partition 左边存放0和1，右边存放2.两边往中间靠。 设置两个index，left记录第一个1的位置，left左边为0，right记录第一个非2的位置，right右边为2. 然后使用i从头到尾扫一遍，直到与right相遇。 i遇到0就换到左边去，遇到2就换到右边去，遇到1就跳过。 需要注意的是：由于left记录第一个1的位置，因此A[left]与A[i]交换后，A[left]为0,A[i]为1，因此i++； 而right记录第一个非2的位置，可能为0或1，因此A[right]与A[i]交换后，A[right]为2,A[i]为0或1，i不能前进，要后续判断。 由此该数组分为4段：[0,left)–&gt;0; [left,i)–&gt;1; [i,right]–&gt;乱序; (right,n-1]–&gt;2 123456789101112131415161718192021222324252627class Solution &#123; public void sortColors(int[] nums) &#123; if(nums == null || nums.length == 0) return; int left = 0; int right = nums.length-1; int i = 0; while(i &lt;= right)&#123; if(nums[i] == 0)&#123; swap(nums,i,left); i++; left++; &#125;else if(nums[i] == 1)&#123; i++; &#125;else&#123; swap(nums,i,right); right--; &#125; &#125; &#125; public void swap(int[] nums, int i, int j)&#123; int tem = nums[i]; nums[i] = nums[j]; nums[j] = tem; &#125;&#125; Sort List 归并排序 快慢指针将链表分为两个部分 慢指针的next为null 再合并两个排序好的链表 Insertion Sort List 选择排序，i前有序，i后无序，两层循环 链表的插入排序，同样两层循环，考虑到头指针也需要被排序，需要新增一个fakeHead。 链表的插入需要维护三个指针，pre，cur，next， pre始终指向有序链表的fakeHead，cur指向当前需要排序的节点，next指向下一个待排序的节点。 当有序链表为空或者pre.next所指向的元素的值比当前节点的值大时，需要将cur插入到pre.next之前的位置， 否则，则将pre指针后移，最后返回fakeHead.next即可。 Maximum GapGiven an unsorted array, find the maximum difference between the successive elements in its sorted form. Return 0 if the array contains less than 2 elements. Example 1: Input: [3,9,6,1] Output: 3 Explanation: The sorted form of the array is [1,3,6,9], either 3,6 or 6,9 has the maximum difference 3. Example 2: Input: [10] Output: 0 Explanation: The array contains less than 2 elements, therefore return 0. Notes: You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range. Try to solve it in linear time/space. 直接排序 桶排序，取相邻两个桶，后一个桶的最小值和前一个桶的最大值可能就是那个值 Best Meeting Point A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|. For example, given three people living at (0,0), (0,4), and (2,2): 1 - 0 - 0 - 0 - 1 | | | | | 0 - 0 - 0 - 0 - 0 | | | | | 0 - 0 - 1 - 0 - 0 The point (0,2) is an ideal meeting point, as the total traveldistance of 2+2+2=6 is minimal. So return 6. 曼哈顿距离，我们可以分开计算横坐标和纵坐标 算出各个横坐标到中点横坐标的距离，加上各个纵坐标到中点纵坐标的距离，就是结果 ComparatorMeeting Rooms Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],…] (si &lt; ei), determine if a person could attend all meetings. 判断区间是否重合 先对数组按照开始时间排序，如果下一个的开始时间早于前一个的结束时间则不行 12345678910111213141516171819public boolean canAttendMeetings(Interval[] intervals) &#123; // base case if(intervals == null || intervals.length == 0) return true; // sort Arrays.sort(intervals, (a, b) -&gt; a.start == b.start ? a.end - b.end : a.start - b.start); //or Arrays.sort(intervals, new Comparator&lt;Interval&gt;()&#123; public int compare(Interval i1, Interval i2)&#123; return i1.start-i2.start; &#125; &#125;); for(int i = 0; i &lt; intervals.length - 1; i++) &#123; if(intervals[i].end &gt; intervals[i+1].start) return false; &#125; return true;&#125; Meeting Rooms II Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],…] (si &lt; ei), find the minimum number of conference rooms required. 思路 overlap的条件依然是：intervals[i].end &gt; intervals[j].start不同的是这题需要求房间数。还是先sort，i指向之前有overlap的最小end的那一个。 复杂度 Time Complexity: O(NlogN)，Space: O(N)。 heap 因为要知道之前有overlap的最小的end，所以可以用一个min heap。每次检查新的start是否比heap的top元素小，是的话就把保存原来的end，同时放进新的end；否则就放新的end同时poll出原来的，因为没有overlap且新的end较大。最后heap的大小就是需要的房间数。比如： [1, 5], [2, 4], [3, 6], [5, 7] heap: [5]。[2, 4]的start是2，比5小，所以放入4。 heap: [4, 5]。接着[3 ,6]的start是3，比4小，所以又放入6。 heap: [4, 5, 6]。[5, 7]的start是5，比4大，因此poll出4，放入7。 heap: [5, 6, 7]。最后heap的size为3。 4被pop出来是因为[2, 4]和[5, 7]公用一个房间，只要放7进去就可以了。 12345678910111213141516public int minMeetingRooms(Interval[] intervals) &#123; // base case if(intervals == null || intervals.length == 0) return 0; // sort Arrays.sort(intervals, (a, b) -&gt; a.start == b.start ? a.end - b.end : a.start - b.start); // min heap to store the end PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(); minHeap.offer(intervals[0].end); for(int i = 1; i &lt; intervals.length; i++) &#123; // no overlap if(minHeap.peek() &lt;= intervals[i].start) minHeap.poll(); minHeap.offer(intervals[i].end); &#125; return minHeap.size(); &#125; Insert Intervals 即向有序、不重叠的区间序列中插入一个区间。如区间产生重叠，则合并。求插入新区间后的区间序列。 如：A = [1,3],[6,9]，插入[2,6]，插入后新序列为[1,9]。 对新给的序列，有三种对应情况 旧区间在新区间之前 新区间在旧区间之前 有重叠 123456789101112131415161718192021222324class Solution &#123; public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123; List&lt;Interval&gt; ans = new ArrayList&lt;Interval&gt;(); for(int i = 0 ; i &lt; intervals.size() ;i++)&#123; Interval now = intervals.get(i); if(now.end &lt; newInterval.start)&#123; //intervals before the newInterval ans.add(now); continue; &#125; else if(now.start &gt; newInterval.end)&#123; //intervals after the newInterval ans.add(newInterval); ans.addAll(intervals.subList(i,intervals.size())); //add all remaining intervals and return return ans; &#125; else&#123; //intervals overlap the newInterval , update the interval range newInterval.start = Math.min(newInterval.start, now.start); newInterval.end = Math.max(newInterval.end, now.end); &#125; &#125; ans.add(newInterval); //if there are no intervals after the newInterval, than add it and return return ans; &#125;&#125; Merge IntervalsGiven a collection of intervals, merge all overlapping intervals. Example 1: Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Example 2: Input: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considerred overlapping. 先根据start排序 再遍历判断是否重叠，interval.start &lt;= end重叠 123456789101112131415161718192021222324252627282930313233/** * Definition for an interval. * public class Interval &#123; * int start; * int end; * Interval() &#123; start = 0; end = 0; &#125; * Interval(int s, int e) &#123; start = s; end = e; &#125; * &#125; */class Solution &#123; public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; if(intervals.size() &lt;= 1) return intervals; Collections.sort(intervals, (a, b) -&gt; a.start == b.start ? a.end - b.end : a.start - b.start); List&lt;Interval&gt; merged = new ArrayList&lt;&gt;(); int start = intervals.get(0).start; int end = intervals.get(0).end; for(Interval interval:intervals)&#123; if(interval.start &lt;= end )&#123; end = Math.max(interval.end,end); &#125;else&#123; merged.add(new Interval(start,end)); start = interval.start; end = interval.end; &#125; &#125; merged.add(new Interval(start,end)); return merged; &#125;&#125; Largest NumberGiven a list of non negative integers, arrange them such that they form the largest number. Example 1: Input: [10,2] Output: 210 Example 2: Input: [3,30,34,5,9] Output: 9534330 Note: The result may be very large, so you need to return a string instead of an integer. 对哪个数放在前面的问题，其实对ab两个数进行排序 如果ab &gt; ba，那么a应该在b之前，写一个符合条件的comparator即可 123456789101112131415161718192021222324252627class Solution &#123; public String largestNumber(int[] nums) &#123; if(nums == null || nums.length == 0) return ""; String[] arr = new String[nums.length]; for(int i = 0;i &lt; nums.length;i++)&#123; arr[i] = String.valueOf(nums[i]); &#125; //逆序，方便之后append Arrays.sort(arr, new Comparator&lt;String&gt;()&#123; public int compare(String a, String b)&#123; String s1 = a+b; String s2 = b+a; return s2.compareTo(s1); &#125; &#125;); if(arr[0].equals("0")) return "0"; StringBuilder sb = new StringBuilder(); for(String s: arr)&#123; sb.append(s); &#125; return sb.toString(); &#125;&#125; Bucket SortFirst Missing PositiveGiven an unsorted integer array, find the smallest missing positive integer. Example 1: Input: [1,2,0] Output: 3 Example 2: Input: [3,4,-1,1] Output: 2 Example 3: Input: [7,8,9,11,12] Output: 1 Note: Your algorithm should run in O(n) time and uses constant extra space. 交换数组元素，使得数组中第i位存放数值(i+1)。 最后遍历数组，寻找第一个不符合此要求的元素，返回其下标。 整个过程需要遍历两次数组，复杂度为O(n)。 12345678910111213141516171819202122class Solution &#123; public int firstMissingPositive(int[] nums) &#123; if(nums == null || nums.length == 0) return 1; int i = 0; int n = nums.length; while(i &lt; n)&#123; if(nums[i] != i+1 &amp;&amp; nums[i] &gt;= 1 &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[i] != nums[nums[i]-1])&#123; int tem = nums[nums[i]-1]; nums[nums[i]-1] = nums[i]; nums[i] = tem; &#125;else&#123; i++; &#125; &#125; for(int j = 0;j &lt; n;j++)&#123; if(nums[j] != j+1)&#123; return j+1; &#125; &#125; return n+1; &#125;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>算法</category>
        <category>LeetCode Category</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFS]]></title>
    <url>%2F2018%2F04%2F18%2FBFS%2F</url>
    <content type="text"><![CDATA[题目列表 Binary Tree Right Side View 层次遍历，输出最右边的数 123456789101112131415161718192021public class Solution &#123; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; // reverse level traversal List&lt;Integer&gt; result = new ArrayList(); Queue&lt;TreeNode&gt; queue = new LinkedList(); if (root == null) return result; queue.offer(root); while (queue.size() != 0) &#123; int size = queue.size(); for (int i=0; i&lt;size; i++) &#123; TreeNode cur = queue.poll(); if (i == 0) result.add(cur.val); if (cur.right != null) queue.offer(cur.right); if (cur.left != null) queue.offer(cur.left); &#125; &#125; return result; &#125;&#125; Populating Next Right Pointers in Each NodeFor example,Given the following perfect binary tree, 1 / \ 2 3 / \ / \ 4 5 6 7 After calling your function, the tree should look like: 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ / \ 4-&gt;5-&gt;6-&gt;7 -&gt; NULL 由于是完全二叉树，所以若节点的左子结点存在的话，其右子节点必定存在， 所以左子结点的next指针可以直接指向其右子节点， 对于其右子节点的处理方法是，判断其父节点的next是否为空，若不为空，则指向其next指针指向的节点的左子结点，若为空则指向NULL Populating Next Right Pointers in Each Node II 不是完全二叉树 借助dummy结点的解法！！！ 1234567891011121314151617181920212223public class Solution &#123; public void connect(TreeLinkNode root) &#123; TreeLinkNode dummy = new TreeLinkNode(0); TreeLinkNode cur = dummy; while(root != null)&#123; if(root.left != null)&#123; cur.next = root.left; cur = cur.next; &#125; if(root.right != null)&#123; cur.next = root.right; cur = cur.next; &#125; root = root.next; if(root == null)&#123; cur = dummy; root = cur.next; cur.next = null; &#125; &#125; &#125;&#125; Word LadderFor example, Given: beginWord = “hit” endWord = “cog” wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”] As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”, return its length 5. Note: Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. 解题思路 BFS 可以想象成一棵树，根节点是start字符串， 第二层是所有的和它相差一个字母的字符串（之前出现过的，之后就没有必要出现了，因为出现的话，也是abc变成bbc又变回abs，没有意义）， 需要一个队列来实现广度优先搜索，因为是从顶层到底层来遍历的，所以发现等于end的时候的层数值就是最小的，返回即可。 1234567891011121314151617181920212223242526272829class Solution &#123; public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; Set&lt;String&gt; dict = new HashSet&lt;&gt;(wordList); Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.add(beginWord); int level = 1; while (!queue.isEmpty()) &#123; int size = queue.size(); for (int q = 0; q &lt; size; q++) &#123; char[] cur = queue.poll().toCharArray(); for (int i=0; i &lt; cur.length; i++) &#123; char tmp = cur[i]; for (char chr='a'; chr &lt;= 'z'; chr++) &#123; cur[i] = chr; String dest = new String(cur); if (dict.contains(dest)) &#123; if (dest.equals(endWord)) return level+1; queue.add(dest); dict.remove(dest); &#125; &#125; cur[i] = tmp; &#125; &#125; level++; &#125; return 0; &#125; &#125; Word Ladder II 需要返回所有的最短路径 呃，有点难。。。]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>算法</category>
        <category>LeetCode Category</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>BinaryTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary Search]]></title>
    <url>%2F2018%2F04%2F18%2FBinarySearch%2F</url>
    <content type="text"><![CDATA[有序数组，用于查找 何时使用需要优化O(n)复杂度时，一般只能二分法 算法模板123456789101112131415public static int binarySearch(int[] arr, int x) &#123; int low = 0; int high = arr.length-1; while(low &lt;= high) &#123; int middle = low + (high - low)/2; if(x == arr[middle]) &#123; return middle; &#125;else if(x &lt;arr[middle]) &#123; high = middle - 1; &#125;else &#123; low = middle + 1; &#125; &#125; return -1; &#125; 题型第一类 考察基本用法，题目并没有说明没有重复值，需要继续查找 search insert position search for a range isBadVersion Closest Binary Search Tree Value 二叉搜索树找离target最近的node的值 二分判断左右 Find Peak Element 二分查找折半后中间那个元素后， 和紧跟的那个元素比较下大小， 如果大于，则说明峰值在前面， 如果小于则在后面。这样就可以找到一个峰值了 Median of Two Sorted Arrays Search for a range 查找等于target的一个范围，即找到最先出现的target和最后出现的target 12345678910111213141516171819202122232425262728class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int[] res = &#123;-1,-1&#125;; if(nums.length == 0) return res; int low = 0; int high = nums.length-1; while(nums[low] &lt; nums[high])&#123; int mid = low + (high - low)/2; if(nums[mid] &gt; target)&#123; high = mid - 1; &#125;else if(nums[mid] &lt; target)&#123; low = mid + 1; &#125;else&#123; if(nums[low] &lt; target) low++; if(nums[high] &gt; target) high--; &#125; &#125; if(nums[low] == target)&#123; res[0] = low; res[1] = high; &#125; return res; &#125;&#125; Median of Two Sorted Arrays第二类 和数学相关 sqrt(X) pow(x, n) fastPower sqrt(X) i * i &lt;= x &amp;&amp; (i+1)(i+1) &gt; x 1234567891011121314public int mySqrt(int x) &#123; if (x == 0) return 0; int start = 1, end = x; while (start &lt; end) &#123; int mid = start + (end - start) / 2; if (mid &lt;= x / mid &amp;&amp; (mid + 1) &gt; x / (mid + 1))// Found the result return mid; else if (mid &gt; x / mid)// Keep checking the left part end = mid; else start = mid + 1;// Keep checking the right part &#125; return start;&#125; pow(x, n)1234567891011public class Solution &#123; public double pow(double x, int n) &#123; if(n == 0) return 1; if(n&lt;0)&#123; n = -n; x = 1/x; &#125; return (n%2 == 0) ? pow(x*x, n/2) : x*pow(x*x, n/2); &#125;&#125; 第三类 二维上运用 Search a 2d Matrix 矩阵从左到右递增，第二行最小值比第一行最大值大 可转化为一维的二分，matrix[mid/col][mid%col] == target Search a 2d Matrix II 矩阵从左到右递增，从上到下递增 第四类 部分sorted的数组或者rotated的数组 search in rotated sorted array search in rotated sorted array II(duplicate allowed) find min in rotated sorted array find min in rotated sorted array II(duplicate allowed) Search in Rotated Sorted ArrayExample 1: 12Input: nums = [4,5,6,7,0,1,2], target = 0Output: 4 Example 2: 12Input: nums = [4,5,6,7,0,1,2], target = 3Output: -1 解题方案 1234567891011121314151617181920212223242526public class Solution &#123; public int search(int[] nums, int target) &#123; int start = 0; int end = nums.length - 1; while (start &lt;= end)&#123; int mid = start + (end - start) / 2; if (nums[mid] == target) return mid; if (nums[start] &lt;= nums[mid])&#123; if (target &lt; nums[mid] &amp;&amp; target &gt;= nums[start]) end = mid - 1; else start = mid + 1; &#125; if (nums[mid] &lt;= nums[end])&#123; if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end]) start = mid + 1; else end = mid - 1; &#125; &#125; return -1; &#125;&#125; Search in rotated sorted array II(duplicate allowed)nums may contain duplicates. 12345678910111213141516171819202122232425class Solution &#123; public boolean search(int[] nums, int target) &#123; int start = 0; int end = nums.length - 1; while (start &lt;= end)&#123; int mid = start + (end - start) / 2; if (nums[mid] == target) return true; if(nums[start] == nums[mid])&#123; start++; &#125;else if (nums[start] &lt; nums[mid])&#123; if (target &lt; nums[mid] &amp;&amp; target &gt;= nums[start]) end = mid - 1; else start = mid + 1; &#125;else&#123; if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end]) start = mid + 1; else end = mid - 1; &#125; &#125; return false; &#125;&#125; Find min in rotated sorted array Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Find the minimum element. If rotate, A[min] &lt; A[min - 1]; If not, A[0]. If not, there are 2 conditions as well: If it is greater than both left and right element, then minimum element should be on its right, otherwise on its left. Find Minimum in Rotated Sorted Array II The array may contain duplicates. 1234567891011121314151617181920class Solution &#123; public int findMin(int[] nums) &#123; if(nums == null || nums.length == 0) return -1; if(nums.length == 1) return nums[0]; int start = 0; int end = nums.length - 1; while (start &lt;= end)&#123; int mid = start + (end - start) / 2; if (nums[mid] &gt; nums[end])&#123; start = mid + 1; &#125;else if(nums[mid] &lt; nums[end])&#123; end = mid; &#125;else&#123; end--; &#125; &#125; return nums[start]; &#125;&#125; Longest Increasing Subsequence动态规划 123456789101112131415161718192021public class Solution &#123; public int lengthOfLIS(int[] nums) &#123; if (nums.length == 0) &#123; return 0; &#125; int[] dp = new int[nums.length]; dp[0] = 1; int maxans = 1; for (int i = 1; i &lt; dp.length; i++) &#123; int maxval = 0; for (int j = 0; j &lt; i; j++) &#123; if (nums[i] &gt; nums[j]) &#123; maxval = Math.max(maxval, dp[j]); &#125; &#125; dp[i] = maxval + 1; maxans = Math.max(maxans, dp[i]); &#125; return maxans; &#125;&#125; 二分查找 if x is larger than all tails, append it, increase the size by 1 if tails[i-1] &lt; x &lt;= tails[i], update tails[i] 123456789101112131415161718192021222324252627282930public int findPositionToReplace(int[] a, int low, int high, int x) &#123; int mid; while (low &lt;= high) &#123; mid = low + (high - low) / 2; if (a[mid] == x) return mid; else if (a[mid] &gt; x) high = mid - 1; else low = mid + 1; &#125; return low;&#125;public int lengthOfLIS(int[] nums) &#123; if (nums == null | nums.length == 0) return 0; int n = nums.length, len = 0; int[] increasingSequence = new int[n]; increasingSequence[len++] = nums[0]; for (int i = 1; i &lt; n; i++) &#123; if (nums[i] &gt; increasingSequence[len - 1]) increasingSequence[len++] = nums[i]; else &#123; int position = findPositionToReplace(increasingSequence, 0, len - 1, nums[i]); increasingSequence[position] = nums[i]; &#125; &#125; return len;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>算法</category>
        <category>LeetCode Category</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>BinarySearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS]]></title>
    <url>%2F2018%2F04%2F18%2FDFS%2F</url>
    <content type="text"><![CDATA[遇到要求所有组合，可能，排列等解集的问题，一般都是用DFS/BFS + backtracking来做 Path Sum 给定一个值，判断是否有一个从根到叶子的路径的value之和等于这个值 非递归 DFS，两个栈，一个放node，一个放到当前node的curSum 如果node是叶子结点，并且curSum等于给定的那个值时，返回true 递归 判断root为null 判断左右子树为null，且该值等于root.val 减去root.val对左右子树递归判断 Path Sum II 需要返回所有可能的路径 1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); pathSum(ans, path, root, sum); return ans;&#125;private void pathSum(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; path, TreeNode root, int sum) &#123; if (root == null) return; List&lt;Integer&gt; newPath = new ArrayList&lt;&gt;(path); newPath.add(root.val); if (root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == sum) &#123; ans.add(newPath); return; &#125; pathSum(ans, newPath, root.left, sum - root.val); pathSum(ans, newPath, root.right, sum - root.val);&#125; Sum Root to Leaf NumbersGiven a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123. Find the total sum of all root-to-leaf numbers. For example, 123 1 / \2 3 The root-to-leaf path 1-&gt;2 represents the number 12. The root-to-leaf path 1-&gt;3 represents the number 13. Return the sum = 12 + 13 = 25. 和上一题类似]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>算法</category>
        <category>LeetCode Category</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[腾讯]]></title>
    <url>%2F2018%2F04%2F16%2F%E8%85%BE%E8%AE%AF%2F</url>
    <content type="text"><![CDATA[腾讯后台开发实习生暑期实习面试 自我介绍 写hql 给定腾讯新闻数据，三个表 第一个表：腾讯新闻版面id，文章id 第二个表，浏览行为数据：时间戳，版面id，文章id 第三个表，评论行为数据：时间戳，版面id，文章id 求每天文章/版面的曝光 曝光 = 评论/浏览 求两个数组的交集 hashset 排序，再比较]]></content>
      <categories>
        <category>面试经历</category>
        <category>2018</category>
        <category>暑期</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary Tree]]></title>
    <url>%2F2018%2F04%2F12%2FBinaryTree%2F</url>
    <content type="text"><![CDATA[Binary Tree遍历前序、中序、后序遍历 解法 递归 非递归，用stack Morris解法，非递归，不用栈，O(1)空间，二叉搜索树 Binary Tree Preorder Traversal根-左-右 递归 非递归 根先入栈 右孩子不为空则入栈 左孩子不为空则入栈 循环跳出条件为栈为空 Inorder Traversal左-根-右 递归 非递归 root入栈 不断找root = root.left入栈 当root为null时出栈，同时root = root.right postOrder Traversal左-右-根 递归 非递归 根入栈 当栈不为空时，判断栈顶元素node的左右孩子，都为null，则出栈 右孩子不为空，右孩子入栈,node.right = null 左孩子不为空，左孩子入栈,node.left = null Binary Tree Level Order Traversal &amp; IIBinary Tree Zigzag Level Order Traversal层次遍历 queue 根入队列 当队列不为空时，node出队列并打印结点，判断左右孩子，分别入队列 将List顺序反转 Collections.reverse(subList); Binary Tree Recursion pre order in order post order Max Depth Min Depth Is Balanced Tree Same Tree Symmetric Tree Validate Binary Search Tree Recover Binary Search Tree Construct Binary Tree from pre-order and in-order Construct Binary Tree from post-order and in-order Convert Sorted Array to BST Convert Sorted LinkedList to BST Max Depth of Binary Tree 递归 对左右子树深度求Max 非递归 层次遍历 Minimum Depth of Binary Tree 递归 左右孩子都不为空时，取Min() 否则，取Max 非递归 层次遍历 当左右孩子都为空时return当前深度 否则入队列，深度++ Balanced Binary Tree 平衡二叉树每一个结点的左右子树的深度相差不超过1 递归求深度差是否满足即可 Symmetric Tree 二叉树是否镜像对称 递归 停止条件是 left==None &amp; right==None left.val==right.val 比较left.left right.right &amp; left.right right.left 非递归 1234567891011121314151617public boolean isSymmetric(TreeNode root) &#123; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.add(root); q.add(root); while (!q.isEmpty()) &#123; TreeNode t1 = q.poll(); TreeNode t2 = q.poll(); if (t1 == null &amp;&amp; t2 == null) continue; if (t1 == null || t2 == null) return false; if (t1.val != t2.val) return false; q.add(t1.left); q.add(t2.right); q.add(t1.right); q.add(t2.left); &#125; return true;&#125; Valid Binary Search Tree 是否满足结点的值左&lt;根&lt;右 递归 判断结点的值是否在取值范围内 非递归 中序遍历 一旦出现先pop的node的值比后面的大，则不是 Flatten Binary Tree to Linked ListFor example, Given 1 / \ 2 5 / \ \ 3 4 6 The flattened tree should look like: 1 \ 2 \ 3 \ 4 \ 5 \ 6 思路1 递归 DFS找到最左结点，然后返回其父结点 把其父节点和右子节点断开 将原左子结点连上父节点的右子节点上 然后再把原右子节点连到新右子节点的右子节点上 然后再回到上一父节点做相同操作 代码 1234567891011121314151617class Solution &#123; public void flatten(TreeNode root) &#123; if(root == null) return; if(root.left != null) flatten(root.left); if(root.right != null) flatten(root.right); TreeNode tem = root.right; root.right = root.left; root.left = null; while(root.right != null)&#123; root = root.right; &#125; root.right = tem; &#125;&#125; 思路2 非递归 从根节点开始出发，先检测其左子结点是否存在 如存在则将根节点和其右子节点断开， 将左子结点及其后面所有结构一起连到原右子节点的位置， 把原右子节点连到元左子结点最后面的右子节点之后 代码 1234567891011121314151617class Solution &#123; public void flatten(TreeNode root) &#123; TreeNode cur = root; while(cur != null)&#123; if(cur.left != null)&#123; TreeNode p = cur.left; while(p.right != null)&#123; p = p.right; &#125; p.right = cur.right; cur.right = cur.left; cur.left = null; &#125; cur = cur.right; &#125; &#125;&#125; Lowest Common Ancestor of a Binary Tree 给定两个结点，求最小公共祖先 代码 public class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { //发现目标节点则通过返回值标记该子树发现了某个目标结点 if(root == null || root == p || root == q) return root; //查看左子树中是否有目标结点，没有为null TreeNode left = lowestCommonAncestor(root.left, p, q); //查看右子树是否有目标节点，没有为null TreeNode right = lowestCommonAncestor(root.right, p, q); //都不为空，说明做右子树都有目标结点，则公共祖先就是本身 if(left!=null&amp;&amp;right!=null) return root; //如果发现了目标节点，则继续向上标记为该目标节点 return left == null ? right : left; } } Binary Tree Longest Consecutive SequenceFor example, 1 \ 3 / \ 2 4 \ 5 Longest consecutive sequence path is 3-4-5, so return 3. 2 \ 3 / 2 / 1 Longest consecutive sequence path is 2-3,not3-2-1, so return 2. 解题思路 先序遍历 判断后一个结点是否比前一个结点的值大一 如果是则长度加1，否则长度重置为1，然后更新结果res 代码 123456789101112131415161718private int result = Integer.MIN_VALUE; public int longestConsecutive(TreeNode root) &#123; if(root == null) return 0; dfs(root, 0, root); return result; &#125; private void dfs(TreeNode root, int cur, TreeNode pre) &#123; if(root == null) return; if(root.val == pre.val+1) cur++; else cur = 1; result = Math.max(result, cur); dfs(root.left, cur, root); dfs(root.right, cur, root); &#125; Recover Binary Search Tree 二叉排序树中有两个节点被交换了，要求把树恢复成二叉排序树。空间复杂度为常数 递归中序遍历二叉树，空间复杂度是O(logn)，最差仍是O(n) 设置一个pre指针，记录当前节点中序遍历时的前节点， 如果当前节点大于pre节点的值，说明需要调整次序。 有一个技巧是如果遍历整个序列过程中只出现了一次次序错误，说明就是这两个相邻节点需要被交换。 非递归，空间复杂度是O(logn)，最差仍是O(n) 栈 中序遍历 Morris待更新 Count Complete Tree Nodes最后一层结点可能是1～2^(树的深度-1) 获得最左子树的深度和最右子树的深度，判断是否相同，相同则直接返回2^（深度）-1 如果不是，则递归计算左右子树，再加1 Binary Tree Maximum Path Sum 路径至少包含一个结点，可以不包含根结点，求path中结点的值的最大和 思路：递归求一条经过root的最大路径，这条路径可能是： 1) 左边某条路径 + root + 右边某条路径 2) 左边某条路径 + root 3) root + 右边某条路径 4) root 对left和right与0比较，可MMath.max(maxValue, left + right + node.val) 递归函数的返回值是以当前node为根的最大path sum,相当于local max最后计算global的时候需要 1234567891011121314151617public class Solution &#123; int maxValue; public int maxPathSum(TreeNode root) &#123; maxValue = Integer.MIN_VALUE; maxPathDown(root); return maxValue; &#125; private int maxPathDown(TreeNode node) &#123; if (node == null) return 0; int left = Math.max(0, maxPathDown(node.left)); int right = Math.max(0, maxPathDown(node.right)); maxValue = Math.max(maxValue, left + right + node.val); return Math.max(left, right) + node.val; &#125;&#125; Construct Binary Tree from Inorder and Preorder 有两个矩阵，则对前序遍历的矩阵pre,根结点即为pre[0] 那么对应的中序遍历矩阵，找到根结点，假设是in[4]，那么in[0-3]即为左子树，in[5-length]即为右子树 递归即可 1234567891011121314151617181920212223242526272829class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; if(preorder.length != inorder.length)&#123; return null; &#125; return build(0,preorder.length-1,preorder,0,inorder.length-1,inorder); &#125; public TreeNode build(int preStart,int preEnd,int[] preorder,int instart,int inEnd,int[] inorder)&#123; if(preStart&gt;preEnd || instart&gt;inEnd) return null; TreeNode root = new TreeNode(preorder[preStart]); int index = 0; for (int i = instart; i &lt;= inEnd; i++) &#123; if (inorder[i] == root.val) &#123; index = i; break; &#125; &#125; int lengthLeft = index - instart; root.left = build(preStart+1,preStart+lengthLeft,preorder,instart,index-1,inorder); root.right = build(preStart+lengthLeft+1,preEnd,preorder,index+1,inEnd,inorder); return root; &#125;&#125; Construct Binary Tree from Inorder and Postorder 和上一个类似 对后序遍历的矩阵post,根结点即为post[length-1] 那么对应的中序遍历矩阵，找到根结点，假设是in[4]，那么in[0-3]即为左子树，in[5-length]即为右子树 递归即可 Unique Binary Search Tree 当给定 n 时，要求出有 n 个节点的不重复的二叉查找树 动态规划 卡特兰数 123456789101112131415161718public class Solution &#123; public int numTrees(int n) &#123; int[] dp = new int[n + 1]; dp[0] = dp[1] = 1; //从节点数2开始计算到节点数为n的BST for(int i = 2; i &lt; n + 1; i++)&#123; //计算根是第一个数的BST数量，直到根是最后一个数的BST数量，这里j可以理解为根左边的节点数 for(int j = 0; j &lt; i; j++)&#123; //有n的节点的BST一共有 G(n)=F(1,n-1)+F(2,n-1)+...+F(n-1,n-1)个 //以i为根总共n个节点的BST有 F(i,n)=G(i-1)*G(i+1-&gt;n)个 //BST形态数量之和一共有多少个节点有关 G(i+1-&gt;n)=G(n-i) //所以G(n)= G(0)*G(n-1)+G(1)*G(n-2)+... dp[i] += dp[j] * dp[i - j - 1]; &#125; &#125; return dp[n]; &#125;&#125; 数学方法 123456public int numTrees(int n) &#123; int c = 1; for (int i = 2; i &lt;= n; i++) c = 2*(2*i-1)*c/(i+1); return c;&#125; 递归 求出以 i 为根节点的所有不重复二叉查找树的和，其中 i 从 1 到 n。 当 i 为根节点时，1~i-1 都在根节点的左子树上，i+1~n 都在根节点的右子树上。 左右子树也都是二叉查找树。根据排列组合可以知道，当i为根节点时，不重复二叉查找树的数量因该是左子树的数量乘以右子树的数量。即Root( i ) = numTrees( i - 1 ) * numTrees( n - i )。 numTrees( n ) = Root( 1 ) + Root( 2 ) + Root( 3 ) + …… + Root( n ). Unique Binary Search Tree II 和上一题不一样在于需要输出所有情况 边界条件的处理 当start &lt; end时，正常处理 当start = end时，说明只剩下一个数字可用，也就只有一种子树了 当start &gt; end时，说明上一个递归里选了start或者end做root，那么左右子树就是null，返回null 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public List&lt;TreeNode&gt; generateTrees(int n) &#123; return generateTrees(1,n); &#125; public List&lt;TreeNode&gt; generateTrees(int start,int end) &#123; List&lt;TreeNode&gt; result = new ArrayList&lt;TreeNode&gt;(); if (start &gt; end) &#123; result.add(null); return result; &#125; for (int i = start; i &lt;= end; i++) &#123; List&lt;TreeNode&gt; left = generateTrees(start, i-1); List&lt;TreeNode&gt; right = generateTrees(i+1, end); for (int j = 0; j &lt; left.size(); j++) &#123; for (int k = 0; k &lt; right.size(); k++) &#123; TreeNode root = new TreeNode(i); root.left = left.get(j); root.right = right.get(k); result.add(root); &#125; &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>算法</category>
        <category>LeetCode Category</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>BinaryTree</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Greedy]]></title>
    <url>%2F2018%2F04%2F11%2FGreedy%2F</url>
    <content type="text"><![CDATA[贪心的奥义就是每一步都选择当前回合”可见范围“（即可得知的信息）内的最优，而在每一步都仅选择当前回合”可见范围“内的最优这一策略下能够导致全局最优的结果的情况使用贪心就会是正确的，否则不适用贪心（或不适用当前对贪心中的最优的定义）。 因此，贪心一个点是选择当前最优，另一个点是这个最优要怎么定义，比如是选使得A最小的还是选使得A-B或A/B最小的等等。 贪心的正确性其实都要通过归纳法或反证法等手段进行严格地证明，而这也是算法分析课程的一个重要讲授内容。 Jump Game For example: A = [2,3,1,1,4], return true. A = [3,2,1,0,4], return false. 数组里的每个元素表示从该位置可以跳出的最远距离，要求问从第一个元素（index=0）开始，能否达到数组的最后一个元素 贪心 设一个值max，遍历更新max = Math.max(max,i+nums[i]) 最后判断max是否大于等于nums.length-1 动态规划 dp[i] i处可到的最远距离 dp[i] = Math.max(dp[i-1],i+nums[i]) i可达 dp[i] = dp[i-1] i不可达 Jump Game II 给定一个非负整数数组，给定的初始化位置在数组的起始位置。数组中的每个元素代表着你能都在此位置跳跃的最大的距离。你的目标是用最少的跳跃数达到数组的末尾 贪心 一次循环判断，当前所能到达的最远位置 如果到不了当前位置，则step加1 动态规划 dp[i] 到达i处的最少步数 两重循环，dp[i]&gt;dp[j]+1 ？dp[i]=dp[j]+1：dp[i] （i &gt; j ,i from 0 to n, j+nums[j] &gt;= i） Gas Station 在一个圆形路径上有N个加油站，在位置 i 上的汽油的数目为gas[i]. 你有一个汽车，这个汽车的油箱是无限容量的，它从加油站 i 到 加油站 （i+1）需要耗费的汽油数为cost[i]. 开始这段旅程的时候，你的起始状态是在加油站中的一个，油箱为空的. 若一次性完成整个的圆形路途，返回你的其实加油站的序号，若不能完成整个路途，返回-1. 如果total为负数，则无论如何都开不完一圈。 如果从一个加油站i出发，开到加油站j所属路段的时候油耗尽，那么从i,j之间的任一个加油站出发都会在j路段或j之前路段耗尽油(相邻的加油站到达必须剩余油量&gt;=0) 循环计算走一环的total和到某站点i的sum 如果sum&lt;0，则开始的站点变为i+1 最后判断total Candy 多个小朋友站成一排，根据他们的得分分发糖果，得分高的小朋友要比旁边得分低的小朋友得到的糖果多，每个小朋友至少得到一枚糖果，问最少要准备多少糖果？ 每个人初始为1 先从左到右扫描一遍，使得右边比左边得分高的小朋友糖果数比左边多。 再从右到左扫描一遍，使得左边比右边得分高的小朋友糖果数比右边多。 Product of Array Except Self 除本身之外的数组之积 O(n) 不能用除法 两次遍历 对result[i]来说，先保存从左到右计算0 ~ i-1的乘积x 再从右到左计算i+1 ~ n的乘积y,计算x与y的乘积即可 Meeting Rooms II因为要知道之前有overlap的最小的end，所以可以用一个min heap。每次检查新的start是否比heap的top元素小，是的话就把保存原来的end，同时放进新的end；否则就放新的end同时poll出原来的，因为没有overlap且新的end较大。最后heap的大小就是需要的房间数。 123456789101112131415161718192021222324252627public int minMeetingRooms(Interval[] intervals) &#123; if(intervals==null||intervals.length==0) return 0; Arrays.sort(intervals, new Comparator&lt;Interval&gt;()&#123; public int compare(Interval i1, Interval i2)&#123; return i1.start-i2.start; &#125; &#125;); //Arrays.sort可替换成： //Arrays.sort(intervals, (a, b) -&gt; a.start == b.start ? a.end - b.end : a.start - b.start); PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;Integer&gt;(); int count=1; queue.offer(intervals[0].end); for(int i=1; i&lt;intervals.length; i++)&#123; if(intervals[i].start &gt;= queue.peek())&#123; queue.poll(); &#125; queue.offer(intervals[i].end); &#125; return queue.size();&#125; Task Scheduler 安排CPU的任务，规定在两个相同任务之间至少隔n个时间点 Input: tasks = [‘A’,’A’,’A’,’B’,’B’,’B’], n = 2 Output: 8 Explanation: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B. 我们首先考虑出现频率最高的task，我们仍假设为A，出现的频率为x，我们知道，要满足A的时间需求，我们至少应该有 x-1个n的间隔。对于频率小于x的任务，假设为B，我们按序插入任务B，可以发现，这样的插入也是满足要求的。 AB-AB-AB模块的次数为任务最大次数减1，模块的长度为n+1，最后加上的字母个数为出现次数最多的任务，可能有多个并列。 如例题中模块AB-的次数为2，长度为3，结果即为2*3+2 1234567891011121314public class Solution &#123; public int leastInterval(char[] tasks, int n) &#123; int[] c = new int[26]; for(char t : tasks)&#123; c[t - 'A']++; &#125; Arrays.sort(c); int i = 25; while(i &gt;= 0 &amp;&amp; c[i] == c[25]) i--; return Math.max(tasks.length, (c[25] - 1) * (n + 1) + 25 - i); &#125; &#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>算法</category>
        <category>LeetCode Category</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>DynamicProgramming</tag>
        <tag>Greedy</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[腾讯云]]></title>
    <url>%2F2018%2F04%2F10%2F%E8%85%BE%E8%AE%AF%E4%BA%91%2F</url>
    <content type="text"><![CDATA[腾讯云后台开发实习生暑期实习面试 介绍项目 多线程的实现方式，线程的状态 new Thread / implements Runnable gc,什么时候gc，内存溢出 Java GC Linux指令，怎么查看内存线程使用情况 Mysql索引，group by &amp; union TCP的…四次挥手，为什么等待2MSL? 用过哪些大数据框架 怎么判断一棵二叉树是镜像的？ 层次遍历，每次取左子树左右结点，右子树右左结点，判断是否相同 栈实现O(1)获得最小的数getMin() 非常棒的一道题。原理很简单，但是需要思考清楚为什么可以。原理可以参考下图： 准备两个栈，一个正常栈，一个辅助栈，正常栈做pop和push。辅助栈push更新最小值，pop出正常栈的最小值。 过程很简单，当正常栈push的时候，查看辅助栈的栈顶元素，如果是比辅助栈栈顶还小或者等于，那么更新到栈顶。否则不加如辅助栈。 当正常栈做pop，查看辅助栈栈顶是否相等，相等的话一起pop，否则不动。 PS：注意当做push的时候，辅助栈栈顶元素和新元素相等，还是要入栈，因为再做pop把元素出栈后，正常栈其实后面还是有这个元素。 原理：其实就是类似动态规划的原理，辅助栈里的元素，全是到正常栈该元素位置的最小值是谁。所以除非正常栈做出栈弹出到这个值，否则辅助栈的栈顶就是当前的最小值。 1000瓶水，1瓶有毒，一只小白鼠喝了有毒的一周死亡，现给10只小白鼠一周时间，怎么做？ 二进制 标记]]></content>
      <categories>
        <category>面试经历</category>
        <category>2018</category>
        <category>暑期</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今日头条]]></title>
    <url>%2F2018%2F04%2F09%2F%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[今日头条后台开发面试 自我介绍 给定一个结点，确定二叉树中序遍历的后继结点（结点有左指针，右指针，父亲指针） 判断是否有右子树，有就找右子树最左的结点 没有，则不断找父亲结点，直到当前结点是父亲结点的左孩子 介绍项目 hashmap的equals和hashcode方法，怎么判断key存在（底层） 首先hash(key)得到key的hashcode()，hashmap根据获得的hashcode找到要插入的位置所在的链，在这个链里面放的都是hashcode相同的Entry键值对，在找到这个链之后，会通过equals()方法判断是否已经存在要插入的键值对，而这个equals比较的其实就是key。 判断key是否存在的时候是先比较key的hashCode，再比较相等或equals的 Http的keep-alive长连接的特性，多个json怎么区分（content-length） 数据库事务的一致性 事务执行前与执行后数据内在的逻辑始终是成立的。比如转账前与转账后两人存款的总和始终不变。]]></content>
      <categories>
        <category>面试经历</category>
        <category>2018</category>
        <category>实习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList]]></title>
    <url>%2F2018%2F04%2F07%2FLinkedList%2F</url>
    <content type="text"><![CDATA[dummy node的运用 merge linked list一定要会 题目列表LinkedList题大体可分为三类：reverse类、Merge类、快慢针类 Rotate List Copy list with random pointers Convert sorted list to Binary Search Tree Remove Duplicates Remove Duplicates II Add Two Numbers insertion sort list use a dummy node to add node to new list one at a time reverse类 reverse linked list reverse print list reverse nodes in k group swap nodes in pairs palindrome list reorder list Merge类 merge linked list merge K sorted List 快慢针类 list cycle I, II get kth node ( get middle node) intersection of two lists remove nth node from end of list Add Two Numbers Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 Explanation: 342 + 465 = 807. dummy node的使用，sum &amp; carry 最后要对carry进行判断 Remove Duplicates For example, Given 1-&gt;1-&gt;2, return 1-&gt;2. Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. 保留重复的值，可用cur = head,判断cur.val == cur.next.val ? Remove Duplicates II For example, Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5. Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3. 删除重复的值，需要dummy node，cur = dummy,需要记录cur.next.val进行循环删除 Merge类Merge Two Sorted Lists 递归 非递归 Merge K Sorted Lists 二分+递归 使用堆（优先队列），将K个链表的头结点全部添加到队列，由于优先级队列采用了最小堆数据结构，堆顶为队列的最小元素，我们将其取出添加到结果链表中，取出元素对应的链表下移一个节点，并将这个节点添加到优先级队列中；然后我们继续取出堆顶元素，…，直到优先级队列为空，那么其中所有元素取尽，K个链表的元素已经全部排序到结果链表。 快慢针类List Cycle 快慢指针，最后是否相遇 fast.next != null &amp;&amp; fast.next.next != null List Cycle II 找到环开始的地方 假设从起点到环开始的地方长度为x,相遇点距离环起点为k，环长为L d = x + m*L + k 2d = x + n*L +k 则 x + (2m -n)*L +k = 0 所以 x = (L-k) + (n-2m-1)*L 所以 一指针从开始出发，一指针从相遇点出发，最终会在环开始的地方相遇 Remove Nth Node From End 删除从尾部开始数的第n个结点 快慢指针，快指针先走n步 Partition List 给定一个链表，一个整数x，将链表分开确定一边比x小，另一表不小于x，并保持原来的链表的相对顺序 需要dummy node 可以新建一个链表用来存小于x的node,并将原来对应的node删掉，最后将原来的list接在现在的之后 reverse类Reverse Linked List 头插法 递归 Reverse Linked List II 将链表m到n的位置的结点逆置 dummy node 找到开始反转的前一个node pre 维持不变，以及找到真正开始反转的结点start，下一个结点 then Palindrome List 双指针，判断fast.next是否为null，不是则slow = slow.next 对slow进行逆置 一一比较两个链表的值 Swap Nodes in Pairs For example,Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. dummy node 三个node的使用，cur first second cur = cur.next.next Reorder List Given a singly linked list L: L0→L1→…→Ln-1→Ln, reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→… 找到中点，前半部分结尾设为null 将后半部分reverse 再merge Rotate List Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2, return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL. two pointer 找到length-k个，注意k可能大于length(%),并将next设为null 将原来链表的end的next设为head 返回原来的length-k+1个 Copy List with Random Pointer 如果要copy一个带有random pointer的list，主要的问题就是有可能这个random指向的位置还没有被copy到，所以解决方法都是多次扫描list。 使用HashMap，HashMap的key存原始pointer，value存新的pointer。 hashmap，一次遍历put(node,new RandomListNode(node.label)) 再次遍历，对next，random指针进行修改 3次遍历list，时间复杂度为O(3n)=O(n)。 对每个node进行复制，并插入其原始node的后面，新旧交替，变成重复链表。如：原始：1-&gt;2-&gt;3-&gt;null，复制后：1-&gt;1-&gt;2-&gt;2-&gt;3-&gt;3-&gt;null 遍历每个旧node，把旧node的random的复制给新node的random，因为链表已经是新旧交替的。所以复制方法为： node.next.random = node.random.next 前面是说旧node的next的random，就是新node的random，后面是旧node的random的next，正好是新node，是从旧random复制来的。 把新旧两个表拆开，返回新的表即可。 Convert Sorted List to Binary Search Tree递归 找到中点 递归 中序遍历 左子树-根-右子树 Intersection of Two Linked ListFor example, the following two linked lists: A: a1 → a2 → c1 → c2 → c3 B: b1 → b2 → b3 → c1 → c2 → c3 begin to intersect at node c1. 获得两个链表的长度差x，较长的先往前x，再一起往前，直到相等]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>算法</category>
        <category>LeetCode Category</category>
      </categories>
      <tags>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位运算]]></title>
    <url>%2F2018%2F04%2F07%2F%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[例题 XOR相关Single Number 找到数组中只出现一次的元素，其它出现两次，不用额外内存异或XOR ^ Concept If we take XOR of zero and some bit, it will return that bit a⊕0=a If we take XOR of two same bits, it will return 0 a⊕a=0 a⊕b⊕a=(a⊕a)⊕b=0⊕b=b Single Number II 找到数组中只出现一次的元素，其它出现三次，不用额外内存 利用只出现3次的特性，模3的值只可能是0或1，则第一次出现存在ones中，第二次出现存在twos中，同时清掉ones的值，第三次出现，存在ones中，但twos中有了，同时清掉ones，twos的值 12345678public int singleNumber(int[] A) &#123; int ones = 0, twos = 0; for(int i = 0; i &lt; A.length; i++)&#123; ones = (ones ^ A[i]) &amp; ~twos; twos = (twos ^ A[i]) &amp; ~ones; &#125; return ones;&#125; Single Number III 2n+2的数组，每个元素出现两次，除了两个只出现一次的数，找到这两个数 time O(n) space O(1) 遍历数组异或，得到两个只出现一次的数异或之后的值x 将该值x与~(x-1)相与，获得最后几位不同的数值y 初始化返回数组，res[2]={0,0} 遍历数组，判断num[i]&amp;y == 0? res[0]^num[i]:res[1]^num[i] Missing Number 给定一个0-n每个元素都不同的数组，数组元素缺了一个，比如0，1，3，缺了2，找到缺少的那个数 对0-n做异或得x 对数组做异或得y 返回x^y &amp;相关Count of 1 bits 给定一个整数，求该整数二进制表示时1的个数 检查每一位是否是1，右移12345678910static int countSetBits(int n)&#123; int count = 0; while (n &gt; 0) &#123; count += n &amp; 1; n &gt;&gt;= 1; &#125; return count;&#125; bitwise从integer减1时，从右往左所有0变1，将最右边1变为0 比如110100 减1 得110011，对这两个数做&amp;，变为110000 所以n &amp; (n-1)可以将n的最后一个1消掉，用while判断是否消掉所有的1 Power of Two 给定一个整数，判断是否是2的次方 2的power只有一位是1，利用n &amp; (n-1)将1消掉，接着判断是否为0 Shift相关Reverse Bits 0100 -&gt; 0010 32位整数，循环32次，将当前bit赋值给res,整数右移，res左移 1234567891011public class Solution &#123; // you need treat n as an unsigned value public int reverseBits(int n) &#123; int res = 0; for(int i = 0;i &lt; 32;i++)&#123; res = (res&lt;&lt;1) | (n&amp;1); n = n&gt;&gt;1; &#125; return res; &#125;&#125; Math相关Bitwise AND of Numbers Range 给定范围[m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回范围内所有整数的按位与，包括边界。 例如，给定范围[5, 7], 你应该返回4。 [m, n]范围的按位与的结果为m与n的公共“左边首部（left header）” 1234567891011class Solution &#123; public int rangeBitwiseAnd(int m, int n) &#123; int count = 0; while(m!=n)&#123; m = m&gt;&gt;1; n = n&gt;&gt;1; count++; &#125; return m&lt;&lt;count; &#125;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>算法</category>
        <category>LeetCode Category</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap & ConcurrentHashMap]]></title>
    <url>%2F2018%2F04%2F03%2FHashMap%26ConcurrentHashMap%2F</url>
    <content type="text"><![CDATA[HashMap实现原理HashMap即是采用了链地址法，也就是数组+链表的方式 HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。 所以，HashMap的整体结构如下 简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度依然为O(1)，因为最新的Entry会插入链表头部，仅需简单改变引用链即可，而对于查找操作来讲，此时就需要遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。 其他几个重要字段 12345678//实际存储的key-value键值对的个数transient int size;//阈值，当table == &#123;&#125;时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到int threshold;//负载因子，代表了table的填充度有多少，默认是0.75final float loadFactor;//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationExceptiontransient int modCount; HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值 initialCapacity默认为16，loadFactory默认为0.75 在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组 123456789101112131415161718192021222324public V put(K key, V value) &#123; //如果table数组为空数组&#123;&#125;，进行数组填充（为table分配实际内存空间），入参为threshold，此时threshold为initialCapacity 默认是1&lt;&lt;4(24=16) if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; //如果key为null，存储位置为table[0]或table[0]的冲突链上 if (key == null) return putForNullKey(value); int hash = hash(key);//对key的hashcode进一步计算，确保散列均匀 int i = indexFor(hash, table.length);//获取在table中的实际位置 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; //如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++;//保证并发访问时，若HashMap内部结构发生变化，快速响应失败 addEntry(hash, key, value, i);//新增一个entry return null;&#125; 通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。 HashMap的数组长度一定是2的次幂 如果数组进行扩容，数组长度发生变化，而存储位置 index = h&amp;(length-1),index也可能会发生变化，需要重新计算index 扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换) 数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀 多线程下使用HashMap JDK1.7 存在死循环 ConcurrentHashMap实现原理分段锁 ConcurrentHashMap采用了非常精妙的”分段锁”策略，ConcurrentHashMap的主干是个Segment数组。 在ConcurrentHashMap，一个Segment就是一个子哈希表，Segment里维护了一个HashEntry数组，并发环境下，对于不同Segment的数据进行操作是不用考虑锁竞争的。 所以，对于同一个Segment的操作才需考虑线程同步，不同的Segment则无需考虑。 Segment数组的大小ssize是由concurrentLevel来决定的，但是却不一定等于concurrentLevel，ssize一定是大于或等于concurrentLevel的最小的2的次幂。 put的主要逻辑也就两步： 1.定位segment并确保定位的Segment已初始化 2.调用Segment的put方法。 Segment的get方法无需加锁，由于其中涉及到的共享变量都使用volatile修饰，volatile可以保证内存可见性，所以不会读取到过期数据。 Segment上的put方法，Segment中的put方法是要加锁的。只不过是锁粒度细了而已。]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Math相关]]></title>
    <url>%2F2018%2F04%2F02%2F%E6%95%B0%E5%AD%A6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[题型总结 第一种类型是最简单的， 就是对整数进行直接操作， 一般来说就是逐位操作， 比如反转， 比较等。 LeetCode中这类题目有Palindrome Number和Reverse Integer。 第二种题型是算术运算的题目， 比如乘除法， 阶乘， 开方等， LeetCode中这类题目有Sqrt(x)， Pow(x, n)和Divide Two Integers。 这种题目有时候看似复杂， 其实还是有几个比较通用的解法的， 下面主要介绍三种方法： 二分法 牛顿法 位移法 第三种题目是解析几何的题目， 一般来说解析几何题目的模型都比较复杂， 而且实现细节比较多， 在面试中并不常见， LeetCode中也只有Max Points on a Line是属于这种题型。 Math without Operator 不用operator进行数学运算 解题方法 对于乘除的题目，&lt;&lt;1是乘2，&gt;&gt;1是除以2 对于加减的题目，a ^ b得到sum，a &amp; b得到carry 注意问题 正负问题 是否会overflow,int的取值范围 -2147483648 ～ 2147473647 例题 Divide Two Integers 不用乘法，除法，取余实现除法 不断减去被除数，直至小于除数，会超时 任何一个数，都可以表示成：(2^k)*除数 &lt;= 当前被除数 &lt;(2^(k+1))*除数 123456789101112while (divd &gt;= divs) &#123; int counter = 0; // keep multiply by 2 until divs &gt; divd while (divd &gt;= (divs &lt;&lt; counter)) &#123; counter++; &#125; // rollback counter so that (divs&lt;&lt;counter) &lt;= divd counter--; // quotient ret += 1 &lt;&lt; counter; divd -= divs &lt;&lt; counter; &#125; Ugly NumberI：判断是否是丑数 如果ugly number能被2,3或者5整除，那么就除以可以整除的 如果不能被2,3,􏰏5其中一个整除，则说明不是ugly number ugly number应该可以一直被除到1，此时可以结束，说明这个数是ugly number II:找到n-th的ugly number丑陋数列可以拆分为下面3个子列表 (1)1x2,2x2,3x2,4x2,5x2,… (2)1x3,2x3,3x3,4x3,5x3,… (3)1x5,2x5,3x5,4x5,5x5,… 我们􏰤􏰥发现每一个子列表都是ugly number本身(1, 2, 3, 4, 5, …) 乘以2, 3, 5 使用与归并相似的合并方法，从3个子列表中获得ugly number。每一步获得最小的，然后后移。 三个指针p2,p3,p5分别代表下一次乘以2,3,5的来比较ugly number的index，如果用过了就指向下一个ugly number Add Digits (Digit root) 如38，3+8 = 11，1+1=2 num%9运算即可 Add Binary从后往前不断加，类似merge two list Trailing Zeros n!中有几个0 0的多少与2和5有关，而2比5多，因此只关心5即可 解题方法 n / 5,得到所有5的一次方的数量，加到结果 n/ (5^2)，得到所有5的二次方的数量，加到结果 5的三次方… 直到n不大于下一个5的k次方则停止 1234567891011int findTrailingZeros(int n)&#123; // Initialize result int count = 0; // Keep dividing n by powers of 5 and update count for (int i=5; n/i&gt;=1; i *= 5) count += n/i; return count;&#125; Palindrome Number 不用额外空间 用数学方法不断获得最大位和最小位，比较之后去掉，同时除数大小也要调整 Cont PrimesSieve of Eratosthenes 1234567891011Input: an integer n &gt; 1. Let A be an array of Boolean values, indexed by integers 2 to n, initially all set to true. for i = 2, 3, 4, ..., not exceeding √n: if A[i] is true: for j = i2, i2+i, i2+2i, i2+3i, ..., not exceeding n: A[j] := false. Output: all i such that A[i] is true. Roman to Integer &amp; Integer to RomanMultiply StringsExcel Sheet Column Number26进制]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>算法</category>
        <category>LeetCode Category</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求和问题]]></title>
    <url>%2F2018%2F04%2F01%2F%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述 一般是给一组n个数字，给1个target，求出k个数字的sum为target。有变化的就是求closet，求个数，求组合等。 注意事项 可能有重复项，注意去重，除了2Sum都可以先排序 2 Sum 解法 方法一 brute force 枚举所有的k-subset，从N中选出k个，时间复杂度O(n^k) 先sort，再two pointer 两指针之和与target比较，大于则high–,小于则low++, O(nlogn) 利用hashmap hashmap保存nums[i],i，循环判断map中是否存在target-nums[i],O(n) 后续题目 对于2Sum的题目 返回index，则优先使用hashmap做，排序会打乱顺序 如果是返回value，则用先sort，再two pointer 对 3sum, 3sum closest, 4sum等题目，因为大部分都是根据two sum two pointer做法的延伸，所以都是要求return value。 two pointer有利于跳过重复元素，用来计算closet，smaller等不等于target的题，优先使用 3 Sum 解法 可转换为2Sum问题，先取出一个数i，在剩下的数组中找sum为target-i的 时间复杂度为O(nlogn+n^2) = O(n^2) 3 Sum Closetsort + two pointer，不断更新最接近target的值 4 Sum 解法 退化为3sum，两层loop，内部2 sum， O(n^3) K Sum 解法 一步步退化，最后变为2 Sum，O(n^(k-1))]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>算法</category>
        <category>LeetCode Category</category>
      </categories>
      <tags>
        <tag>K Sum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程面试的10大算法概念汇总]]></title>
    <url>%2F2018%2F03%2F31%2F%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E7%9A%8410%E5%A4%A7%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[字符串 如果IDE没有代码自动补全功能，所以你应该记住下面的这些方法。 123456toCharArray() // 获得字符串对应的char数组Arrays.sort() // 数组排序Arrays.toString(char[] a) // 数组转成字符串charAt(int x) // 获得某个索引处的字符length() // 字符串长度length // 数组大小 链表 在Java中，链表的实现非常简单，每个节点Node都有一个值val和指向下个节点的链接next。 123456789class Node &#123; int val; Node next; Node(int x) &#123; val = x; next = null; &#125;&#125; 链表两个著名的应用是栈Stack和队列Queue。 栈： 12345678910111213141516171819202122232425262728class Stack&#123; Node top; public Node peek()&#123; if(top != null)&#123; return top; &#125; return null; &#125; public Node pop()&#123; if(top == null)&#123; return null; &#125;else&#123; Node temp = new Node(top.val); top = top.next; return temp; &#125; &#125; public void push(Node n)&#123; if(n != null)&#123; n.next = top; top = n; &#125; &#125;&#125; 队列： 123456789101112131415161718192021222324class Queue&#123; Node first, last; public void enqueue(Node n)&#123; if(first == null)&#123; first = n; last = first; &#125;else&#123; last.next = n; last = n; &#125; &#125; public Node dequeue()&#123; if(first == null)&#123; return null; &#125;else&#123; Node temp = new Node(first.val); first = first.next; if(last == temp) last = first; return temp; &#125; &#125;&#125; 树 这里的树通常是指二叉树，每个节点都包含一个左孩子节点和右孩子节点，像下面这样： 12345class TreeNode&#123; int value; TreeNode left; TreeNode right;&#125; 下面是与树相关的一些概念： 平衡 vs. 非平衡：平衡二叉树中，每个节点的左右子树的深度相差至多为1（1或0）。 满二叉树（Full Binary Tree）：除叶子节点以外的每个节点都有两个孩子。 完美二叉树（Perfect Binary Tree）：是具有下列性质的满二叉树：所有的叶子节点都有相同的深度或处在同一层次，且每个父节点都必须有两个孩子。 完全二叉树（Complete Binary Tree）：二叉树中，可能除了最后一个，每一层都被完全填满，且所有节点都必须尽可能向左靠。 图 图相关的问题主要集中在深度优先搜索（depth first search）和广度优先搜索（breath first search）。 排序 Algorithm Average Time Worst Time Space Stable 冒泡排序 n^2 n^2 1 Y 选择排序 n^2 n^2 1 N 插入排序 n^2 n^2 Y 快速排序 nlog(n) n^2 N 归并排序 nlog(n) nlog(n) Y 堆排序 nlog(n) nlog(n) N 递归 vs. 迭代 对程序员来说，递归应该是一个与生俱来的思想（a built-in thought），可以通过一个简单的例子来说明。 问题： 有n步台阶，一次只能上1步或2步，共有多少种走法。 步骤1:找到走完前n步台阶和前n-1步台阶之间的关系。 为了走完n步台阶，只有两种方法：从n-1步台阶爬1步走到或从n-2步台阶处爬2步走到。如果f(n)是爬到第n步台阶的方法数，那么f(n) = f(n-1) + f(n-2)。 步骤2: 确保开始条件是正确的。 f(0) = 0;f(1) = 1; 12345public static int f(int n)&#123; if(n &lt;= 2) return n; int x = f(n-1) + f(n-2); return x;&#125; 递归方法的时间复杂度是n的指数级，因为有很多冗余的计算，如下： f(5) f(4) + f(3) f(3) + f(2) + f(2) + f(1) f(2) + f(1) + f(1) + f(0) + f(1) + f(0) + f(1) f(1) + f(0) + f(1) + f(1) + f(0) + f(1) + f(0) + f(1) 直接的想法是将递归转换为迭代： 1234567891011121314151617public static int f(int n) &#123; if (n &lt;= 2)&#123; return n; &#125; int first = 1, second = 2; int third = 0; for (int i = 3; i &lt;= n; i++) &#123; third = first + second; first = second; second = third; &#125; return third;&#125; 对这个例子而言，迭代花费的时间更少 动态规划动态规划是解决下面这些性质类问题的技术： 一个问题可以通过更小子问题的解决方法来解决（译者注：即问题的最优解包含了其子问题的最优解，也就是最优子结构性质）。有些子问题的解可能需要计算多次（译者注：也就是子问题重叠性质）。子问题的解存储在一张表格里，这样每个子问题只用计算一次。需要额外的空间以节省时间。 位操作位操作符： OR () AND (&amp;) XOR (^) Left Shift (&lt;&lt;) Right Shift (&gt;&gt;) Not (~) 1\ 0=1 1&amp;0=0 1^0=1 0010&lt;&lt;2=1000 1100&gt;&gt;2=0011 ~1=0 概率问题 善于转换成对立的问题 比如求50个人至少有两个人生日相同的概率（忽略闰年） ——-&gt; 计算所有人生日都互不相同的概率，也就是：365/365 364/365 363/365 … (365-49)/365，这样至少两个人生日相同的概率就是1 – 这个值。 排列组合]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>算法</category>
        <category>LeetCode Category</category>
      </categories>
      <tags>
        <tag>算法概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁金服]]></title>
    <url>%2F2018%2F03%2F30%2F%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D%2F</url>
    <content type="text"><![CDATA[蚂蚁金服Java暑期实习生面试 一面 介绍项目，主要介绍在微软的实习，要注意项目讲得对方能理解 10亿条文件排序，外部归并，merge时堆内部排序 一堆运动员的成绩排序，如a:10,b:20,c:5，排序并保证新来的一个运动员也是有序的 用treemap, map底层怎么实现的，哈希表或红黑树 白板写代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//假设用一组字符串表示一个目录下的层级结构:// 如"dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"//表示的结构为// dir// subdir1// file1.ext// subsubdir1// subdir2// subsubdir2// file2.ext &#125; import java.util.ArrayList;import java.util.List;public class Main &#123; class Value&#123; public int i = 15; &#125; public static void main(String[] args) &#123; System.out.println(getLargestLength("dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext")); &#125; public static int getLargestLength(String str)&#123; int max = 0; if(str == null || str.length() == 0)&#123; return max; &#125; String arr [] = str.split("\n"); if(arr[0].contains("\t")) return -1; List&lt;Integer&gt; dirLength = new ArrayList&lt;&gt;(); dirLength.add(arr[0].length()); max = arr[0].length(); for (int i = 1; i &lt; arr.length; i++)&#123; int length = arr[i].replaceAll("\t", "").length(); int count = arr[i].length() - length; if (dirLength.size() &lt; count) &#123; //输入欠缺中间目录 return -1; &#125; else if (count == 0) &#123; //新的根目录 dirLength = null; &#125; else &#123; dirLength = dirLength.subList(0, count); &#125; dirLength.add(length + dirLength.get(count - 1)); if (dirLength.get(count) &gt; max)&#123; max = dirLength.get(count); &#125; &#125; return max; &#125;&#125; 二面 介绍项目 给一个二维数组代表会议室的预定时间区间，比如[1,2],[2,3],[1,3]，则最少需要的会议室的数量为2 贪心 转换为一个会议室利用率最高的问题，对开始时间排序，选择下一个开始时间离结束时间最近的 数学题，给1-5五个数字，全排列，[12345,12354,…,54312,54321],求中间两个数的差值 hiveql和sql是一样的么？不一样，举例说明，并说明理由 hiveql数据表的join,map reduce的过程？ 给一个整数数组[x1,x2…xi,…xn]，求X+Y+Z&lt;N的所有可能性，不能重复 3sum 的变体，先排序，外层循环，内层两个指针判断，如果和&gt; N-Z，则尾指针前移 HTTP怎么做到有状态？ 我们要实现的是一种web应用，实现这种应用的协议我们选择了http这种本质上是无状态的通信协议。但是事实上，我们需要我们的web应用是有状态的。所以我们加入了cookies、session等机制去实现由状态的web应用 Web应用=http协议+session、cookies等状态机制+其他辅助的机制 MySQL数据库引擎，innoDB的特点？别的引擎？ InnoDB：该存储引擎为MySQL表提供了ACID事务支持、系统崩溃修复能力和多版本并发控制（即MVCC Multi-Version Concurrency Control）的行级锁;该引擎支持自增长列（auto_increment）,自增长列的值不能为空，如果在使用的时候为空则自动从现有值开始增值，如果有但是比现在的还大，则直接保存这个值; 该引擎存储引擎支持外键（foreign key）,外键所在的表称为子表而所依赖的表称为父表。该引擎在5.5后的MySQL数据库中为默认存储引擎。 ISAM：该引擎在读取数据方面速度很快，而且不占用大量的内存和存储资源；但是ISAM不支持事务处理、不支持外来键、不能够容错、也不支持索引。该引擎在包括MySQL 5.1及其以上版本的数据库中不再支持。 MyISAM：该引擎基于ISAM数据库引擎，除了提供ISAM里所没有的索引和字段管理等大量功能，MyISAM还使用一种表格锁定的机制来优化多个并发的读写操作，但是需要经常运行OPTIMIZE TABLE命令，来恢复被更新机制所浪费的空间，否则碎片也会随之增加，最终影响数据访问性能。MyISAM还有一些有用的扩展，例如用来修复数据库文件的MyISAMChk工具和用来恢复浪费空间的 MyISAMPack工具。MyISAM强调了快速读取操作，主要用于高负载的select，这可能也是MySQL深受Web开发的主要原因：在Web开发中进行的大量数据操作都是读取操作，所以大多数虚拟主机提供商和Internet平台提供商（Internet Presence Provider，IPP）只允许使用MyISAM格式。 HEAP（也称为MEMORY）：该存储引擎通过在内存中创建临时表来存储数据。每个基于该存储引擎的表实际对应一个磁盘文件，该文件的文件名和表名是相同的，类型为.frm。该磁盘文件只存储表的结构，而其数据存储在内存中，所以使用该种引擎的表拥有极高的插入、更新和查询效率。这种存储引擎默认使用哈希（HASH）索引，其速度比使用B-+Tree型要快，但也可以使用B树型索引。由于这种存储引擎所存储的数据保存在内存中，所以其保存的数据具有不稳定性，比如如果mysqld进程发生异常、重启或计算机关机等等都会造成这些数据的消失，所以这种存储引擎中的表的生命周期很短，一般只使用一次。 CSV（Comma-Separated Values逗号分隔值）：使用该引擎的MySQL数据库表会在MySQL安装目录data文件夹中的和该表所在数据库名相同的目录中生成一个.CSV文件（所以，它可以将CSV类型的文件当做表进行处理），这种文件是一种普通文本文件，每个数据行占用一个文本行。该种类型的存储引擎不支持索引，即使用该种类型的表没有主键列；另外也不允许表中的字段为null。 小英的用户数据一台机器放不下的时候，怎么办？]]></content>
      <categories>
        <category>面试经历</category>
        <category>2018</category>
        <category>暑期</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜狐智能媒体研发中心]]></title>
    <url>%2F2018%2F03%2F28%2F%E6%90%9C%E7%8B%90%E6%99%BA%E8%83%BD%E5%AA%92%E4%BD%93%E7%A0%94%E5%8F%91%E4%B8%AD%E5%BF%83%2F</url>
    <content type="text"><![CDATA[搜狐智能媒体研发中心Java实习生面试 并发编程，能并发的数据结构 Springboot为什么能做到不配置一些xml？ 1.0版本的智慧教室会遇到哪些问题？并发？底层的哪些不够用了，才会出现这些问题？ JVM参数调优，怎么做？参数的意义？ HTTP要了解得更深入一些 服务器怎么判断是某个用户，用户登录的时候怎么返回该用户的信息，session怎么做安全？ MySQL建表的时候需要注意什么？long类型在mysql中怎么存？ Redis适合存一些什么样的数据？在什么场合使用？ Spring的IOC、AOP需要知道流程，Java基础，NIO等… 单链表反转，递归，非递归]]></content>
      <categories>
        <category>面试经历</category>
        <category>2018</category>
        <category>暑期</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜狐汽车]]></title>
    <url>%2F2018%2F03%2F23%2F%E6%90%9C%E7%8B%90%E6%B1%BD%E8%BD%A6%2F</url>
    <content type="text"><![CDATA[搜狐汽车Java后台开发实习生面试 介绍简历 String为什么是final的,Enum,数据库连接（左外，右外，内连接） 用栈实现队列(时间复杂度),数组找出只出现一次的元素(时间复杂度),手写快排 Java运行时的编译情况，大的项目是怎么编译的 Spring的文档什么的有没有看过 确定自己喜欢的是什么，有没有兴趣，自驱动能力 String为什么是final的？ 不可变final指不在原内存地址上修改数据，而是重新指向一个新对象，新地址 JDK源码，java.lang.String前三行 123456public final class String implements java.io.Serializable,Comparable&lt;String&gt;,CharSequence&#123; /** String本质是个char数组，而且用final修饰*/ private final char[] value; &#125; Array可变，只是在后面的String的所有方法里没有动数组的元素，没有暴露内部成员。String不可变的关键都在底层实现，而不是一个final 不可变是为了安全 SQL四种连接 内联接（典型的联接运算，使用像 = 或 &lt;&gt; 之类的比较运算符）。包括相等联接和自然联接。内联接使用比较运算符根据每个表共有的列的值匹配两个表中的行。例如，检索 students和courses表中学生标识号相同的所有行。 外联接。外联接可以是左向外联接、右向外联接或完整外部联接。在 FROM子句中指定外联接时，可以由下列几组关键字中的一组指定： 1）LEFT JOIN或LEFT OUTER JOIN左向外联接的结果集包括 LEFT OUTER子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值。 2）RIGHT JOIN 或 RIGHT OUTER JOIN右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。 3）FULL JOIN 或 FULL OUTER JOIN完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。 交叉联接交叉联接返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉联接也称作笛卡尔积。]]></content>
      <categories>
        <category>面试经历</category>
        <category>2018</category>
        <category>暑期</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试宝典]]></title>
    <url>%2F2018%2F03%2F19%2FJava%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%2F</url>
    <content type="text"><![CDATA[JavaJava程序设计基本概念JVM JVM使用Unicode字符表示 ClassLoader知识 Java程序并不是一个可执行文件，而是由许多独立的类文件组成，每个文件对应一个Java类。这些类文件不是全部装入内存，程序根据需要载入。 基本概念 JVM实现的一部分 包括bootstrap classloader(启动类加载器) 在JVM运行时加载Java核心API，其中包括用户定义ClassLoader（用户定义，指通过java程序实现的ClassLoader，ExtClassLoader和AppClassLoader） 加载流程（父类委托模式） JVM启动，运行bootstrap classloader，加载Java核心API（ExtClassLoader和AppClassLoader也被加载） 调用ExtClassLoader加载扩展API AppClassLoader加载CLASSPATH目录下定义的Class i++ i++；先赋值在自加；++i；先自加在赋值 java中间变量缓存机制 123456public static void main(String[] args)&#123; int j = 0; for(int i = 0; i &lt; 100; i++) j = j++; System.out.println(j); &#125; 以上代码的输出结果是？ 0！！！ 因为java的中间缓存变量机制使j=j++语句看以分解成如下操作： temp = j;j = j + 1;j = temp; 类型转换java的数据类型转换 三大类，布尔型、字符型、数值型，数值型分为整型和浮点型 简单数据类型之间的转换、字符串与其他数据类型的转换、其他实用数据类型的转换 简单数据类型之间的转换 低级-&gt;高级 （byte、short、char）- int - long - float - double 可分为三种 自动类型转换e.g. char-&gt;int 转换为对应ASCII码值 强制类型转换 （溢出或精读下降） 包装类过渡类型转换6个包装类: Boolean Character Integer Long Float Double 位运算&amp;&amp;，|| 短路运算符，符合前面，后面就不做了&amp;，|非短路 异常Java中的异常 所有抛出的异常必须从Throwable派生而来，Error，死循环、内存泄漏等，不处理；Exception分为RuntimeException（不处理）和非运行时异常（捕获、声明） final、finally、finalize的区别 final关键字 修饰类，不能派生新子类，不能被继承，类不能同时被abstract和final修饰 修饰变量或方法，保证在使用中不被改变。变量只能在定义或构造函数赋值，方法不能重写（override） finally 异常处理时 finalize 方法名 在垃圾收集器将对象从内存中清除出去之前做必要的清理工作 传递与引用传值与传引用 基本类型变量，传值的副本；引用类型变量，传引用的副本 静态修饰符 static 静态变量（类变量） 静态成员属于整个类 静态方法（类方法） 静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员 输入/输出流 内存管理垃圾回收 Java在对象创建时自动分配内存，当对象引用不存在时释放内存。 Java实用垃圾回收技术监视程序运行，当对象不再使用时自动释放内存。使用软指针跟踪对象的各个引用，并用对象表将软指针映射为对象的引用。使用软指针，垃圾回收器能以单独的线程在后台运行，依次检查每个对象。通过改变对象表项，可标记、移除、移动、检查对象。 cloneclone方法是object的方法，所以任何一个类都会自动拥有这个方法。但这并不说明就可以调用clone了，需要显示指明可以调用clone，需要写上字符串“implements Cloneable”。该字符串只是起指示作用。 面向对象集合类 HashMap和Hashtable的区别 HashMap允许null值，null键 Hashtable不允许null值和null键 Hashtable方法是同步的 多态的概念]]></content>
      <categories>
        <category>Java基础</category>
        <category>读书笔记</category>
        <category>Java面试宝典</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM垃圾回收]]></title>
    <url>%2F2018%2F03%2F18%2FJava%20JVM%2F</url>
    <content type="text"><![CDATA[JVM堆区栈区每个线程执行每个方法的时候都会在栈中申请一个栈帧，每个栈帧包括局部变量区和操作数栈，用于存放此次方法调用过程中的临时变量、参数和中间结果。 方法区存放了要加载的类信息、静态变量、final类型的常量、属性和方法信息。JVM用持久代(PermanetGeneration)来存放方法区， 垃圾回收GChttp://www.jianshu.com/p/5261a62e4d29垃圾回收(Garbage Collection)是Java虚拟机(JVM)垃圾回收器提供的一种用于在空闲时间不定时回收无任何对象引用的对象占据的内存空间的一种机制。 内存不足或应用程序空闲时会触发 可以手动调用system.gc或finalize方法。 java的对象引用引用：如果Reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。 强引用：对象实例化 软引用：可能还有用的对象，会在内存不足的时候释放 弱引用：比软引用还弱，只能生存到下次垃圾回收 虚引用：最弱，甚至不能用虚引用获得一个实例对象，存在是为了在对象被回收后获得系统反馈 垃圾：无任何对象引用的对象 回收：清理“垃圾”占用的内存空间而非对象本身 发生地点：一般发生在堆内存中，因为大部分的对象都储存在堆内存中 发生时间：程序空闲时间不定时回收 垃圾回收算法（1）找到所有存活对象（2）回收被无用对象占用的内存空间，使该空间可被程序再次使用。 1. 判断是否是垃圾对象的算法1.1 引用计数算法堆中每个对象（不是引用）都有一个引用计数器。当一个对象被创建并初始化赋值后，该变量计数设置为1。每当有一个地方引用它时，计数器值就加1（a = b， b被引用，则b引用的对象计数+1）。当引用失效时（一个对象的某个引用超过了生命周期（出作用域后）或者被设置为一个新值时），计数器值就减1。任何引用计数为0的对象可以被当作垃圾收集。当一个对象被垃圾收集时，它引用的任何对象计数减1。 优点：引用计数收集器执行简单，判定效率高，交织在程序运行中。对程序不被长时间打断的实时环境比较有利（OC的内存管理使用该算法）。 缺点： 难以检测出对象之间的循环引用。同时，引用计数器增加了程序执行的开销。所以Java语言并没有选择这种算法进行垃圾回收。 早期的JVM使用引用计数，现在大多数JVM采用对象引用遍历（根搜索算法）。 1.2 根搜索算法根集(Root Set)是正在执行的Java程序可以访问的引用变量（注意：不是对象）的集合(包括局部变量、参数、类变量)，程序可以使用引用变量访问对象的属性和调用对象的方法。 （1）通过一系列名为“GC Roots”的对象作为起始点，寻找对应的引用节点。（2）找到这些引用节点后，从这些节点开始向下继续寻找它们的引用节点。（3）重复（2）。（4）搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，就证明此对象是不可用的。 Java和C#中都是采用根搜索算法来判定对象是否存活的。 首先，垃圾回收器将某些特殊的对象定义为GC根对象。 （所谓的GC根对象包括：（1）虚拟机栈中引用的对象（栈帧中的本地变量表）；（2）方法区中的常量引用的对象；（3）方法区中的类静态属性引用的对象；（4）本地方法栈中JNI（Native方法）的引用对象。（5）活跃线程。） 接下来，垃圾回收器会对内存中的整个对象图进行遍历，它先从GC根对象开始，然后是根对象引用的其它对象，比如实例变量。回收器将访问到的所有对象都标记为存活。（标记过程中有许多复杂的规则和操作）当标记阶段完成后，GC开始进入下一阶段，删除不可达对象。 2. 回收垃圾对象内存的算法2.1 Tracing算法（标记-清除）就直接删除标记的内存，不做处理 优点：不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效。 缺点：（1）标记和清除过程的效率都不高。（这种方法需要使用一个空闲列表来记录所有的空闲区域以及大小。对空闲列表的管理会增加分配对象时的工作量。）。（2）标记清除后会产生大量不连续的内存碎片。虽然空闲区域的大小是足够的，但是可能没有足够大的连续空间。 2.2 Compacting算法（标记-整理）将所有对象内存向一端移动，清除端外的。 优点：（1）经过整理之后，新对象的分配只需要通过指针碰撞便能完成（Pointer Bumping），相当简单。（2）使用这种方法空闲区域的位置是始终可知的，也不会再有碎片的问题了。 缺点：GC暂停的时间会增长，因为你需要将所有的对象都拷贝到一个新的地方，还得更新它们的引用地址。 2.3 Copying算法将内存按容量分为大小相等的两块，每次只使用其中的一块（对象面），当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面（空闲面），然后再把已使用过的内存空间一次清理掉。 复制算法比较适合于新生代（短生存期的对象），在老年代（长生存期的对象）中，对象存活率比较高，如果执行较多的复制操作，效率将会变低，所以老年代一般会选用其他算法，如标记—整理算法。 优点：（1）标记阶段和复制阶段可以同时进行。（2）每次只对一块内存进行回收，运行高效。（3）只需移动栈顶指针，按顺序分配内存即可，实现简单。（4）内存回收时不用考虑内存碎片的出现（得活动对象所占的内存空间之间没有空闲间隔）。 缺点：需要一块能容纳下所有存活对象的额外的内存空间。因此，可一次性分配的最大内存缩小了一半。 2.4 Adaptive算法监控情况并选择最合适的垃圾回收算法 在特定的情况下，一些垃圾收集算法会优于其它算法。基于Adaptive算法的垃圾收集器就是监控当前堆的使用情况，并将选择适当算法的垃圾收集器。 java的堆内存Java的堆内存基于Generation算法（Generational Collector）划分为新生代、年老代和持久代。新生代又被进一步划分为Eden和Survivor区，最后Survivor由FromSpace（Survivor0）和ToSpace（Survivor1）组成。所有通过new创建的对象的内存都在堆中分配，其大小可以通过-Xmx和-Xms来控制。 分代收集，因为不同的对象的生命周期是不一样的。因此，可以将不同生命周期的对象分代，不同的代采取不同的回收算法（4.1-4.3）进行垃圾回收（GC），以便提高回收效率。 （1）对象优先在Eden分配。 （2）大对象直接进入老年代。 （3）长期存活的对象将进入老年代。 年轻代young generationMinor GC/Scavenge GC（非常频繁，并不是eden满了才发生）几乎所有新生成的对象首先都是放在年轻代的。新生代内存按照8:1:1的比例分为一个Eden区和两个Survivor(Survivor0,Survivor1)区。大部分对象在Eden区中生成。当新对象生成，Eden Space申请失败（因为空间不足等），则会发起一次GC(Scavenge GC)。回收时先将Eden区存活对象复制到一个Survivor0区，然后清空Eden区，当这个Survivor0区也存放满了时，则将Eden区和Survivor0区存活对象复制到另一个Survivor1区，然后清空Eden和这个Survivor0区，此时Survivor0区是空的，然后将Survivor0区和Survivor1区交换，即保持Survivor1区为空， 如此往复。当Survivor1区不足以存放 Eden和Survivor0的存活对象时，就将存活对象直接存放到老年代。当对象在Survivor区躲过一次GC的话，其对象年龄便会加1，默认情况下，如果对象年龄达到15岁，就会移动到老年代中。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。 年老代old generationMajor GC/Full GC（老年代满了才发生）在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。一般来说，大对象会被直接分配到老年代。所谓的大对象是指需要大量连续存储空间的对象，最常见的一种大对象就是大数组。 持久代permanent generation用于存放静态文件（class类、方法）和常量等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。对永久代的回收主要回收两部分内容：废弃常量和无用的类。 垃圾回收器不同的垃圾回收器算法不同，可能同时有不同的回收器多线程运行。（1）串行垃圾回收器（Serial Garbage Collector） （2）并行垃圾回收器（Parallel Garbage Collector） （3）并发标记扫描垃圾回收器（CMS Garbage Collector） （4）G1垃圾回收器（G1 Garbage Collector） 如何降低垃圾回收开销(1)不要显式调用System.gc()(2)尽量减少临时对象的使用(3)对象不用时最好显式置为Null(4)尽量使用StringBuffer,而不用String来累加字符串(5)能用基本类型如Int,Long,就不用Integer,Long对象(6)尽量少用静态对象变量(7)分散对象创建或删除的时间 版本变化永久代空间在Java SE8特性中已经被移除。取而代之的是元空间（MetaSpace）。 JVM的参数：PermSize 和 MaxPermSize 会被忽略并给出警告（如果在启用时设置了这两个参数）。 元空间 Metaspace大部分类元数据都在本地内存中分配。 一个新的参数 (MaxMetaspaceSize)可以使用。允许你来限制用于类元数据的本地内存。如果没有特别指定，元空间将会根据应用程序在运行时的需求动态设置大小。 如果类元数据的空间占用达到参数“MaxMetaspaceSize”设置的值，将会触发对死亡对象和类加载器的垃圾回收。一些各种各样的数据已经转移到Java堆空间。 Java 元空间为无限（默认值） ，永久代有大小限制。元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。]]></content>
      <categories>
        <category>Java面试</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求职分享]]></title>
    <url>%2F2018%2F03%2F03%2F%E5%BE%AE%E8%BD%AF%E6%B1%82%E8%81%8C%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[IEG组求职分享 留在微软的人儿product组内部tansfer到IEG的小哥哥 基础知识准备：leetcode,geeksforgeeks 简历：要根据不同公司不同岗位有针对性地准备 Tips 微软，谷歌，对用过哪些框架不在意，注重基础，算法，数学等，主要看自学能力 如果遇到实在不会的题，学会从别的角度出发，说出自己的想法，即使给出的解决方案不好，也比不说强 微软产品组 秋招，summer intern 在线面试，两轮技术面（基础算法+机器学习算法），manager面等，表现优秀转正几率大 product组的小姐姐 自我介绍，突出重点，别光说简历上的 一般算法面试的难度在leetcode的中等难度 重复强调stc的summer intern！ 可以准备暑期实习，感受下流程，或者找一些不会去的公司参加春招 阿里的Java岗问得比较底层，小米，微软更侧重于算法 IEG做语音的小姐姐 计算机基础：牛客网 算法：剑指offer，leetcode 求职公众号推荐：柠檬offer，职场薪火，互联派 没留下的人儿算法-何 选定自己想要干啥，一般算法和开发分开，只攻一个 外企：MSRA,Google,Amazon,IBM,Airbnb,FreeWheel 算法！！！ MSRA：四轮面试 2技术+1研究+1leader (研究会问一些论文或项目，外加一些数据逻辑思维题) Google：OnlineTest + 技术面试 （在线建议不要组团做，容易被禁，一般做对一题就行） 技术面试题，如：先二维动归入门，再四维，再最大流算法 常考点： 国内互联网常考：手写排序算法 算法岗常考：简单统计模型公式推导、模型的优缺点；特征工程的经验；深度学习模型的原理；数理统计题；开放题：1.如何统计北京有多少个红绿灯 2.如何找出意思相同的不同表达（“周杰伦的老婆”，“昆凌”） 有意思的题：1. 给一把有刻度的尺子，把任意凸多边形二等分；2. 烧一根绳子需要半小时，如何用两根确定45分钟；3. A,B两人随机在3点～4点之间到C地，每个人最多停留15分钟，问两个人可以在C地碰到的概率]]></content>
      <categories>
        <category>前辈经验分享</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList题]]></title>
    <url>%2F2017%2F09%2F30%2FLinkedList%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Leetcode83.Remove Duplicates from Sorted ListGiven a sorted linked list, delete all duplicates such that each element appear only once. For example,Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. 1234567891011121314public ListNode deleteDuplicates(ListNode head) &#123; if(head == null || head.next == null)&#123; return head; &#125; ListNode cur = head; while(cur.next != null)&#123; if(cur.val == cur.next.val)&#123; cur.next = cur.next.next; &#125;else&#123; cur = cur.next; &#125; &#125; return head; &#125; 82.Remove Duplicates from Sorted List IIGiven a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. For example,Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3. 1234567891011121314151617181920public ListNode deleteDuplicates(ListNode head) &#123; if(head == null || head.next == null)&#123; return head; &#125; ListNode dummy = new ListNode(0); dummy.next = head; ListNode cur = dummy; while(cur.next != null &amp;&amp; cur.next.next != null)&#123; if(cur.next.val == cur.next.next.val)&#123; int temp = cur.next.val; while(cur.next ！= null &amp;&amp; cur.next.val == temp)&#123; cur.next = cur.next.next; &#125; &#125;else&#123; cur = cur.next; &#125; &#125; return dummy.next; &#125; 147.Insertion Sort ListSort a linked list using insertion sort. 插入排序：两层循环，将数插入到已经排序的数组中合适的位置去 1234567891011121314151617181920/*Function to sort array using insertion sort*/ void sort(int arr[]) &#123; int n = arr.length; for (int i=1; i&lt;n; ++i) &#123; int key = arr[i]; int j = i-1; /* Move elements of arr[0..i-1], that are greater than key, to one position ahead of their current position */ while (j&gt;=0 &amp;&amp; arr[j] &gt; key) &#123; arr[j+1] = arr[j]; j = j-1; &#125; arr[j+1] = key; &#125; &#125; 链表的插入排序，同样两层循环，考虑到头指针也需要被排序，需要新增一个fakeHead。 链表的插入需要维护三个指针，pre，cur，next，pre始终指向有序链表的fakeHead，cur指向当前需要排序的节点，next指向下一个待排序的节点。 当有序链表为空或者pre.next所指向的元素的值比当前节点的值大时，需要将cur插入到pre.next之前的位置，否则，则将pre指针后移，最后返回fakeHead.next即可。 123456789101112131415161718public ListNode insertionSortList(ListNode head) &#123; if(head == null || head.next == null)&#123; return head; &#125; ListNode dummy = new ListNode(0); ListNode cur = head; while(cur != null)&#123; ListNode pre = dummy; ListNode next= cur.next; while(pre.next != null &amp;&amp; pre.next.val &lt; cur.val)&#123; pre = pre.next; &#125; cur.next = pre.next; pre.next = cur; cur = next; &#125; return dummy.next; &#125; 92.Reverse Linked List IIReverse a linked list from position m to n. Do it in-place and in one-pass. For example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL. Note:Given m, n satisfy the following condition:1 ≤ m ≤ n ≤ length of list. 指定位置的链表部分逆转，考虑到头指针也可能被逆转，新建fakeHead。 维护三个指针，pre永远指向m-1个位置的节点，start指向m位置的节点，then指向start.next 12345678910111213141516171819202122232425public ListNode reverseBetween(ListNode head, int m, int n) &#123; if(head == null)&#123; return null; &#125; ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; for(int i = 0;i &lt; m-1;i++)&#123; pre = pre.next; &#125; ListNode start = pre.next; ListNode then = start.next; for(int i = 0;i &lt; n-m ;i++)&#123; start.next = then.next; then.next = pre.next; pre.next = then; then = start.next; &#125; return dummy.next; &#125; 148.Sort ListSort a linked list in O(n log n) time using constant space complexity. 归并排序 123456789101112131415161718192021222324252627282930313233343536373839public ListNode sortList(ListNode head) &#123; if(head == null || head.next == null)&#123; return head; &#125; ListNode pre = head; ListNode slower = head; ListNode faster = head; while(faster !=null &amp;&amp; faster.next != null)&#123; pre = slower; slower = slower.next; faster = faster.next.next; &#125; pre.next = null; ListNode h1 = sortList(head); ListNode h2 = sortList(slower); return merge(h1,h2);&#125;public ListNode merge(ListNode head1,ListNode head2) &#123; if(head1 == null)&#123; return head2; &#125; if(head2 == null)&#123; return head1; &#125; ListNode mergeHead = null; if(head1.val &lt; head2.val)&#123; mergeHead = head1; mergeHead.next = merge(head1.next,head2); &#125;else&#123; mergeHead = head2; mergeHead.next = merge(head1,head2.next); &#125; return mergeHead;&#125; 23.Merge k Sorted ListsMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 递归转化为已知问题，合并两个有序链表 123456789101112131415161718192021222324252627282930313233343536public ListNode mergeKLists(ListNode[] lists) &#123; return partition(lists,0,lists.length-1);&#125;public ListNode partition(ListNode[] lists,int start,int end) &#123; if(start == end)&#123; return lists[start]; &#125; if(start &lt; end)&#123; int middle = (start+end)/2; ListNode l1 = partition(lists,start,middle); ListNode l2 = partition(lists,middle+1,end); return merge(l1,l2); &#125;else&#123; return null; &#125;&#125;public ListNode merge(ListNode head1,ListNode head2) &#123; if(head1 == null)&#123; return head2; &#125; if(head2 == null)&#123; return head1; &#125; ListNode mergeHead = null; if(head1.val &lt; head2.val)&#123; mergeHead = head1; mergeHead.next = merge(head1.next,head2); &#125;else&#123; mergeHead = head2; mergeHead.next = merge(head1,head2.next); &#125; return mergeHead;&#125; 143.Reorder ListGiven a singly linked list L: L0?L1?…?Ln-1?Ln,reorder it to: L0?Ln?L1?Ln-1?L2?Ln-2?… For example,Given {1,2,3,4}, reorder it to {1,4,2,3}. You must do this in-place without altering the nodes’ values. 找到中心节点，将后半段链表反转变成一个新链表，再合并即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public void reorderList(ListNode head) &#123; if(head == null || head.next == null)&#123; return; &#125; ListNode pre = null; ListNode slower = head; ListNode faster = head; while(faster != null &amp;&amp; faster.next != null)&#123; pre = slower; slower = slower.next; faster = faster.next.next; &#125; pre.next = null; ListNode head2 = reverse(slower); merge(head,head2);&#125;public ListNode reverse(ListNode head) &#123; ListNode pre = null; ListNode cur = head; while(cur!=null)&#123; ListNode temp = cur.next; cur.next = pre; pre = cur; cur = temp; &#125; return pre;&#125;public void merge(ListNode h1,ListNode h2) &#123; while(h1 != null &amp;&amp; h1.next!=null)&#123; ListNode n1 = h1.next; ListNode n2 = h2.next; h1.next = h2; if(n1 == null)&#123; break; &#125; h2.next = n1; h1 = n1; h2 = n2; &#125;&#125; 2.Add Two NumbersYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 123456789101112131415161718192021222324public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(0); ListNode cur = dummy; ListNode p1 = l1; ListNode p2 = l2; int carry = 0; while(p1 != null || p2 != null)&#123; int x = p1 == null ? 0:p1.val; int y = p2 == null ? 0:p2.val; int sum = x + y + carry; carry = sum/10; cur.next = new ListNode(sum%10); cur = cur.next; if(p1 != null) p1 = p1.next; if(p2 != null) p2 = p2.next; &#125; if(carry &gt; 0)&#123; cur.next = new ListNode(carry); &#125; return dummy.next; &#125; 86.Partition ListGiven a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.给定一个单链表和数值x，划分链表使得所有小于x的节点排在大于等于x的节点之前。 You should preserve the original relative order of the nodes in each of the two partitions.你应该保留两部分内链表节点原有的相对顺序。 For example,Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5. 1234567891011121314151617181920212223public ListNode partition(ListNode head, int x) &#123; if(head == null || head.next == null)&#123; return head; &#125; ListNode leftDummy = new ListNode(0); ListNode rightDummy = new ListNode(0); ListNode left = leftDummy; ListNode right = rightDummy; while(head != null)&#123; if(head.val &lt; x)&#123; left.next = head; left = head; &#125;else&#123; right.next = head; right = head; &#125; head = head.next; &#125; right.next = null; left.next = rightDummy.next; return leftDummy.next; &#125; 138.Copy List with Random PointerA linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.Return a deep copy of the list. 浅拷贝是指源对象与拷贝对象共用一份实体，仅仅是引用的变量不同（名称不同）。对其中任何一个对象的改动都会影响另外一个对象。举个例子，一个人一开始叫张三，后来改名叫李四了，可是还是同一个人，不管是张三缺胳膊少腿还是李四缺胳膊少腿，都是这个人倒霉。 深拷贝是指源对象与拷贝对象互相独立，其中任何一个对象的改动都不会对另外一个对象造成影响。举个例子，一个人名叫张三，后来用他克隆（假设法律允许）了另外一个人，叫李四，不管是张三缺胳膊少腿还是李四缺胳膊少腿都不会影响另外一个人。 因此，本题转换为拷贝原链表为一个新链表，next，random都得符合 1234567891011121314151617181920212223242526/** * Definition for singly-linked list with a random pointer. * class RandomListNode &#123; * int label; * RandomListNode next, random; * RandomListNode(int x) &#123; this.label = x; &#125; * &#125;; */public RandomListNode copyRandomList(RandomListNode head) &#123; if(head == null)&#123; return null; &#125; Map&lt;RandomListNode,RandomListNode&gt; map = new HashMap&lt;RandomListNode,RandomListNode&gt;(); RandomListNode node = head; while(node != null)&#123; map.put(node,new RandomListNode(node.label)); node = node.next; &#125; node = head; while(node != null)&#123; map.get(node).next = map.get(node.next); map.get(node).random = map.get(node.random); node = node.next; &#125; return map.get(head);&#125; 445.Add Two Numbers II假定用一个链表表示两个数，其中每个节点仅包含一个数字。假设这两个数的数字顺序排列，请设计一种方法将两个数相加，并将其结果表现为链表的形式。 样例给出 6-&gt;1-&gt;7 + 2-&gt;9-&gt;5。即，617 + 295。返回 9-&gt;1-&gt;2。即，912 。 将链表放入栈操作，利用栈的特性，进行加法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; /* * @param l1: The first list. * @param l2: The second list. * @return: the sum list of l1 and l2. */ public ListNode addLists2(ListNode l1, ListNode l2) &#123; // write your code here Stack&lt;Integer&gt; s1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; s2 = new Stack&lt;Integer&gt;(); while(l1 != null)&#123; s1.push(l1.val); l1 = l1.next; &#125; while(l2 != null)&#123; s2.push(l2.val); l2 = l2.next; &#125; int sum = 0; ListNode cur = new ListNode(0); while(!s1.isEmpty()||!s2.isEmpty())&#123; if(!s1.isEmpty())&#123; sum += s1.pop(); &#125; if(!s2.isEmpty())&#123; sum += s2.pop(); &#125; cur.val = sum%10; ListNode head = new ListNode(sum/10); head.next = cur; cur = head; sum = sum/10; &#125; return cur.val == 0?cur.next:cur; &#125;&#125; LintCode交换链表当中两个节点给你一个链表以及两个权值v1和v2，交换链表中权值为v1和v2的这两个节点。保证链表中节点权值各不相同，如果没有找到对应节点，那么什么也不用做。 样例给出链表 1-&gt;2-&gt;3-&gt;4-&gt;null ，以及 v1 = 2 ， v2 = 4返回结果 1-&gt;4-&gt;3-&gt;2-&gt;null。 头节点，相邻情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; /* * @param head: a ListNode * @param v1: An integer * @param v2: An integer * @return: a new head of singly-linked list */ public ListNode swapNodes(ListNode head, int v1, int v2) &#123; // write your code here ListNode dummy = new ListNode(0); dummy.next = head; ListNode cur = dummy; ListNode p1 = null; ListNode p2 = null; while(cur.next != null)&#123; if(cur.next.val == v1)&#123; p1 = cur; &#125;else if(cur.next.val == v2)&#123; p2 = cur; &#125; cur = cur.next; &#125; if(p1 == null || p2 == null)&#123; return dummy.next; &#125; ListNode n1 = p1.next; ListNode n2 = p2.next; ListNode x1 = n1.next; ListNode x2 = n2.next; if(p1.next == p2)&#123; p1.next = n2; n2.next = n1; n1.next = x2; &#125;else if(p2.next == p1)&#123; p2.next = n1; n1.next = n2; n2.next = x1; &#125;else&#123; p1.next = n2; n2.next = x1; p2.next = n1; n1.next = x2; &#125; return dummy.next; &#125;&#125; 回文链表设计一种方式检查一个链表是否为回文链表。 样例1-&gt;2-&gt;1 就是一个回文链表。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; /* * @param head: A ListNode. * @return: A boolean. */ public boolean isPalindrome(ListNode head) &#123; // write your code here if(head == null || head.next == null)&#123; return true; &#125; ListNode slower = head; ListNode faster = head; while(faster.next != null &amp;&amp; faster.next.next != null)&#123; slower = slower.next; faster = faster.next.next; &#125; ListNode mid = slower; ListNode first = mid.next; ListNode cur = first.next; first.next = null; while(cur != null)&#123; ListNode tem = cur.next; cur.next = mid.next; mid.next = cur; cur = tem; &#125; slower = mid.next; faster = head; while(slower != null)&#123; if(faster.val != slower.val)&#123; return false; &#125; faster = faster.next; slower = slower.next; &#125; return true; &#125;&#125; 重排链表给定一个单链表L: L0→L1→…→Ln-1→Ln, 重新排列后为：L0→Ln→L1→Ln-1→L2→Ln-2→… 必须在不改变节点值的情况下进行原地操作。 样例给出链表 1-&gt;2-&gt;3-&gt;4-&gt;null，重新排列后为1-&gt;4-&gt;2-&gt;3-&gt;null。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Definition for ListNode. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int val) &#123; * this.val = val; * this.next = null; * &#125; * &#125; */public class Solution &#123; /* * @param head: The head of linked list. * @return: nothing */ public void reorderList(ListNode head) &#123; // write your code here if(head == null || head.next == null) return; ListNode p1 = head; ListNode p2 = head; while(p2.next != null &amp;&amp; p2.next.next != null)&#123; p1 = p1.next; p2 = p2.next.next; &#125; ListNode preM = p1; ListNode pre = p1.next; while(pre.next != null)&#123; ListNode cur = pre.next; pre.next = cur.next; cur.next = preM.next; preM.next = cur; &#125; p1 = head; p2 = preM.next; while(p1 != preM)&#123; preM.next = p2.next; p2.next = p1.next; p1.next = p2; p1 = p2.next; p2 = preM.next; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>算法</category>
        <category>刷题打卡</category>
      </categories>
      <tags>
        <tag>LinkedList</tag>
      </tags>
  </entry>
</search>
