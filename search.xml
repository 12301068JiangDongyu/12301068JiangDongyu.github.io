<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面试经验]]></title>
    <url>%2F2018%2F03%2F23%2F%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[搜狐汽车 介绍简历 问了String为什么是final的,Enum,数据库连接（左外，右外，内连接） 用栈实现队列(时间复杂度),数组找出只出现一次的元素(时间复杂度),手写快排 Java运行时的编译情况，大的项目是怎么编译的 Spring的文档什么的有没有看过 确定自己喜欢的是什么，有没有兴趣，自驱动能力 String为什么是final的？ 不可变final指不在原内存地址上修改数据，而是重新指向一个新对象，新地址 JDK源码，java.lang.String前三行 123456 public final class String implements java.io.Serializable,Comparable&lt;String&gt;,CharSequence&#123; /** String本质是个char数组，而且用final修饰*/ private final char[] value; &#125; Array可变，只是在后面的String的所有方法里没有动数组的元素，没有暴露内部成员。String不可变的关键都在底层实现，而不是一个final 不可变是为了安全 SQL四种连接 内联接（典型的联接运算，使用像 = 或 &lt;&gt; 之类的比较运算符）。包括相等联接和自然联接。内联接使用比较运算符根据每个表共有的列的值匹配两个表中的行。例如，检索 students和courses表中学生标识号相同的所有行。 外联接。外联接可以是左向外联接、右向外联接或完整外部联接。在 FROM子句中指定外联接时，可以由下列几组关键字中的一组指定： 1）LEFT JOIN或LEFT OUTER JOIN左向外联接的结果集包括 LEFT OUTER子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值。 2）RIGHT JOIN 或 RIGHT OUTER JOIN右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。 3）FULL JOIN 或 FULL OUTER JOIN完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。 交叉联接交叉联接返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉联接也称作笛卡尔积。 搜狐智能媒体研发中心 并发编程，能并发的数据结构 Springboot为什么能做到不配置一些xml？ 1.0版本的智慧教室会遇到哪些问题？并发？底层的哪些不够用了，才会出现这些问题？ JVM参数调优，怎么做？参数的意义？ HTTP要了解得更深入一些 服务器怎么判断是某个用户，用户登录的时候怎么返回该用户的信息，session怎么做安全？ MySQL建表的时候需要注意什么？long类型在mysql中怎么存？ Redis适合存一些什么样的数据？在什么场合使用？ Spring的IOC、AOP需要知道流程，Java基础，NIO等… 单链表反转，递归，非递归 蚂蚁金服一面 介绍项目，主要介绍在微软的实习，要注意项目讲得对方能理解 10亿条文件排序，外部归并，merge时堆内部排序 一堆运动员的成绩排序，如a:10,b:20,c:5，排序并保证新来的一个运动员也是有序的 用treemap, map底层怎么实现的，哈希表或红黑树 白板写代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//假设用一组字符串表示一个目录下的层级结构:// 如"dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"//表示的结构为// dir// subdir1// file1.ext// subsubdir1// subdir2// subsubdir2// file2.ext &#125; import java.util.ArrayList;import java.util.List;public class Main &#123; class Value&#123; public int i = 15; &#125; public static void main(String[] args) &#123; System.out.println(getLargestLength("dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext")); &#125; public static int getLargestLength(String str)&#123; int max = 0; if(str == null || str.length() == 0)&#123; return max; &#125; String arr [] = str.split("\n"); if(arr[0].contains("\t")) return -1; List&lt;Integer&gt; dirLength = new ArrayList&lt;&gt;(); dirLength.add(arr[0].length()); max = arr[0].length(); for (int i = 1; i &lt; arr.length; i++)&#123; int length = arr[i].replaceAll("\t", "").length(); int count = arr[i].length() - length; if (dirLength.size() &lt; count) &#123; //输入欠缺中间目录 return -1; &#125; else if (count == 0) &#123; //新的根目录 dirLength = null; &#125; else &#123; dirLength = dirLength.subList(0, count); &#125; dirLength.add(length + dirLength.get(count - 1)); if (dirLength.get(count) &gt; max)&#123; max = dirLength.get(count); &#125; &#125; return max; &#125;&#125; 二面 介绍项目 给一个二维数组代表会议室的预定时间区间，比如[1,2],[2,3],[1,3]，则最少需要的会议室的数量为2 贪心 转换为一个会议室利用率最高的问题，对开始时间排序，选择下一个开始时间离结束时间最近的 数学题，给1-5五个数字，全排列，[12345,12354,…,54312,54321],求中间两个数的差值 hiveql和sql是一样的么？不一样，举例说明，并说明理由 hiveql数据表的join,map reduce的过程？ 给一个整数数组[x1,x2…xi,…xn]，求X+Y+Z&lt;N的所有可能性，不能重复 3sum 的变体，先排序，外层循环，内层两个指针判断，如果和&gt; N-Z，则尾指针前移 HTTP怎么做到有状态？ 我们要实现的是一种web应用，实现这种应用的协议我们选择了http这种本质上是无状态的通信协议。但是事实上，我们需要我们的web应用是有状态的。所以我们加入了cookies、session等机制去实现由状态的web应用 Web应用=http协议+session、cookies等状态机制+其他辅助的机制 MySQL数据库引擎，innoDB的特点？别的引擎？ InnoDB：该存储引擎为MySQL表提供了ACID事务支持、系统崩溃修复能力和多版本并发控制（即MVCC Multi-Version Concurrency Control）的行级锁;该引擎支持自增长列（auto_increment）,自增长列的值不能为空，如果在使用的时候为空则自动从现有值开始增值，如果有但是比现在的还大，则直接保存这个值; 该引擎存储引擎支持外键（foreign key）,外键所在的表称为子表而所依赖的表称为父表。该引擎在5.5后的MySQL数据库中为默认存储引擎。 ISAM：该引擎在读取数据方面速度很快，而且不占用大量的内存和存储资源；但是ISAM不支持事务处理、不支持外来键、不能够容错、也不支持索引。该引擎在包括MySQL 5.1及其以上版本的数据库中不再支持。 MyISAM：该引擎基于ISAM数据库引擎，除了提供ISAM里所没有的索引和字段管理等大量功能，MyISAM还使用一种表格锁定的机制来优化多个并发的读写操作，但是需要经常运行OPTIMIZE TABLE命令，来恢复被更新机制所浪费的空间，否则碎片也会随之增加，最终影响数据访问性能。MyISAM还有一些有用的扩展，例如用来修复数据库文件的MyISAMChk工具和用来恢复浪费空间的 MyISAMPack工具。MyISAM强调了快速读取操作，主要用于高负载的select，这可能也是MySQL深受Web开发的主要原因：在Web开发中进行的大量数据操作都是读取操作，所以大多数虚拟主机提供商和Internet平台提供商（Internet Presence Provider，IPP）只允许使用MyISAM格式。 HEAP（也称为MEMORY）：该存储引擎通过在内存中创建临时表来存储数据。每个基于该存储引擎的表实际对应一个磁盘文件，该文件的文件名和表名是相同的，类型为.frm。该磁盘文件只存储表的结构，而其数据存储在内存中，所以使用该种引擎的表拥有极高的插入、更新和查询效率。这种存储引擎默认使用哈希（HASH）索引，其速度比使用B-+Tree型要快，但也可以使用B树型索引。由于这种存储引擎所存储的数据保存在内存中，所以其保存的数据具有不稳定性，比如如果mysqld进程发生异常、重启或计算机关机等等都会造成这些数据的消失，所以这种存储引擎中的表的生命周期很短，一般只使用一次。 CSV（Comma-Separated Values逗号分隔值）：使用该引擎的MySQL数据库表会在MySQL安装目录data文件夹中的和该表所在数据库名相同的目录中生成一个.CSV文件（所以，它可以将CSV类型的文件当做表进行处理），这种文件是一种普通文本文件，每个数据行占用一个文本行。该种类型的存储引擎不支持索引，即使用该种类型的表没有主键列；另外也不允许表中的字段为null。 小英的用户数据一台机器放不下的时候，怎么办？ 腾讯云一面 介绍项目 多线程的实现方式，线程的状态 new Thread / implements Runnable gc,什么时候gc，内存溢出 Java GC Linux指令，怎么查看内存线程使用情况 Mysql索引，group by &amp; union TCP的…四次挥手，为什么等待2MSL? 用过哪些大数据框架 怎么判断一棵二叉树是镜像的？ 层次遍历，每次取左子树左右结点，右子树右左结点，判断是否相同 栈实现O(1)获得最小的数getMin() 非常棒的一道题。原理很简单，但是需要思考清楚为什么可以。原理可以参考下图： 准备两个栈，一个正常栈，一个辅助栈，正常栈做pop和push。辅助栈push更新最小值，pop出正常栈的最小值。 过程很简单，当正常栈push的时候，查看辅助栈的栈顶元素，如果是比辅助栈栈顶还小或者等于，那么更新到栈顶。否则不加如辅助栈。 当正常栈做pop，查看辅助栈栈顶是否相等，相等的话一起pop，否则不动。 PS：注意当做push的时候，辅助栈栈顶元素和新元素相等，还是要入栈，因为再做pop把元素出栈后，正常栈其实后面还是有这个元素。 原理：其实就是类似动态规划的原理，辅助栈里的元素，全是到正常栈该元素位置的最小值是谁。所以除非正常栈做出栈弹出到这个值，否则辅助栈的栈顶就是当前的最小值。 1000瓶水，1瓶有毒，一只小白鼠喝了有毒的一周死亡，现给10只小白鼠一周时间，怎么做？ 二进制 标记 今日头条一面 自我介绍 给定一个结点，确定二叉树中序遍历的后继结点（结点有左指针，右指针，父亲指针） 判断是否有右子树，有就找右子树最左的结点 没有，则不断找父亲结点，直到当前结点是父亲结点的左孩子 介绍项目 hashmap的equals和hashcode方法，怎么判断key存在（底层） 首先hash(key)得到key的hashcode()，hashmap根据获得的hashcode找到要插入的位置所在的链，在这个链里面放的都是hashcode相同的Entry键值对，在找到这个链之后，会通过equals()方法判断是否已经存在要插入的键值对，而这个equals比较的其实就是key。 判断key是否存在的时候是先比较key的hashCode，再比较相等或equals的 Http的keep-alive长连接的特性，多个json怎么区分（content-length） 数据库事务的一致性 事务执行前与执行后数据内在的逻辑始终是成立的。比如转账前与转账后两人存款的总和始终不变。 腾讯一面 自我介绍 写hql 给定腾讯新闻数据，三个表 第一个表：腾讯新闻版面id，文章id 第二个表，浏览行为数据：时间戳，版面id，文章id 第三个表，评论行为数据：时间戳，版面id，文章id 求每天文章/版面的曝光 曝光 = 评论/浏览 求两个数组的交集 hashset 排序，再比较 微软Summer Intern一面 介绍azure table为什么能做到一个用户的数据在一台机器上 介绍datafactory入hive的过程，如果将copy和hive分开，怎么做？用socket？为什么websocket能做到双方发消息？ 多态是在编译时知道？还是运行时？ B extends A; A a = new A() 编译时 A a = new B() 运行时 给定一个正整数，求阶乘？ 越界？ 非递归？ n较小时 1234567public static long getNFactorial(int n)&#123; if(n==0)&#123; return 1l; &#125; return n*getNFactorial1(n-1);&#125;``` public static long getNFactorial1(int n){ if(n==0){ return 1l; } long sum=1l; for(int i=1;i&lt;=n;i++){ sum=sum*i; } return sum; } 12- n较大时 public static void getNFactorial(int n) { int num[] = new int[1000]; int i, j; if (n == 1 || n == 0) { System.out.println(1); } else { int p, h;// p 存放当前结果的位数，h为进位； p = 1; h = 0; num[1] = 1; for (i = 2; i &lt;= n; i++) { // 使得a[]的每位与i相乘 for (j = 1; j &lt;= p; j++) { num[j] = num[j] * i + h; h = num[j] / 10; num[j] = num[j] % 10; } // 表示向新的位置进位 while (h &gt; 0) { num[j] = h % 10; h = h / 10; j++; } p = j - 1; } for (i = p; i &gt;= 1; i--) { System.out.print(num[i]); } } }` 二面 2 Sum &amp; 3 Sum int parse(String str)的测试用例 为什么用azure？ 商汤Java实习生 Collections框架体系 HashSet的特性 基于HashMap实现 无序不重复 HashMap结构 哈希表，数组+链表 HashMap和ConcurrentHashMap区别 锁的了解 线程池有哪些？ 怎么实现线程？ 并发包… SpringBoot中@ReseController注解对应哪两个 @ResponseBody和@Controller的组合注解。 Redis支持哪些类型？ Strings Lists Sets 求交集、并集 Sorted Set hashes]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList]]></title>
    <url>%2F2017%2F09%2F30%2FLinkedList%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Leetcode83.Remove Duplicates from Sorted ListGiven a sorted linked list, delete all duplicates such that each element appear only once. For example,Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. 1234567891011121314public ListNode deleteDuplicates(ListNode head) &#123; if(head == null || head.next == null)&#123; return head; &#125; ListNode cur = head; while(cur.next != null)&#123; if(cur.val == cur.next.val)&#123; cur.next = cur.next.next; &#125;else&#123; cur = cur.next; &#125; &#125; return head; &#125; 82.Remove Duplicates from Sorted List IIGiven a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. For example,Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3. 1234567891011121314151617181920public ListNode deleteDuplicates(ListNode head) &#123; if(head == null || head.next == null)&#123; return head; &#125; ListNode dummy = new ListNode(0); dummy.next = head; ListNode cur = dummy; while(cur.next != null &amp;&amp; cur.next.next != null)&#123; if(cur.next.val == cur.next.next.val)&#123; int temp = cur.next.val; while(cur.next ！= null &amp;&amp; cur.next.val == temp)&#123; cur.next = cur.next.next; &#125; &#125;else&#123; cur = cur.next; &#125; &#125; return dummy.next; &#125; 147.Insertion Sort ListSort a linked list using insertion sort. 插入排序：两层循环，将数插入到已经排序的数组中合适的位置去 1234567891011121314151617181920/*Function to sort array using insertion sort*/ void sort(int arr[]) &#123; int n = arr.length; for (int i=1; i&lt;n; ++i) &#123; int key = arr[i]; int j = i-1; /* Move elements of arr[0..i-1], that are greater than key, to one position ahead of their current position */ while (j&gt;=0 &amp;&amp; arr[j] &gt; key) &#123; arr[j+1] = arr[j]; j = j-1; &#125; arr[j+1] = key; &#125; &#125; 链表的插入排序，同样两层循环，考虑到头指针也需要被排序，需要新增一个fakeHead。 链表的插入需要维护三个指针，pre，cur，next，pre始终指向有序链表的fakeHead，cur指向当前需要排序的节点，next指向下一个待排序的节点。 当有序链表为空或者pre.next所指向的元素的值比当前节点的值大时，需要将cur插入到pre.next之前的位置，否则，则将pre指针后移，最后返回fakeHead.next即可。 123456789101112131415161718public ListNode insertionSortList(ListNode head) &#123; if(head == null || head.next == null)&#123; return head; &#125; ListNode dummy = new ListNode(0); ListNode cur = head; while(cur != null)&#123; ListNode pre = dummy; ListNode next= cur.next; while(pre.next != null &amp;&amp; pre.next.val &lt; cur.val)&#123; pre = pre.next; &#125; cur.next = pre.next; pre.next = cur; cur = next; &#125; return dummy.next; &#125; 92.Reverse Linked List IIReverse a linked list from position m to n. Do it in-place and in one-pass. For example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL. Note:Given m, n satisfy the following condition:1 ≤ m ≤ n ≤ length of list. 指定位置的链表部分逆转，考虑到头指针也可能被逆转，新建fakeHead。 维护三个指针，pre永远指向m-1个位置的节点，start指向m位置的节点，then指向start.next 12345678910111213141516171819202122232425public ListNode reverseBetween(ListNode head, int m, int n) &#123; if(head == null)&#123; return null; &#125; ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; for(int i = 0;i &lt; m-1;i++)&#123; pre = pre.next; &#125; ListNode start = pre.next; ListNode then = start.next; for(int i = 0;i &lt; n-m ;i++)&#123; start.next = then.next; then.next = pre.next; pre.next = then; then = start.next; &#125; return dummy.next; &#125; 148.Sort ListSort a linked list in O(n log n) time using constant space complexity. 归并排序 123456789101112131415161718192021222324252627282930313233343536373839public ListNode sortList(ListNode head) &#123; if(head == null || head.next == null)&#123; return head; &#125; ListNode pre = head; ListNode slower = head; ListNode faster = head; while(faster !=null &amp;&amp; faster.next != null)&#123; pre = slower; slower = slower.next; faster = faster.next.next; &#125; pre.next = null; ListNode h1 = sortList(head); ListNode h2 = sortList(slower); return merge(h1,h2);&#125;public ListNode merge(ListNode head1,ListNode head2) &#123; if(head1 == null)&#123; return head2; &#125; if(head2 == null)&#123; return head1; &#125; ListNode mergeHead = null; if(head1.val &lt; head2.val)&#123; mergeHead = head1; mergeHead.next = merge(head1.next,head2); &#125;else&#123; mergeHead = head2; mergeHead.next = merge(head1,head2.next); &#125; return mergeHead;&#125; 23.Merge k Sorted ListsMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 递归转化为已知问题，合并两个有序链表 123456789101112131415161718192021222324252627282930313233343536public ListNode mergeKLists(ListNode[] lists) &#123; return partition(lists,0,lists.length-1);&#125;public ListNode partition(ListNode[] lists,int start,int end) &#123; if(start == end)&#123; return lists[start]; &#125; if(start &lt; end)&#123; int middle = (start+end)/2; ListNode l1 = partition(lists,start,middle); ListNode l2 = partition(lists,middle+1,end); return merge(l1,l2); &#125;else&#123; return null; &#125;&#125;public ListNode merge(ListNode head1,ListNode head2) &#123; if(head1 == null)&#123; return head2; &#125; if(head2 == null)&#123; return head1; &#125; ListNode mergeHead = null; if(head1.val &lt; head2.val)&#123; mergeHead = head1; mergeHead.next = merge(head1.next,head2); &#125;else&#123; mergeHead = head2; mergeHead.next = merge(head1,head2.next); &#125; return mergeHead;&#125; 143.Reorder ListGiven a singly linked list L: L0?L1?…?Ln-1?Ln,reorder it to: L0?Ln?L1?Ln-1?L2?Ln-2?… For example,Given {1,2,3,4}, reorder it to {1,4,2,3}. You must do this in-place without altering the nodes’ values. 找到中心节点，将后半段链表反转变成一个新链表，再合并即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public void reorderList(ListNode head) &#123; if(head == null || head.next == null)&#123; return; &#125; ListNode pre = null; ListNode slower = head; ListNode faster = head; while(faster != null &amp;&amp; faster.next != null)&#123; pre = slower; slower = slower.next; faster = faster.next.next; &#125; pre.next = null; ListNode head2 = reverse(slower); merge(head,head2);&#125;public ListNode reverse(ListNode head) &#123; ListNode pre = null; ListNode cur = head; while(cur!=null)&#123; ListNode temp = cur.next; cur.next = pre; pre = cur; cur = temp; &#125; return pre;&#125;public void merge(ListNode h1,ListNode h2) &#123; while(h1 != null &amp;&amp; h1.next!=null)&#123; ListNode n1 = h1.next; ListNode n2 = h2.next; h1.next = h2; if(n1 == null)&#123; break; &#125; h2.next = n1; h1 = n1; h2 = n2; &#125;&#125; 2.Add Two NumbersYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 123456789101112131415161718192021222324public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(0); ListNode cur = dummy; ListNode p1 = l1; ListNode p2 = l2; int carry = 0; while(p1 != null || p2 != null)&#123; int x = p1 == null ? 0:p1.val; int y = p2 == null ? 0:p2.val; int sum = x + y + carry; carry = sum/10; cur.next = new ListNode(sum%10); cur = cur.next; if(p1 != null) p1 = p1.next; if(p2 != null) p2 = p2.next; &#125; if(carry &gt; 0)&#123; cur.next = new ListNode(carry); &#125; return dummy.next; &#125; 86.Partition ListGiven a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.给定一个单链表和数值x，划分链表使得所有小于x的节点排在大于等于x的节点之前。 You should preserve the original relative order of the nodes in each of the two partitions.你应该保留两部分内链表节点原有的相对顺序。 For example,Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5. 1234567891011121314151617181920212223public ListNode partition(ListNode head, int x) &#123; if(head == null || head.next == null)&#123; return head; &#125; ListNode leftDummy = new ListNode(0); ListNode rightDummy = new ListNode(0); ListNode left = leftDummy; ListNode right = rightDummy; while(head != null)&#123; if(head.val &lt; x)&#123; left.next = head; left = head; &#125;else&#123; right.next = head; right = head; &#125; head = head.next; &#125; right.next = null; left.next = rightDummy.next; return leftDummy.next; &#125; 138.Copy List with Random PointerA linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.Return a deep copy of the list. 浅拷贝是指源对象与拷贝对象共用一份实体，仅仅是引用的变量不同（名称不同）。对其中任何一个对象的改动都会影响另外一个对象。举个例子，一个人一开始叫张三，后来改名叫李四了，可是还是同一个人，不管是张三缺胳膊少腿还是李四缺胳膊少腿，都是这个人倒霉。 深拷贝是指源对象与拷贝对象互相独立，其中任何一个对象的改动都不会对另外一个对象造成影响。举个例子，一个人名叫张三，后来用他克隆（假设法律允许）了另外一个人，叫李四，不管是张三缺胳膊少腿还是李四缺胳膊少腿都不会影响另外一个人。 因此，本题转换为拷贝原链表为一个新链表，next，random都得符合 1234567891011121314151617181920212223242526/** * Definition for singly-linked list with a random pointer. * class RandomListNode &#123; * int label; * RandomListNode next, random; * RandomListNode(int x) &#123; this.label = x; &#125; * &#125;; */public RandomListNode copyRandomList(RandomListNode head) &#123; if(head == null)&#123; return null; &#125; Map&lt;RandomListNode,RandomListNode&gt; map = new HashMap&lt;RandomListNode,RandomListNode&gt;(); RandomListNode node = head; while(node != null)&#123; map.put(node,new RandomListNode(node.label)); node = node.next; &#125; node = head; while(node != null)&#123; map.get(node).next = map.get(node.next); map.get(node).random = map.get(node.random); node = node.next; &#125; return map.get(head);&#125; 445.Add Two Numbers II假定用一个链表表示两个数，其中每个节点仅包含一个数字。假设这两个数的数字顺序排列，请设计一种方法将两个数相加，并将其结果表现为链表的形式。 样例给出 6-&gt;1-&gt;7 + 2-&gt;9-&gt;5。即，617 + 295。返回 9-&gt;1-&gt;2。即，912 。 将链表放入栈操作，利用栈的特性，进行加法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; /* * @param l1: The first list. * @param l2: The second list. * @return: the sum list of l1 and l2. */ public ListNode addLists2(ListNode l1, ListNode l2) &#123; // write your code here Stack&lt;Integer&gt; s1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; s2 = new Stack&lt;Integer&gt;(); while(l1 != null)&#123; s1.push(l1.val); l1 = l1.next; &#125; while(l2 != null)&#123; s2.push(l2.val); l2 = l2.next; &#125; int sum = 0; ListNode cur = new ListNode(0); while(!s1.isEmpty()||!s2.isEmpty())&#123; if(!s1.isEmpty())&#123; sum += s1.pop(); &#125; if(!s2.isEmpty())&#123; sum += s2.pop(); &#125; cur.val = sum%10; ListNode head = new ListNode(sum/10); head.next = cur; cur = head; sum = sum/10; &#125; return cur.val == 0?cur.next:cur; &#125;&#125; LintCode交换链表当中两个节点给你一个链表以及两个权值v1和v2，交换链表中权值为v1和v2的这两个节点。保证链表中节点权值各不相同，如果没有找到对应节点，那么什么也不用做。 样例给出链表 1-&gt;2-&gt;3-&gt;4-&gt;null ，以及 v1 = 2 ， v2 = 4返回结果 1-&gt;4-&gt;3-&gt;2-&gt;null。 头节点，相邻情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; /* * @param head: a ListNode * @param v1: An integer * @param v2: An integer * @return: a new head of singly-linked list */ public ListNode swapNodes(ListNode head, int v1, int v2) &#123; // write your code here ListNode dummy = new ListNode(0); dummy.next = head; ListNode cur = dummy; ListNode p1 = null; ListNode p2 = null; while(cur.next != null)&#123; if(cur.next.val == v1)&#123; p1 = cur; &#125;else if(cur.next.val == v2)&#123; p2 = cur; &#125; cur = cur.next; &#125; if(p1 == null || p2 == null)&#123; return dummy.next; &#125; ListNode n1 = p1.next; ListNode n2 = p2.next; ListNode x1 = n1.next; ListNode x2 = n2.next; if(p1.next == p2)&#123; p1.next = n2; n2.next = n1; n1.next = x2; &#125;else if(p2.next == p1)&#123; p2.next = n1; n1.next = n2; n2.next = x1; &#125;else&#123; p1.next = n2; n2.next = x1; p2.next = n1; n1.next = x2; &#125; return dummy.next; &#125;&#125; 回文链表设计一种方式检查一个链表是否为回文链表。 样例1-&gt;2-&gt;1 就是一个回文链表。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; /* * @param head: A ListNode. * @return: A boolean. */ public boolean isPalindrome(ListNode head) &#123; // write your code here if(head == null || head.next == null)&#123; return true; &#125; ListNode slower = head; ListNode faster = head; while(faster.next != null &amp;&amp; faster.next.next != null)&#123; slower = slower.next; faster = faster.next.next; &#125; ListNode mid = slower; ListNode first = mid.next; ListNode cur = first.next; first.next = null; while(cur != null)&#123; ListNode tem = cur.next; cur.next = mid.next; mid.next = cur; cur = tem; &#125; slower = mid.next; faster = head; while(slower != null)&#123; if(faster.val != slower.val)&#123; return false; &#125; faster = faster.next; slower = slower.next; &#125; return true; &#125;&#125; 重排链表给定一个单链表L: L0→L1→…→Ln-1→Ln, 重新排列后为：L0→Ln→L1→Ln-1→L2→Ln-2→… 必须在不改变节点值的情况下进行原地操作。 样例给出链表 1-&gt;2-&gt;3-&gt;4-&gt;null，重新排列后为1-&gt;4-&gt;2-&gt;3-&gt;null。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Definition for ListNode. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int val) &#123; * this.val = val; * this.next = null; * &#125; * &#125; */public class Solution &#123; /* * @param head: The head of linked list. * @return: nothing */ public void reorderList(ListNode head) &#123; // write your code here if(head == null || head.next == null) return; ListNode p1 = head; ListNode p2 = head; while(p2.next != null &amp;&amp; p2.next.next != null)&#123; p1 = p1.next; p2 = p2.next.next; &#125; ListNode preM = p1; ListNode pre = p1.next; while(pre.next != null)&#123; ListNode cur = pre.next; pre.next = cur.next; cur.next = preM.next; preM.next = cur; &#125; p1 = head; p2 = preM.next; while(p1 != preM)&#123; preM.next = p2.next; p2.next = p1.next; p1.next = p2; p1 = p2.next; p2 = preM.next; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm and Data Structure</category>
      </categories>
      <tags>
        <tag>LinkedList</tag>
      </tags>
  </entry>
</search>
