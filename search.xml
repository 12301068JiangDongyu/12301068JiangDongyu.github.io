<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>第一个不重复的字符串</title>
      <link href="/2018/09/05/%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2018/09/05/%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<h2 id="第一个不重复的字符串"><a href="#第一个不重复的字符串" class="headerlink" title="第一个不重复的字符串"></a>第一个不重复的字符串</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给一个很长的字符串，但是都由26个字母组成，返回一个长度为10的第一个与后面不重复的字符串</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>逐个遍历，利用String自带的contains方法判断</li><li>利用hashmap，空间换时间<ul><li>key: 长度为10的字符串，value: 保存字符串起始位置的list</li><li>两个指针去做</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getFirstSubString</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(str.length() &lt; <span class="number">10</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Map&lt;String,List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= str.length() - <span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(str.substring(low+i,low+<span class="number">10</span>+i)))&#123;</span><br><span class="line">                map.put(str.substring(low+i,low+<span class="number">10</span>+i),<span class="keyword">new</span> ArrayList&lt;&gt;(low+i));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.get(str.substring(low+i,low+<span class="number">10</span>+i)).add(low+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String s: map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(s).size() == <span class="number">1</span>)&#123;</span><br><span class="line">                min = Math.min(min,map.get(s).get(<span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.substring(min,min+<span class="number">10</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 算法 </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二叉搜索树转换成双向链表</title>
      <link href="/2018/09/04/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E6%88%90%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2018/09/04/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E6%88%90%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h2 id="二叉搜索树转换成双向链表"><a href="#二叉搜索树转换成双向链表" class="headerlink" title="二叉搜索树转换成双向链表"></a>二叉搜索树转换成双向链表</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul><li>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。</li><li>要求不能创建任何新的结点，只能调整树中结点指针的指向。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>中续遍历</li><li>根节点的左指针指向左子树形成链表的最后一个节点</li><li>根节点的右指针指向右子树形成链表的第一个节点</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">         TreeNode left = Convert(root.left);</span><br><span class="line">         TreeNode p = left;</span><br><span class="line">         <span class="keyword">while</span>(p != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">             p = p.right;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(left != <span class="keyword">null</span>)&#123;</span><br><span class="line">             p.right = root;</span><br><span class="line">             root.left = p;</span><br><span class="line">         &#125;</span><br><span class="line">         TreeNode right = Convert(root.right);</span><br><span class="line">         <span class="keyword">if</span>(right != <span class="keyword">null</span>)&#123;</span><br><span class="line">             root.right = right;</span><br><span class="line">             right.left = root;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> left == <span class="keyword">null</span> ? root:left;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 算法 </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java锁机制</title>
      <link href="/2018/07/31/Java%E9%94%81%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/07/31/Java%E9%94%81%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>在开发Java多线程应用程序中，各个线程之间由于要共享资源，必须用到锁机制。Java提供了多种多线程锁机制的实现方式，常见的有synchronized、ReentrantLock、Semaphore、AtomicInteger等。每种机制都有优缺点与各自的适用场景，必须熟练掌握他们的特点才能在Java多线程应用开发时得心应手。——<a href="http://blog.jiangdongyu.space/2018/07/30/%E5%B8%B8%E7%94%A8%E9%94%81%E6%9C%BA%E5%88%B6%E7%AE%80%E4%BB%8B/">Java锁机制详解</a></p><a id="more"></a><p>线程同步有关的类图关系可用以下的图总结：</p><p><img src="http://p9fh1pach.bkt.clouddn.com/1042141-20180119085622974-1501528059.jpg" alt="avatar"></p><ol><li>Java Concurrency API 中的 Lock 接口是什么？对比同步它有什么优势？</li></ol><p>Lock接口比同步方法和同步块（这里的同步就是考察Synchronized关键字）提供了更具扩展性的锁操作。Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性，Lock是一个类，通过这个类可以实现同步访问；他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。它的优势有：可以使锁更<strong>公平</strong>；可以使线程在等待锁的时候<strong>响应中断</strong>；可以让线程<strong>尝试获取锁</strong>，并在无法获取锁的时候立即返回或者等待一段时间；可以在不同的范围，以不同的顺序获取和释放锁。</p><p>关于API及代码的例子请移步：《<a href="https://www.cnblogs.com/dolphin0520/p/3923167.html" target="_blank" rel="noopener">java并发编程Lock</a>》。常用接口方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先<strong>lock()</strong>方法是平常使用得最多的一个方法，就是用来<strong>获取锁</strong>。如果锁已被其他线程获取，则进行等待。由于在前面讲到如果采用Lock，必须<strong>主动</strong>去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用Lock来进行同步的话，是以下面这种形式去使用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//处理任务</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">     </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();   <span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>tryLock()</strong>方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line"><span class="keyword">if</span>(lock.tryLock()) &#123;</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="comment">//处理任务</span></span><br><span class="line">     &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">         </span><br><span class="line">     &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">         lock.unlock();   <span class="comment">//释放锁</span></span><br><span class="line">     &#125; </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果不能获取锁，则直接做其他事情</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>lockInterruptibly()</strong>方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。由于lockInterruptibly()的声明中抛出了异常，所以lock.lockInterruptibly()必须放在try块中或者在调用lockInterruptibly()的方法外声明抛出InterruptedException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">     <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock，意思是“可重入锁”，ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。以下给出一个ReentrantLock的运行实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();    <span class="comment">//注意这个地方，声明为类的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         <span class="comment">//可以用Java箭头函数特性改写上述冗余代码：</span></span><br><span class="line">         <span class="comment">// new Thread()&#123;()-&gt;Thread.currentThread&#125;.start();</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"得到了锁"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                arrayList.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"释放了锁"</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文中提到了Lock接口以及对象，使用它，很优雅的控制了竞争资源的安全访问，但是这种锁不区分读写，称这种锁为普通锁。为了提高性能，Java提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。Java中读写锁有个接口java.util.concurrent.locks. ReadWriteLock，也有具体的实现ReentrantReadWriteLock，因而会有下面的提问：</p><ol start="2"><li>ReadWriteLock是什么？</li></ol><p>读写锁：分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm自己控制的，我们只要上好相应的锁即可。如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁；如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！读写锁接口：<strong>ReadWriteLock</strong>，它的具体实现类为：<strong>ReentrantReadWriteLock</strong>。</p><p>《<a href="https://www.cnblogs.com/liang1101/p/6475555.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">ReadWriteLock场景应用</a>》：在多线程的环境下，对同一份数据进行读写，会涉及到线程安全的问题。比如在一个线程读取数据的时候，另外一个线程在写数据，而导致前后数据的不一致性；一个线程在写数据的时候，另一个线程也在写，同样也会导致线程前后看到的数据的不一致性。这时候可以在读写方法中加入互斥锁，任何时候只能允许一个线程的一个读或写操作，而不允许其他线程的读或写操作，这样是可以解决这样以上的问题，但是效率却大打折扣了。因为在真实的业务场景中，一份数据，读取数据的操作次数通常高于写入数据的操作，而线程与线程间的读读操作是不涉及到线程安全的问题，没有必要加入互斥锁，只要在读-写，写-写期间上锁就行了。</p><ol start="3"><li>锁机制有什么用</li></ol><p>有些业务逻辑在执行过程中要求对数据进行<strong>排他性</strong>的访问，于是需要通过一些机制保证在此过程中数据被锁住不会被外界修改，这就是所谓的锁机制。</p><ol start="4"><li>什么是乐观锁（Optimistic Locking）？如何实现乐观锁？如何避免ABA问题</li></ol><p>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于<strong>多读</strong>的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。</p><ol start="5"><li>解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁</li></ol><p><strong>重入锁（ReentrantLock）</strong>是一种递归无阻塞的同步机制。重入锁，也叫做递归锁，指的是同一线程外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，但不受影响。在JAVA环境下 ReentrantLock 和synchronized 都是可重入锁。</p><p><strong>自旋锁</strong>，由于自旋锁使用者一般保持锁时间非常短，因此选择自旋而不是睡眠是非常必要的，自旋锁的效率远高于互斥锁。如何旋转呢？何为自旋锁，就是如果发现锁定了，不是睡眠等待，而是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时 才能进入临界区。</p><p><strong>偏向锁</strong>(Biased Locking)是Java6引入的一项多线程优化，它会偏向于<strong>第一个访问锁的线程</strong>，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。</p><p><strong>轻量级锁</strong>是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁。</p><p><strong>公平锁</strong>，就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己</p><p><strong>非公平锁</strong>比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。</p><ol start="6"><li>什么时候应该使用可重入锁？</li></ol><p>场景1：如果已加锁，则不再重复加锁。a、忽略重复加锁。b、用在界面交互时点击执行较长时间请求操作时，防止多次点击导致后台重复执行（忽略重复触发）。以上两种情况多用于进行非重要任务防止重复执行，（如：清除无用临时文件，检查某些资源的可用性，数据备份操作等）</p><p>场景2：如果发现该操作已经在执行，则尝试等待一段时间，等待超时则不执行（尝试等待执行）这种其实属于场景2的改进，等待获得锁的操作有一个时间的限制，如果超时则放弃执行。用来防止由于资源处理不当长时间占用导致死锁情况（大家都在等待资源，导致线程队列溢出）。</p><p>场景3：如果发现该操作已经加锁，则等待一个一个加锁（同步执行，类似synchronized）这种比较常见大家也都在用，主要是防止资源使用冲突，保证同一时间内只有一个操作可以使用该资源。但与synchronized的明显区别是性能优势（伴随jvm的优化这个差距在减小）。同时Lock有更灵活的锁定方式，公平锁与不公平锁，而synchronized永远是公平的。这种情况主要用于对资源的争抢（如：文件操作，同步消息发送，有状态的操作等）</p><p>场景4：可中断锁。synchronized与Lock在默认情况下是不会响应中断(interrupt)操作，会继续执行完。lockInterruptibly()提供了可中断锁来解决此问题。（场景3的另一种改进，没有超时，只能等待中断或执行完毕）这种情况主要用于取消某些操作对资源的占用。如：（取消正在同步运行的操作，来防止不正常操作长时间占用造成的阻塞）</p><ol start="7"><li>简述锁的等级方法锁、对象锁、类锁</li></ol><p><strong>方法锁</strong>（synchronized修饰方法时）通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。synchronized 方法控制对类成员变量的访问： 每个类实例对应一把锁，每个 synchronized 方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态，从而有效避免了类成员变量的访问冲突。</p><p><strong>对象锁</strong>（synchronized修饰方法或代码块）当一个对象中有synchronized method或synchronized block的时候调用此对象的同步方法或进入其同步区域时，就必须先获得对象锁。如果此对象的对象锁已被其他调用者占用，则需要等待此锁被释放。（方法锁也是对象锁）。java的所有对象都含有1个互斥锁，这个锁由JVM自动获取和释放。线程进入synchronized方法的时候获取该对象的锁，当然如果已经有线程获取了这个对象的锁，那么当前线程会等待；synchronized方法正常返回或者抛异常而终止，JVM会自动释放对象锁。这里也体现了用synchronized来加锁的1个好处，方法抛异常的时候，锁仍然可以由JVM来自动释放。　</p><p><strong>类锁</strong>(synchronized修饰<strong>静态</strong>的方法或代码块)，由于一个class不论被实例化多少次，其中的静态方法和静态变量在内存中都只有一份。所以，一旦一个静态的方法被申明为synchronized。此类所有的实例化对象在调用此方法，共用同一把锁，我们称之为类锁。对象锁是用来控制实例方法之间的同步，类锁是用来控制静态方法（或静态变量互斥体）之间的同步。类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别的。java类可能会有很多个对象，但是只有1个Class对象，也就是说类的不同实例之间共享该类的Class对象。Class对象其实也仅仅是1个java对象，只不过有点特殊而已。由于每个java对象都有1个互斥锁，而类的静态方法是需要Class对象。所以所谓的类锁，不过是Class对象的锁而已。获取类的Class对象有好几种，最简单的就是［类名.class］的方式。</p><ol start="8"><li>Java中活锁和死锁有什么区别？</li></ol><p>死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。死锁发生的<strong>四个条件</strong></p><ul><li>互斥条件：线程对资源的访问是<strong>排他性</strong>的，如果一个线程对占用了某资源，那么其他线程必须处于等待状态，直到资源被释放。</li><li>请求和保持条件：线程T1至少已经保持了一个资源R1占用,但又提出对另一个资源R2请求，而此时，资源R2被其他线程T2占用，于是该线程T1也必须等待，但又对自己保持的资源R1不释放。</li><li>不剥夺条件：线程已获得的资源，在未使用完之前，不能被其他线程剥夺，只能在使用完以后由自己释放。</li><li>环路等待条件：在死锁发生时，必然存在一个“进程-资源环形链”，即：{p0,p1,p2,…pn},进程p0（或线程）等待p1占用的资源，p1等待p2占用的资源，pn等待p0占用的资源。（最直观的理解是，p0等待p1占用的资源，而p1而在等待p0占用的资源，于是两个进程就相互等待）</li></ul><p><strong>活锁</strong>：是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。</p><ol start="9"><li>如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？</li></ol><p>预防死锁，预先破坏产生死锁的四个条件。互斥不可能破坏，所以有如下3种方法：</p><ul><li>破坏，请求和保持条件<ul><li>进程等所有要请求的资源都空闲时才能申请资源，这种方法会使资源严重浪费（有些资源可能仅在运行初期或结束时才使用，甚至根本不使用）</li><li>允许进程获取初期所需资源后，便开始运行，运行过程中再逐步释放自己占有的资源。比如有一个进程的任务是把数据复制到磁盘中再打印，前期只需要获得磁盘资源而不需要获得打印机资源，待复制完毕后再释放掉磁盘资源。这种方法比上一种好，会使资源利用率上升。</li></ul></li><li>破坏，不可抢占条件。这种方法代价大，实现复杂</li><li>破坏，循坏等待条件。对各进程请求资源的顺序做一个规定，避免相互等待。这种方法对资源的利用率比前两种都高，但是前期要为设备指定序号，新设备加入会有一个问题，其次对用户编程也有限制</li></ul><ol start="10"><li>死锁与饥饿的区别？</li></ol><p><strong>相同点</strong>：二者都是由于竞争资源而引起的。</p><p><strong>不同点</strong>：</p><ul><li>从进程状态考虑，死锁进程都处于等待状态，忙等待(处于运行或就绪状态)的进程并非处于等待状态，但却可能被饿死；</li><li>死锁进程等待永远不会被释放的资源，饿死进程等待会被释放但却不会分配给自己的资源，表现为等待时限没有上界(排队等待或忙式等待)；</li><li>死锁一定发生了循环等待，而饿死则不然。这也表明通过资源分配图可以检测死锁存在与否，但却不能检测是否有进程饿死；</li><li>死锁一定涉及多个进程，而饥饿或被饿死的进程可能只有一个。</li><li>在饥饿的情形下，系统中有至少一个进程能正常运行，只是饥饿进程得不到执行机会。而死锁则可能会最终使整个系统陷入死锁并崩溃</li></ul><ol start="11"><li>怎么检测一个线程是否拥有锁？</li></ol><p>java.lang.Thread中有一个方法叫<strong>holdsLock()</strong>，它返回true如果当且仅当当前线程拥有某个具体对象的锁</p><ol start="12"><li>如何实现分布式锁？</li></ol><ul><li>基于数据库实现分布式锁</li><li>基于缓存（redis，memcached，tair）实现分布式锁</li><li>基于Zookeeper实现分布式锁</li></ul><p>可以参考详情《<a href="http://www.hollischuang.com/archives/1716" target="_blank" rel="noopener">分布式锁的几种实现方式</a>》、《<a href="https://www.cnblogs.com/rwxwsblog/p/6046034.html" target="_blank" rel="noopener">分布式锁的3种方式</a>》</p><ol start="13"><li>Executors类是什么？ Executor和Executors的区别</li></ol><p>正如上面所说，这三者均是 Executor 框架中的一部分。Java 开发者很有必要学习和理解他们，以便更高效的使用 Java 提供的不同类型的线程池。总结一下这三者间的区别，以便大家更好的理解：</p><ul><li>Executor 和 ExecutorService 这两个接口主要的区别是：ExecutorService 接口继承了 Executor 接口，是 Executor 的子接口</li><li>Executor 和 ExecutorService 第二个区别是：Executor 接口定义了 execute()方法用来接收一个Runnable接口的对象，而 ExecutorService 接口中的 submit()方法可以接受Runnable和Callable接口的对象。</li><li>Executor 和 ExecutorService 接口第三个区别是 Executor 中的 execute() 方法不返回任何结果，而 ExecutorService 中的 submit()方法可以通过一个 Future 对象返回运算结果。</li><li>Executor 和 ExecutorService 接口第四个区别是除了允许客户端提交一个任务，ExecutorService 还提供用来控制线程池的方法。比如：调用 shutDown() 方法终止线程池。可以通过 《Java Concurrency in Practice》 一书了解更多关于关闭线程池和如何处理 pending 的任务的知识。</li><li>Executors 类提供工厂方法用来创建不同类型的线程池。比如: newSingleThreadExecutor() 创建一个只有一个线程的线程池，newFixedThreadPool(int numOfThreads)来创建固定线程数的线程池，newCachedThreadPool()可以根据需要创建新的线程，但如果已有线程是空闲的会重用已有线程。</li></ul><table><thead><tr><th style="text-align:left">Executor</th><th style="text-align:left">ExecutorService</th></tr></thead><tbody><tr><td style="text-align:left">Executor 是 Java 线程池的核心接口，用来并发执行提交的任务</td><td style="text-align:left">ExecutorService 是 Executor 接口的扩展，提供了异步执行和关闭线程池的方法</td></tr><tr><td style="text-align:left">提供execute()方法用来提交任务</td><td style="text-align:left">提供submit()方法用来提交任务</td></tr><tr><td style="text-align:left">execute()方法无返回值</td><td style="text-align:left">submit()方法返回Future对象，可用来获取任务执行结果</td></tr><tr><td style="text-align:left">不能取消任务</td><td style="text-align:left">可以通过Future.cancel()取消pending中的任务</td></tr><tr><td style="text-align:left">没有提供和关闭线程池有关的方法</td><td style="text-align:left">提供了关闭线程池的方法</td></tr></tbody></table><ol start="14"><li>什么是Java线程转储(Thread Dump)，如何得到它？</li></ol><p>线程转储是一个JVM活动线程的列表，它对于分析系统瓶颈和死锁非常有用。</p><p>有很多方法可以获取线程转储——使用Profiler，Kill -3命令，jstack工具等等。我更喜欢jstack工具，因为它容易使用并且是JDK自带的。由于它是一个基于终端的工具，所以我们可以编写一些脚本去定时的产生线程转储以待分析。</p><ol start="15"><li>如何在Java中获取线程堆栈？</li></ol><p>Java虚拟机提供了线程转储（thread dump）的后门，通过这个后门可以把线程堆栈打印出来。通常我们将堆栈信息重定向到一个文件中，便于我们分析，由于信息量太大，很可能超出控制台缓冲区的最大行数限制造成信息丢失。这里介绍一个jdk自带的打印线程堆栈的工具，jstack用于打印出给定的Java进程ID或core file或远程调试服务的Java堆栈信息。（<a href="https://blog.csdn.net/weiweicao0429/article/details/53185999" target="_blank" rel="noopener">Java问题定位之Java线程堆栈分析</a>）</p><pre><code>示例：$jstack –l 23561 &gt;&gt; xxx.dump命令 : $jstack [option] pid &gt;&gt; 文件 </code></pre><p>>&gt;表示输出到文件尾部，实际运行中，往往一次dump的信息，还不足以确认问题，建议产生三次dump信息，如果每次dump都指向同一个问题，我们才确定问题的典型性。</p><ol start="16"><li>说出 3 条在 Java 中使用线程的最佳实践</li></ol><ul><li>给你的线程起个有意义的名字。这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor这种名字比Thread-1. Thread-2 and Thread-3好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。</li><li>避免锁定和缩小同步的范围锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。</li><li>多用同步类少用wait和notify，首先，CountDownLatch, Semaphore, CyclicBarrier和Exchanger这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。</li><li>多用并发集合少用同步集合，这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap。</li></ul>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java多线程基础</title>
      <link href="/2018/07/30/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/07/30/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>在一个程序中，能够独立运行的程序片段叫做“线程”，利用它进行编写的程序叫做多线程处理程序。通常情况下，多线程程序能够更好低利用计算机资源，提高程序执行的效率。多线程编程具有重要的意义，每个程序猿都应该掌握。</p><a id="more"></a><p><a href="http://www.cnblogs.com/hanganglin/articles/3517178.html" target="_blank" rel="noopener">本文原文链接</a></p><h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><ul><li>新建状态：用Thread的new语句创建了线程对象，此时对象只在堆内存中分配了内存。</li><li>就绪状态：当新建状态下的线程对象调用了start()方法后，该线程就进入了就绪状态，处于这个状态的线程位于可运行池中，等待获得CPU使用权。</li><li>运行状态：正在被CPU执行的线程状态。</li><li>阻塞状态：当线程因为某种原因处于阻塞状态时，JVM不会给线程分配CPU，直到线程重新进入就绪状态，才有机会被CPU运行。<ul><li>位于对象<strong>等待池</strong>中的阻塞状态：当线程运行获取对象锁后，执行了Object.wait()方法，JVM就会把该线程加入对象的等待池中，这种状态必须等待其他线程调用同个对象的notify()或notifyAll()方法时才有可能激活为就绪状态；</li><li>位于<strong>对象锁</strong>中的阻塞状态：当线程运行时，试图获取某个对象的同步锁时，如果该对象的同步锁已被其他线程占用，则JVM就会把当前线程放入对象的锁池中，当对象的同步锁被释放后，JVM就会根据一定的调度算法，将处于对象锁中阻塞状态的某个线程激活为就绪状态；</li><li>其他阻塞状态：当线程执行了sleep()方法，或者调用了其他线程的join()方法，或发出了I/O请求时，线程就会进入这个状态。</li></ul></li></ul><h2 id="Java创建多线程的几种方式"><a href="#Java创建多线程的几种方式" class="headerlink" title="Java创建多线程的几种方式"></a>Java创建多线程的几种方式</h2><p>Java通过线程类Thread来创建多线程，每个线程是Thread类或其子类的实例对象，每个对象描述了一个单独的线程。Java中创建一个线程，有两种实现方法，详细介绍如下。</p><h3 id="通过继承Thread类创建线程（了解即可，不常用）"><a href="#通过继承Thread类创建线程（了解即可，不常用）" class="headerlink" title="通过继承Thread类创建线程（了解即可，不常用）"></a>通过继承Thread类创建线程（了解即可，不常用）</h3><ul><li>通过这种方式创建的线程之间是彼此相互独立的，各自有用自己的资源，互不干扰。</li><li><strong>缺点</strong>：<ul><li>Java是单继承的，继承Thead类后不能继承其他类，可能不满足开发需求；</li><li>多线程之间无法共享资源。</li></ul></li></ul><h3 id="通过实现Runnable接口创建线程（推荐使用）"><a href="#通过实现Runnable接口创建线程（推荐使用）" class="headerlink" title="通过实现Runnable接口创建线程（推荐使用）"></a>通过实现Runnable接口创建线程（推荐使用）</h3><p>通过继承Thread类创建的多线程可以满足非协同工作的多线程需求，但当要求各个线程之间需要处理共享资源时，只能通过实现Runnable接口的方式。</p><p><strong>优点</strong>：</p><ul><li>避免了Java但继承带来的局限性；</li><li>多线程之间可以共享资源，相互协作。</li></ul><h3 id="通过FutureTask类创建带返回值的线程（需要获得线程返回值时使用）"><a href="#通过FutureTask类创建带返回值的线程（需要获得线程返回值时使用）" class="headerlink" title="通过FutureTask类创建带返回值的线程（需要获得线程返回值时使用）"></a>通过FutureTask类创建带返回值的线程（需要获得线程返回值时使用）</h3><p>FutureTask是一种可以取消的异步的计算任务。它的计算是通过Callable实现的，它等价于<strong>可以携带返回值的Runnable</strong>。</p><p>FutureTask是为了弥补Thread的不足而设计的，它可以让程序员准确地知道线程什么时候执行完成并获得到线程执行完成后返回的结果（如果有需要）。</p><p><strong>FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果</strong></p><h3 id="通过TimerTask类创建计划任务类线程"><a href="#通过TimerTask类创建计划任务类线程" class="headerlink" title="通过TimerTask类创建计划任务类线程"></a>通过TimerTask类创建计划任务类线程</h3><p>Timer和TimerTask是用来创建定时任务，定时任务实质就是一个线程。TimerTask继承了Runnable接口，通过Timer启动计划任务入口有schedule和scheduleAtFixedRate两种方法。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>Java语言的关键字，用它来修饰一个方法或一个代码块的时候，能够保证在同一个时刻最多只有一个线程执行该段代码，可保证修饰的代码在执行过程中不会被其他线程干扰，即<strong>原子性</strong>。</p><h3 id="synchronized可修饰的对象"><a href="#synchronized可修饰的对象" class="headerlink" title="synchronized可修饰的对象"></a>synchronized可修饰的对象</h3><ul><li>synchronized {普通方法}<ul><li>同一时间只能有一个线程访问<strong>同一个对象</strong>的该方法。</li><li>缺点：同步整个方法<strong>效率不高</strong>。 </li><li>synchronized void method() { … }相当于void method( synchronized(this) { … } )</li></ul></li><li>synchronized {代码块}<ul><li>对代码块执行线程同步，效率要高于对整个函数执行同步，<strong>推荐</strong>使用这种方法。</li></ul></li><li>synchronized {static方法}<ul><li>加锁的对象是<strong>类</strong>，同一时间，该类的所有对象中的synchronized static方法只能有一个线程访问。 </li><li>class Foo { public synchronized static fun(){…}}等价于在class Foo { public static fun(){ synchronized(Foo.class){ … } }}</li></ul></li><li>synchronized {run方法}：此时为同步普通方法的特殊情况，由于在线程的整个生命期内run方法一直在运行，因此<strong>同一个Runnable对象的多个线程只能串行运行</strong>。 </li></ul><h3 id="使用synchronized应重点理解以下细节："><a href="#使用synchronized应重点理解以下细节：" class="headerlink" title="使用synchronized应重点理解以下细节："></a>使用synchronized应重点理解以下细节：</h3><ul><li>当多个并发线程访问同一个对象的同步代码块时，一段时间内只能有一个线程得到执行，其他线程必须等待当前线程执行完代码块后再执行代码；</li><li>当一个线程访问一个对象的同步代码块时，其他线程可以访问该对象的中的非同步代码块；</li><li><strong>当一个线程访问一个对象的同步代码块时，其他线程对该对象中的所有同步代码块均不能访问</strong></li></ul><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal主要用来更方便地访问线程内部变量，提供了保持对象的方法和避免参数传递的方便的对象访问方式。查阅了网上很多资料，大都观点说ThreadLocal是用来解决多线程共享对象的访问问题的，对此，本人完全不赞同，这压根就是两码事。当线程调用ThreadLocal.set()方法时，具体的值是保存在线程内部的ThreadLocal.ThreadLocalMap对象中，也就是说，每个线程设值的变量都只限于本线程访问，对于其他线程是隔离的，这与线程同步完全是两码事。</p><p>假设三个打印机进程共享一台打印机资源，通常我们使用同步方法（如synchronized、Lock等）来对打印机进行同步操作，这是为了解决多线程下的安全问题。使用ThreadLocal，相当于增加了两台打印机资源，给每个打印进程分配了一台打印机。</p><p>因此，<strong>ThreadLocal不是用来解决对象共享访问问题的，也不是为线程提供共享变量的副本，而仅仅是为线程隔离对象</strong>。</p><p>此外，线程的数据是保存在线程内部的变量中的，而非保存在ThreadLocal对象中，ThreadLocal的get与set方法可以直接操作线程Thread内部ThreadLocal.ThreadLocalMap对象。在ThreadLocal.ThreadLocalMap中保存了一个Entry数组，通过ThreadLocal对象作为数组下标操作数据。</p><p>在ThreadLocal.ThreadLocalMap中，使用了弱引用WeakReference，避免了内存泄露。</p><p>多线程共享一个数据库连接等适用，为每个线程单独建立一个连接资源。</p><h2 id="线程其他常用操作方法"><a href="#线程其他常用操作方法" class="headerlink" title="线程其他常用操作方法"></a>线程其他常用操作方法</h2><p>1、Object.wait()、Object.notify()和Object.notifyAll()</p><p>Object.wait是指线程在获取对象锁后，由于某些条件的不成立，主动<strong>释放对象锁</strong>，同时本线程进入对象等待池中处于阻塞状态。在synchronized同步块中，一旦线程捕获某个对象的同步锁，系统就很难控制线程，必须等待线程主动释放对象锁，这时候，在同步块内，使用Object.wait()可以使线程在进入synchronized同步块后主动释放对象锁。因此Object.wait()、Object.notify()和Object.notifyAll()方法<strong>必须在synchronized同步块内使用</strong>，否则会抛出IllegalMonitorStateException异常。</p><ul><li>Object.wait() ：线程调用此方法后，只有当其他线程调用同个对象的notify()或notifyAll()方法后，才可能激活为就绪状态；</li><li>Object.wait(long timeout) ：线程调用此方法后，当其他线程调用同个对象的notify()或notifyAll()方法，<strong>或者超过时间timeout</strong>，线程都可能激活为就绪状态。</li></ul><p>当其他线程调用Object.notify()后，JVM会根据调度策略调取一个对象等待池中的线程，将其从阻塞状态激活为就绪状态，当此线程<strong>再次获得对象锁和CPU后</strong>，就可以进入执行状态。</p><p>方法Object.notify()和方法Object.notifyAll()用于将处于wait等待状态的线程激活为就绪状态，notify()是根据调度策略激活某一个线程，notifyAll()是将所有处于等待线程池中的线程全部激活为就绪状态，但是激活后就绪状态的线程要想重新执行，必须再次获得对象锁。 </p><p>2、Thread.sleep(long millis)和Thread.yield()</p><p>这两个方法都会让当前正在执行的线程处于<strong>暂时停止执行</strong>的状态，交出CPU的使用权一段时间。与Object.wait()方法不同的是，Thread.sleep(long millis)和Thread.yield()在暂停线程的同时<strong>不会释放已获得的对象锁</strong>，而Object.wait()会暂停线程并且释放对象锁。</p><p>两者的<strong>区别</strong>如下：</p><ul><li>Thread.sleep方法必须带一个时间参数，单位毫秒，当线程执行sleep后，在指定时间内，将转为<strong>阻塞</strong>状态；Thread.yield方法不带参数，当线程执行yield后，线程将进入<strong>就绪</strong>状态。</li><li>Thread.sleep会抛出InterruptedException异常，而Thread.yield方法不会抛出异常。</li><li>sleep()方法比yield()方法具有更好的移植性。</li><li>sleep()方法会给其他线程运行的机会，而不考虑其他线程的优先级，因此会给较低线程一个运行的机会；yield()方法只会给相同优先级或者更高优先级的线程一个运行的机会。</li></ul><p>实际上，yield()方法对应了如下操作： </p><p>先检测当前是否有<strong>相同优先级</strong>的线程处于同可运行状态，如有，则把 CPU 的占有权交给此线程，否则继续运行原来的线程。所以yield()方法称为“<strong>退让</strong>”，它把运行机会让给了同等优先级的其他线程。yield()只是提前结束当前线程占用CPU的时间，线程转为就绪状态，等待下一个时间片再继续获得CPU并执行。</p><p>3、Thread.join()</p><p>Thread.join()可以将多线程的异步变为同步，在父线程调用子线程的join方法后，必须等待子线程执行结束，父线程才会继续执行下去。Thread.join()方法会抛出InterruptedException异常。</p><p>4、volatile关键字</p><p>volatile是synchronized的一种弱实现，它可以保证变量的<strong>可见性</strong>，而不能保证程序执行的原子性。JVM运行多线程时，在主内存中保存着共享变量，每个线程运行时有一个自己的栈，用来保存从本线程运行需要的变量。当线程访问一个变量值的时候，首先通过对象的引用找到在主内存的地址，然后把变量的值拷贝到本线程的栈中，建立一个变量的副本。在线程对该变量计算的过程中，该变量副本和主内存的原始变量就没有任何关系了，当线程结算结束时，再将变量副本写回到主内存中对象变量的地址中，更新内存中的共享变量，详细的交互过程如下图所示。</p><p><img src="http://p9fh1pach.bkt.clouddn.com/191326344702.jpg" alt="avatar"></p><p>使用volatile修饰的变量，JVM只能保证从主内存加载到线程工作栈中的值是最新的，但使用过程不能完全保证线程对该变量同步的情况，因此，建议少使用volatile，对需要同步的地方使用synchronized。</p><p>5、Thread.start()和Thread.run() </p><p><strong>启动线程应该使用Thread.start()，Thread.run()只是调用Runnable中的run方法，并没有启动线程，此时整个程序还是只有一个线程，顺序执行。</strong></p><p>6、Thread.setDaemon()设置守护线程</p><p>Java中有两类线程，分别是用户线程(User Thread)和守护线程(Daemon Thread)。守护线程是指在程序运行时后台提供一种通用服务的线程，如垃圾回收线程就是一个守护线程，当所有的非守护线程结束时，程序也就终止了，同时会结束所有的守护进程。用户线程和守护线程唯一的区别就是，当程序中只剩守护线程时，程序就会结束，而只要程序中还存在一个非守护线程，程序就不会终止。</p><ul><li>普通线程转换为守护线程。Thread.SetDaemon(true)可以将普通线程转换为守护线程，但是设置必须在Thread.start()之前，否则会报IllegalThreadStateException异常。</li><li>Daemon线程产生的子线程也是Daemon的。</li><li>守护线程应该永远不去访问固有资源，如文件和数据库等，因为他可能随时会中断。</li></ul><p>7、<a href="http://jiangzhengjun.iteye.com/blog/652269" target="_blank" rel="noopener">Thread.interrput()中断线程</a></p><p>调用线程的Thread.interrupt方法中断线程时，JVM将会将对应线程内的中断状态位设置为true，可以在线程执行的方法中调用Thread.interrupted()或Thread.currentThread().isInterrupted()来检测中断位是否为true，至于线程下一步是死亡还是继续执行完全取决于程序本身，这一点与强制结束线程的已废弃的方法stop不同。</p><p>当其他线程通过Thread.interrupt请求中断当前线程时，当前线程可能正处于非阻塞状态、阻塞状态或请求锁临时状态，下面来分析各种状态下如何来中断当前线程。</p><ul><li>被请求中断时，当前线程处于非阻塞状态。<ul><li>此时可以在程序中调用方法获取线程内中断状态位的值，并根据该值自由决定是否结束当前线程。获取中断位值建议有两种方法:</li><li>Thread.currentThread().isInterrupted()方法，返回状态值</li><li>Thread.interrupted()静态方法，返回状态值，<strong>并将中断位状态值重置为false</strong>。也就是说，此时若调用两次Thread.interrupted()方法，第二次方法返回值为false。因此<strong>建议使用方法Thread.currentThread().isInterrupted()来获取中断位状态值</strong>，常见线程循环时的中断方式如下所示：</li><li>另一种实现方式-使用中断信号量(共享变量)中断非阻塞状态线程也是一种很受欢迎的方式，其实笔者认为，这种方式与使用Thread.interrupt来实现中断的内部机理是一样的。</li></ul></li></ul><pre><code>while(!Thread.currentThread().isInterrupted() &amp;&amp; more work to do){      do more work  } </code></pre><ul><li>被请求中断时，当前线程处于阻塞状态。 <ul><li>对于由于调用Object.wait()、Thread.sleep()或Thread.join()等方式而处于阻塞状态的线程，被请求中断时会<strong>抛出异常InterruptException</strong>，使当前线程从阻塞状态激活进入异常代码块，便于结束。注意，在抛出异常InterruptException后，中断状态位会被重置为false，因此<strong>在使用Thread.currentThread().isInterrupted()检测循环是否中断的代码块内，若捕捉到此异常，必须将状态位重新设置为true，否则线程循环将永不停止。</strong><ul><li>对由于请求I/O操作而处于阻塞状态的线程，被请求中断时，I/O通道会立即被关闭，并抛出异常ClosedByInterruptException，处理方式与上述一致。</li><li>被请求中断时，当前线程正处于获取锁的过程中，这时候线程是无法响应中断的，也就是说，<strong>当线程采用synchronized争夺锁资源而发生死锁时，使用Thread.interrupt是无法使线程中断的。补充一点，当使用Lock锁并且通过方法lockInterruptibly()设置响应中断锁时，线程可以被中断</strong>。</li></ul></li></ul></li></ul><p>8、TimeUnit枚举工具</p><p>TimeUnit是一个枚举，可以使用它来简化某些操作，如让线程休眠5分钟，可以写成：TimeUnit.MINUTES.sleep(5)，相当于Thread.sleep(5*60*1000)，时间会在TimeUnit内部自动转化。</p><p>9、Condition.await()、Condition.signal()和Condition.signalAll()</p><p>同Object.wait()、Object.notify()和Object.notifyAll()对应功能一致，Object的方法用于synchronized同步块中，而Condition的方法用于ReentrantLock的lock()与unlock()之间。</p><p>可用Reentrant.newCondition()来产生一个新的Condition。</p>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java锁机制简介</title>
      <link href="/2018/07/30/%E5%B8%B8%E7%94%A8%E9%94%81%E6%9C%BA%E5%88%B6%E7%AE%80%E4%BB%8B/"/>
      <url>/2018/07/30/%E5%B8%B8%E7%94%A8%E9%94%81%E6%9C%BA%E5%88%B6%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>在开发Java多线程应用程序中，各个线程之间由于要共享资源，必须用到锁机制。Java提供了多种多线程锁机制的实现方式，常见的有<strong>synchronized、ReentrantLock、Semaphore、AtomicInteger</strong>等。每种机制都有优缺点与各自的适用场景，必须熟练掌握他们的特点才能在Java多线程应用开发时得心应手。</p><a id="more"></a><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>几乎每一个Java开发人员都认识synchronized，使用它来实现多线程的同步操作是非常简单的，只要在需要同步的对方的方法、类或代码块中加入该关键字，它能够保证在同一个时刻最多只有一个线程执行同一个对象的同步代码，可保证修饰的代码在执行过程中不会被其他线程干扰。使用synchronized修饰的代码具有<strong>原子性和可见性</strong>，在需要进程同步的程序中使用的频率非常高，可以满足一般的进程同步要求（详见《<a href="http://blog.jiangdongyu.space/2018/07/30/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">Java多线程基础</a>》）。</p><p><strong>synchronized实现的机理依赖于软件层面上的JVM</strong>，因此其性能会随着Java版本的不断升级而提高。事实上，在Java1.5中，synchronized是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。到了Java1.6，synchronized进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的Java1.7与1.8中，均对该关键字的实现机理做了优化。</p><p>需要说明的是，<strong>当线程通过synchronized等待锁时是不能被Thread.interrupt()中断的</strong>，因此程序设计时必须检查确保合理，否则可能会造成线程死锁的尴尬境地。</p><p>最后，尽管Java实现的锁机制有很多种，并且有些锁机制性能也比synchronized高，但还是强烈推荐在多线程应用程序中使用该关键字，因为实现方便，后续工作由JVM来完成，可靠性高。只有在确定锁机制是当前多线程程序的性能瓶颈时，才考虑使用其他机制，如ReentrantLock等。</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>可重入锁，顾名思义，这个锁可以被线程多次重复进入进行获取操作。ReentantLock继承接口Lock并实现了接口中定义的方法，除了能完成synchronized所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。</p><p><strong>Lock实现的机理依赖于特殊的CPU指定</strong>，可以认为不受JVM的约束，并可以通过其他语言平台来完成底层的实现。在并发量较小的多线程应用程序中，ReentrantLock与synchronized性能相差无几，但在高并发量的条件下，synchronized性能会迅速下降几十倍，而ReentrantLock的性能却能依然维持一个水准，因此我们建议在<strong>高并发量</strong>情况下使用ReentrantLock。</p><p>ReentrantLock引入两个概念：<strong>公平锁与非公平锁</strong>。<strong>公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁。反之，JVM按随机、就近原则分配锁的机制则称为不公平锁</strong>。ReentrantLock在构造函数中提供了是否公平锁的初始化方式，默认为非公平锁。这是因为，非公平锁实际执行的效率要远远超出公平锁，除非程序有特殊需要，否则最常用非公平锁的分配机制。</p><p>ReentrantLock通过方法lock()与unlock()来进行加锁与解锁操作，与synchronized会被JVM自动解锁机制不同，ReentrantLock加锁后需要手动进行解锁。为了避免程序出现异常而无法正常解锁的情况，使用ReentrantLock必须在finally控制块中进行解锁操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">try &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    //...进行任务操作</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们详细介绍有关ReentrantLock提供的<strong>可响应中断锁、可轮询锁请求、定时锁</strong>等机制与操作方式。</p><p>1、线程在等待资源过程中需要中断</p><p>ReentrantLock的在<strong>获取锁的过程</strong>中有2种锁机制，<strong>忽略中断锁</strong>和<strong>响应中断锁</strong>。当等待线程A或其他线程尝试中断线程A时，忽略中断锁机制则不会接收中断，而是继续处于等待状态；响应中断锁则会处理这个中断请求，并将线程A由阻塞状态唤醒为就绪状态，不再请求和等待资源。</p><p><strong>lock.lock()</strong>可设置锁机制为忽略中断锁，<strong>lock.lockInterruptibly()</strong>可设置锁机制为响应中断锁。</p><p>ReentrantLock.lockInterruptibly()方法可设置线程在<strong>获取锁的时候</strong>响应其他线程对当前线程发出的中断请求。但必须注意，<strong>此处响应中断锁是指正在获取锁的过程中，如果线程此时并非处于获取锁的状态，通过此方法设置是无法中断线程的</strong>，非阻塞状态可根据中断标记位Thread.currentThread().isInterrupted()在程序中手动设置中断，阻塞状态可通过抛出异常InterruptedException来中断线程，详细可参考博文《<a href="http://blog.jiangdongyu.space/2018/07/30/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">Java多线程基础</a>》。</p><p>2、实现可轮询的锁请求</p><p>在synchronized中，一旦发生死锁，唯一能够恢复的办法只能重新启动程序，唯一的预防方法是在设计程序时考虑完善不要出错。而有了Lock以后，死锁问题就有了新的预防办法，它提供了<strong>tryLock()</strong>轮询方法来获得锁，如果锁可用则获取锁，如果锁不可用，则此方法返回false，并不会为了等待锁而阻塞线程，这极大地降低了死锁情况的发生。典型使用语句如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line"><span class="keyword">if</span>(lock.tryLock())&#123;</span><br><span class="line">    <span class="comment">//锁可用，则成功获取锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取锁后进行处理</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//锁不可用，其他处理方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、定时锁请求</p><p>在synchronized中，一旦发起锁请求，该请求就不能停止了，如果不能获得锁，则当前线程会阻塞并等待获得锁。在某些情况下，你可能需要让线程在一定时间内去获得锁，如果在指定时间内无法获取锁，则让线程放弃锁请求，转而执行其他的操作。Lock就提供了定时锁的机制，使用<strong>Lock.tryLock(long timeout, TimeUnit unit)</strong>来指定让线程在timeout单位时间内去争取锁资源，如果超过这个时间仍然不能获得锁，则放弃锁请求，定时锁可以避免线程陷入死锁的境地。</p><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>上述两种锁机制类型都是“互斥锁”，学过操作系统的都知道，互斥是进程同步关系的一种特殊情况，相当于只存在一个临界资源，因此同时最多只能给一个线程提供服务。但是，在实际复杂的多线程应用程序中，可能存在多个临界资源，这时候我们可以借助Semaphore信号量来完成多个临界资源的访问。</p><p>Semaphore基本能完成ReentrantLock的所有工作，使用方法也与之类似，通过acquire()与release()方法来获得和释放临界资源。经实测，<strong>Semaphone.acquire()方法默认为可响应中断锁</strong>，与ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被Thread.interrupt()方法中断。</p><p>此外，Semaphore也实现了可轮询的锁请求与定时锁的功能，除了方法名tryAcquire与tryLock不同，其使用方法与ReentrantLock几乎一致。Semaphore也提供了公平与非公平锁的机制，也可在构造函数中进行设定。</p><p>Semaphore的锁释放操作也由手动进行，因此与ReentrantLock一样，为避免线程因抛出异常而无法正常释放锁的情况发生，<strong>释放锁的操作也必须在finally代码块中完成</strong>。</p><p>Semaphore支持多个临界资源，而ReentrantLock只支持一个临界资源，笔者认为ReentrantLock是Semaphore的一种特殊情况。</p><h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><p>首先说明，此处AtomicInteger是一系列相同类的代表之一，常见的还有AtomicLong、AtomicLong等，他们的实现原理相同，区别在与运算对象类型的不同。令人兴奋地，还可以通过<strong>AtomicReference<v></v></strong>将一个对象的所有操作转化成原子操作。</p><p>我们知道，在多线程程序中，诸如++i 或 i++等运算不具有原子性，是不安全的线程操作之一。通常我们会使用synchronized将该操作变成一个原子操作，但JVM为此类操作特意提供了一些同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger的性能是ReentantLock的好几倍。</p>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>揭秘Spring AOP</title>
      <link href="/2018/07/26/%E6%8F%AD%E7%A7%98Spring%20AOP/"/>
      <url>/2018/07/26/%E6%8F%AD%E7%A7%98Spring%20AOP/</url>
      <content type="html"><![CDATA[<p>AOP要解决的问题：分离功能性需求和非功能性需求</p><p><strong>使用场景</strong></p><ul><li>权限控制</li><li>缓存控制</li><li>事务控制</li><li>审计日志</li><li>性能监控</li></ul><h3 id="切面表达式"><a href="#切面表达式" class="headerlink" title="切面表达式"></a>切面表达式</h3><ul><li>designators指示器，描述通过什么方式去匹配类的哪些方法</li><li>Wildcards通配符</li><li>operators运算符</li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/aop1.png" alt="avatar"></p><p><img src="http://p9fh1pach.bkt.clouddn.com/aop2.png" alt="avatar"></p><ul><li>within表达式</li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/aop3.png" alt="avatar"></p><p><img src="http://p9fh1pach.bkt.clouddn.com/aop4.png" alt="avatar"></p><p><img src="http://p9fh1pach.bkt.clouddn.com/aop5.png" alt="avatar"></p><p><img src="http://p9fh1pach.bkt.clouddn.com/aop6.png" alt="avatar"></p><ul><li>execution表达式</li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/aop7.png" alt="avatar"></p><p>?表示可以省略</p><ul><li>advice注解<br><img src="http://p9fh1pach.bkt.clouddn.com/aop8.png" alt="avatar"></li></ul>]]></content>
      
      <categories>
          
          <category> JavaWeb </category>
          
          <category> Spring </category>
          
          <category> AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis</title>
      <link href="/2018/07/26/Redis/"/>
      <url>/2018/07/26/Redis/</url>
      <content type="html"><![CDATA[<h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><p>为什么需要NoSQL？</p><ul><li>高并发读写</li><li>海量数据的高效率存储与访问</li><li>高可扩展性和高可用性</li></ul><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul><li>应用场景<ul><li>缓存</li><li>任务队列</li><li>应用排行榜</li><li>网站访问统计</li><li>数据过期处理</li><li>分布式集群架构中的session分离</li></ul></li><li>数据类型<ul><li>String</li><li>List：rpoplpush</li><li>Set</li><li>Hash</li><li>Sorted Set </li></ul></li><li>持久化<ul><li>RDB：定时内存快照，在指定的时间间隔写入硬盘</li><li>AOF：将以日志，记录每一个操作，服务器启动后就构建数据库，修改同步</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> 数据库基础 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>菜鸟二面</title>
      <link href="/2018/07/24/%E8%8F%9C%E9%B8%9F%E4%BA%8C%E9%9D%A2/"/>
      <url>/2018/07/24/%E8%8F%9C%E9%B8%9F%E4%BA%8C%E9%9D%A2/</url>
      <content type="html"><![CDATA[<p>还是聊了半个小时- -</p><a id="more"></a><ul><li>介绍学习、实习、项目情况</li><li>介绍影响最深、提升能力最快的项目</li><li>问一些相对比较难的题</li><li>SpringBoot和Spring的区别<ul><li>SpringBoot是在Spring上的快速开发包</li><li>SpringBoot内嵌了一些容器，比如tomcat</li><li>问内嵌的tomcat和不内嵌的有什么区别？内嵌的无需部署war文件</li></ul></li><li>MyBatis和Hibernate有什么区别？<ul><li>MyBatis半自动，Hibernate全自动</li><li>Hibernate为什么能实现全自动？</li><li>通过对象关系模型来实现对数据库的操作，并且拥有完整的JavaBean对象来自动拼装SQL语句。</li></ul></li><li>问觉得阿里和微软的区别</li><li>给了些建议- -</li></ul>]]></content>
      
      <categories>
          
          <category> 面试经历 </category>
          
          <category> 2018 </category>
          
          <category> 秋招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>79. Word Search</title>
      <link href="/2018/07/24/79.%20Word%20Search/"/>
      <url>/2018/07/24/79.%20Word%20Search/</url>
      <content type="html"><![CDATA[<p>Given a 2D board and a word, find if the word exists in the grid.</p><p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><a id="more"></a><p><strong>Example:</strong></p><pre><code>board =[  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]Given word = &quot;ABCCED&quot;, return true.Given word = &quot;SEE&quot;, return true.Given word = &quot;ABCB&quot;, return false.</code></pre><p><strong>思路：</strong><br>还算是比较明显的dfs的题。</p><ul><li>首先需要找到word首字母的位置，才能接着判断</li><li>接下来就是递归的过程，上下左右都有可能</li><li>同时为了避免当前再被递归到，需要将当前值先修改再恢复</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word == <span class="keyword">null</span> || word.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="keyword">null</span> || board.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; board.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; board[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == word.charAt(<span class="number">0</span>) &amp;&amp; exists(board, word, i, j, <span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(<span class="keyword">char</span>[][] board, String word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word.length() == start) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; board.length &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; board[<span class="number">0</span>].length &amp;&amp; board[i][j] == word.charAt(start))&#123;</span><br><span class="line">            board[i][j] = <span class="string">'$'</span>;</span><br><span class="line">            <span class="keyword">boolean</span> res = exists(board, word, i-<span class="number">1</span>, j, start+<span class="number">1</span>) || exists(board, word, i+<span class="number">1</span>, j, start+<span class="number">1</span>) || exists(board, word, i, j-<span class="number">1</span>, start+<span class="number">1</span>) || exists(board, word, i, j+<span class="number">1</span>, start+<span class="number">1</span>);</span><br><span class="line">            board[i][j] = word.charAt(start);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 算法 </category>
          
          <category> 刷题打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> BackTracking </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第四范式</title>
      <link href="/2018/07/19/%E7%AC%AC%E5%9B%9B%E8%8C%83%E5%BC%8F/"/>
      <url>/2018/07/19/%E7%AC%AC%E5%9B%9B%E8%8C%83%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>第四范式 Java 开发实习生 面试</p><a id="more"></a><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ul><li>自我介绍</li><li>介绍一下项目</li><li>Exception &amp;&amp; Error      </li><li>synchronized关键字static修饰和没有static修饰<ul><li>比如synchronized修饰方法，让循环输出1-10，new两个类，调用该线程</li><li>作用域不同，static修饰指同步类，输出两次1-10</li><li>非static修饰，是同步局部变量，不能确定结果</li></ul></li><li>final修饰字段，方法，类<ul><li>字段不可变</li><li>方法不可override</li><li>类不能被继承</li></ul></li><li>String,StringBuilder,StringBuffer <ul><li>String不可变，源码是用final修饰的private数组，同时方法等没改变数组的值</li><li>StringBuilder，StringBuffer都可变，StringBuffer线程安全</li></ul></li><li>ArrayList和LinkedList<ul><li>同：实现List接口</li><li>异：ArrayList查 O(1),增删 O(n)</li><li>LinkedList查 O(n),增删 O(1)</li></ul></li><li>知不知道Dequeue?</li><li>实现最小栈GetMin()<ul><li>leetcode原题155.Min Stack</li></ul></li></ul><p><strong>Q: Exception &amp;&amp; Error</strong></p><p><img src="http://p9fh1pach.bkt.clouddn.com/20160603151809323.jpeg" alt="avatar"></p><p>A: Error和Exception都继承自<strong>Throwable</strong>；</p><p><strong>Exception：</strong></p><blockquote><p>RuntimeException 类及其子类表示“JVM 常用操作”引发的错误</p></blockquote><ul><li>可以是可被控制（checked）或者不可控制（unchecked）；<ul><li>unchecked exception（非检查异常）: 运行时异常,比如常见的NullPointerException、IndexOutOfBoundsException。对于运行时异常，java编译器<strong>不要求</strong>必须进行异常捕获处理或者抛出声明，由程序员自行决定。</li><li>checked exception（检查异常，编译异常）: 非运行时异常,java编译器<strong>强制</strong>程序员必须进行捕获处理，比如常见的IOExeption和SQLException。对于非运行时异常如果不进行捕获或者抛出声明处理，编译都不会通过。</li></ul></li><li>表示一个由<strong>程序员</strong>导致的错误；</li><li>应该在应用程序级被处理；</li></ul><p><strong>Error：</strong></p><blockquote><p>大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。</p></blockquote><ul><li>总是不可控制的（unchecked）；</li><li>经常用来表示<strong>系统错误或者底层资源</strong>错误；</li><li>如果可能的话，应该在系统级被捕捉；</li></ul><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ul><li>自我介绍</li><li>项目介绍比较详细</li><li>问了下熟悉的技术</li></ul>]]></content>
      
      <categories>
          
          <category> 面试经历 </category>
          
          <category> 2018 </category>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTPS通信过程</title>
      <link href="/2018/07/19/HTTPS%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/07/19/HTTPS%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取。所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。</p><a id="more"></a><h3 id="HTTPS简介"><a href="#HTTPS简介" class="headerlink" title="HTTPS简介"></a>HTTPS简介</h3><p>HTTPS其实是有两部分组成：<strong>HTTP + SSL / TLS</strong>，也就是在HTTP上又加了一层<strong>处理加密信息的模块</strong>。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。具体是如何进行加密，解密，验证的，且看下图。</p><p><img src="http://p9fh1pach.bkt.clouddn.com/20121130144420002.png" alt="avatar"></p><ul><li>客户端发起HTTPS请求<ul><li>这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。</li></ul></li><li>服务端的配置<ul><li>采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对<strong>公钥和私钥</strong>。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</li></ul></li><li>传送证书<ul><li>这个证书其实就是<strong>公钥</strong>，只是包含了很多信息，如证书的颁发机构，过期时间等等。</li></ul></li><li>客户端解析证书<ul><li>这部分工作是有客户端的TLS来完成的，首先会<strong>验证公钥是否有效</strong>，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就<strong>生成一个随机值</strong>。然后用*8证书对该随机值进行加密**。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</li></ul></li><li>传送加密信息<ul><li>这部分<strong>传送的是用证书加密后的随机值</strong>，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</li></ul></li><li>服务段解密信息<ul><li>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行<strong>对称加密</strong>。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</li></ul></li><li>传输加密后的信息<ul><li>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原</li></ul></li><li>客户端解密信息<ul><li>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> HTTPS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>菜鸟一面</title>
      <link href="/2018/07/19/%E8%8F%9C%E9%B8%9F%E4%B8%80%E9%9D%A2/"/>
      <url>/2018/07/19/%E8%8F%9C%E9%B8%9F%E4%B8%80%E9%9D%A2/</url>
      <content type="html"><![CDATA[<p>说了下午有事，就简单聊了半个小时</p><a id="more"></a><ul><li>为什么要用多线程</li><li>线程是不是越多效率越快？</li><li>怎么控制线程，尽可能减少上下文切换？或者说有没有一种方式达到了多线程的效果，但是避免了上下文切换？<ul><li>提示concurrent包里有</li></ul></li><li>讲一下Spring IOC，为什么要控制反转？目的是啥？IOC的过程？</li><li>两个int型的set求交集？</li><li>求交集的同时，还要给出相同的数字的个数？</li><li>如果set特别大，大到无法在内存处理，怎么办？</li><li>Linux的了解？</li><li>问微软的pipeline导入为什么能提高效率？</li><li>问了下职业规划</li></ul><p><strong>如何减少上下文切换？</strong></p><p>减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。</p><ul><li>无锁并发并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。</li><li>CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要加锁。<ul><li>CAS:Compare and Swap,是比较并交换的意思。</li><li>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</li></ul></li><li>使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。</li><li>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li></ul>]]></content>
      
      <categories>
          
          <category> 面试经历 </category>
          
          <category> 2018 </category>
          
          <category> 秋招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Keep</title>
      <link href="/2018/07/17/Keep/"/>
      <url>/2018/07/17/Keep/</url>
      <content type="html"><![CDATA[<p>Keep Java 开发实习生 面试</p><a id="more"></a><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ul><li>自我介绍</li><li>问项目</li><li>int[]数组长度为n，问数组中连续m个数的最大值</li><li>链表反转</li><li>20w条ip地址的数据，给一个ip地址，怎么找到？</li><li>设计用户发微博的数据库，以及查看首页功能<ul><li>首页时间线表，但对于大V发微博，告知关注者的时间线处理有问题</li></ul></li><li>微博用户群组问题，怎么做到分群组？<ul><li>图的BFS</li></ul></li><li>对设计的微博的表，怎么建索引？建索引为什么会快？</li><li>http和https的区别？https的加密过程？</li></ul><p>Q：哪些情况需要加索引？</p><ul><li>在经常需要<strong>搜索的列</strong>上，可以加快搜索的速度；</li><li>在作为<strong>主键</strong>的列上，强制该列的唯一性和组织表中数据的排列结构；</li><li>在经常用在<strong>连接的列</strong>上，这些列主要是一些外键，可以加快连接的速度；</li><li>在经常需要<strong>根据范围进行搜索的列</strong>上创建索引，因为索引已经排序，其指定的范围是连续的；</li><li>在经常需要<strong>排序的列</strong>上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li><li>在经常使用在<strong>WHERE子句中的列</strong>上面创建索引，加快条件的判断速度。</li></ul><p>Q：哪些情况不需要加索引？</p><ul><li>第一，对于那些在查询中<strong>很少使用或者参考</strong>的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li><li>第二，对于那些只有<strong>很少数据值</strong>的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</li><li>第三，对于那些定义为<strong>text, image和bit</strong>数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 </li><li>第四，当<strong>修改性能远远大于检索性能时</strong>，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li></ul><p>Q：数据库建立索引为什么会加快查询速度？</p><p>首先明白为什么索引会增加速度，DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行<strong>全表扫描</strong>，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段<strong>增加索引</strong>，查询时就会<strong>先去索引列表中一次定位到特定值的行数</strong>，大大减少遍历匹配的行数，所以能明显增加查询的速度。</p><p><a href="http://blog.jiangdongyu.space/2018/07/19/HTTPS%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B/">HTTPS通信过程</a></p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ul><li>介绍项目</li><li>垃圾回收策略</li><li>HotSpot垃圾收集器，G1的特点，优缺点…<ul><li><a href="http://blog.jiangdongyu.space/2018/06/06/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/">垃圾收集器与内存分配策略</a></li></ul></li><li>为什么Eden: Survivor: Survivor是8:1:1 ?</li><li>IOC，IOC的初始化过程？</li><li>AOP，AOP的动态代理怎么做？ <ul><li>InvocationHandler接口</li></ul></li><li>concurrent包里有些啥？</li><li><strong>ThreadPoolExecutor类得看源码</strong></li><li>Java锁机制，Java怎么实现CAS的？多线程i++问题？AtomicInteger？UnSafe类？</li></ul>]]></content>
      
      <categories>
          
          <category> 面试经历 </category>
          
          <category> 2018 </category>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>对Spring IOC和AOP的理解</title>
      <link href="/2018/07/15/Spring%20IOC%20AOP/"/>
      <url>/2018/07/15/Spring%20IOC%20AOP/</url>
      <content type="html"><![CDATA[<p>在面试中，经常会问，说说你对Spring IOC和AOP的理解，问题很宽泛，似乎不知道从何说起。</p><p><strong>回答思路</strong>：</p><ul><li>先用通俗易懂的话解释下何为IOC和AOP</li><li>各自的实现原理</li><li>自己的项目中如何使用</li></ul><p>以下是个人的一些总结，仅供参考。</p><a id="more"></a><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>许多应用都是通过彼此间的相互合作来实现业务逻辑的，如类A要调用类B的方法，以前我们都是在类A中，通过自身new一个类B，然后在调用类B的方法，现在我们把new类B的事情交给Spring来做，在我们调用的时候，容器会为我们实例化。</p><ul><li>IOC容器的初始化过程<ul><li>资源定位，即定义bean的xml</li><li>载入</li><li>IOC容器注册，注册beanDefinition</li></ul></li></ul><p>IOC容器的初始化过程，一般不包含bean的依赖注入的实现，在Spring IOC设计中，bean的<strong>注册</strong>和<strong>依赖注入</strong>是两个过程，依赖注入一般发生在应用<strong>第一次索取bean</strong>的时候，但是也可以在xm中配置，在容器初始化的时候，这个bean就完成了初始化。</p><p>三种<strong>注入方式</strong>：</p><ul><li>构造器</li><li>接口</li><li>set注入(常用)</li></ul><p>bean是如何创建——<strong>工厂模式</strong></p><p>数据是如何注入——<strong>反射</strong></p><p><a href="http://blog.jiangdongyu.space/2018/07/13/Spring%20IOC%E5%8E%9F%E7%90%86/">IOC的定义及实现原理</a></p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>面向切面编程，在我们的应用中，经常需要做一些事情，但是这些事情<strong>与核心业务无关</strong>，比如，要记录所有update*方法的执行时间时间，操作人等等信息，记录到日志，</p><p>通过Spring的AOP技术，就可以在不修改update*的代码的情况下完成该需求。</p><p>AOP的好处就是你只需要干你的正事，其它事情别人帮你干。</p><p>从Spring的角度看，AOP最大的用途就在于提供了<strong>事务管理</strong>的能力。事务管理就是一个关注点，你的正事就是去访问数据库，而你不想管事务（太烦），所以，Spring在你访问数据库之前，自动帮你开启事务，当你访问数据库结束之后，自动帮你提交/回滚事务！</p><p><a href="http://blog.jiangdongyu.space/2018/07/13/%E7%90%86%E8%A7%A3AOP/">AOP的实现原理——代理</a></p><p><a href="http://blog.jiangdongyu.space/2018/07/15/AOP%E7%9A%84%E5%BA%94%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/">AOP的应用的三种实现方式</a></p>]]></content>
      
      <categories>
          
          <category> JavaWeb </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> AOP </tag>
            
            <tag> IOC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AOP的应用的三种实现方式</title>
      <link href="/2018/07/15/AOP%E7%9A%84%E5%BA%94%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/07/15/AOP%E7%9A%84%E5%BA%94%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>Spring有两大核心，IOC和AOP。IOC在java web项目中无时无刻不在使用。然而AOP用的比较少，的确也是一般的项目用的场所不多。<strong>事务控制</strong>基本都用，但却是Spring封装的不需要我们再去实现，但Spring的AOP远不止这些。</p><a id="more"></a><h2 id="概念术语"><a href="#概念术语" class="headerlink" title="概念术语　　"></a>概念术语　　</h2><p>在开始之前，需要理解Spring AOP的一些基本的概念术语(总结的个人理解，并非Spring官方定义)：</p><ul><li><strong>切面</strong>(aspect)：用来切插业务方法的类。</li><li><strong>连接点</strong>(joinpoint)：是切面类和业务类的连接点，其实就是封装了业务方法的一些基本属性，作为通知的参数来解析。</li><li><strong>通知</strong>(advice)：在切面类中，声明对业务方法做额外处理的方法。</li><li><strong>切入点</strong>(pointcut)：业务类中指定的方法，作为切面切入的点。其实就是指定某个方法作为切面切的地方。</li><li><strong>目标对象</strong>(target object)：被代理对象。</li><li><strong>AOP代理</strong>(aop proxy)：代理对象。</li><li><strong>AOP通知类型</strong>：<ul><li>前置通知(before advice)：在切入点之前执行。</li><li>后置通知(after returning advice)：在切入点执行完成后，执行通知。</li><li>环绕通知(around advice)：包围切入点，调用方法前后完成自定义行为。</li><li>异常通知(after throwing advice)：在切入点抛出异常后，执行通知。</li></ul></li></ul><h2 id="Spring-AOP环境"><a href="#Spring-AOP环境" class="headerlink" title="Spring AOP环境"></a>Spring AOP环境</h2><p>要在项目中使用Spring AOP则需要在项目中导入除了spring jar包之外，还有aspectjweaver.jar，aopalliance.jar，asm.jar和cglib.jar 。</p><p>好了，前提工作准备完成，Spring提供了很多的实现AOP的方式，在学习过程中，循序渐进。进行<strong>Spring接口方式</strong>，<strong>Schema配置方式</strong>和<strong>注解</strong>的三种方式进行学习。好了废话不多说了，开始Spring AOP学习之旅：</p><h3 id="AOP接口"><a href="#AOP接口" class="headerlink" title="AOP接口"></a>AOP接口</h3><p>利用Spring AOP接口实现AOP，主要是为了指定自定义通知来供Spring AOP机制识别。主要接口：前置通知 MethodBeforeAdvice，后置通知：AfterReturningAdvice，环绕通知：MethodInterceptor，异常通知：ThrowsAdvice 。见例子代码：</p><h4 id="业务接口："><a href="#业务接口：" class="headerlink" title="业务接口："></a>业务接口：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理类接口，也是业务类接口</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 利用接口的方式，spring aop 将默认通过jdk 动态代理来实现代理类</span></span><br><span class="line"><span class="comment"> * 不利用接口，则spring aop 将通过cglib 来实现代理类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBaseBusiness</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用作代理的切入点方法</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">(String obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这方法不被切面切</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(String obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这方法切不切呢？可以设置</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modify</span><span class="params">(String obj)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务类："><a href="#业务类：" class="headerlink" title="业务类："></a>业务类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务类，也是目标对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBusiness</span> <span class="keyword">implements</span> <span class="title">IBaseBusiness</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切入点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========调用切入点："</span> + obj + <span class="string">"说：你敢删除我！===========\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄～"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"================这个方法不能被切。。。============== \n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄～ 嘿嘿！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modify</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=================这个也设置加入切吧====================\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄改瞄啊！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通知类："><a href="#通知类：" class="headerlink" title="通知类："></a>通知类：</h4><ul><li>前置通知：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前置通知。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBeforeAdvice</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * method : 切入的方法</span></span><br><span class="line"><span class="comment">     * args ：切入方法的参数</span></span><br><span class="line"><span class="comment">     * target ：目标对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========进入beforeAdvice()============ \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"准备在"</span> + target + <span class="string">"对象上用"</span>);</span><br><span class="line">        System.out.print(method + <span class="string">"方法进行对 '"</span>);</span><br><span class="line">        System.out.print(args[<span class="number">0</span>] + <span class="string">"'进行删除！\n\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"要进入切入点方法了 \n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>后置通知：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后置通知</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAfterReturnAdvice</span> <span class="keyword">implements</span> <span class="title">AfterReturningAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * returnValue ：切入点执行完方法的返回值，但不能修改</span></span><br><span class="line"><span class="comment">     * method ：切入点方法</span></span><br><span class="line"><span class="comment">     * args ：切入点方法的参数数组</span></span><br><span class="line"><span class="comment">     * target ：目标对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========进入afterReturning()=========== \n"</span>);</span><br><span class="line">        System.out.println(<span class="string">"切入点方法执行完了 \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(args[<span class="number">0</span>] + <span class="string">"在"</span>);</span><br><span class="line">        System.out.print(target + <span class="string">"对象上被"</span>);</span><br><span class="line">        System.out.print(method + <span class="string">"方法删除了"</span>);</span><br><span class="line">        System.out.print(<span class="string">"只留下："</span> + returnValue + <span class="string">"\n\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>环绕通知：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 环绕通知</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAroundAdvice</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * invocation ：连接点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========进入around环绕方法！=========== \n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用目标方法之前执行的动作</span></span><br><span class="line">        System.out.println(<span class="string">"调用方法之前: 执行！\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法的参数</span></span><br><span class="line">        Object[] args = invocation.getArguments();</span><br><span class="line">        <span class="comment">// 调用的方法</span></span><br><span class="line">        Method method = invocation.getMethod();</span><br><span class="line">        <span class="comment">// 获取目标对象</span></span><br><span class="line">        Object target = invocation.getThis();</span><br><span class="line">        <span class="comment">// 执行完方法的返回值：调用proceed()方法，就会触发切入点方法执行</span></span><br><span class="line">        Object returnValue = invocation.proceed();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"===========结束进入around环绕方法！=========== \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"输出："</span> + args[<span class="number">0</span>] + <span class="string">";"</span> + method + <span class="string">";"</span> + target + <span class="string">";"</span> + returnValue + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"调用方法结束：之后执行！\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>异常通知：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异常通知，接口没有包含任何方法。通知方法自定义</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAfterThrowsAdvice</span> <span class="keyword">implements</span> <span class="title">ThrowsAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知方法，需要按照这种格式书写</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">     *            可选：切入的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     *            可选：切入的方法的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     *            可选：目标对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> throwable</span></span><br><span class="line"><span class="comment">     *            必填 : 异常子类，出现这个异常类的子类，则会进入这个通知。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(Method method, Object[] args, Object target, Throwable throwable)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除出错啦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义指定切点："><a href="#定义指定切点：" class="headerlink" title="定义指定切点："></a>定义指定切点：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个切点，指定对应方法匹配。来供切面来针对方法进行处理&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 继承NameMatchMethodPointcut类，来用方法名匹配</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pointcut</span> <span class="keyword">extends</span> <span class="title">NameMatchMethodPointcut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3990456017285944475L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置单个方法匹配</span></span><br><span class="line">        <span class="keyword">this</span>.setMappedName(<span class="string">"delete"</span>);</span><br><span class="line">        <span class="comment">// 设置多个方法匹配</span></span><br><span class="line">        String[] methods = &#123; <span class="string">"delete"</span>, <span class="string">"modify"</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//也可以用“ * ” 来做匹配符号</span></span><br><span class="line">        <span class="comment">// this.setMappedName("get*");</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setMappedNames(methods);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.matches(method, targetClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context/spring-context-3.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/aop     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ==============================利用spring自己的aop配置================================ --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 声明一个业务类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baseBusiness"</span> <span class="attr">class</span>=<span class="string">"aop.base.BaseBusiness"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 声明通知类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baseBefore"</span> <span class="attr">class</span>=<span class="string">"aop.base.advice.BaseBeforeAdvice"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baseAfterReturn"</span> <span class="attr">class</span>=<span class="string">"aop.base.advice.BaseAfterReturnAdvice"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baseAfterThrows"</span> <span class="attr">class</span>=<span class="string">"aop.base.advice.BaseAfterThrowsAdvice"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baseAround"</span> <span class="attr">class</span>=<span class="string">"aop.base.advice.BaseAroundAdvice"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定切点匹配类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"pointcut"</span> <span class="attr">class</span>=<span class="string">"aop.base.pointcut.Pointcut"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 包装通知，指定切点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"matchBeforeAdvisor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.DefaultPointcutAdvisor"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pointcut"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"pointcut"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"advice"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"baseBefore"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用ProxyFactoryBean 产生代理对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"businessProxy"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 代理对象所实现的接口 ，如果有接口可以这样设置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"proxyInterfaces"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>aop.base.IBaseBusiness<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 设置目标对象 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"baseBusiness"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 代理对象所使用的拦截器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>matchBeforeAdvisor<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>baseAfterReturn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>baseAround<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="测试类："><a href="#测试类：" class="headerlink" title="测试类："></a>测试类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Debug</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"aop/schema_aop.xml"</span>);</span><br><span class="line">        IBaseBusiness business = (IBaseBusiness ) context.getBean(<span class="string">"businessProxy"</span>);</span><br><span class="line">        business.delete(<span class="string">"猫"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的代码实现可以从代码注释中很容易理解<strong>接口方式</strong>的实现。结果也可想而知，前置方法会在切入点方法之前执行，后置会在切入点方法执行之后执行，环绕则会在切入点方法执行前执行同时方法结束也会执行对应的部分。主要是调用proceed()方法来执行切入点方法。来作为环绕通知前后方法的分水岭。然后在实现的过程中，有几点却是可以细揣摩一下的。</p><p>可以看出在xml配置businessProxy这个bean的时候，ProxyFactoryBean类中指定了，proxyInterfaces参数。这里我把他配置了IBaseBusiness接口。因为在项目开发过程中，往往业务类都会有对应的接口，以方便利用IOC解耦。但Spring AOP却也能支持没有接口的代理。这就是为什么需要导入cglib.jar的包。看过spring的源码，知道在目标切入对象如果有实现接口，spring会默认走jdk动态代理来实现代理类。如果没有接口，则会通过cglib来实现代理类。</p><p>这个业务类现在有<strong>前置通知，后置通知，环绕</strong>三个通知同时作用，可能以及更多的通知进行作用。那么这些通知的执行顺序是怎么样的？就这个例子而言，同时实现了三个通知。在例子xml中，则显示执行before通知，然后执行around的前处理，执行切点方法，再执行return处理。最后执行around的后处理。经过测试，知道spring处理顺序是按照xml配置顺序依次处理通知，以队列的方式存放前通知，以压栈的方式存放后通知。所以是<strong>前通知依次执行，后通知到切入点执行完之后，从栈里在后进先出的形式把后通知执行</strong>。</p><p>在实现过程中发现通知执行对应目标对象的整个类中的方法，如何精确到某个方法，则需要定义一个切点匹配的方式：spring提供了方法名匹配或正则方式来匹配。然后通过DefaultPointcutAdvisor来包装通知，指定切点.</p><p>利用方式一的配置起来，可见代码还是非常的厚重的，<strong>定义一个切面就要定义一个切面类，然而切面类中，就一个通知方法</strong>，着实没有必要。所以Spring提供了，依赖aspectj的schema配置和基于aspectj 注解方式。这两种方式非常简介方便使用，也是项目中普遍的使用方式。梳理之：</p><h3 id="schema配置"><a href="#schema配置" class="headerlink" title="schema配置"></a>schema配置</h3><h4 id="业务类：-1"><a href="#业务类：-1" class="headerlink" title="业务类："></a>业务类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectBusiness</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切入点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========调用切入点："</span> + obj + <span class="string">"说：你敢删除我！===========\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄～"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"================这个方法不能被切。。。============== \n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄～ 嘿嘿！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modify</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=================这个也设置加入切吧====================\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄改瞄啊！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切面类："><a href="#切面类：" class="headerlink" title="切面类："></a>切面类：</h4><p>切面类中，包含了所有的通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个切面</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint jp)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========进入before advice============ \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"准备在"</span> + jp.getTarget().getClass() + <span class="string">"对象上用"</span>);</span><br><span class="line">        System.out.print(jp.getSignature().getName() + <span class="string">"方法进行对 '"</span>);</span><br><span class="line">        System.out.print(jp.getArgs()[<span class="number">0</span>] + <span class="string">"'进行删除！\n\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"要进入切入点方法了 \n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jp</span></span><br><span class="line"><span class="comment">     *            连接点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">     *            返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(JoinPoint jp, String result)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========进入after advice=========== \n"</span>);</span><br><span class="line">        System.out.println(<span class="string">"切入点方法执行完了 \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(jp.getArgs()[<span class="number">0</span>] + <span class="string">"在"</span>);</span><br><span class="line">        System.out.print(jp.getTarget().getClass() + <span class="string">"对象上被"</span>);</span><br><span class="line">        System.out.print(jp.getSignature().getName() + <span class="string">"方法删除了"</span>);</span><br><span class="line">        System.out.print(<span class="string">"只留下："</span> + result + <span class="string">"\n\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pjp</span></span><br><span class="line"><span class="comment">     *            连接点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAround</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========进入around环绕方法！=========== \n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用目标方法之前执行的动作</span></span><br><span class="line">        System.out.println(<span class="string">"调用方法之前: 执行！\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法的参数</span></span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        <span class="comment">// 调用的方法名</span></span><br><span class="line">        String method = pjp.getSignature().getName();</span><br><span class="line">        <span class="comment">// 获取目标对象</span></span><br><span class="line">        Object target = pjp.getTarget();</span><br><span class="line">        <span class="comment">// 执行完方法的返回值：调用proceed()方法，就会触发切入点方法执行</span></span><br><span class="line">        Object result = pjp.proceed();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"输出："</span> + args[<span class="number">0</span>] + <span class="string">";"</span> + method + <span class="string">";"</span> + target + <span class="string">";"</span> + result + <span class="string">"\n"</span>);</span><br><span class="line">        System.out.println(<span class="string">"调用方法结束：之后执行！\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doThrow</span><span class="params">(JoinPoint jp, Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除出错啦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context/spring-context-3.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/aop     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ==============================利用spring 利用aspectj来配置AOP================================ --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 声明一个业务类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aspectBusiness"</span> <span class="attr">class</span>=<span class="string">"aop.schema.AspectBusiness"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 声明通知类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aspectAdvice"</span> <span class="attr">class</span>=<span class="string">"aop.schema.advice.AspectAdvice"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"businessAspect"</span> <span class="attr">ref</span>=<span class="string">"aspectAdvice"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置指定切入的对象 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"point_cut"</span> <span class="attr">expression</span>=<span class="string">"execution(* aop.schema.*.*(..))"</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 只匹配add方法作为切入点</span></span><br><span class="line"><span class="comment">            &lt;aop:pointcut id="except_add" expression="execution(* aop.schema.*.add(..))" /&gt;</span></span><br><span class="line"><span class="comment">             --&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 前置通知 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"doBefore"</span> <span class="attr">pointcut-ref</span>=<span class="string">"point_cut"</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 后置通知 returning指定返回参数 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"doAfter"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">pointcut-ref</span>=<span class="string">"point_cut"</span> <span class="attr">returning</span>=<span class="string">"result"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"doAround"</span> <span class="attr">pointcut-ref</span>=<span class="string">"point_cut"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"doThrow"</span> <span class="attr">pointcut-ref</span>=<span class="string">"point_cut"</span> <span class="attr">throwing</span>=<span class="string">"e"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="测试类：-1"><a href="#测试类：-1" class="headerlink" title="测试类："></a>测试类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Debug</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"aop/schema_aop.xml"</span>);</span><br><span class="line">        AspectBusiness business = (AspectBusiness) context.getBean(<span class="string">"aspectBusiness"</span>);</span><br><span class="line">        business.delete(<span class="string">"猫"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="aspectj注解"><a href="#aspectj注解" class="headerlink" title="aspectj注解"></a>aspectj注解</h3><p>注解在项目中已经到处都是了，撇开一些优劣不提，开发的便利性和可读性是非常的方便的。用来配置Spring AOP也非常简单便利</p><h4 id="业务类：-2"><a href="#业务类：-2" class="headerlink" title="业务类："></a>业务类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Business</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切入点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========调用切入点："</span> + obj + <span class="string">"说：你敢删除我！===========\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄～"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"================这个方法不能被切。。。============== \n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄～ 嘿嘿！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modify</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=================这个也设置加入切吧====================\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄改瞄啊！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切面类：-1"><a href="#切面类：-1" class="headerlink" title="切面类："></a>切面类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义切面</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Aspect</span> : 标记为切面类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Pointcut</span> : 指定匹配切点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Before</span> : 指定前置通知，value中指定切入点匹配</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@AfterReturning</span> ：后置通知，具有可以指定返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@AfterThrowing</span> ：异常通知</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定切入点匹配表达式，注意它是以方法的形式进行声明的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* aop.annotation.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(value = <span class="string">"execution(* aop.annotation.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint jp)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========进入before advice============ \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"准备在"</span> + jp.getTarget().getClass() + <span class="string">"对象上用"</span>);</span><br><span class="line">        System.out.print(jp.getSignature().getName() + <span class="string">"方法进行对 '"</span>);</span><br><span class="line">        System.out.print(jp.getArgs()[<span class="number">0</span>] + <span class="string">"'进行删除！\n\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"要进入切入点方法了 \n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jp</span></span><br><span class="line"><span class="comment">     *            连接点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">     *            返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(value = <span class="string">"anyMethod()"</span>, returning = <span class="string">"result"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(JoinPoint jp, String result)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========进入after advice=========== \n"</span>);</span><br><span class="line">        System.out.println(<span class="string">"切入点方法执行完了 \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(jp.getArgs()[<span class="number">0</span>] + <span class="string">"在"</span>);</span><br><span class="line">        System.out.print(jp.getTarget().getClass() + <span class="string">"对象上被"</span>);</span><br><span class="line">        System.out.print(jp.getSignature().getName() + <span class="string">"方法删除了"</span>);</span><br><span class="line">        System.out.print(<span class="string">"只留下："</span> + result + <span class="string">"\n\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pjp</span></span><br><span class="line"><span class="comment">     *            连接点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around</span>(value = <span class="string">"execution(* aop.annotation.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAround</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========进入around环绕方法！=========== \n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用目标方法之前执行的动作</span></span><br><span class="line">        System.out.println(<span class="string">"调用方法之前: 执行！\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法的参数</span></span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        <span class="comment">// 调用的方法名</span></span><br><span class="line">        String method = pjp.getSignature().getName();</span><br><span class="line">        <span class="comment">// 获取目标对象</span></span><br><span class="line">        Object target = pjp.getTarget();</span><br><span class="line">        <span class="comment">// 执行完方法的返回值：调用proceed()方法，就会触发切入点方法执行</span></span><br><span class="line">        Object result = pjp.proceed();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"输出："</span> + args[<span class="number">0</span>] + <span class="string">";"</span> + method + <span class="string">";"</span> + target + <span class="string">";"</span> + result + <span class="string">"\n"</span>);</span><br><span class="line">        System.out.println(<span class="string">"调用方法结束：之后执行！\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(value = <span class="string">"execution(* aop.annotation.*.*(..))"</span>, throwing = <span class="string">"e"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doThrow</span><span class="params">(JoinPoint jp, Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除出错啦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置：-1"><a href="#配置：-1" class="headerlink" title="配置："></a>配置：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context/spring-context-3.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/aop     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"aop.annotation"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 打开aop 注解 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="测试类：-2"><a href="#测试类：-2" class="headerlink" title="测试类："></a>测试类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Debug</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"aop/annotation_aop.xml"</span>);</span><br><span class="line">        Business business = (Business) context.getBean(<span class="string">"business"</span>);</span><br><span class="line">        business.delete(<span class="string">"猫"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> JavaWeb </category>
          
          <category> Spring </category>
          
          <category> AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AOP的定义实现原理——代理</title>
      <link href="/2018/07/13/%E7%90%86%E8%A7%A3AOP/"/>
      <url>/2018/07/13/%E7%90%86%E8%A7%A3AOP/</url>
      <content type="html"><![CDATA[<p>Aspect Oriented Programming面向切面编程。解耦是程序员编码开发过程中一直追求的。AOP也是为了解耦所诞生。</p><p><strong>具体思想</strong>是：定义一个切面，在切面的纵向定义处理方法，处理完成之后，回到横向业务流。</p><p>AOP在Spring框架中被作为核心组成部分之一，的确Spring将AOP发挥到很强大的功能。最常见的就是<strong>事务控制</strong>。</p><p>AOP 主要是利用<strong>代理模式</strong>的技术来实现的。</p><a id="more"></a><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><blockquote><p>就是设计模式中的proxy模式</p></blockquote><ul><li>业务接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象主题角色：声明了真实主题和代理主题的共同接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITalk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String msg)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>业务实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真实主题角色：定义真实的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeopleTalk</span> <span class="keyword">implements</span> <span class="title">ITalk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String username;</span><br><span class="line">    <span class="keyword">public</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PeopleTalk</span><span class="params">(String username, String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(msg + <span class="string">"!你好,我是"</span> + username + <span class="string">"，我年龄是"</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代理对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理主题角色：内部包含对真实主题的引用，并且提供和真实主题角色相同的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkProxy</span> <span class="keyword">implements</span> <span class="title">ITalk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ITalk talker;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TalkProxy</span><span class="params">(ITalk talker)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// super();</span></span><br><span class="line">        <span class="keyword">this</span>.talker = talker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        talker.talk(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String msg, String singname)</span> </span>&#123;</span><br><span class="line">        talker.talk(msg);</span><br><span class="line">        sing(singname);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">(String singname)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"唱歌："</span> + singname);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理测试类，使用代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyPattern</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不需要执行额外方法的。</span></span><br><span class="line">        ITalk people = <span class="keyword">new</span> PeopleTalk(<span class="string">"AOP"</span>, <span class="string">"18"</span>);</span><br><span class="line">        people.talk(<span class="string">"No ProXY Test"</span>);</span><br><span class="line">        System.out.println(<span class="string">"-----------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要执行额外方法的（切面）</span></span><br><span class="line">        TalkProxy talker = <span class="keyword">new</span> TalkProxy(people);</span><br><span class="line">        talker.talk(<span class="string">"ProXY Test"</span>, <span class="string">"代理"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码可以看出来，代理模式其实就是AOP的雏形。上端代码中talk(String msg, String singname)是一个切面。在代理类中的sing(singname)方法是个后置处理方法。</p><p>这样就实现了，其他的辅助方法和业务方法的解耦。业务不需要专门去调用，而是走到talk方法，顺理成章的调用sing方法</p><p>再从这段代码看：</p><ul><li>要实现代理方式，必须要定义接口。</li><li>每个业务类，需要一个代理类。</li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><blockquote><p>jdk1.5中提供，利用反射。实现InvocationHandler接口。</p><p>业务接口还是必须得，业务接口，业务类同上。</p></blockquote><ul><li>代理类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 需要代理的目标类 */</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写法固定，aop专用:绑定委托对象并返回一个代理类</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delegate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Object</span></span><br><span class="line"><span class="comment">     *            target：指被代理的对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Method</span></span><br><span class="line"><span class="comment">     *            method：要调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Object</span></span><br><span class="line"><span class="comment">     *            [] args：方法调用时所需要的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 切面之前执行</span></span><br><span class="line">        System.out.println(<span class="string">"切面之前执行"</span>);</span><br><span class="line">        <span class="comment">// 执行业务</span></span><br><span class="line">        result = method.invoke(target, args);</span><br><span class="line">        <span class="comment">// 切面之后执行</span></span><br><span class="line">        System.out.println(<span class="string">"切面之后执行"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 绑定代理，这种方式会在所有的方法都加上切面方法</span></span><br><span class="line">        ITalk iTalk = (ITalk) <span class="keyword">new</span> DynamicProxy().bind(<span class="keyword">new</span> PeopleTalk());</span><br><span class="line">        iTalk.talk(<span class="string">"业务说明"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果会是：</p><pre><code>切面之前执行people talk业务说明切面之后执行</code></pre><p>说明只要在业务调用方法切面之前，是可以动态的加入需要处理的方法。</p><p>从代码来看，如果再建立一个业务模块，也只需要一个代理类。ITalk iTalk = (ITalk) new DynamicProxy().bind(new PeopleTalk()); 将业务接口和业务类绑定到动态代理类。</p><p>但是这种方式：还是需要定义接口。</p><h3 id="利用cglib"><a href="#利用cglib" class="headerlink" title="利用cglib"></a>利用cglib</h3><blockquote><p>CGLIB是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强。采用的是继承的方式。</p></blockquote><ul><li>业务类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeopleTalk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"people talk"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>cglib代理类</li></ul><blockquote><p>MethodInterceptor</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用cglib动态代理</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建代理对象</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());</span><br><span class="line">        <span class="comment">// 回调方法</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">"事物开始"</span>);</span><br><span class="line">        result = methodProxy.invokeSuper(proxy, args);</span><br><span class="line">        System.out.println(<span class="string">"事物结束"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PeopleTalk peopleTalk = (PeopleTalk) <span class="keyword">new</span> CglibProxy().getInstance(<span class="keyword">new</span> PeopleTalk());</span><br><span class="line">        peopleTalk.talk(<span class="string">"业务方法"</span>);</span><br><span class="line">        peopleTalk.spreak(<span class="string">"业务方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出结果：</p><pre><code>事物开始people talk业务方法事物结束事物开始spreak chinese业务方法事物结束</code></pre><h3 id="AOP创建过程"><a href="#AOP创建过程" class="headerlink" title="AOP创建过程"></a>AOP创建过程</h3><p><img src="http://p9fh1pach.bkt.clouddn.com/aop9.png" alt="avatar"></p><ul><li>如何选择JDK动态代理还是继承cglib</li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/aop10.png" alt="avatar"></p><p><img src="http://p9fh1pach.bkt.clouddn.com/aop11.png" alt="avatar"></p><p>多个AOP的类调用，采用<strong>责任链模式</strong>。</p>]]></content>
      
      <categories>
          
          <category> JavaWeb </category>
          
          <category> Spring </category>
          
          <category> AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IOC的定义及实现原理——反射</title>
      <link href="/2018/07/13/Spring%20IOC%E5%8E%9F%E7%90%86/"/>
      <url>/2018/07/13/Spring%20IOC%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="IOC-DI"><a href="#IOC-DI" class="headerlink" title="IOC(DI)"></a>IOC(DI)</h2><p>Java程序员都知道：Java程序中的每个业务逻辑至少需要两个或以上的对象来协作完成，通常，每个对象在使用他的合作对象时，自己均要使用像new object()这样的语法来完成合作对象的申请工作。你会发现，对象间的耦合度高了。而IOC的<strong>思想</strong>是: <strong>Spring容器来实现这些相互依赖对象的创建、协调工作</strong>。对象只需要关系业务逻辑本身就可以了。从这方面来说，对象如何得到他的协作对象的责任被反转了(IOC、DI)。</p><a id="more"></a><p>DI其实就是IOC的另外一种说法。DI是由Martin Fowler 在2004年初的一篇论文中首次提出的。他总结：<strong>控制的什么被反转了？就是：获得依赖对象的方式反转了</strong>。</p><h3 id="IOC与DI"><a href="#IOC与DI" class="headerlink" title="IOC与DI"></a>IOC与DI</h3><p>首先想说说IOC(Inversion of Control，控制倒转)。这是Spring的<strong>核心</strong>，贯穿始终。所谓IOC，对于Spring框架来说，就是<strong>由Spring来负责控制对象的生命周期和对象间的关系</strong>。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，<strong>在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。</strong></p><p>那么IOC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，<strong>所有的类都会在Spring容器中登记</strong>，告诉Spring你是个什么东西，你需要什么东西，然后Spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。<strong>所有的类的创建、销毁都由Spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是Spring</strong>。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被Spring控制，所以这叫控制反转。</p><p>IOC的一个重点是在系统运行中，<strong>动态</strong>地向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了Spring我们就只需要告诉Spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，Spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖Connection才能正常运行，而这个Connection是由Spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢? Java 1.3之后一个重要特征是<strong>反射</strong>(reflection)，它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，<strong>Spring就是通过反射来实现注入的</strong>。</p><h3 id="Spring是怎么运行的"><a href="#Spring是怎么运行的" class="headerlink" title="Spring是怎么运行的"></a>Spring是怎么运行的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> ApplicationContext context = <span class="keyword">new</span> FileSystemXmlApplicationContext(</span><br><span class="line"><span class="string">"applicationContext.xml"</span>);</span><br><span class="line"> Animal animal = (Animal) context.getBean(<span class="string">"animal"</span>);</span><br><span class="line"> animal.say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>applicationContext.xml</strong>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"animal"</span> <span class="attr">class</span>=<span class="string">"phz.springframework.test.Cat"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"kitty"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>类phz.springframework.test.Cat:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"I am "</span> + name + <span class="string">"!"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = name;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了phz.springframework.test.Animal接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显上面的代码输出<strong>I am kitty!</strong></p><h3 id="实现Spring"><a href="#实现Spring" class="headerlink" title="实现Spring"></a>实现Spring</h3><p>那么到底Spring是如何做到的呢？</p><p>接下来就让我们自己写个Spring来看看Spring到底是怎么运行的吧！ </p><p>首先，我们定义一个Bean类，这个类用来存放一个Bean拥有的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/* Bean Id */</span></span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"><span class="comment">/* Bean Class */</span></span><br><span class="line"><span class="keyword">private</span> String type;</span><br><span class="line"><span class="comment">/* Bean Property */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; properties = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br></pre></td></tr></table></figure><p>一个Bean包括id,type,和Properties。 </p><p>接下来Spring就开始加载我们的配置文件了，将我们配置的信息保存在一个HashMap中，HashMap的key就是Bean的Id，HasMap的value是这个Bean，只有这样我们才能通过context.getBean(“animal”)这个方法获得Animal这个类。我们都知道Spirng可以注入基本类型，而且可以注入像List，Map这样的类型，接下来就让我们以Map为例看看Spring是怎么保存的。</p><p>Map配置可以像下面的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">class</span>=<span class="string">"Test"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testMap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"b"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring是怎样保存上面的配置呢？代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(beanProperty.element(<span class="string">"map"</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line"> Map&lt;String, Object&gt; propertiesMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"> Element propertiesListMap = (Element) beanProperty</span><br><span class="line">.elements().get(<span class="number">0</span>);</span><br><span class="line"> Iterator&lt;?&gt; propertiesIterator = propertiesListMap</span><br><span class="line">.elements().iterator();</span><br><span class="line"> <span class="keyword">while</span> (propertiesIterator.hasNext()) &#123;</span><br><span class="line">  Element vet = (Element) propertiesIterator.next();</span><br><span class="line">  <span class="keyword">if</span> (vet.getName().equals(<span class="string">"entry"</span>)) &#123;</span><br><span class="line">   String key = vet.attributeValue(<span class="string">"key"</span>);</span><br><span class="line">   Iterator&lt;?&gt; valuesIterator = vet.elements()</span><br><span class="line">.iterator();</span><br><span class="line">   <span class="keyword">while</span> (valuesIterator.hasNext()) &#123;</span><br><span class="line">Element value = (Element) valuesIterator.next();</span><br><span class="line"><span class="keyword">if</span> (value.getName().equals(<span class="string">"value"</span>)) &#123;</span><br><span class="line"> propertiesMap.put(key, value.getText());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (value.getName().equals(<span class="string">"ref"</span>)) &#123;</span><br><span class="line"> propertiesMap.put(key, <span class="keyword">new</span> String[] &#123; value.attributeValue(<span class="string">"bean"</span>) &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  bean.getProperties().put(name, propertiesMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就进入最核心部分了，让我们看看Spring到底是怎么<strong>依赖注入</strong>的吧，其实依赖注入的思想也很简单，它是通过<strong>反射</strong>机制实现的，在实例化一个类时，它通过<strong>反射调用类中set方法将事先保存在HashMap中的类属性注入到类中</strong>。让我们看看具体它是怎么做的吧。</p><p>首先<strong>实例化</strong>一个类，像这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line"> Class&lt;?&gt; cls = <span class="keyword">null</span>;</span><br><span class="line"> Object obj = <span class="keyword">null</span>;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  cls = Class.forName(className);</span><br><span class="line">  obj = cls.newInstance();</span><br><span class="line"> &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着它将这个<strong>类的依赖注入进去</strong>，像这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setProperty</span><span class="params">(Object obj, String name, String value)</span> </span>&#123;</span><br><span class="line"> Class&lt;? extends Object&gt; clazz = obj.getClass();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  String methodName = returnSetMthodName(name);</span><br><span class="line">  Method[] ms = clazz.getMethods();</span><br><span class="line">  <span class="keyword">for</span> (Method m : ms) &#123;</span><br><span class="line">   <span class="keyword">if</span> (m.getName().equals(methodName)) &#123;</span><br><span class="line"><span class="keyword">if</span> (m.getParameterTypes().length == <span class="number">1</span>) &#123;</span><br><span class="line"> Class&lt;?&gt; clazzParameterType = m.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line"> setFieldValue(clazzParameterType.getName(), value, m,obj);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后它将这个类的实例返回给我们，我们就可以用了。我们还是以Map为例看看它是怎么做的，我写的代码里面是创建一个HashMap并把该HashMap注入到需要注入的类中，像这样，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line"> Iterator&lt;?&gt; entryIterator = ((Map&lt;?, ?&gt;) value).entrySet().iterator();</span><br><span class="line"> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"> <span class="keyword">while</span> (entryIterator.hasNext()) &#123;</span><br><span class="line">  Entry&lt;?, ?&gt; entryMap = (Entry&lt;?, ?&gt;) entryIterator.next();</span><br><span class="line">  <span class="keyword">if</span> (entryMap.getValue() <span class="keyword">instanceof</span> String[]) &#123;</span><br><span class="line">map.put((String) entryMap.getKey(),</span><br><span class="line">getBean(((String[]) entryMap.getValue())[<span class="number">0</span>]));</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> BeanProcesser.setProperty(obj, property, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，这样我们就可以用Spring给我们创建的类了，是不是也不是很难啊？当然Spring能做到的远不止这些，这个示例程序仅仅提供了Spring最核心的依赖注入功能中的一部分。 </p><p>本文参考了大量文章无法一一感谢，在这一起感谢，如果侵犯了你的版权深表歉意，很希望对大家有帮助！</p>]]></content>
      
      <categories>
          
          <category> JavaWeb </category>
          
          <category> Spring </category>
          
          <category> IOC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> IOC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>String</title>
      <link href="/2018/07/11/String/"/>
      <url>/2018/07/11/String/</url>
      <content type="html"><![CDATA[<h3 id="38-Count-and-Say"><a href="#38-Count-and-Say" class="headerlink" title="38.Count and Say"></a>38.Count and Say</h3><p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p><a id="more"></a><pre><code>1.     12.     113.     214.     12115.     111221</code></pre><p>1 is read off as “one 1” or 11.</p><p>11 is read off as “two 1s” or 21.</p><p>21 is read off as “one 2, then one 1” or 1211.</p><p>Given an integer n, generate the nth term of the count-and-say sequence.</p><p><strong>Note</strong>: Each term of the sequence of integers will be represented as a string.</p><p><strong>Example 1</strong>:</p><pre><code>Input: 1Output: &quot;1&quot;</code></pre><p><strong>Example 2</strong>:</p><pre><code>Input: 4Output: &quot;1211&quot;</code></pre><blockquote><p>题目有些晦涩，就以上面的例子解释，“1”读出来是“一个1”，因此第二行就是“11”，“11”读出来是“两个1”,因此第三行就是“21”,“21”读出来是“一个2一个1”，因此第四行就是“1211”，以此类推</p></blockquote><p><strong>思路</strong></p><ul><li>如果我们要获得第n个字符串，那我们首先要获得第n-1个字符串的值。所以我们设置一个prev变量来保存每一次操作的到的字符串的值，从而进行下一次操作。</li><li>操作其实就是从前到后对每一个字符(say)连续出现的次数计数(count)，如果字符变了，那么就将刚才count和say的值加入curr字符串中。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder cur = <span class="keyword">new</span> StringBuilder(<span class="string">"1"</span>);</span><br><span class="line">        StringBuilder pre;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">char</span> say = pre.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; pre.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pre.charAt(j) != say)&#123;</span><br><span class="line">                    cur.append(count).append(say);</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                    say = pre.charAt(j);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    count++; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.append(count).append(say);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.toString();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-Zigzag-Conversion"><a href="#6-Zigzag-Conversion" class="headerlink" title="6.Zigzag Conversion"></a>6.Zigzag Conversion</h3><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p><pre><code>P   A   H   NA P L S I I GY   I   R</code></pre><p>And then read line by line: “PAHNAPLSIIGYIR”</p><p>Write the code that will take a string and make this conversion given a number of rows:</p><p>string convert(string s, int numRows);</p><p><strong>Example 1</strong>:</p><pre><code>Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3Output: &quot;PAHNAPLSIIGYIR&quot;</code></pre><p><strong>Example 2</strong>:</p><pre><code>Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4Output: &quot;PINALSIGYAHRPI&quot;Explanation:P     I    NA   L S  I GY A   H RP     I</code></pre><ul><li>重要是找准规律！</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> length = c.length;</span><br><span class="line">        StringBuilder[] sb = <span class="keyword">new</span> StringBuilder[numRows];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; numRows;i++) sb[i] = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; length)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; numRows &amp;&amp; i &lt; length;j++)&#123;</span><br><span class="line">                sb[j].append(c[i++]);<span class="comment">//垂直往下</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = numRows-<span class="number">2</span>;j &gt; <span class="number">0</span> &amp;&amp; i &lt; length;j--)&#123;</span><br><span class="line">                sb[j].append(c[i++]);<span class="comment">//斜着向上</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; numRows;j++)&#123;</span><br><span class="line">            sb[<span class="number">0</span>].append(sb[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb[<span class="number">0</span>].toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="58-Length-of-Last-word"><a href="#58-Length-of-Last-word" class="headerlink" title="58.Length of Last word"></a>58.Length of Last word</h3><p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.</p><p>If the last word does not exist, return 0.</p><p>Note: A word is defined as a character sequence consists of non-space characters only.</p><p><strong>Example:</strong></p><pre><code>Input: &quot;Hello World&quot;Output: 5</code></pre><ul><li>比较简单</li><li>记得trim(),再进行split操作</li></ul><h3 id="165-Compare-Version-Number"><a href="#165-Compare-Version-Number" class="headerlink" title="165.Compare Version Number"></a>165.Compare Version Number</h3><p>Compare two version numbers version1 and version2.<br>If <strong>version1 &gt; version2</strong> return <strong>1</strong>; if <strong>version1 &lt; version2</strong> return <strong>-1</strong>;otherwise return <strong>0</strong>.</p><p>You may assume that the version strings are non-empty and contain only digits and the . character.<br>The . character does not represent a decimal point and is used to separate number sequences.<br>For instance, 2.5 is not “two and a half” or “half way to version three”, it is the fifth second-level revision of the second first-level revision.</p><p><strong>Example 1:</strong></p><pre><code>Input: version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot;Output: -1</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: version1 = &quot;1.0.1&quot;, version2 = &quot;1&quot;Output: 1</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;Output: -1</code></pre><ul><li>还是挺简单的，但是要注意split的时候”.”的表示</li><li>在java中“\”代表转义字符，而“.”代表一个元字符，要表示一个“.”就需要用“.”，所以”\.” 在实际编译中就代表“.”</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(String version1, String version2)</span> </span>&#123;</span><br><span class="line">        String[] ver1 = version1.split(<span class="string">"\\."</span>);</span><br><span class="line">        String[] ver2 = version2.split(<span class="string">"\\."</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = Math.max(ver1.length,ver2.length);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = i &lt; ver1.length ? Integer.parseInt(ver1[i]):<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> num2 = i &lt; ver2.length ? Integer.parseInt(ver2[i]):<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(num1 &gt; num2)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num1 &lt; num2)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="151-Reverse-Words-in-a-String"><a href="#151-Reverse-Words-in-a-String" class="headerlink" title="151.Reverse Words in a String"></a>151.Reverse Words in a String</h3><p>Given an input string, reverse the string word by word.</p><p><strong>Example:</strong>  </p><pre><code>Input: &quot;the sky is blue&quot;,Output: &quot;blue is sky the&quot;.</code></pre><p><strong>Note:</strong></p><ul><li>A word is defined as a sequence of non-space characters.</li><li>Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces.</li><li>You need to reduce multiple spaces between two words to a single space in the reversed string.</li></ul><p><strong>注意两个单词之间可能有多个空格</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String[] arr = s.trim().split(<span class="string">" +"</span>);<span class="comment">//处理一个或多个空格</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            sb.append(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="186-Reverse-Words-in-a-String-II"><a href="#186-Reverse-Words-in-a-String-II" class="headerlink" title="186.Reverse Words in a String II"></a>186.Reverse Words in a String II</h3><p>Given an input string, reverse the string word by word. A word is defined as a sequence of non-space characters.</p><p>The input string <strong>does not contain</strong> leading or trailing spaces and the words are always separated by a single space.</p><p>For example, Given s = “the sky is blue”, return “blue is sky the”.</p><p>Could you do it in-place without allocating extra space?</p><ul><li>先反转整个数组，再对每个单词进行反转</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseWords</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        reverse(s, <span class="number">0</span>, s.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">                reverse(s, start, i - <span class="number">1</span>);</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(s, start, s.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = s[start];</span><br><span class="line">            s[start] = s[end];</span><br><span class="line">            s[end] = tmp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Palindrome"><a href="#Palindrome" class="headerlink" title="Palindrome"></a>Palindrome</h3><h4 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5.Longest Palindromic Substring"></a>5.Longest Palindromic Substring</h4><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer.</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: &quot;cbbd&quot;Output: &quot;bb&quot;</code></pre><p><strong>暴力枚举</strong></p><ul><li>穷举所有子字符串的可能，然后依次按位判断其是否是回文，并更新结果。虽然其时间复杂度很高，但它对空间的要求很低。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxStart = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; len - i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isPalindrome(s,i,j) &amp;&amp; (i+<span class="number">1</span>) &gt; maxLen)&#123;</span><br><span class="line">                    maxLen = i+<span class="number">1</span>;</span><br><span class="line">                    maxStart = j;</span><br><span class="line">                &#125;      </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxStart,maxStart+maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = j;</span><br><span class="line">        <span class="keyword">int</span> right = i+j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left) != s.charAt(right))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态规划</strong></p><ul><li>dp[i][j]代表字符串从i到j是否为回文串</li><li>当s.charAt(i)==s.charAt(j)并且dp[i+1][j-1]为true时，dp[i][j] = true</li><li>需要注意上述i,j相邻以及i,j中间有别的字符时，上式也成立</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxStart = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(j)==s.charAt(i) &amp;&amp; (j-<span class="number">2</span> &lt;= i || dp[i+<span class="number">1</span>][j-<span class="number">1</span>]))&#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(maxLength &lt; j-i+<span class="number">1</span>)&#123;</span><br><span class="line">                        maxLength = j -i + <span class="number">1</span>;</span><br><span class="line">                        maxStart = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxStart,maxStart + maxLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>中心扩散法</strong></p><ul><li>从小到大连续以某点为个中心的所有子字符串进行计算</li><li>外层循环遍历的是子字符串的中心点，内层循环则是从中心扩散</li><li>中心对称有两种情况，一是奇数个字母以某个字母对称，而是偶数个字母以两个字母中间为对称</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    String longest = <span class="string">""</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="comment">//计算奇数子字符串</span></span><br><span class="line">            helper(s, i, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//计算偶数子字符串</span></span><br><span class="line">            helper(s, i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(String s, <span class="keyword">int</span> idx, <span class="keyword">int</span> offset)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = idx;</span><br><span class="line">        <span class="keyword">int</span> right = idx + offset;</span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span> &amp;&amp; right&lt;s.length() &amp;&amp; s.charAt(left)==s.charAt(right))&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 截出当前最长的子串</span></span><br><span class="line">        String currLongest = s.substring(left + <span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">// 判断是否比全局最长还长</span></span><br><span class="line">        <span class="keyword">if</span>(currLongest.length() &gt; longest.length())&#123;</span><br><span class="line">            longest = currLongest;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="214-Shortest-Palindrome"><a href="#214-Shortest-Palindrome" class="headerlink" title="214.Shortest Palindrome"></a>214.Shortest Palindrome</h4><p>Given a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;aacecaaa&quot;Output: &quot;aaacecaaa&quot;</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: &quot;abcd&quot;Output: &quot;dcbabcd&quot;</code></pre><p><strong>暴力求解</strong></p><ul><li>补充之后的回文字符串的中心肯定在原字符串中</li><li>从原字符的第一个字符为起点至少存在一个回文串，找到原字符串中以第一个字符为起点最长的回文串，找到之后剩下的工作就是把剩余部分的翻转补充到原字符串头部</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || s.length() == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> len = s.length(), tail = len;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (tail &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(s.substring(<span class="number">0</span>, tail))) &#123;</span><br><span class="line">                builder = builder.append(s.substring(tail, len)).reverse();<span class="comment">//substring()从beginIndex开始取，到endIndex结束，从0开始数，其中不包括endIndex位置的字符</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tail--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.append(s).toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) != str.charAt(len - i - <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>KMP</strong>: O(n)</p><h3 id="242-Valid-Anagram"><a href="#242-Valid-Anagram" class="headerlink" title="242.Valid Anagram"></a>242.Valid Anagram</h3><p>Given two strings s and t , write a function to determine if t is an anagram of s.</p><p><strong>Example 1:</strong></p><pre><code>Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;Output: true</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: s = &quot;rat&quot;, t = &quot;car&quot;Output: false</code></pre><p><strong>Note:</strong></p><p>You may assume the string contains only lowercase alphabets.</p><p><strong>Follow up:</strong></p><p>What if the inputs contain unicode characters? How would you adapt your solution to such case?</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()!=t.length())&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">char</span>[] s1 = s.toCharArray();</span><br><span class="line">            <span class="keyword">char</span>[] s2 = t.toCharArray();</span><br><span class="line">            Arrays.sort(s1);</span><br><span class="line">            Arrays.sort(s2);</span><br><span class="line">            <span class="keyword">return</span> Arrays.equals(s1,s2);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="49-Group-Anagram"><a href="#49-Group-Anagram" class="headerlink" title="49.Group Anagram"></a>49.Group Anagram</h3><p>Given an array of strings, group anagrams together.</p><p><strong>Example:</strong></p><pre><code>Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],Output:[  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],  [&quot;nat&quot;,&quot;tan&quot;],  [&quot;bat&quot;]]</code></pre><p><strong>Note:</strong></p><ul><li>All inputs will be in lowercase.</li><li>The order of your output does not matter.</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        Map&lt;String,List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(String s:strs)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] c = s.toCharArray();<span class="comment">//String转char数组</span></span><br><span class="line">            Arrays.sort(c);</span><br><span class="line">            String key = String.valueOf(c);<span class="comment">//char数组转String</span></span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(key)) map.put(key,<span class="keyword">new</span> ArrayList());</span><br><span class="line">            map.get(key).add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(map.values());<span class="comment">//返回一个HashMap的值的Collection</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 算法 </category>
          
          <category> LeetCode Category </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程安全与锁优化</title>
      <link href="/2018/07/08/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/"/>
      <url>/2018/07/08/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>Brian Goetz对线程安全的定义：当多个线程访问一个对象时，如果不考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调度方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。</p><a id="more"></a><h3 id="Java语言中的线程安全"><a href="#Java语言中的线程安全" class="headerlink" title="Java语言中的线程安全"></a>Java语言中的线程安全</h3><p>按照线程安全的“安全程度”由强至弱来排序，java里面各种操作共享的数据分为以下5类：<strong>不可变，绝对线程安全，相对线程安全，线程兼容，线程对立</strong>。</p><ul><li><strong>不可变</strong>：可以是基本类型的<strong>final</strong>；可以是final对象，但对象的行为不会对其状态产生任何影响，比如<strong>String</strong>的subString就是new一个String对象，<strong>枚举类型</strong>，各种<strong>Number类型</strong>如BigInteger和BigDecimal等<strong>大数据类型</strong>都是不可变的，但是同为Number子类型的AtomicInteger和AtomicLong则并非不可变我觉得原因是它里面状态对象是unsafe对象，所做的操作都是CAS操作，可以保证原子性。</li><li><strong>绝对线程安全</strong>：他是完全满足Brian Goetz给出的线程安全的定义，一个类要达到这种程度，需要付出很大的，甚至不切实际的代价。</li><li><strong>相对线程安全</strong>：这就是我们通常意义上的线程安全。需要<strong>保证对象单独的操作时线程安全的</strong>。比如Vector，HashTable，synchronizedCollection包装集合等。</li><li><strong>线程兼容</strong>：<strong>对象本身不是线程安全的，但可以通过同步手段实现</strong>。一般我们说的不是线程安全的，绝大多数是指这个。比如ArrayList，HashMap等。</li><li><strong>线程对立</strong>：<strong>不管调用端是否采用了同步的措施，都无法在并发中使用的代码</strong>。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。</li></ul><h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><ul><li>互斥同步<ul><li>在多线程访问的时候，保证<strong>同一时间只有一条线程使用</strong>。而<strong>互斥是实现同步的一种手段</strong>，临界区(Critical Section)，互斥量(Mutex)，信号量(Semaphore)都是主要的互斥实现方式。java里最基本的互斥同步手段是<strong>synchronized</strong>，编译之后会形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象，还有个锁的计数器，来记录拥有锁的次数</li><li>其实在“Java与线程”里已经提到，java的线程是映射到操作系统的<strong>原生线程</strong>之上的，不管阻塞还是唤醒都需要操作系统的帮忙完成，都需要从用户态转换到核心态，这是很耗费时间的，是java语言中的一个<strong>重量级</strong>(Heavyweight)操作，虽然虚拟机本身会做一点优化的操作，比如通知操作系统阻塞之前会加一段自旋等待的过程，避免频繁切换到核心态。</li><li>还可以使用<strong>java.util.concurrent包中的重入锁（ReentrantLock）来实现同步</strong>，ReentrantLock比synchronized增加了一些高级功能：等待可中断、可实现公平锁以及锁可以绑定多个条件。</li></ul></li><li>非阻塞同步（Non-Blocking Synchronization）<ul><li><strong>互斥和同步最主要的问题就是阻塞和唤醒所带来的性能问题，所以这通常叫阻塞同步(悲观的并发策略)</strong>。随着硬件指令集的发展，我们有另外的选择：<strong>基于冲突检测的乐观并发策略</strong>，通俗讲就是先操作，如果没有其他线程争用共享的数据，操作就成功，如果有，则进行其他的补偿(最常见就是不断的重试)，这种乐观的并发策略许多实现都不需要把线程挂起，这种同步操作被称为<strong>非阻塞同步</strong>。</li></ul></li><li>无同步方案<ul><li>有一些代码天生就是线程安全的，不需要同步。其中有如下两类：</li><li><strong>可重入代码</strong>(Reentrant Code): 纯代码，具有不依赖存储在堆上的数据和公用的系统资源，用到的状态量都由参数中传入，不调用非可重入的方法等特征，它的返回结果是可以预测的。</li><li><strong>线程本地存储</strong>(Thread Local Storage): <strong>把共享数据的可见范围限制在同一个线程之内</strong>，这样就无须同步也能保证线程之间不出现数据争用问题。可以通过java.lang.ThreadLocal类来实现线程本地存储的功能。</li></ul></li></ul><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>为了在线程之间更高效的共享数据，以及解决竞争问题，从而提高程序的执行效率，创建了各种<strong>锁优化技术</strong>：适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、 锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）等。</p><ul><li><strong>自旋锁与自适应自旋</strong>：<ul><li>线程挂起和恢复的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力，在许多应用中，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得，可以让后请求锁的线程等待一会儿，但不放弃处理器的执行时间，让线程执行一个<strong>忙循环(自旋)</strong>。</li><li>自旋锁默认的自旋次数值是10次，可以使用参数-XX:PreBlockSpin更改。</li><li>自适应自旋意味着<strong>自旋的时间不再固定</strong>，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</li></ul></li><li><strong>锁消除</strong>：<ul><li>虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到<strong>不可能存在共享数据竞争的锁进行消除</strong>。锁消除的主要判定依据来源于<strong>逃逸分析</strong>的数据支持。</li></ul></li><li><strong>锁粗化</strong>：<ul><li>如果虚拟机探测到有一系列连续操作都<strong>对同一个对象反复加锁和解锁</strong>，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。</li></ul></li><li><strong>轻量级锁</strong>：<ul><li>使用对象头的Mark Word中锁标志位代替操作系统互斥量实现的锁。轻量级锁并不是用来代替重量级锁，它的本意是<strong>在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗</strong>。</li><li>轻量级锁是在无竞争的情况下使用CAS（Compare-and-Swap）操作去消除同步使用的互斥量。</li></ul></li><li><strong>偏向锁</strong>：<ul><li>和轻量级锁原理基本一致，但偏向锁在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 读书笔记 </category>
          
          <category> 深入理解Java虚拟机 </category>
          
          <category> 高效并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Thread </tag>
            
            <tag> Lock </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java内存模型与线程</title>
      <link href="/2018/07/06/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2018/07/06/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>衡量一个服务性能的高低好坏，每秒事物处理数(TPS)是最重要的指标之一，它代表着一秒内服务端平均能响应的请求总数，而TPS的值与程序的<strong>并发</strong>能力又有密切的关系。对于计算量相同的任务，程序线程并发协调越有条不紊，效率自然就越高；反之，线程之间频繁阻塞甚至死锁，将会大大降低程序的并发能力。</p><a id="more"></a><h2 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h2><p>物理机并发问题与虚拟机的情况有不少相似之处。</p><p>计算机的存储设备与处理器的运算速度有几个数量级的差距，因而加入高速缓存来作为内存与处理器之间的缓冲，引入新的问题：<strong>缓存一致性</strong>。</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG299.jpeg" alt="avatar"></p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p>Java内存模型的主要目标是定义程序中各个变量的<strong>访问规则</strong>，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量，包括了<strong>实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数</strong>，因为后者是线程私有的，不会被共享，自然没有竞争问题。</p><p>Java内存模型规定了所有的变量都存储在<strong>主内存</strong>中。每条<strong>线程</strong>还有自己的<strong>工作内存</strong>，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，<strong>线程对变量的所有操作都必须在工作内存中进行</strong>，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG300.jpeg" alt="avatar"></p><h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的(对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外)：</p><ul><li>lock(锁定): 作用于<strong>主内存</strong>的变量，它把一个变量标识为一条线程独占的状态</li><li>unlock(解锁): 作用于<strong>主内存</strong>的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read(读取): 作用于<strong>主内存</strong>变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li>load(载入): 作用于<strong>工作内存</strong>的变量，它把read操作从主内存中得到的变量值放入到工作内存的变量副本中。</li><li>use(使用): 作用于<strong>工作内存</strong>的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个<strong>需要使用到变量</strong>的值的字节码指令的时候将会执行这个操作。</li><li>assign(赋值): 作用于<strong>工作内存</strong>的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个<strong>给变量赋值</strong>的字节码指令时将会执行这个操作。</li><li>store(存储): 作用于<strong>工作内存</strong>变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li><li>write(写入): 作用于<strong>主内存</strong>变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ul><p>Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：</p><ol><li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</li><li>不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步会主内存中。</li><li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use和store操作之前，必须先执行过assign和load操作。</li><li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock之后，只有执行相同次数的unlock操作，变量才会被解锁。</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定住的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store和write操作）。</li></ol><h3 id="对于volatile型变量的特殊规则"><a href="#对于volatile型变量的特殊规则" class="headerlink" title="对于volatile型变量的特殊规则"></a>对于volatile型变量的特殊规则</h3><p>关键字volatile可以说是Java虚拟机提供的<strong>最轻量级的同步机制</strong>。当一个变量被定义成volatile之后，它将具备两种特性，第一是<strong>保证此变量对所有线程的可见性</strong>，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以<strong>立即得知的</strong>。</p><p>由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性。</p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li><li>变量不需要与其他的状态变量共同参与不变约束。</li></ul><p>第二个特性是<strong>禁止指令重排序优化</strong>。普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这样就是Java内存模型中描述的所谓的“线程内表现为串行的语义”。</p><h3 id="对于long和double型变量的特殊规则"><a href="#对于long和double型变量的特殊规则" class="headerlink" title="对于long和double型变量的特殊规则"></a>对于long和double型变量的特殊规则</h3><p>Java内存模型要求lock、unlock、read、load、assign、use、store和write这8个操作都具有原子性，但是对于64位的数据类型long和double，在模型中特别定义了一条宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这四个操作的原子性，这点就是所谓的long和double的<strong>非原子性协定</strong>。</p><p>如果有多个线程共享一个未被声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读到一个既非原值，也非其他线程修改值的代表了“半个变量”的数值。</p><p>不过这种读取到“半个变量”的情况非常罕见，因为Java内存模型虽然允许虚拟机不把long和double变量的读写实现成原子操作，但<strong>允许虚拟机选择把这些操作实现为具有原子性的操作</strong>，而且还“强烈建议”虚拟机这样实现。目前各种平台下的商用虚拟机几乎都选择吧64位数据的读写操作作为原子操作来对待，因此在编码时，不需要将long和double变量专门声明为volatile。</p><h3 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h3><p>Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的：</p><ul><li>原子性(Atomicity):<ul><li>由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，我们大致可以认为基本数据类型的访问读写是具备原子性的。</li><li>在synchronized块之间的操作也具备原子性。</li></ul></li><li>可见性(Visibility): <ul><li>指当一个线程修改了共享变量的值，其他线程能够<strong>立即</strong>得知这个修改。</li><li>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介实现可见性的</li><li>普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能<strong>立即</strong>同步到主内存，以及每次使用前立即从主内存刷新。</li><li>除了volatile之外，synchronized和final也能实现可见性。同步块的可见性是由“<strong>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中</strong>”这条规则获得的，而final关键字的可见性是指：<strong>被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去，那在其他线程中就能看见final字段的值</strong></li></ul></li><li>有序性(Ordering): <ul><li>Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。</li><li>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了<strong>禁止指令重排序</strong>的语义，而synchronized则是由“<strong>一个变量在同一个时刻只允许一条线程对其进行lock操作</strong>”这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能<strong>串行</strong>地进入</li></ul></li></ul><h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p>先行发生是Java内存模型中定义的两项操作之间的<strong>偏序关系</strong>，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了小写、调用了方法等。</p><p>下面是Java内存模型下一些“天然的”先行发生关系，这些先行发送关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，他们就没有顺序性保障，虚拟机可以对它们进行随意重新排序。</p><ul><li>程序次序规则(Program Order Rule): 在一个线程内，按照程序<strong>代码顺序</strong>，书写在钱吗的操作先于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li><li>管程锁定规则(Monitor Lock Rule): 一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。</li><li>volatile变量规则(Volatile Variable Rule): 对一个volatile变量的写操作先行发生于后面对这个变量的读操作。“后面”是指时间上的先后顺序。</li><li>线程启动规则(Thread Start Rule): Thread对象的start()方法先行发生于此线程的每一个动作。</li><li>线程终止规则(Thread Termination Rule): 线程中所有操作都先行发生于此线程的终止检测。</li><li>线程中断规则(Thread Interruption Rule): 对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li><li>对象终结规则(Finalizer Rule): 一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</li><li>传递性(Transitivity): 如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得到操作A先行发生于操作C。</li></ul><h2 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h2><h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><ul><li>使用内核线程实现<ul><li>内核线程(Kernel Thread，KLT)就是直接由操作系统内核支持的线程，这种线程由<strong>内核</strong>来完成<strong>线程切换</strong>，内核通过操纵<strong>调度器</strong>对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程都可以看做是内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就叫<strong>多线程内核</strong>。</li><li>程序一般不会直接使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程(Light Weight Process，LWP)，轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。<br><img src="http://p9fh1pach.bkt.clouddn.com/20141214145942631.png" alt="avatar"></li><li>由于内核线程的支持，每个轻量级进程都成为一个<strong>独立</strong>的调度单元，即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作，但轻量级进程具有它的局限性：基于线程内核实现，各种线程操作都需要进行<strong>系统调用</strong>，系统调用代价高，需要在用户态和内核态中来回切换；轻量级进程都需要有一个内核线程的支持，<strong>消耗内核资源</strong></li></ul></li><li>使用用户线程实现<ul><li><strong>广义</strong>上，一个线程只要不是内核线程，那就可以认为是用户线程(User Thread，UT)。</li><li><strong>狭义</strong>上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到线程存在的实现。<br><img src="http://p9fh1pach.bkt.clouddn.com/20141214150247703.png" alt="avatar"></li><li>使用用户线程的<strong>优势劣势</strong>都在于没有系统内核的支援，所有线程操作都需要用户程序自己处理，困难，实现复杂，放弃使用  </li></ul></li><li>使用用户线程加轻量级进程混合实现<ul><li>线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式。在这种混合实现下，既存在用户线程，也存在轻量级进程。<br><img src="http://p9fh1pach.bkt.clouddn.com/20141214150313341.png" alt="avatar"></li></ul></li></ul><h3 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h3><p>线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是<strong>协同式线程调度</strong>(Cooperative Threads-Scheduling)和<strong>抢占式线程调度</strong>(Preemptive Threads-Scheduling)。</p><ul><li>如果使用<strong>协同式</strong>调度的多线程系统，线程的执行时间由<strong>线程</strong>本身来控制，线程把自己的工作执行完毕后，要主动通知系统切换到另一个线程上去。</li><li>如果使用<strong>抢占式</strong>调度的多线程系统，那么每个线程将由<strong>系统</strong>来分配执行时间，线程的切换不由线程本身来决定(在Java中，Thread.yield()可以让出执行时间，但要获取执行时间的话，线程本身是没有什么办法)。Java使用抢占式调度。线程优先级</li></ul><h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>Java语言定义了5种线程状态，在任意一个时间点，一个线程只能有且只有其中的一种状态，这5种状态分别是：</p><ul><li>新建(New): 创建后尚未启动</li><li>运行(Runable): Runable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待CPU为它分配执行时间</li><li>无期限等待(Waiting): 不会被分配CPU执行时间，需要等待被其他线程显式地唤醒</li><li>期限等待(Timed Waiting): 不会被分配CPU执行时间，无须等待被其他线程显式地唤醒，在一定时间之后会由系统自动唤醒</li><li>阻塞(Blocked): 线程被阻塞了，“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是等待一段时间，或者唤醒动作的发生</li><li>结束(Terminated): 已终止线程的线程状态，线程已经结束执行</li></ul><p>上述5种状态在遇到特定事件发生的时候会相互转换。<br><img src="http://p9fh1pach.bkt.clouddn.com/20141214150758572.png" alt="avatar"></p>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 读书笔记 </category>
          
          <category> 深入理解Java虚拟机 </category>
          
          <category> 高效并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>晚期(运行期)优化</title>
      <link href="/2018/07/05/%E6%99%9A%E6%9C%9F(%E8%BF%90%E8%A1%8C%E6%9C%9F)%E4%BC%98%E5%8C%96/"/>
      <url>/2018/07/05/%E6%99%9A%E6%9C%9F(%E8%BF%90%E8%A1%8C%E6%9C%9F)%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>在部分商用虚拟机(HotSpot、IBM J9)中，Java程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“<strong>热点代码</strong>”。为了提高热点代码的执行效率，在运行时，虚拟机会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为<strong>即时编译器</strong>。</p><a id="more"></a><h2 id="HotSpot虚拟机内的即时编译器"><a href="#HotSpot虚拟机内的即时编译器" class="headerlink" title="HotSpot虚拟机内的即时编译器"></a>HotSpot虚拟机内的即时编译器</h2><h3 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h3><p>并不是所有的Java虚拟机都采用解释器与编译器并存的架构，但许多主流的商用虚拟机，如HotSpot、J9等，都同时包含解释器与编译器。解释器与编译器两者各有优势：</p><ul><li>当程序需要<strong>迅速启动和执行</strong>的时候，<strong>解释器</strong>可以首先发挥作用，省去编译的时间，立即执行</li><li>程序运行后，随着时间的推移，<strong>编译器</strong>逐渐发挥作用，把越来越多代码编译成本地代码之后，可以获取更高的执行效率</li><li>当程序运行环境中内存资源限制较大，可以使用<strong>解释执行节约内存</strong>，反之可以使用<strong>编译执行提升效率</strong></li><li>解释器还可以作为编译器<strong>激进优化</strong>时的一个“逃生门”，让编译器根据概率选择一些大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立时可以通过<strong>逆优化</strong>退回到解释状态继续执行。</li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG292.jpeg" alt="avatar"></p><p>无论采用的编译器是Client Compiler还是Server Compiler，解释器与编译器搭配使用的方式在虚拟机中称为“混合模式”，用户可以使用参数“-Xint”<strong>强制</strong>虚拟机运行于“解释模式”，这时<strong>编译器完全不介入工作</strong>，全部代码都使用解释方式执行。另外，也可以使用参数“-Xcomp”强制虚拟机运行于“编译模式”，这时<strong>优先</strong>采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程。</p><p>为了在程序启动相应速度与运行效率之间达到最佳平衡，HotSpot虚拟机还会逐渐启用<strong>分层编译</strong>的策略，分层编译根据<strong>编译器编译、优化的规模与耗时</strong>，划分出不同的编译层次：</p><ul><li>第0层，程序解释执行，解释器不开启性能监控功能，可触发第1层编译</li><li>第1层，也称为C1编译，将字节码编译为本地代码，进行简单、可靠的优化，如有必要加入性能监控的逻辑</li><li>第2层，也称为C2编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。</li></ul><p>实施分层编译后，Client Compiler和Server Compiler将会同时工作，许多代码可能会被多次编译，用<strong>Client Compiler</strong>获取<strong>更高的编译速度</strong>，用<strong>Server Compiler</strong>来获取<strong>更好的编译质量</strong>，在解释执行的时候也无须再承担收集性能监控信息的任务。</p><h3 id="编译对象与触发条件"><a href="#编译对象与触发条件" class="headerlink" title="编译对象与触发条件"></a>编译对象与触发条件</h3><p>“热点代码”有两类：</p><ul><li>被多次调用的方法</li><li>被多次执行的循环体</li></ul><p>“多次”的概念？</p><p>判断一段代码是不是热点代码，是不是需要触发即时编译，这样的行为称为<strong>热点探测</strong>，判定方式有两种：</p><ul><li>基于<strong>采样</strong>的热点探测<ul><li>周期性检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，那这个方法就是“热点方法”</li><li>实现简单、高效，容易获取方法调用关系</li><li>很难精确地确认一个方法的热度，容易因为收到线程阻塞或别的外界因素的影响而扰乱热点探测</li></ul></li><li>基于<strong>计数器</strong>的热点探测(HotSpot采用)<ul><li>为每个方法建立计数器，统计方法的执行次数，如果执行次数超过了一定的阈值就认为它是“热点方法”</li><li>实现麻烦，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系</li><li>更加精准和严谨</li></ul></li></ul><p>HotSpot为每个方法准备了两类计数器：方法调用计数器和回边计数器</p><ul><li>方法调用计数器<ul><li>统计方法被调用的次数，Client模式下默认阈值1500，Server默认10000</li><li>交互过程如下图：<br><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG293.jpeg" alt="avatar"></li><li>如果不做任何设置，方法调用计数器统计的是一个相对的<strong>执行频率</strong>，即一段时间内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的<strong>衰减</strong>，而这段时间称为此方法统计的<strong>半衰周期</strong>。进行热度衰减的动作在虚拟机进行<strong>垃圾收集</strong>时顺便进行。</li></ul></li><li>回边计数器<ul><li>统计一个方法中循环体代码执行的次数，为了触发OSR编译</li><li>虚拟机运行在Client模式下，回边计数器阈值计算公式为：<strong>方法调用计数器阈值 X OSR比率 /100</strong></li><li>虚拟机运行在Server模式下，回边计数器阈值计算公式为：<strong>方法调用计数器阈值 X (OSR比率 - 解释器监控比率) /100</strong></li><li>执行过程如下图：<br><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG294.jpeg" alt="avatar"> </li></ul></li></ul><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>默认设置下，无论是方法调用产生的即时编译请求，还是OSR编译请求，虚拟机在代码编译器还未完成之前，都仍然按照解释方式继续进行，而编译动作则在后台的编译线程中进行。</p><p>在后台编译的过程中，Client Compiler是一个简单快速的三段式编译器，主要的关注点在于局部性的优化，而放弃了许多耗时较长的全局优化手段。</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG295.jpeg" alt="avatar"></p><p>而Server Compiler则是专门面向服务端的典型应用并为服务端的性能配置特别调整过的编译器，也是一个充分优化过的高级编译器，它会执行所有经典的优化动作，如无用代码消除、循环展开、循环表达式外提、消除公共子表达式、常量传播、基本块重排序等，还会实施一些与Java语言特性密切相关的优化技术，如范围检查消除、空值检查消除等。</p><p>以<strong>即时编译</strong>的标准来看，Server Compiler比较缓慢，但它的编译速度依然远远超过传统的静态优化编译器，而且它相对于Client Compiler编译输出的<strong>代码质量</strong>有所提高，可以减少本地代码的执行时间，从而抵消了额外的编译时间开销，所以也有很多非服务端的应用选择使用Server模式的虚拟机运行。</p><h2 id="编译优化技术"><a href="#编译优化技术" class="headerlink" title="编译优化技术"></a>编译优化技术</h2><p>以编译方式执行本地代码比解释方式更快，除去虚拟机解释执行字节码需要额外消耗时间的原因外，还有一个很重要的原因就是虚拟机设计团队几乎把对代码的所有优化措施都集中在了即时编译器之中。</p><ul><li>公共子表达式消除</li><li>数组边界检查消除</li><li>方法内联<ul><li>非虚方法，直接内联</li><li>虚方法，会向“类型继承关系分析”(CHA)查询此方法在当前程序下是否有多个目标版本可选择，如果只有一个版本，也可以进行内联，不过这种内联属于<strong>激进优化</strong>，需要预留一个“逃生门”，称为<strong>守护内联</strong>。如果程序的后续执行过程中，虚拟机一直没有加载到会令这个方法的<strong>接受者继承关系</strong>发生变化的类，那这个内联优化的代码可以一直用下去。但如果加载了导致继承关系发生变化的新类，那就需要抛弃已经编译的代码，退回到解释状态执行，或者重新进行编译</li><li>如果向CHA查询出来的结果是有多个版本的目标方法可供选择，则编译器还将会尝试使用<strong>内联缓存</strong>来完成方法内联，这是一个建立在方法正常入口之前的缓存，它的工作原理大致是：在未发生方法调用之前，内联缓存为空，当第一次调用发生后，缓存记录下<strong>方法接收者的版本信息</strong>，并且每次进行方法调用时都比较接受者版本，如果以后进来的每次调用的方法接收者版本都是一样的，那这个内联还可以一直用下去。如果发生了方法接收者版本不一致的情况，就说明程序真正使用了虚方法的多态特性，这时才会取消内联，查找虚方法表进行方法分派。</li></ul></li><li>逃逸分析<ul><li>分析对象的作用域：当一个对象在方法中被定义后，它可能被<strong>外部</strong>方法所引用，称为<strong>方法逃逸</strong>。甚至还有可能被<strong>外部</strong>线程访问到，称为<strong>线程逃逸</strong></li><li>如果能证明一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问到这个对象，则可能为这个变量进行一些高效的优化</li><li>栈上分配</li><li>同步消除</li><li>标量替换(标量指一个数据已经无法再分解成更小的数据来表示了，与之对应的称为聚合量)</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 读书笔记 </category>
          
          <category> 深入理解Java虚拟机 </category>
          
          <category> 程序编译与代码优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Class </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>早期(编译期)优化</title>
      <link href="/2018/07/04/%E6%97%A9%E6%9C%9F(%E7%BC%96%E8%AF%91%E6%9C%9F)%E4%BC%98%E5%8C%96/"/>
      <url>/2018/07/04/%E6%97%A9%E6%9C%9F(%E7%BC%96%E8%AF%91%E6%9C%9F)%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>Java语言的“编译期”是一段“不确定”的操作过程，因为它可能指：</p><ul><li>前端编译器（编译器的“前端”）把*.java文件转变成*.class文件的过程: Javac</li><li>后端运行期编译器(JIT)把字节码转变成机器码的过程:HotSpot VM的C1、C2</li><li>静态提前编译器(AOT)直接把*.java文件编译成本地机器码的过程</li></ul><p>本章讨论的“编译期”和“编译器”都仅限于第一类编译过程。</p><p>Javac对代码的运行效率几乎没有任何优化措施，但做了许多针对Java语言编码过程的优化措施来改善程序员的编码风格和提高编码效率。相当多新生的Java语法特性，都是靠编译器的“<strong>语法糖</strong>”来实现。</p><a id="more"></a><h2 id="Javac编译器"><a href="#Javac编译器" class="headerlink" title="Javac编译器"></a>Javac编译器</h2><p>Javac编译过程大致可以分为3个过程：</p><ul><li>解析和填充符号表过程</li><li>插入式注解处理器的注解处理过程</li><li>分析与字节码生成过程</li></ul><h3 id="Javac的源码与调试"><a href="#Javac的源码与调试" class="headerlink" title="Javac的源码与调试"></a>Javac的源码与调试</h3><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG290.jpeg" alt="avatar"></p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG291.jpeg" alt="avatar"></p><h3 id="解析和填充符号表"><a href="#解析和填充符号表" class="headerlink" title="解析和填充符号表"></a>解析和填充符号表</h3><ul><li>词法、语法分析<ul><li>词法分析将源代码的字符流转变为标记(Token)集合</li><li>语法分析根据Token序列构造抽象语法树</li></ul></li><li>填充符号表<ul><li>符号表是由一组符号地址和符号信息构成的表格</li></ul></li></ul><h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h3><p>注解在<strong>运行期</strong>间发生作用。</p><p>如果注解处理器在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round(上图10-4的循环过程)。</p><h3 id="语义分析与字节码生成"><a href="#语义分析与字节码生成" class="headerlink" title="语义分析与字节码生成"></a>语义分析与字节码生成</h3><p>语法分析后，编译器获得了程序代码的抽象语法树表示，<strong>语法树</strong>能表示一个<strong>结构正确</strong>的源程序的抽象，但无法保证源程序是符合逻辑的。而<strong>语义分析</strong>的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。</p><ul><li>标注检查<ul><li>检查变量使用前是否已被声明、变量与赋值之间的数据类型能否匹配等</li></ul></li><li>数据及控制流分析<ul><li>能检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被处理了等问题</li><li>将<strong>局部变量</strong>声明为final，对<strong>运行期</strong>没有影响，<strong>变量的不变性仅仅由编译器在编译期间保障</strong>。</li></ul></li><li>解语法糖<ul><li>使用语法糖能增加程序的可读性，从而减少程序代码出错的机会</li></ul></li><li>字节码生成<ul><li>把前面各个步骤所生成的信息转化成字节码写到磁盘中，进行少量的代码添加和转换工作</li></ul></li></ul><h2 id="Java语法糖的味道"><a href="#Java语法糖的味道" class="headerlink" title="Java语法糖的味道"></a>Java语法糖的味道</h2><h3 id="泛型与类型擦除"><a href="#泛型与类型擦除" class="headerlink" title="泛型与类型擦除"></a>泛型与类型擦除</h3><p>Java中的泛型只在程序源码中存在，在编译后的字节码文件中，会替换成原来的原生类型，并在相应的地方插入强制转型代码。ArrayList<int>和ArrayList<string>对Java来说就是同一个类。Java中泛型实现方法称为<strong>类型擦除</strong>，基于这种方法实现的泛型称为<strong>伪泛型</strong>。</string></int></p><p>引入Signature、LocalVariableTypeTable等属性用于解决伴随泛型而来的参数类型的识别问题。擦除法所谓的擦除，只是对方法的Code属性中的字节码进行擦除，元数据中还是保留了泛型信息。</p><h3 id="自动装箱、拆箱与遍历循环"><a href="#自动装箱、拆箱与遍历循环" class="headerlink" title="自动装箱、拆箱与遍历循环"></a>自动装箱、拆箱与遍历循环</h3><p>遍历循环会把代码还原成迭代器的实现，这就是遍历的类需要实现Iterable接口的原因。</p><p>这是关于Java中<strong>自动装箱与拆箱</strong>的一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoxingTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Integer c = <span class="number">3</span>;</span><br><span class="line">        Integer d = <span class="number">3</span>;</span><br><span class="line">        Integer e = <span class="number">321</span>;</span><br><span class="line">        Integer f = <span class="number">321</span>;</span><br><span class="line">        Long g = <span class="number">3L</span>;</span><br><span class="line">        System.out.println(c == d); <span class="comment">//true</span></span><br><span class="line">        System.out.println(e == f); <span class="comment">//false</span></span><br><span class="line">        System.out.println(c == (a + b)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(c.equals(a + b)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(g == (a + b)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(g.equals(a + b)); <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>装箱代码，注意IntegerCache的存在：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拆箱代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译完的class文件，再重新反编译后的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoxingTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Integer a = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">        Integer b = Integer.valueOf(<span class="number">2</span>);</span><br><span class="line">        Integer c = Integer.valueOf(<span class="number">3</span>);</span><br><span class="line">        Integer d = Integer.valueOf(<span class="number">3</span>);</span><br><span class="line">        Integer e = Integer.valueOf(<span class="number">321</span>);</span><br><span class="line">        Integer f = Integer.valueOf(<span class="number">321</span>);</span><br><span class="line">        Long g = Long.valueOf(<span class="number">3L</span>);</span><br><span class="line">        System.out.println(c == d); </span><br><span class="line">        System.out.println(e == f); </span><br><span class="line">        System.out.println(c.intValue() == a.intValue() + b.intValue());</span><br><span class="line">        System.out.println(c.equals(Integer.valueOf(a.intValue() + b.intValue())));</span><br><span class="line">        System.out.println(g.longValue() == a.intValue() + b.intValue());</span><br><span class="line">        System.out.println(g.equals(Integer.valueOf(a.intValue() + b.intValue())));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>System.out.println(c == d) =&gt; <em>System.out.println(c == d)</em>：类型一致，不涉及装箱与拆箱，变量c、d保存于线程私有栈中，c和d是保存的是一个地址引用，指向内存堆中的某个地址，对于值在【-128，127】Integer类型，由于IntegerCache.cache[]的存在，所以c、d指向的是堆中同一个地址，故执行结果为true</li><li>System.out.println(e == f) =&gt; <em>System.out.println(e == f)</em>:  类型一致，不涉及装箱与拆箱操作，判定规则参照上面的分析，因为321不在【-128，127】内，故e和f指向的是内存堆中两个不同的地址，故执行结果为false</li><li>System.out.println(c == (a + b)) =&gt; <em>System.out.println(c.intValue() == a.intValue() + b.intValue())</em>：通过反编译字节码我们可以看到，这里涉及了包装类型的拆箱操作，只有基础类型才可以进行加法操作，实际比较的是存于Java私有线程栈中两个int类型的数值比较，执行结果为true</li><li>System.out.println(c.equals(a + b)) =&gt; <em>System.out.println(c.equals(Integer.valueOf(a.intValue() + b.intValue())))</em>：这里涉及了先拆箱，然后再装箱的操作，a+b先执行拆箱操作，然后再对结果执行装箱操作，最后执行equals方法，我们看下Integer类中equals方法的定义如下，很明显，执行结果为true</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">        <span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>System.out.println(g == (a + b)) =&gt; <em>System.out.println(g.longValue() == a.intValue() + b.intValue())</em>：类型不一致，拆箱操作，g和a、b分别执行了拆箱操作，然后比较结果，执行结果为true</li><li>System.out.println(g.equals(a + b)) =&gt; <em>System.out.println(g.equals(Integer.valueOf(a.intValue() + b.intValue())))</em>：与第四条规则一致，先拆箱执行加法操作，然后加法结果执行装箱操作，最后执行Long类型的equals方法，Long中equals方法定义如下，故执行结果为false</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Long) &#123;</span><br><span class="line">        <span class="keyword">return</span> value == ((Long)obj).longValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集合中只能包含对象，不能包含基础数据类型，如果将基础数据类型的数据添加到集合操作，JVM（JDK1.5之后）会自动进行装箱操作，将基础数据类型封装为对应的封装类</p><p><img src="http://p9fh1pach.bkt.clouddn.com/OOP_WrapperClass.png" alt="avatar"></p><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><p>使用条件为常量的if语句</p>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 读书笔记 </category>
          
          <category> 深入理解Java虚拟机 </category>
          
          <category> 程序编译与代码优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Class </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>虚拟机字节码执行引擎</title>
      <link href="/2018/07/02/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
      <url>/2018/07/02/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
      <content type="html"><![CDATA[<p>从<strong>概念模型</strong>的角度讲解虚拟机的方法调用和字节码执行。</p><h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>栈帧是用于支持虚拟机进行<strong>方法调用和方法执行</strong>的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的<strong>局部变量表、操作数栈、动态连接和方法返回地址</strong>等信息。每一个方法从调用开始至执行完成的过程，都对应着一个<strong>栈帧</strong>在虚拟机栈里面从<strong>入栈到出栈</strong>的过程。</p><a id="more"></a><p><strong>编译</strong>时，栈帧需要多大的局部变量表，多深的操作数栈都已经完全确定，并且写入到方法表的Code属性中，因此一个<strong>栈帧需要分配多少内存</strong>，仅仅取决于<strong>具体的虚拟机实现</strong>。</p><p>对执行引擎来说，在活动线程中，只有位于<strong>栈顶的栈帧</strong>才是有效的，称为<strong>当前栈帧</strong>，与这个栈帧相关联的方法称为当前方法。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如下图所示：</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG281.jpeg" alt="avatar"></p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表是一组<strong>变量值存储空间</strong>，用于存放<strong>方法参数和方法内部定义的局部变量</strong>。在Java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。</p><p>局部变量表的容量以变量槽(Slot)为最小单位，一个Slot可以存放一个32位以内的数据类型(boolean、byte、char、short、int、float、reference和returnAddress)。而对于64位的数据类型，虚拟机会以<strong>高位对齐</strong>的方式为其分配<strong>两个连续</strong>的Slot空间。</p><p>虚拟机通过索引定位的方式使用局部变量表。</p><p>如果一个局部变量定义了但没有赋初始值是不能被使用的。</p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈也常称为操作栈，它是一个后入先出栈。同局部变量表一样，操作数栈的最大深度也在<strong>编译</strong>的时候写入到Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意的Java数据类型。</p><p>在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的。但在大多数虚拟机的实现都会做一些优化处理，令两个栈帧出现一部分重叠。让下面栈帧的部分<strong>操作数栈</strong>与上面栈帧的部分<strong>局部变量表</strong>重叠在一起，这样在进行方法调用时就可以共用一部分数据，无须进行额外的参数复制传递。</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG282.jpeg" alt="avatar"></p><p>Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。</p><h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的<strong>动态连接</strong>。</p><p>Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在<strong>类加载阶段或者第一次使用</strong>的时候就转化为直接引用，这种转化称为<strong>静态解析</strong>。另外一部分将在每一次<strong>运行期间</strong>转化为直接引用，这部分称为<strong>动态连接</strong>。</p><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>方法开始执行后，有两种方式可以退出这个方法</p><ul><li>执行引擎遇到任意一个方法返回的字节码指令，可能会有返回值传递给上层方法调用者(<strong>正常完成出口</strong>)</li><li>执行过程遇到异常，并且该异常在方法体内没有被处理(<strong>异常完成出口</strong>)</li></ul><p>方法退出后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。</p><p>方法<strong>正常退出</strong>时，<strong>调用者的PC计数器</strong>的值可以作为<strong>返回地址</strong>，栈帧中很可能会保存这个计数器的值。方法<strong>异常</strong>退出时，返回地址是要通过<strong>异常处理器表</strong>来确定的。</p><h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为<strong>栈帧信息</strong>。</p><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>确定被调用方法的版本</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个<strong>可确定的调用版本</strong>，并且这个方法的调用版本<strong>在运行期是不可改变的</strong>。换句话说，<strong>调用目标在程序代码写好、编译器进行编译时就必须确定下来</strong>。这类方法的调用称为<strong>解析</strong>。</p><p>在Java中符合“编译期可知，运行期不可变”的，包括静态方法和私有方法两大类，适合在类加载阶段进行解析。</p><p>与之对应的是，在Java虚拟机里提供了5条方法调用字节码指令：</p><ul><li>invokestatic：静态方法</li><li>invokespecial：调用实例构造器\<init>方法、私有方法和父类方法</init></li><li>invokevirtual：虚方法</li><li>invokeinterface：接口方法，会在运行时再确定一个实现该接口的对象</li><li>invokedynamic：现在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法</li></ul><p>只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、实例构造器、私有方法和父类方法4类(非虚方法，非虚方法还包含被final修饰的方法)。其他都称为虚方法。</p><p>解析调用是静态的过程。</p><h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><p>揭示多态性特征的一些最基本的体现。</p><ul><li>静态分派<ul><li>重载(同名函数，不同参数个数/类型)相关，虚拟机重载时通过参数的静态类型作为判断依据</li></ul></li><li>动态分派<ul><li>重写(子类父类之间)有关，根据实际类型确定方法执行版本</li></ul></li><li>单分派与多分派<ul><li>方法的接收者与方法的参数统称为方法的宗量</li><li>单分派根据一个宗量对目标方法进行选择</li><li>多分派根据多于一个宗量对目标方法进行选择</li><li><strong>Java的静态分派属于多分派类型，动态分派属于单分派类型</strong></li></ul></li><li>虚拟动态分派的实现<ul><li>虚方法表</li><li>内联缓存</li><li>基于“类型继承关系分析”技术的守护内联</li></ul></li></ul><h3 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h3><ul><li>动态类型语言<ul><li>动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期</li><li>“变量无类型而变量值才有类型”</li></ul></li><li>JDK1.7与动态类型</li><li>java.lang.invoke包 <ul><li>MethodHandle</li></ul></li><li>invokedynamic指令</li><li>掌控方法分派规则<ul><li>Son类中调用祖父类thinking()方法：<br><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG283.jpeg" alt="avatar"></li></ul></li></ul><h2 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h2><h3 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h3><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG284.jpeg" alt="avatar"></p><p>上图中下面那条分支，是传统编译原理中程序代码到目标机器代码的生成过程，而中间那条分支，就是解释执行的过程。</p><p>Java程序编译半独立。Javac编译器完成程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机内部。</p><h3 id="基于栈的指令集与基于寄存器的指令集"><a href="#基于栈的指令集与基于寄存器的指令集" class="headerlink" title="基于栈的指令集与基于寄存器的指令集"></a>基于栈的指令集与基于寄存器的指令集</h3><p>基于栈的指令集的优点：</p><ul><li>可移植</li><li>代码相对更加紧凑</li><li>编译器实现更简单</li></ul><p>基于栈的指令集的缺点：执行速度相对较慢</p>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 读书笔记 </category>
          
          <category> 深入理解Java虚拟机 </category>
          
          <category> 虚拟机执行子系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Class </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>虚拟机类加载机制</title>
      <link href="/2018/06/29/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/06/29/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p><strong>虚拟机的类加载机制:</strong></p><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。</p><p>Java语言<strong>运行期</strong>类加载的特性</p><a id="more"></a><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>类的生命周期：加载，验证，准备，解析，初始化，使用和卸载。其中验证，准备，解析3个部分统称为连接，发生顺序如下：</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG279.jpeg" alt="avatar"></p><p>其中，加载、验证、准备、初始化和卸载顺序是确定的，类的加载过程必须按照这个顺序按部就班地开始，但是解析阶段则不一定(动态绑定，多态)</p><p><strong>那什么时候开始类加载的第一个过程“加载”呢？</strong></p><p>虚拟机规范严格规定了有且只有5种情况必须立即对类进行“初始化”（加载、验证、准备自然在这之前），以下五种情况称为<strong>对一个类的主动引用</strong>：</p><ul><li>遇到<strong>new、getstatic、putstatic或invokestati</strong>这4条字节码指令时，如果类没有进行初始化，则需要先初始化<ul><li>生成这4条指令最常见的场景是：new 实例化对象时，读取、设置一个类的静态字段(被final修饰，常量除外)，调用一个类的静态方法</li></ul></li><li>使用<strong>java.lang.reflect包</strong>的方法对类进行<strong>反射</strong>调用时，如果类没有进行初始化，则需要先初始化</li><li>初始化类时，如果<strong>父类</strong>还没有初始化，则需要先初始化父类</li><li>虚拟机启动时，用户需要指定一个<strong>主类</strong>（包含main()方法的类），虚拟机会先初始化主类</li><li>使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REE_getStatic、REE_putStatic、REE_invokeStatic的方法句柄，并且该句柄所对应的类没有进行初始化，则需要先初始化</li></ul><p>除此之外，所有引用类的方式不会触发初始化，称为<strong>被动引用</strong></p><p><strong>接口</strong>的加载过程与<strong>类</strong>加载过程稍有不同，只是第3条，一个接口在初始化时，<strong>不</strong>要求其父类接口全部完成了初始化，只有在<strong>真正用到父接口</strong>的时候才会初始化。</p><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>在加载阶段，虚拟机需要完成以下3件事情：</p><ul><li>通过一个类的全限定名来获取此类的二进制流</li><li>将该字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ul><p>“通过一个类的全限定名来获取此类的二进制流”，没有指明从哪里获取，怎么获取：</p><ul><li>从ZIP包获取，JAR、WAR、EAR</li><li>网络获取，Applet</li><li>运算时生成，动态代理技术</li><li>其他文件生成，JSP</li><li>数据库读取</li><li>……</li></ul><p>相对于类加载过程中的其他阶段，一个<strong>非数组类</strong>的加载阶段（加载过程中获取类的二进制字节流的动作）可控性最强，既可以用系统提供的引导类加载器，也可以由用户自定义的类加载器来完成（重写类加载器的loadClass()）</p><p>而<strong>数组</strong>类，是由<strong>Java虚拟机直接创建</strong>的，但是数组类的元素类型，最终还是需要类加载器来创建，一个数组类的创建过程遵循以下<strong>规则</strong>：</p><ul><li>如果数组的组件类型是引用类型，递归非数组类加载过程加载，数组将在加载该组件类型的类加载器的类名称空间上被标识</li><li>不是引用类型，将数组标记为与引导类加载器关联</li><li>数组类的可见性与它的组件类型的可见性一致，如果不是引用类型，默认为public</li></ul><p>加载阶段与连接阶段的部分内容交叉进行，加载阶段尚未完成，连接阶段可能已经开始。但这两个阶段开始的时间仍然保持先后顺序。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>确保Class文件的字节流包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</p><p>验证阶段大致会完成以下4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证</p><ul><li>文件格式验证<ul><li>保证输入的<strong>字节流</strong>能正确地解析并存储于<strong>方法区</strong>之内，格式上符合描述一个Java类型信息的要求</li><li>验证魔数、主次版本号、常量池中的常量类型…</li><li>基于<strong>字节流</strong>进行验证，后面3个验证都是基于<strong>方法区的存储结构</strong>进行的</li></ul></li><li>元数据验证<ul><li>对类的元数据信息进行<strong>语义校验</strong>，保证不存在不符合Java语言规范的元数据信息</li><li>是否有父类、父类是否继承不允许被继承的类，类中的字段、方法是否与父类矛盾…</li></ul></li><li>字节码验证<ul><li>通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的</li><li>在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对<strong>类的方法体</strong>进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件</li><li>保证方法体中的类型转换有效、跳转指令不会跳转到方法体以外的字节码指令上…</li><li>为了优化，Code属性中<strong>“StackMapTable“</strong>，描述方法体中所有基本块开始时本地变量表和操作栈该有的状态，在字节码验证期间，就不用推导合法性，直接查该属性中的记录即可。将字节码验证的<strong>类型推导</strong>转变为<strong>类型检查</strong>。</li></ul></li><li>符号引用验证<ul><li>发生在虚拟机将符号引用转化为直接引用时，在<strong>解析阶段</strong>发生，确保解析动作能正常执行</li><li>对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验</li><li>符号引用中通过字符串描述的全限定名能否找到对应的类，符号引用中的类、方法、字段的访问行是否可被当前类所访问…</li></ul></li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>正式为<strong>类变量</strong>分配<strong>内存</strong>并设置类变量<strong>初始值</strong>，内存都在<strong>方法区</strong>中分配。</p><ul><li>进行内存分配的只是<strong>类变量</strong>(被static修饰)，不包含实例变量</li><li>初始化，一般指赋0值，但如果是常量(static final)，则是常量具体的值</li></ul><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用在Class文件中以CONSTANT_Class_info等类型的常量出现。</p><p><strong>解析阶段符号引用和直接引用的关联:</strong></p><ul><li>符号引用：以一组符号来描述所引用的目标，符号形式不限，只要在使用时能无歧义地定位到目标即可。与虚拟机实现的<strong>内存布局无关</strong>，引用的目标<strong>不一定已经加载到内存中</strong>。虚拟机实现的内存布局可以各不相同，但它们能接受的<strong>符号引用都是一致的</strong>。</li><li>直接引用：可以是直接指向目标的指针、相对偏移量或者能间接定位到目标的句柄。和与虚拟机实现的<strong>内存布局相关</strong>，<strong>同一个符号引用</strong>在不同虚拟机翻译出来的<strong>直接引用一般不会相同</strong>。如果有了直接引用，那引用的目标<strong>必定已经在内存中</strong>。</li></ul><p><strong>解析阶段发生的具体时间不确定</strong>，只要求了在16个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。</p><p>因此，虚拟机实现可以按需判断是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用时才去解析它。</p><p>对一个符号引用的<strong>多次解析</strong>很常见，除了invokedynamic指令外，虚拟机实现可以对第一次解析进行<strong>缓存</strong>。需要保证的是在同一个实体中，如果一个符号引用之前被<strong>成功解析过</strong>，那么后续的解析也应该<strong>一直成功</strong>；同样的，如果<strong>第一次失败</strong>，那么之后也应该收到<strong>相同的异常</strong>。</p><p>而对于invokedynamic指令用于<strong>动态语言支持</strong>，必须等到程序实际运行到这条指令的时候，解析动作才能进行。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用店限定符7类符号引用进行，以下是前4种：</p><h4 id="类或接口的解析"><a href="#类或接口的解析" class="headerlink" title="类或接口的解析"></a>类或接口的解析</h4><p>假设当前代码所处的类为D，要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，虚拟机完成整个解析需要3个步骤：</p><ul><li>如果C不是数组类型，虚拟机会把代表N的全限定名传递给D的类加载器去加载类C，加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作。一旦加载过程出现异常则宣告失败</li><li>如果C是数组类型，并且数组的元素类型为对象，那将会按照第1点的规则加载数组元素类型，接着由虚拟机生成一个代表词数组维度和元素的数组对象</li><li>如果上述步骤没有出现异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还需要进行<strong>符号引用验证</strong>，确认D是否具备对C的访问<strong>权限</strong>，如果没有，则抛出java.lang.IllegalAccessError异常。</li></ul><h4 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h4><p>要解析一个未被解析过的字段符号引用，首先会对<strong>字段所属的类或接口的符号引用进行解析</strong>。如果在解析的过程中出现异常，则解析失败。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索：</p><ul><li>如果C本身包含了简单名称和字段描述符都与目标相匹配的字段，则直接返回该字段的直接引用，查找结束</li><li>否则，如果C实现了接口，则<strong>按照继承关系从下往上递归搜索</strong>各个接口以及父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回该字段的直接引用，查找结束</li><li>否则，如果C不是java.lang.Object的话，<strong>按照继承关系从下往上递归搜索</strong>其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回该字段的直接引用，查找结束</li><li>否则，查找失败，抛出java.lang.NoSuchFieldError异常</li></ul><p>如果查找过程成功返回了引用，将会对这个字段进行<strong>权限验证</strong>，如果没有访问权限，则抛出java.lang.IllegalAccessError异常。</p><p>如果有一个<strong>同名字段同时出现在C的接口和父类中，或者同时在自己或父类的多个接口中出现，那编译器可能拒绝编译</strong>。</p><h4 id="类方法解析"><a href="#类方法解析" class="headerlink" title="类方法解析"></a>类方法解析</h4><p>第一个步骤和字段解析一样，也需要先解析出<strong>类方法表</strong>的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C表示这个类，接下来虚拟机会按照如下步骤进行后续的类方法搜索：</p><ul><li>类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是<strong>接口</strong>，直接抛出java.lang.IncompatibleClassChangeError异常</li><li>如果通过第1步，在类C中查找是否有简单名称和字段描述符都与目标相匹配的方法，如果有则直接返回这个方法的直接引用，查找结束</li><li>否则，在C的<strong>父类</strong>中递归查找是否有简单名称和字段描述符都与目标相匹配的方法，如果有则直接返回这个方法的直接引用，查找结束</li><li>否则，在C实现的<strong>接口列表及它们的父接口</strong>之中递归查找是否有简单名称和字段描述符都与目标相匹配的方法，如果有，说明C是个<strong>抽象类</strong>，这时查找结束，抛出java.lang.AbstractMethodError异常</li><li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError</li></ul><p>最后，如果查找过程成功返回了直接引用，将会对这个方法进行<strong>权限验证</strong>，如果发现不具备权限，将抛出java.lang.IllegalAccessError异常。</p><h4 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h4><p>接口方法也需要先解析出<strong>接口方法表</strong>的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C表示这个接口，接下来虚拟机会按照如下步骤进行后续的接口方法搜索：</p><ul><li>与类方法解析不同，如果在接口方法表中发现class_index中索引的C是<strong>类</strong>，直接抛出java.lang.IncompatibleClassChangeError异常</li><li>否则，在接口C中查找是否有简单名称和字段描述符都与目标相匹配的方法，如果有则直接返回这个方法的直接引用，查找结束</li><li>否则，在的<strong>父接口</strong>之中递归查找，直到java.lang.Object类，看是否有简单名称和字段描述符都与目标相匹配的方法，如果有则直接返回这个方法的直接引用，查找结束</li><li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常</li></ul><p>接口中所有方法默认都是public的，因此不需要进行权限验证。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>真正开始执行类中定义的Java代码，初始化阶段是执行类构造器clinit()方法的过程。</p><ul><li>clinit()方法是由编译器自动收集类中的所有<strong>类变量的赋值动作</strong>和<strong>静态语句块中的语句</strong>合并产生的，静态语句块中只能<strong>访问</strong>到定义在静态语句块<strong>之前的变量</strong>，定义在它之<strong>后</strong>的变量，只能<strong>赋值</strong>不能访问。</li><li>虚拟机保证子类的clinit()方法执行前，父类的clinit()方法已经执行完毕</li><li>父类中定义的静态语句块要优先于子类的变量赋值操作</li><li>接口中不能使用静态语句块，但仍有变量初始化赋值操作，因此也会生成clinit()方法。但接口的clinit()方法，<strong>不需要先执行父类的clinit()方法</strong>。只有当<strong>父接口中定义的变量使用时，父接口才会初始化</strong>。另外，<strong>接口的实现类</strong>在初始化时也一样<strong>不会</strong>执行接口的clinit()方法</li><li>虚拟机会保证一个类的clinit()方法在多线程环境中被正确地加锁、同步</li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>虚拟机设计团队把类<strong>加载</strong>阶段中的“通过一个类的全限定名来获取此类的二进制流”这个动作放到Java虚拟机的外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“<strong>类加载器</strong>”。</p><h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>类加载器用于实现类的加载动作。对于任意一个类，都需要由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。也就是说，比较两个类是否“相等”，只有这两个类是由同一个类加载器加载的前提下才有意义。</p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>从Java虚拟机的角度来讲，只存在两种不同类型的类加载器：</p><ul><li>启动类加载器，C++语言实现，虚拟机自身的一部分</li><li>其他所有的类加载器，Java语言实现，独立于虚拟机外部，全都继承自抽象类java.lang.ClassLoader</li></ul><p>从Java开发人员的角度来看，绝大部分Java程序都会使用到以下3种系统提供的类加载器：</p><ul><li>启动类加载器：负责将存放在<strong>\&lt;JAVA_HOME&gt;\lib</strong>目录中的，或者被<strong>-Xbootclasspath参数所指定的路径</strong>中的，并且是<strong>虚拟机识别的类库</strong>加载到虚拟机内存中。启动类加载器<strong>无法被Java程序直接引用</strong></li><li>扩展类加载器：负责加载<strong>\&lt;JAVA_HOME&gt;\lib\ext</strong>目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器</li><li>应用程序类加载器：负责加载用户类路径(Classpath)上所指定的类库，开发者可以直接使用这个类加载器。程序的<strong>默认</strong>类加载器。</li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG280.jpeg" alt="avatar"></p><p>双亲委派模型要求顶层是启动类加载器，其余的类加载器应该有自己的父类加载器。类加载器之间的父子关系是使用组合关系来复用父加载器的代码。</p><p>双亲委派模型的<strong>工作过程</strong>：</p><p>如果一个类加载器收到了类加载请求，它<strong>不会自己去尝试加载这个类</strong>，而是将这个请求<strong>委派给父类加载器</strong>去完成，每一个层次的类加载器都这样，因此所有的加载请求最终都应该传送到顶层的启动类中，只有当<strong>父类</strong>加载器反馈自己<strong>无法完成</strong>这个加载请求时，子加载器才会尝试自己加载。</p><h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h3><ul><li>向前兼容</li><li>模型自身缺陷<ul><li>双亲委派模型很好地解决了各个类加载器的基础类的统一问题(越基础的类由越上层的类加载器进行加载)</li><li>基础类又要调回用户的代码，比如JNDI，可以使用线程上下文类加载器</li></ul></li><li>用户对程序动态性的追求，热部署等</li></ul>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 读书笔记 </category>
          
          <category> 深入理解Java虚拟机 </category>
          
          <category> 虚拟机执行子系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Class </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Stack</title>
      <link href="/2018/06/26/Stack/"/>
      <url>/2018/06/26/Stack/</url>
      <content type="html"><![CDATA[<p>Stack实际上也是通过<strong>数组</strong>去实现的。</p><p>执行push时(即，将元素推入栈中)，是通过将元素追加的数组的末尾中。</p><p>执行peek时(即，取出栈顶元素，不执行删除)，是返回数组末尾的元素。</p><p>执行pop时(即，取出栈顶元素，并将该元素从栈中删除)，是取出数组末尾的元素，然后将该元素从数组中删除。</p><p>Stack继承于Vector，意味着Vector拥有的属性和功能，Stack都拥有。</p><a id="more"></a><h3 id="225-Implement-Stack-with-Queue"><a href="#225-Implement-Stack-with-Queue" class="headerlink" title="225.Implement Stack with Queue"></a>225.Implement Stack with Queue</h3><p>Implement the following operations of a stack using queues.</p><ul><li>push(x) – Push element x onto stack.</li><li>pop() – Removes the element on top of the stack.</li><li>top() – Get the top element.</li><li>empty() – Return whether the stack is empty.</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyStack stack = new MyStack();</span><br><span class="line">stack.push(1);</span><br><span class="line">stack.push(2);  </span><br><span class="line">stack.top();   // returns 2</span><br><span class="line">stack.pop();   // returns 2</span><br><span class="line">stack.empty(); // returns false</span><br></pre></td></tr></table></figure><p><strong>Notes:</strong></p><ul><li>You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty operations are valid.</li><li>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.</li><li>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</li></ul><p><strong>维护两个队列</strong></p><ul><li>Push O(n),Pop O(1)<ul><li>Push: q2存放新元素，q1元素逐个添加到q2队尾，q1，q2互换</li><li>Pop: q1.poll()</li><li>Top: q1.peek()</li><li>Empty: q1.isEmpty()</li></ul></li><li>Push O(1),Pop O(n)<ul><li>Push: q1直接存,并更新top值</li><li>Pop: q1的大小大于1时，更新top值，并移到q2;删除q1的值，交换q1,q2</li><li>Top: 直接返回top</li><li>Empty: q1.isEmpty()</li></ul></li></ul><p><strong>维护一个队列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> LinkedList&lt;Integer&gt; q1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push element x onto stack.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    q1.add(x);</span><br><span class="line">    <span class="keyword">int</span> sz = q1.size();</span><br><span class="line">    <span class="keyword">while</span> (sz &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        q1.add(q1.remove());</span><br><span class="line">        sz--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="232-Implement-Queue-with-stacks"><a href="#232-Implement-Queue-with-stacks" class="headerlink" title="232.Implement Queue with stacks"></a>232.Implement Queue with stacks</h3><p>Implement the following operations of a queue using stacks.</p><ul><li>push(x) – Push element x to the back of queue.</li><li>pop() – Removes the element from in front of queue.</li><li>peek() – Get the front element.</li><li>empty() – Return whether the queue is empty.</li></ul><p><strong>Example:</strong></p><pre><code>MyQueue queue = new MyQueue();queue.push(1);queue.push(2);  queue.peek();  // returns 1queue.pop();   // returns 1queue.empty(); // returns false</code></pre><p><strong>Notes:</strong></p><ul><li>You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid.</li><li>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.</li><li>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</li></ul><p><strong>(Two Stacks) Push - O(1) per operation, Pop - Amortized O(1) per operation.</strong></p><ul><li>Push: s1直接存,记录下最开始s1为空时的peek值</li><li>Pop: s2为空时，把s1中的值pop到s2,再返回s2.pop()</li><li>Peek: s2为空直接返回peek,否则返回s2.peek()</li><li>Empty: s1.isEmpty()&amp;&amp;s2.isEmpty()</li></ul><h3 id="155-Min-Stack"><a href="#155-Min-Stack" class="headerlink" title="155.Min Stack"></a>155.Min Stack</h3><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><ul><li>push(x) – Push element x onto stack.</li><li>pop() – Removes the element on top of the stack.</li><li>top() – Get the top element.</li><li>getMin() – Retrieve the minimum element in the stack.</li></ul><p><strong>Example:</strong></p><pre><code>MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --&gt; Returns -3.minStack.pop();minStack.top();      --&gt; Returns 0.minStack.getMin();   --&gt; Returns -2.</code></pre><p><strong>使用两个栈(借助辅助栈，存储min)</strong></p><ul><li>Push: s1直接push，当s2为空或者新入栈的元素小于等于栈顶元素时，s2也入栈</li><li>Pop: s1直接pop，如果s1中pop的元素和s2栈顶元素相同，s2也pop</li><li>Top: s1.peek()</li><li>GetMin: s2.peek()</li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20.Valid Parentheses"></a>20.Valid Parentheses</h4><p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p>Note that an empty string is also considered valid.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;()&quot;Output: true</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: &quot;()[]{}&quot;Output: true</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: &quot;(]&quot;Output: false</code></pre><p><strong>Example 4:</strong></p><pre><code>Input: &quot;([)]&quot;Output: false</code></pre><p><strong>Example 5:</strong></p><pre><code>Input: &quot;{[]}&quot;Output: true</code></pre><ul><li>典型Stack的题，符号匹配<ul><li>是左括号，则入栈</li><li>判断是否是对应的右括号，同时栈不为空</li><li>都不满足，则返回false</li><li>最后判断栈是否为空</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'('</span> || c == <span class="string">'['</span> || c == <span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">')'</span> &amp;&amp; !stack.empty() &amp;&amp; stack.peek() == <span class="string">'('</span>)&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">']'</span> &amp;&amp; !stack.empty() &amp;&amp; stack.peek() == <span class="string">'['</span>)&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'&#125;'</span> &amp;&amp; !stack.empty() &amp;&amp; stack.peek() == <span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>更简洁的解法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'('</span>)</span><br><span class="line">stack.push(<span class="string">')'</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'&#123;'</span>)</span><br><span class="line">stack.push(<span class="string">'&#125;'</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'['</span>)</span><br><span class="line">stack.push(<span class="string">']'</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || stack.pop() != c)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="150-Evaluate-Reverse-Polish-Notation"><a href="#150-Evaluate-Reverse-Polish-Notation" class="headerlink" title="150.Evaluate Reverse Polish Notation"></a>150.Evaluate Reverse Polish Notation</h4><p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p><p>Valid operators are +, -, *, /. Each operand may be an integer or another expression.</p><p><strong>Note:</strong></p><ul><li>Division between two integers should truncate toward zero.</li><li>The given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation.</li></ul><p><strong>Example 1:</strong></p><pre><code>Input: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]Output: 9Explanation: ((2 + 1) * 3) = 9</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]Output: 6Explanation: (4 + (13 / 5)) = 6</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]Output: 22Explanation:  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22</code></pre><p><strong>解题思路</strong></p><ul><li>用栈解决</li><li>遇到数字直接入栈</li><li>遇到操作符，则pop出两个数字，进行计算，计算后的值接着入栈</li><li>需要注意的是除法的时候，是后pop出来的除以先pop出来的</li></ul><h4 id="84-Largest-Rectangel-in-Histrogram"><a href="#84-Largest-Rectangel-in-Histrogram" class="headerlink" title="84.Largest Rectangel in Histrogram"></a>84.Largest Rectangel in Histrogram</h4><blockquote><p>在DP专题总结过</p></blockquote><p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. </p><p><img src="http://p9fh1pach.bkt.clouddn.com/1418713310-55de4fd532244.png" alt="avatar"></p><p>Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].</p><p><img src="http://p9fh1pach.bkt.clouddn.com/765770818-55de4fe7f3337.png" alt="avatar"></p><p>The largest rectangle is shown in the shaded area, which has area = 10 unit.</p><ul><li>栈，存放数组的index</li><li>栈为空或者数组是递增状态，则直接push</li><li>小于则pop，并计算当前的最大面积</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = height.length;</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> h = (i == len ? <span class="number">0</span> : height[i]);</span><br><span class="line">            <span class="keyword">if</span>(s.isEmpty() || h &gt;= height[s.peek()])&#123;</span><br><span class="line">                s.push(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> tp = s.pop();</span><br><span class="line">                maxArea = Math.max(maxArea, height[tp] * (s.isEmpty() ? i : i - <span class="number">1</span> - s.peek()));</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>, largestArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; height.length || (index == height.length &amp;&amp; !stack.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index != height.length &amp;&amp; (stack.isEmpty() || height[stack.peek()] &lt; height[index])) &#123;</span><br><span class="line">                stack.push(index++);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = height[stack.pop()];</span><br><span class="line">                <span class="keyword">int</span> w = stack.isEmpty() ? index : index - stack.peek() - <span class="number">1</span>;</span><br><span class="line">                largestArea = Math.max(largestArea, h * w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> largestArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="85-Maximal-Rectangle"><a href="#85-Maximal-Rectangle" class="headerlink" title="85.Maximal Rectangle"></a>85.Maximal Rectangle</h4><blockquote><p>在DP专题总结过</p></blockquote><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing all 1’s and return its area.</p><ul><li>要求最大的矩形，实际上可以将矩阵的每一行，转化为上一题的直方图，</li><li>而直方图的每个竖条的数字，就是该行对应坐标正上方，向上方向有多少个连续的1。</li><li>要转化为直方图，方法是每一行的数值都累加上一行计算出来的数值，而第一行的数值就是本身。如果原始矩阵中遇到0，则累加中断，重新置0。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 0 1 1 0 -&gt; 0 0 1 1 0</span><br><span class="line">0 0 1 1 0 -&gt; 0 0 2 2 0</span><br><span class="line">1 1 0 0 0 -&gt; 1 1 0 0 0</span><br><span class="line">1 1 1 0 0 -&gt; 2 2 1 0 0</span><br></pre></td></tr></table></figure><ul><li>dp[i][j]化为直方图的值</li><li>接着对dp[i][j]进行Largest Rectangle in Histogram计算即可</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i == 0 --&gt; dp[i][j] = matrix[i][j] - &apos;0&apos;</span><br><span class="line">i != 0 --&gt; </span><br><span class="line">matrix[i][j] == 1 --&gt; dp[i][j] = dp[i-1][j] + matrix[i][j] - &apos;0&apos;</span><br><span class="line">matrix[i][j] != 1 --&gt; dp[i][j] = 0</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="comment">// 如果是第一行就是自身，如果遇到0则停止累加</span></span><br><span class="line">                dp[i][j] =  i == <span class="number">0</span> ? matrix[i][j] - <span class="string">'0'</span> : matrix[i][j] == <span class="string">'1'</span> ? dp[i-<span class="number">1</span>][j] + matrix[i][j] - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++)&#123;</span><br><span class="line">            <span class="comment">//找每行的最大矩形</span></span><br><span class="line">            <span class="keyword">int</span> tmp = findRowMax(i, dp);</span><br><span class="line">            max = Math.max(max, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findRowMax</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span>[][] matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[row].length== <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stk = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, max = matrix[row][<span class="number">0</span>];</span><br><span class="line">        stk.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(i &lt; matrix[row].length || (i == matrix[row].length &amp;&amp; !stk.isEmpty()))&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != matrix[row].length &amp;&amp; ( stk.isEmpty() || matrix[row][i] &gt;= matrix[row][stk.peek()] ))&#123;</span><br><span class="line">                stk.push(i);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> top = matrix[row][stk.pop()];</span><br><span class="line">                <span class="keyword">int</span> currMax = !stk.isEmpty() ? top * (i - stk.peek() - <span class="number">1</span>) : top * i;</span><br><span class="line">                max = Math.max(currMax, max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="71-Simplify-Path"><a href="#71-Simplify-Path" class="headerlink" title="71.Simplify Path"></a>71.Simplify Path</h4><p>Given an absolute path for a file (Unix-style), simplify it.</p><p>For example,</p><p><strong>path</strong> = “/home/“, =&gt; “/home”</p><p><strong>path</strong> = “/a/./b/../../c/“, =&gt; “/c”</p><p><strong>Corner Cases:</strong></p><ul><li>Did you consider the case where path = “/../“?<br>In this case, you should return “/“.</li><li>Another corner case is the path might contain multiple slashes ‘/‘ together, such as “/home//foo/“.In this case, you should ignore redundant slashes and return “/home/foo”.</li></ul><p><strong>题目意思</strong></p><ul><li>.可忽略，..需要pop掉上一个，比如/b/../c/ -&gt; /c</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">for</span>(String cur: path.split(<span class="string">"/"</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.equals(<span class="string">".."</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!stack.empty()) stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.length()&gt;<span class="number">0</span> &amp;&amp; !cur.equals(<span class="string">"."</span>)) stack.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/"</span>+String.join(<span class="string">"/"</span>,stack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 算法 </category>
          
          <category> LeetCode Category </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>类文件结构</title>
      <link href="/2018/06/25/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
      <url>/2018/06/25/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h2 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h2><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG272.jpeg" alt="avatar"></p><p>Class文件的头4个字节称为魔数(magic),用于确定文件是否是能被虚拟机接收的Class文件。0xCAFEBABE 代表Java</p><p>紧接着的是Class文件的版本号：第5和第6字节是次版本号(minor_version),第7和第8字节是主版本号(major_version)</p><a id="more"></a><p>紧接着主次版本号之后的是常量池入口，由于常量数量不固定，需要放置常量池容量计数值(constant_pool_count), <strong>计数从1开始</strong>, (0用来表示“不引用任何一个常量池项目”)</p><p>常量池中存放两大类常量：字面量和符号引用。字面量接近Java中常量的概念，而符号引用则属于编译原理方面的概念，包含三大类：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p><strong>JDK的bin目录中，javap工具-verbose可用于输出常量表</strong></p><p>常量池结束之后，是访问标志(access_flags), 用于识别一些类或者接口的访问信息。包括是否public、final、abstract等</p><p>类索引(this_class)、父类索引(super_class)分别确定类、父类的全限定名。接口索引集合(interfaces), 由这三项数据确定类的继承关系。</p><p>字段表(field_info)用于描述接口或者类中声明的变量，字段包括类级变量以及实例级变量。</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG273.jpeg" alt="avatar"></p><p>方法表和字段表相似，结构也包含上述的4个部分，仅在访问标志和属性表集合的可选项中有些区别，方法里面的代码存放在属性表集合中“Code”属性中。</p><p>属性表集合，不需要严格顺序，几个常用属性讲解：</p><ul><li>Code属性<ul><li>使用位置：方法表，Java代码编译成的字节码指令</li></ul></li><li>Exceptions属性<ul><li>列出方法中可能抛出的异常，即throws关键字后列举的异常</li></ul></li><li>LineNumberTable属性<ul><li>描述Java源码行号和字节码行号之间的对应关系，选择不生成，则抛出异常时没有出错行号</li></ul></li><li>LocalVariableTable属性<ul><li>描述栈帧中局部变量表中的变量和Java源代码中定义的变量之间的关系，如果不生成，当别人引用该方法时，参数名称会丢失，IDE使用args1等占位符替代，带来不便</li></ul></li><li>SourceFile属性<ul><li>记录生成这个Class文件的源码文件名称，选择不生成，则抛出异常时，不显示出错代码的文件名</li></ul></li><li>ConstantValue属性<ul><li>通知虚拟机为静态变量赋值</li><li>非static变量，在实例构造器init中进行</li><li>类变量，类构造器clinit中/使用ConstantValue</li><li>Sun Javac中，如果同时使用static和final修饰，并且是基本数据类型或者String时，生成ConstantValue来进行初始化，如果没有被final修饰或者类型不符，则在clinit中初始化</li></ul></li><li>InnerClasses属性<ul><li>记录内部类和宿主类之间的关联。如果一个类中定义了内部类，编译器会为它以及它所包含的内部类生成该属性</li></ul></li><li>Deprecated及Synthetic属性<ul><li>标志类型的布尔类型</li><li>Deprecated表示类、字段或方法，已经被程序作者定为不再推荐使用，可以使用@ deprecated注解设置</li><li>Synthetic表示字段或者方法不是由Java源码直接产生的，而是由编译器添加的。所有由非用户生成的类、方法及字段都应该至少设置Synthetic属性或者ACC_SYNTHETIC标志位，但是实例构造器init和类构造器clinit除外</li></ul></li><li>StackMapTable属性<ul><li>位于Code属性的属性表中，在虚拟机类加载的字节码验证阶段被新类型检查验证器使用，用于代替之前比较消耗性能的基于数据流分析的类型推导验证器</li><li>一个方法的Code属性醉倒只能有一个StackMapTable</li></ul></li><li>Signature属性<ul><li>记录泛型类型，Java采用的是擦除法实现的伪泛型，泛型信息编译之后会被擦除，比如运行前做反射时无法得到泛型类型</li></ul></li></ul><h2 id="字节码指令简介"><a href="#字节码指令简介" class="headerlink" title="字节码指令简介"></a>字节码指令简介</h2><p>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字(操作码)以及紧随其后的零至多个代表此操作所需参数(操作数)而构成。Java虚拟机采用操作数栈，大多数质量都不包含操作数。</p><ul><li>加载和存储指令<ul><li>将数据在栈帧中的局部变量表和操作数栈之间来回传输</li></ul></li><li>运算指令<ul><li>用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入操作栈顶</li></ul></li><li>类型转换指令<ul><li>将两种不同的数值类型进行转换，<strong>显式类型转换</strong></li></ul></li><li>对象创建与访问指令<ul><li>针对类实例和数组</li></ul></li><li>操作数栈管理指令<ul><li>直接操作操作数栈，类似操作数据结构中的堆栈</li></ul></li><li>控制转移指令<ul><li>让Java虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的下一条指令继续执行程序。(条件分支ifeq、复合条件分支、无条件分支goto)</li></ul></li><li>方法调用和返回指令<ul><li>方法调用(分派、执行过程)指令与数据类型无关，方法返回指令根据返回值的类型区分</li></ul></li><li>异常处理指令<ul><li>Java中显式抛出异常的操作(throw)都由athrow来实现，很多运行时异常会在检测到时自动抛出</li><li>Java虚拟机中，处理异常(catch)，采用异常表来完成</li></ul></li><li>同步指令<ul><li>支持方法级的同步和方法内部一段指令序列的同步，都使用管程(Monitor)来支持</li><li>方法级同步时隐式的，实现在方法调用和返回操作之中。虚拟机得知是否为同步方法，方法调用时，检查ACC_SYNCHRONIZED访问标志是否被设置，设置则要求成功持有管程，然后才能执行方法，方法完成(成功/失败)时释放管程。方法执行期间，其他线程无法获得该管程。如果同步期间抛出异常，并在内部无法处理，则管程会在异常抛出到同步方法之外时释放</li><li>同步一段指令序列通过synchronized语句块来表示，Java指令集中monitorenter和monitorexit来支持synchronized语义</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 读书笔记 </category>
          
          <category> 深入理解Java虚拟机 </category>
          
          <category> 虚拟机执行子系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Class </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTP中GET与POST的区别</title>
      <link href="/2018/06/20/HTTP/"/>
      <url>/2018/06/20/HTTP/</url>
      <content type="html"><![CDATA[<p>GET和POST是HTTP请求的两种基本方法，最直观的区别就是GET把<strong>参数</strong>包含在URL中，POST通过request body传递参数。</p><p>你轻轻松松的给出了一个<strong>“标准答案”</strong>：</p><a id="more"></a><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求。 </li><li>GET产生的URL地址可以被Bookmark，而POST不可以。 </li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。 </li><li>GET请求只能进行url编码，而POST支持多种编码方式。 </li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 </li><li>GET请求在URL中传送的参数是有长度限制的，而POST没有。 </li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 </li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 </li><li>GET参数通过URL传递，POST放在Request body中。</li></ul><p><strong>GET和POST是什么?</strong></p><p>HTTP协议中的两种发送请求的方法。</p><p><strong>HTTP是什么?</strong></p><p>HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。</p><p>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。</p><p>那么，“标准答案”里的那些区别是怎么回事?</p><p>在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签(设置method为GET)，而且要求把传送的数据放在车顶上(url中)以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩;也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。<br>但是，我们只看到HTTP对GET和POST参数的传送渠道(url还是requrest body)提出了要求。“标准答案”里关于参数大小的限制又是从哪来的呢?</p><p>在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器(发起http请求)和服务器(接受http请求)就是不同的运输公司。虽然理论上，你可以在车顶上无限的堆货物(url中无限加参数)。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，<strong>(大多数)浏览器通常都会限制url长度在2K个字节，而(大多数)服务器最多处理64K大小的url。</strong>超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。<br>好了，现在你知道，<strong>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同</strong>。</p><p>GET和POST还有一个<strong>重大区别</strong>，简单的说：</p><ul><li>GET产生一个TCP数据包;POST产生两个TCP数据包。</li></ul><p>长的说：</p><ul><li>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);</li><li>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。</li></ul><p>也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。</p><p>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑!跳入需谨慎。为什么?</p><ol><li>GET与POST都有自己的语义，不能随便混用。</li><li>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</li><li>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</li></ol><p><a href="http://www.techweb.com.cn/network/system/2016-10-11/2407736.shtml" target="_blank" rel="noopener">本文参考地址</a></p>]]></content>
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算机网络 -- 传输层</title>
      <link href="/2018/06/19/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>/2018/06/19/%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      <content type="html"><![CDATA[<p><strong>知识架构图如下:</strong></p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG268.jpeg" alt="avatar"></p><a id="more"></a><h2 id="传输层提供的服务"><a href="#传输层提供的服务" class="headerlink" title="传输层提供的服务"></a>传输层提供的服务</h2><h3 id="传输层的功能"><a href="#传输层的功能" class="headerlink" title="传输层的功能"></a>传输层的功能</h3><p>面向通信部分的最高层，用户功能中的最低层。传输层提供<strong>可靠</strong>服务（尽管网络层不可靠）</p><p><strong>传输层的功能：</strong></p><ul><li>传输层为运行在不同主机上的<strong>进程</strong>提供逻辑通信（端到端通信），而网络层提供<strong>主机</strong>之间的逻辑通信。</li><li>复用和分用<ul><li>传输层：（复用）不同进程可用同一传输协议，（分用）可剥离给不同进程</li><li>网络层：（复用）不同协议数据可封装成IP数据报发送出去，（分用）可剥离给不同协议</li></ul></li><li>传输层对收到的报文进行差错检测（首部和数据部分），网络层只检测IP数据报的首部，不检验数据部分是否出错</li><li>提供两种不同的传输协议，面向连接的TCP和无连接的UDP，网络层无法同时实现两种</li></ul><h3 id="传输层的寻址与端口"><a href="#传输层的寻址与端口" class="headerlink" title="传输层的寻址与端口"></a>传输层的寻址与端口</h3><ul><li>端口的作用<ul><li>让应用进程将数据通过端口交付给传输层</li><li>让传输层知道讲数据交付给应用层对于进程</li></ul></li><li>端口号：只有本地意义<ul><li>服务端使用的端口号</li><li>客户端使用的端口号，短暂端口号</li></ul></li><li>套接字：组合识别端点<ul><li><strong>IP地址</strong>标识和区别不同主机，<strong>端口号</strong>标识和区别主机众不同应用进程，<strong>套接字</strong>组合识别端点</li><li><strong>套接字 = （主机IP地址，端口号）</strong></li></ul></li></ul><h3 id="无连接服务与面向连接服务"><a href="#无连接服务与面向连接服务" class="headerlink" title="无连接服务与面向连接服务"></a>无连接服务与面向连接服务</h3><ul><li>面向连接服务就是在通信之前，必须建立连接，通信过程中，实时监控和管理连接情况。通信结束后，应该释放连接。<ul><li>TCP不提供广播或组播服务，适合可靠性更重要的场合，如FTP，HTTP，TELNET（远程登录）</li></ul></li><li>无连接的服务，通信不需要先建立连接，需要通信时，直接将信息发送到“网络”中，让信息的传递尽力往目的地传送<ul><li>UDP在IP之上提供多路复用和对数据的错误检查，执行速度快，实时性好，TFTP（小文件传送协议），DNS，SNMP（简单网络管理协议）和RTP（实时协议）</li></ul></li></ul><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><h3 id="UDP数据报"><a href="#UDP数据报" class="headerlink" title="UDP数据报"></a>UDP数据报</h3><p>UDP = IP + 复用/分用 + 差错检测</p><p><strong>UDP优点：</strong></p><ul><li>UDP无需建立连接，没有建立连接的时延</li><li>无连接状态，能支持更多的活动客户机</li><li>首部开销小，8字节开销</li><li>应用层能更好地控制要发送的数据和发送时间，无拥塞控制，发送发自由</li></ul><p>UDP用于一次性传输少量数据的网络应用，也用于多媒体应用，不保证可靠性交付但要求低延迟，应用层可灵活设计可靠性机制保证可靠性。</p><p>UDP面向报文，发送方UDP对应用层交下来的报文，添加首部后直接给IP层，不合并，不拆分；接收方UDP对IP层交上来的数据报，去除首部后直接给应用进程，一次交付一个完整的报文。（以报文为操作单位）</p><p>UDP数据报 = UDP首部（8B） + 用户数据</p><ul><li>源端口：需要对方回信时用，不用则为0</li><li>目的端口</li><li>长度：最小值为8（仅首部）</li><li>校验和：检验UDP数据报在传输中是否出错，有错则丢弃。源主机不想计算校验和，则为0</li></ul><h3 id="UDP校验"><a href="#UDP校验" class="headerlink" title="UDP校验"></a>UDP校验</h3><p>采用首部、伪首部、数据进行二进制反码运算求和再取反</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG269.jpeg" alt="avatar"></p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="TCP协议的特点"><a href="#TCP协议的特点" class="headerlink" title="TCP协议的特点"></a>TCP协议的特点</h3><ul><li>面向连接</li><li>点对点（一对一）</li><li>可靠的交付，无差错、不丢失、不重复且有序</li><li>全双工通信，通信双方都可发送数据</li><li>面向字节流</li></ul><h3 id="TCP报文段-TCP传送的数据单元"><a href="#TCP报文段-TCP传送的数据单元" class="headerlink" title="TCP报文段(TCP传送的数据单元)"></a>TCP报文段(TCP传送的数据单元)</h3><p>TCP报文段分为首部和数据两部分，整个TCP段作为IP数据报的数据部分封装在IP数据报中。首部前20字节是固定的，后面有4N字节是根据需要而增加的选项。</p><p><img src="http://p9fh1pach.bkt.clouddn.com/201806191848.png" alt="avatar"></p><p>TCP报文段既可以用来运载数据，也可以用来建立/释放连接，应答。</p><ul><li>序号字段：4字节，指的是本报文段所发送的数据的第一个字节的序号</li><li>确认号字段：4字节，期望收到对方的下一个报文段的数据的第一个字节的序号。若确认号为N，则表示到序号N-1为止的数据都已正确收到</li><li>数据偏移：首部长度，4位</li><li>保留字段：6位，目前置0</li><li>紧急位URG：URG = 1时，表示<strong>紧急指针</strong>有效，表明有紧急数据，需要尽快送达。URG需要和紧急指针配套使用，数据从第一个字节到紧急指针所指字节就是<strong>紧急数据</strong></li><li>确认位ACK：ACK = 1时<strong>确认号字段</strong>才有效。连接建立后所有传送的报文段都必须把ACK置1</li><li>推送位PSH：（PSH = 1）尽快交付接收应用进程，不用等到缓冲区满了再交付</li><li>复位位RST：（RST = 1）连接出现严重差错，必须释放连接，然后再重新建立运输连接</li><li>同步位SYN：SYN = 1表示这是一个连接请求或连接接收报文<ul><li>SYN = 1，ACK = 0，连接请求报文</li><li>SYN = 1，ACK = 1，连接接收报文</li></ul></li><li>终止位FIN：（FIN = 1）发送方数据发送完毕，要求释放连接</li><li>窗口字段：2字节，指出允许对方发送的数据量</li><li>检验和：2字节，检验首部和数据，计算时和UDP相似，也要加12字节的伪首部，将UDP中的17 -&gt; 6</li><li>紧急指针字段：16位，指出本报文段中紧急数据的字节总数（紧急数据放在报文段数据的最前面）</li><li>选项字段：最大报文段长度（MSS），MSS是TCP报文段中的数据字段的最大长度</li><li>填充字段：为了使整个首部长度是4字节的整数倍</li></ul><h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><p>TCP连接的端口叫套接字，每一条TCP连接唯一地被通信两端的两个端点所确定。</p><h4 id="TCP连接的建立（三次握手）"><a href="#TCP连接的建立（三次握手）" class="headerlink" title="TCP连接的建立（三次握手）"></a>TCP连接的建立（三次握手）</h4><p><img src="http://p9fh1pach.bkt.clouddn.com/20170607205709367.gif" alt="avatar"></p><blockquote><p>最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。</p></blockquote><ul><li>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</li><li>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。<strong>TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</strong></li><li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。<strong>这个报文也不能携带数据，但是同样要消耗一个序号。</strong></li><li>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。<strong>TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</strong></li><li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。 </li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/20170605110405666.png" alt="avatar"></p><p>TCP是全双工通信，通信双方的应用进程在任何时候都能发送数据。</p><p>服务器的资源是在完成第二次握手时分配的，客户端资源是在完成第三次握手时分配的。这使服务器易于受到SYN洪泛攻击。</p><pre><code>Q:为什么TCP客户端最后还要发送一次确认呢？A:防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</code></pre><h4 id="TCP连接的释放（四次挥手）"><a href="#TCP连接的释放（四次挥手）" class="headerlink" title="TCP连接的释放（四次挥手）"></a>TCP连接的释放（四次挥手）</h4><p><img src="http://p9fh1pach.bkt.clouddn.com/20170607205756255.gif" alt="avatar"></p><blockquote><p>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。</p></blockquote><ul><li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。<strong>TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</strong></li><li>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。<strong>TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。*</strong>这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。*</li><li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文<strong>（在这之前还需要接受服务器发送的最后的数据）</strong>。</li><li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li><li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。<strong>注意此时TCP连接还没有释放，必须经过2[Math Processing Error]MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</strong></li><li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。<strong>可以看到，服务器结束TCP连接的时间要比客户端早一些。</strong></li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/20170606084851272.png" alt="avatar"></p><p><strong>为什么客户端最后还要等待2MSL？</strong></p><ul><li>保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，<strong>站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次</strong>，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</li><li>防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</li></ul><p><strong>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</strong></p><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 </p><p>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p><h3 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h3><p>保证接收方进程从缓冲区读出的字节流与发送方发出的字节流是完全一样的</p><p>使用了校验、序号、确认和重传等机制来达到目的</p><ul><li>序号：TCP 数据段以字节为单位对数据段中的“数据”部分进行一一编号，确保每个字节的数据都可以有序传送和接受</li><li>确认：TCP 要求每接受一个数据段都必须由接收端向发送端返回一个确认数据段，其中的“确认号”表明接收端已正确接受的数据段序号（“确认号”前面的所有数据段，确认号表示将要接收的下一个数据段编号）。</li><li>重传<ul><li>超时：超出计时器的重传时间还未收到确认则重传，RTT</li><li>冗余：TCP规定每当比期望序号大的失序报文段到达时，发送一个冗余ACK，指明下一个期待字节的序列号。TCP规定当发送方收到对同一个报文段的3个冗余ACK时，可以认为跟在这个被确认的报文段之后的报文段已经丢失（<strong>快重传</strong>）。</li></ul></li></ul><h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><p>在确认报文中设置窗口字段rwnd来限制发送速率，发送方可也根据当前网络拥塞程度设置拥塞窗口cwnd。<strong>发送窗口的实际大小取rwnd和cwnd的最小值</strong></p><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>根据自己估算的网络拥塞程度设置cwnd来限制发送速率</p><ul><li>慢开始算法：刚连接的TCP，令cwnd = 1（一个最大报文段长度），每收到一个确认后加1。每经过一个RTT，cwnd加倍，直到慢开始门限（ssthresh），改用拥塞避免算法</li><li>拥塞避免算法：cwnd每经过一个RTT就加1（<strong>加法增大</strong>），当出现一次超时，令慢开始门限等于当前cwnd的一半（<strong>乘法减小</strong>）</li></ul><p>根据cwnd的大小执行不同算法：</p><ul><li>cwnd &lt; ssthresh,慢开始算法</li><li>cwnd &gt; ssthresh,停止慢开始，使用拥塞避免算法</li><li>cwnd = ssthresh,都可以（通常使用拥塞避免算法）</li></ul><p>一旦网络出现拥塞时，都要把ssthresh设为cwnd的一半（但不能小于2），然后把cwnd设为1，执行慢开始算法。</p><p>快重传、快恢复是对慢开始算法和拥塞避免算法的改进。</p><ul><li>快重传：发送方连续收到三个重复的ACK时，直接重传对方尚未收到的报文段</li><li>快恢复：发送方连续收到三个重复的ACK时，就执行“乘法减小”，将ssthresh设置为cwnd的一半。<strong>把cwnd设为ssthresh改变后的值</strong>，然后开始执行拥塞避免算法（“加法增大”）</li></ul>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 读书笔记 </category>
          
          <category> 计算机网络 </category>
          
          <category> 传输层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算机网络 -- 网络层</title>
      <link href="/2018/06/13/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/2018/06/13/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      <content type="html"><![CDATA[<p><strong>知识架构图如下:</strong></p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG265.jpeg" alt="avatar"></p><a id="more"></a><h2 id="网络层的功能"><a href="#网络层的功能" class="headerlink" title="网络层的功能"></a>网络层的功能</h2><h3 id="异构网络互联"><a href="#异构网络互联" class="headerlink" title="异构网络互联"></a>异构网络互联</h3><p>网络的互联，指的是将两个以上的计算机网络，通过一定的方法，用一种或多种通信处理设备(即中间设备/中间系统/中继系统)相互连接起来，以构成更大的网络系统。</p><p>四种不同的中继系统：</p><ul><li>物理层中继系统: 中继器，集线器(Hub)</li><li>数据链路层中继系统: 网桥或交换机</li><li>网络层中继系统: 路由器</li><li>网络层以上的中继系统: 网关</li></ul><p>物理层、数据链路层中继系统，只是扩大网络，但仍然是同一个网络，称不上互联。</p><p>网络互联通常是指用路由器进行网络互联和路由选择，路由器就是一台专用计算机，用于在互联网中进行路由选择。</p><p>虚拟(逻辑)互联网络，互联起来的各种物理网络的异构行本来是客观存在的，但使用IP协议可以看起来是一个统一的网络。</p><p>使用虚拟(逻辑)互联网络的好处：当互联网的主机进行通信时，就好像在一个网络上通信一样，而看不见互联的具体的网络异构细节。</p><h3 id="路由与转发"><a href="#路由与转发" class="headerlink" title="路由与转发"></a>路由与转发</h3><p>路由器主要完成两个功能：</p><ul><li><strong>路由选择</strong>(确定哪一条路径): 按照分布式算法，根据从相邻路由器所得到的关于整个网络拓扑的变化情况，动态改变所选路由</li><li><strong>分组转发</strong>(当一个分组到达时所采取的动作): 根据转发表将用户的IP数据报从合适的端口转发出去</li></ul><p>路由表是根据路由选择算法得出的，转发表从路由表得出。转发表的结构应该使查找过程最优化，路由表则需要对网络拓扑变化的计算最优化。</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>在通信子网中，由于出现过量的分组而引起网络性能下降的现象称为<strong>拥塞</strong>。</p><p>判断网络是否进入拥塞状态的方法是观察网络的吞吐量和网络负载的关系：</p><p>网络负载增加:</p><ul><li>吞吐量小于正常:  <ul><li>“轻度拥塞”</li></ul></li><li>吞吐量下降:     <ul><li>拥塞</li></ul></li><li>吞吐量将为0:    <ul><li>死锁</li></ul></li></ul><p><strong>流量控制与拥塞控制的区别</strong>: 流量控制指在发送端和接收端之间的点对点通信量的控制。流量控制所要做的就是抑制发送端发送端发送数据的速率，以便接收端来得及接收。而拥塞控制必须确保通信子网能够传送待传送的数据，是一个全局性的问题，设计网络中所有主机、路由器以及导致网络传输能力下降的所有因素。</p><p>拥塞控制的方法：</p><ul><li>开环控制: 静态预防，视线尽可能考虑好，启动后不修改，不考虑当前网络状态</li><li>闭环控制: 事先不管，动态监控，启动后监视检测，及时解决，基于反馈环路概念</li></ul><h2 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h2><h3 id="静态路由与动态路由"><a href="#静态路由与动态路由" class="headerlink" title="静态路由与动态路由"></a>静态路由与动态路由</h3><p>从能否随网络的通信量货拓扑自适应地进行调整变化来划分，可分为两大类：</p><ul><li>静态路由算法(非自适应): 网络管理员手工配置的路由信息。网络拓扑或链路状态变化时，需要手工修改路由表中相关的静态路由信息。<ul><li>简便、可靠，适合负荷稳定、拓扑变化不大的网络</li><li>不适合大型、复杂网络环境</li></ul></li><li>动态路由算法(自适应): 路由器上的路由表项是通过相互连接的路由器之间彼此交换信息，然后按照一定的算法优化出来的，这些信息是在一定时间间隙里不断更新，以适应不断变化的网络，以随时获得最优的寻路效果<ul><li>改善网络性能并有助于流量控制</li><li>算法复杂，增加网络负担，有时因对动态变化的反应太快而引起振荡，或反应太慢而影响网络路由的一致性</li></ul></li></ul><h3 id="距离-向量路由算法（最常见RIP算法）"><a href="#距离-向量路由算法（最常见RIP算法）" class="headerlink" title="距离-向量路由算法（最常见RIP算法）"></a>距离-向量路由算法（最常见RIP算法）</h3><p>所有结点都定期将它们的整个路由选择表传送给所有与之直接相邻的结点。这种路由选择表包括：</p><ul><li>每条路径的目的地（另一结点）</li><li>路径的代价（也称距离）</li></ul><p>当被通告有新的路由或者到达某一个目的地的距离更小时，会发生更新</p><h3 id="链路状态路由算法（典型OSPF算法）"><a href="#链路状态路由算法（典型OSPF算法）" class="headerlink" title="链路状态路由算法（典型OSPF算法）"></a>链路状态路由算法（典型OSPF算法）</h3><p>链路状态路由算法要求每个参与该算法的结点都有完全的网络拓扑信息。执行两项任务：</p><ul><li>主动测试所有邻接结点的状态</li><li>定期将链路状态传播给所有其他的结点</li></ul><p>在一个链路状态路由选择中，一个结点检查所有直接链路的状态，并将所得的状态信息发送给网上所有其他结点。</p><p>当链路报文到达时，路由结点根据信息去更新网络拓扑和状态“视野图”，一旦链路状态变化，结点对更新了的网络图利用Dijsktra最短路径算法重新计算路由。</p><p><strong>三点特征：</strong></p><ul><li>泛洪法，路由器通过所有端口向所有相邻的路由器发送信息。而每一个相邻路由器又将此信息发往其所有相邻路由器（不包含刚发来信息的路由器）</li><li>发送的信息就是与路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息</li><li>只有当链路状态变化时，才向所有路由器发送此消息</li></ul><p><strong>优点：</strong></p><ul><li>结点使用同样的原始状态数据独立计算路径，不依赖中间结点</li><li>链路状态报文不加改变地传播，易于查找故障</li><li>链路状态报文只包含单个结点关于直接链路的信息，与网络中路由结点的数量无关</li></ul><p>适用于<strong>大型的或路由信息变化聚敛</strong>的互联网环境</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">特点</th><th style="text-align:center">优缺点</th></tr></thead><tbody><tr><td style="text-align:center">距离-向量路由算法</td><td style="text-align:center">仅与直接邻居交谈，为邻居提供从自己到所有其他结点的费用</td><td style="text-align:center">路由环路</td></tr><tr><td style="text-align:center">链路状态路由算法</td><td style="text-align:center">广播方式与所有其他结点交谈，仅告诉与之直接相连链路的费用</td><td style="text-align:center">更好的规模可伸展性</td></tr></tbody></table><h3 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h3><p>将互联网划分为许多自治系统，每个自治系统自主决定内部使用何种路由选择协议。</p><p>路由选择协议：</p><ul><li>内部网关协议(域内路由选择)：自治系统内部使用，RIP和OSFP</li><li>外部网关协议(域间路由选择)：自治系统之间使用，BGP</li></ul><p>采用层次划分区域虽然使交换信息种类增多，使OSPF协议更复杂，但能使每个区域内交换路由信息的通信量大大减小，因而使OSPF能够用于规模更大的自治系统中。</p><h2 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h2><h3 id="IPV4分组"><a href="#IPV4分组" class="headerlink" title="IPV4分组"></a>IPV4分组</h3><p><img src="http://p9fh1pach.bkt.clouddn.com/20131220194104812.jpeg" alt="avatar"></p><p>总长度：首部+数据，以太网帧最大传送单元MTU为1500字节，数据报总长度不能超过</p><p>标识：每产生一个数据报就加1，并赋值给标识字段。当数据报长度超过MTU时必须分片，数据报片都复制一次标识号以便能正确组装原来的数据报</p><p>标志：是否有片，最低位MF，MF=1表示后面还有分片；MF=0表示最后一个分片。标志字段中间的一位是DF，DF=0才允许分片，片在<strong>目的地的网络层</strong>被重新组装</p><p>片偏移：较长的分组在分片后，某片在原分组中的相对位置</p><p>首部检验和：只校验分组首部，不校验数据部分</p><p><strong>生存时间TTL</strong>：数据报在网络中可通过的路由器数的最大值，标识分组在网络中的寿命，确保分组不会永远在网络中循环</p><p>协议：分组携带的数据使用何种协议</p><p>固定部分20B，<strong>首部长度、总长度、片偏移的基本单位分别为4B、1B、8B</strong></p><h3 id="IPV4地址与NAT"><a href="#IPV4地址与NAT" class="headerlink" title="IPV4地址与NAT"></a>IPV4地址与NAT</h3><h4 id="IPV4地址"><a href="#IPV4地址" class="headerlink" title="IPV4地址"></a>IPV4地址</h4><p>IP地址由网络号和主机号两部分组成</p><h4 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h4><p>将专用网络地址转换为公用地址，从而对外隐藏内部管理的IP地址</p><h3 id="子网划分与子网掩码、CIDR"><a href="#子网划分与子网掩码、CIDR" class="headerlink" title="子网划分与子网掩码、CIDR"></a>子网划分与子网掩码、CIDR</h3><h4 id="子网划分-amp-子网掩码"><a href="#子网划分-amp-子网掩码" class="headerlink" title="子网划分&amp;子网掩码"></a>子网划分&amp;子网掩码</h4><p>采用子网掩码对物理子网再一次进行子网划分。</p><p>计算机只需将IP地址和其对应子网掩码逐位相“与”，就可得出相应子网的网络地址</p><h4 id="无分类编址CIDR"><a href="#无分类编址CIDR" class="headerlink" title="无分类编址CIDR"></a>无分类编址CIDR</h4><p>无分类域间路由选择(CIDR)是在变长子网掩码的基础上提出的一种消除传统A、B、C类网络划分，并且可以在软件的支持下实现超网构造的一种IP地址的划分方法。</p><p><strong>主要特点：</strong></p><ul><li>消除传统A、B、C类地址以及划分子网的概念，IP地址的无分类两级编址为：IP::{&lt;网络前缀&gt;,&lt;主机号&gt;}<ul><li>斜线记法，IP地址/网络前缀所占比特数</li><li>例如128.14.32.5/20，掩码是20个连续的1和后续12个连续的0，逐位相“与”可以得到该地址的网络前缀（或直接截取前20位）</li></ul></li><li>将网络前缀都相同的连续IP地址组成“CIDR”地址块，这种地址的聚合称为<strong>路由聚合</strong>或称为构成超网，<strong>使得</strong>路由表中的一个项目可以表示很多个原来传统分类地址的路由，减少路由器之间路由选择信息的交换。二进制表示的IP地址取最长公共前缀作为网络号。</li></ul><h3 id="ARP协议、DHCP协议与ICMP协议"><a href="#ARP协议、DHCP协议与ICMP协议" class="headerlink" title="ARP协议、DHCP协议与ICMP协议"></a>ARP协议、DHCP协议与ICMP协议</h3><h4 id="IP地址与硬件地址"><a href="#IP地址与硬件地址" class="headerlink" title="IP地址与硬件地址"></a>IP地址与硬件地址</h4><h4 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h4><p>IP地址到MAC地址的映射，每个主机设有一个ARP高速缓存，存放本局域网上各主机和路由器的IP地址到MAC地址的映射表(ARP表)</p><p><strong>ARP工作在网络层</strong>，4中典型情况：</p><ul><li>发送方是主机，把数据报发送到本网络另一个主机。用ARP找到目的主机的硬件地址</li><li>发送方是主机，把数据报发送到另一个网络的一个主机。用ARP找到本网络的一个路由器的硬件地址，剩下的工作由路由器完成</li><li>发送方是路由器，把数据报发送到本网络的一个主机。用ARP找到目的主机的硬件地址</li><li>发送方是路由器，把数据报发送到另一个网络的一个主机。用ARP找到本网络的一个路由器的硬件地址，剩下的工作由路由器完成</li></ul><h4 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h4><p>动态主机配置协议常用于给主机动态分配IP地址，提供了即插即用的联网机制。<strong>应用层协议，基于UDP</strong></p><p>DHCP服务器和DHCP客户端的交换过程如下：</p><ul><li>DHCP客户机广播“DHCP发现”消息，试图找到网络中的DHCP服务器，以便从DHCP服务器获得一个IP地址。由于DHCP客户机还未配置IP地址，它只能使用广播方式发送消息，并且源IP地址设置为0.0.0.0。 </li><li>DHCP服务器收到“DHCP发现”消息后，就向网络中广播“DHCP供给”消息，其中包括提供给DHCP客户机的IP地址和相关配置信息。 </li><li>DHCP客户机收到“DHCP供给”消息，如果接受DHCP服务器所提供的相关参数，就通过广播“DHCP请求”向DHCP服务器请求提供IP地址。 </li><li>DHCP服务器广播“DHCP确认”消息，将IP地址分配给DHCP客户机。</li></ul><h4 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h4><p>用来给主机或路由器报告差错和异常情况。</p><p>ICMP报文作为IP层数据报的数据，加上数据报首部，组成IP数据包发送出去。<strong>ICMP协议是IP层协议</strong></p><p>ICMP的报文种类有ICMP差错报告报文和ICMP询问报文：</p><p>差错报告报文有5种：</p><ul><li>终点不可以到达：当路由器和主机不能交付的时候</li><li>源点抑制：当路由器由于网络拥塞而丢弃的时候，源点把数据报发送速率减慢</li><li>时间超过：当路由器收到生存时间为0的数据报的时候</li><li>参数问题：当目的主机发现收到的数据报首部有问题的时候</li><li>改变路由：路由器把改变你的路由交付主机，告诉下一次的主机</li></ul><p>不应发送ICMP差错报告报文：</p><ul><li>对ICMP差错报告报文不再发送ICMP差错报告报文</li><li>若数据报进行了分片,只有第一个分片能发送ICMP报文</li><li>组播地址的数据报,不发送ICMP报文</li><li>特殊地址(如127.0.0.0或0.0.0.0)不发送ICMP报文</li></ul><p>ICMP询问报文：</p><p>回送请求和回答报文(PING,应用层，直接使用ICMP)、时间戳请求和回答报文(Traceroute/tracert)、掩码地址请求和回答报文、路由器询问和通告报文，最常用的是前两类</p><h2 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h2><h3 id="IPV6的主要特点"><a href="#IPV6的主要特点" class="headerlink" title="IPV6的主要特点"></a>IPV6的主要特点</h3><ul><li>IPv6具有更大的地址空间。32-&gt;128</li><li>扩展的地址层次结构</li><li>灵活的首部格式</li><li>改进的选项。</li><li>允许协议继续扩充。如果新的技术或应用需要时，IPV6允许协议进行扩充</li><li>支持即插即用，IPv6加入了对自动配置（Auto Configuration）的支持。</li><li>支持资源预分配</li><li>不允许分片，只有在包的源结点才能分片</li><li>首部长度必须是8B的整数倍</li><li>IPv6具有更高的安全性。身份验证和保密功能</li></ul><p>与IPV4不兼容，兼容TCP、UDP、ICMP、IGMP、BGP和DNS</p><h3 id="IPV6地址"><a href="#IPV6地址" class="headerlink" title="IPV6地址"></a>IPV6地址</h3><p>IPv6协议主要定义了三种地址类型：单播地址（Unicast Address）、组播地址（Multicast Address）和任播地址（Anycast Address）。与原来在IPv4地址相比，新增了“任播地址”类型，取消了原来IPv4地址中的广播地址，因为在IPv6中的广播功能是通过组播来完成的。</p><ul><li>单播地址：用来唯一标识一个接口，类似于IPv4中的单播地址。发送到单播地址的数据报文将被传送给此地址所标识的一个接口。<strong>点对点</strong></li><li>组播地址：用来标识一组接口（通常这组接口属于不同的节点），类似于IPv4中的组播地址。发送到组播地址的数据报文被传送给此地址所标识的所有接口。<strong>一点对多点</strong></li><li>任播地址：用来标识一组接口（通常这组接口属于不同的节点）。发送到任播地址的数据报文被传送给此地址所标识的一组接口中距离源节点<strong>最近</strong>（根据使用的路由协议进行度量）的一个接口。</li></ul><h2 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h2><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG267.jpeg" alt="avatar"></p><h3 id="自治系统"><a href="#自治系统" class="headerlink" title="自治系统"></a>自治系统</h3><p>一个自治系统内的所有网络属于一个行政单位来管辖，一个自治系统的所有路由器在本自治系统内都必须是连通的。</p><h3 id="域内路由与域间路由"><a href="#域内路由与域间路由" class="headerlink" title="域内路由与域间路由"></a>域内路由与域间路由</h3><p>路由选择协议：</p><ul><li>内部网关协议(IGP)：自治系统内部使用，RIP和OSFP</li><li>外部网关协议(EGP)：自治系统之间使用，BGP-4</li></ul><h3 id="RIP路由协议-距离-向量"><a href="#RIP路由协议-距离-向量" class="headerlink" title="RIP路由协议(距离-向量)"></a>RIP路由协议(距离-向量)</h3><p>路由信息协议，分布式的机遇距离向量的路由选择协议</p><p><strong>RIP的特点</strong></p><ul><li>仅和相邻的路由器交换信息。如果两个路由器之间的通信不经过另外一个路由器，那么这两个路由器是相邻的。RIP协议规定，不相邻的路由器之间不交换信息。</li><li>路由器交换的信息是当前本路由器所知道的全部信息。即自己的路由表。</li><li>按固定时间交换路由信息，如，每隔30秒，然后路由器根据收到的路由信息更新路由表。（也可进行相应配置使其触发更新）</li></ul><p><strong>最大优点</strong>就是实现简单，开销较小，收敛过程快</p><p><strong>缺点：</strong></p><ul><li>限制了网络的规模，能使用的最大距离为15（16表示不可达）</li><li>路由器交换的信息是路由器的完整路由表，因而随着网络规模的扩大，开销也就增加。</li><li>“坏消息传播得慢”，使更新过程的收敛时间过长。</li></ul><p>RIP是<strong>应用层</strong>协议，使用<strong>UDP</strong>传送数据，RIP选择的一定是具有最少路径路由器的路径。</p><h3 id="OSPF路由协议"><a href="#OSPF路由协议" class="headerlink" title="OSPF路由协议"></a>OSPF路由协议</h3><h4 id="OSPF协议的基本特点"><a href="#OSPF协议的基本特点" class="headerlink" title="OSPF协议的基本特点"></a>OSPF协议的基本特点</h4><p>开放最短路径优先协议使用分布式链路状态路由算法。</p><p>OSPF与RIP相比有4点主要区别：</p><ul><li>OSPF使用泛洪法向本自治系统中所有路由器发信息，而RIP只向和自己相邻的路由器发送信息</li><li>发送的信息是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。“链路状态”就是说明本路由器和哪些路由器相邻，以及该链路的“度量”（或代价）。而在RIP中发送的信息是本路由器所知道的全部信息，即整个路由表</li><li>只有当链路状态发生变化时，才用泛洪法向所有路由器发送此信息，并且更新过程收敛得快，不会出现RIP“消息传播得慢”的问题。RIP中，不管网络拓扑是否变化，都会定期交换路由表信息</li><li>OSPF是网络层协议，直接使用IP数据报传送。RIP是应用层协议，在传输层使用UDP协议</li></ul><p>除以上区别外，OSPF还有如下<strong>特点</strong>：</p><ul><li>OSPF对不同链路可根据IP分组的不同服务类型而设置成不同的代价，对不同类型业务计算出不同路由</li><li>如果到同一目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫多路径间的<strong>负载平衡</strong></li><li>所有在OSPF路由器之间交换的分组都具有鉴别功能，保证仅在可信赖路由之间交换链路状态信息</li><li>支持可变长度的子网划分和CIDR</li><li>每一个链路状态都带上一个32位的序号，序号越大状态越新</li></ul><h4 id="OSPF的基本工作原理"><a href="#OSPF的基本工作原理" class="headerlink" title="OSPF的基本工作原理"></a>OSPF的基本工作原理</h4><p>全网的拓扑结构图</p><p>利用“区域”减少整个网络负荷</p><h4 id="OSPF的五种分组类型"><a href="#OSPF的五种分组类型" class="headerlink" title="OSPF的五种分组类型"></a>OSPF的五种分组类型</h4><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG266.jpeg" alt="avatar"></p><h3 id="BGP路由协议"><a href="#BGP路由协议" class="headerlink" title="BGP路由协议"></a>BGP路由协议</h3><p>边界网关协议是不同自治系统的路由器之间交换路由信息的协议。</p><p>路径向量路由选择协议，BGP协议是应用层协议，基于TCP，寻找的并非最佳路由</p><h2 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a>IP组播</h2><p>在发送者和每一接受者之间实现点对多点网络连接，仅应用于UDP，使用D类地址格式</p><p>构造组播转发树以避免路由环路</p><h2 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h2><p>移动结点以固定的网络IP地址，实现跨越不同网段的漫游功能，并保证了基于网络IP的网络权限在漫游过程中不发生改变。</p><p>基于IPv4的移动IP定义三种功能实体：移动节点（mobile node）、归属代理（home agent）和外部代理（foreign agent）。归属代理和外部代理又统称为移动代理。</p><h2 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a>网络层设备</h2><h3 id="路由器的组成和功能"><a href="#路由器的组成和功能" class="headerlink" title="路由器的组成和功能"></a>路由器的组成和功能</h3><p>特点：连接异构网络，完成路由转发，隔离冲突和广播域</p><p>组成：</p><ul><li>控制部分（路由选择部分）：路由选择处理机，根据路由协议构造和维护路由表</li><li>分组转发部分：交换结构、一组输入端口、一组输出端口</li></ul><h3 id="路由表与路由转发"><a href="#路由表与路由转发" class="headerlink" title="路由表与路由转发"></a>路由表与路由转发</h3><p>路由表根据路由选择算法得出，主要用于路由选择，标准的路由表具有四个项目：目的网络IP地址、子网掩码、下一跳IP地址、接口</p><p>“转发”根据转发表把IP数据报从合适的端口转发出去，只涉及一个路由器。“路由选择”涉及很多路由器，路由表是很多路由器协同工作的结果</p>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 读书笔记 </category>
          
          <category> 计算机网络 </category>
          
          <category> 网络层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Heap</title>
      <link href="/2018/06/12/Heap/"/>
      <url>/2018/06/12/Heap/</url>
      <content type="html"><![CDATA[<h3 id="272-Closest-Binary-Search-Tree-Value-II"><a href="#272-Closest-Binary-Search-Tree-Value-II" class="headerlink" title="272.Closest Binary Search Tree Value II"></a>272.Closest Binary Search Tree Value II</h3><p>Given a non-empty binary search tree and a target value, find <strong>k</strong> values in the BST that are closest to the target.</p><p><strong>Note:</strong></p><p>Given target value is a floating point. You may assume k is always valid, that is: k ≤ total nodes. You are guaranteed to have only one unique set of k values in the BST that are closest to the target. </p><a id="more"></a><p><strong>Follow up:</strong></p><p>Assume that the BST is balanced, could you solve it in less than O(n) runtime (where n = total nodes)?</p><p><strong>Hint:</strong></p><p>Consider implement these two helper functions: getPredecessor(N), which returns the next smaller node to N. getSuccessor(N), which returns the next larger node to N.</p><ul><li>中序遍历法<ul><li>二叉搜索树的中序遍历就是顺序输出二叉搜索树</li><li>中序遍历二叉搜索树，同时维护一个大小为K的队列</li><li>前K个数直接加入队列</li><li>之后每来一个新的数（较大的数），如果该数和目标的差，相比于队头的数离目标的差来说，更小，则将队头拿出来，将新数加入队列</li><li>更大，则直接退出并返回这个队列</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">closestKValues</span><span class="params">(TreeNode root, <span class="keyword">double</span> target, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; klist = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stk = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="comment">// 迭代中序遍历二叉搜索树的代码</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stk.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stk.isEmpty())&#123;</span><br><span class="line">            TreeNode curr = stk.pop();</span><br><span class="line">            <span class="comment">// 维护一个大小为k的队列</span></span><br><span class="line">            <span class="comment">// 队列不到k时直接加入</span></span><br><span class="line">            <span class="keyword">if</span>(klist.size() &lt; k)&#123;</span><br><span class="line">                klist.offer(curr.val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 队列到k时，判断下新的数是否更近，更近就加入队列并去掉队头</span></span><br><span class="line">                <span class="keyword">int</span> first = klist.peek();</span><br><span class="line">                <span class="keyword">if</span>(Math.abs(first - target) &gt; Math.abs(curr.val - target))&#123;</span><br><span class="line">                    klist.poll();</span><br><span class="line">                    klist.offer(curr.val);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果不是更近则直接退出，后面的数只会更大</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 中序遍历的代码</span></span><br><span class="line">            <span class="keyword">if</span>(curr.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                curr = curr.right;</span><br><span class="line">                <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    stk.push(curr);</span><br><span class="line">                    curr = curr.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 强制转换成List，是用LinkedList实现的所以可以转换</span></span><br><span class="line">        <span class="keyword">return</span> (List&lt;Integer&gt;)klist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>相似的题：<br>270.Closest Binary Search Tree Value</strong></p><p>Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target.</p><p><strong>Note:</strong></p><p>Given target value is a floating point. You are guaranteed to have only one unique value in the BST that is closest to the target.</p><ul><li>递归<ul><li>当遍历到某个根节点时，最近的那个节点要么是在子树里面，要么就是根节点本身</li><li>根据这个递归，返回子树中最近的节点，和根节点中更近的那个</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">closestValue</span><span class="params">(TreeNode root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 选出子树的根节点</span></span><br><span class="line">        TreeNode kid = target &lt; root.val ? root.left : root.right;</span><br><span class="line">        <span class="comment">// 如果没有子树，也就是递归到底时，直接返回当前节点值</span></span><br><span class="line">        <span class="keyword">if</span>(kid == <span class="keyword">null</span>) <span class="keyword">return</span> root.val;</span><br><span class="line">        <span class="comment">// 找出子树中最近的那个节点</span></span><br><span class="line">        <span class="keyword">int</span> closest = closestValue(kid, target);</span><br><span class="line">        <span class="comment">// 返回根节点和子树最近节点中，更近的那个节点</span></span><br><span class="line">        <span class="keyword">return</span> Math.abs(root.val - target) &lt; Math.abs(closest - target) ? root.val : closest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>迭代<ul><li>记录一个最近的值，然后沿着二叉搜索的路径一路比较下去，并更新这个最近值</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">closestValue</span><span class="params">(TreeNode root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> closest = root.val;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果该节点的离目标更近，则更新到目前为止的最近值</span></span><br><span class="line">            closest = Math.abs(closest - target) &lt; Math.abs(root.val - target) ? closest : root.val;</span><br><span class="line">            <span class="comment">// 二叉搜索</span></span><br><span class="line">            root = target &lt; root.val ? root.left : root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> closest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="239-Sliding-Window-Maximum"><a href="#239-Sliding-Window-Maximum" class="headerlink" title="239.Sliding Window Maximum"></a>239.Sliding Window Maximum</h3><p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.</p><p><strong>Example:</strong></p><pre><code>Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3Output: [3,3,5,5,6,7] Explanation: Window position                Max---------------               -----[1  3  -1] -3  5  3  6  7       3 1 [3  -1  -3] 5  3  6  7       3 1  3 [-1  -3  5] 3  6  7       5 1  3  -1 [-3  5  3] 6  7       5 1  3  -1  -3 [5  3  6] 7       6 1  3  -1  -3  5 [3  6  7]      7</code></pre><p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ input array’s size for non-empty array.</p><p><strong>Follow up:</strong><br>Could you solve it in linear time?</p><p><strong>思路与代码</strong></p><p>就看题目中的例子，[1 3 -1] -3 5 3 6 7，我们知道这个窗口中的最大值为3。我们同时也可以确定，3之前的数字无需加入后面大小的比较，因为它们一定比3小。</p><p>按照这种规则，我们可以维护一个存储了可比较数字的链表。这个链表中的数字可以和当前准备加入链表的值进行比较。那么我们看一下将一个值加入该链表有什么场景：</p><ul><li>链表为空，直接加入</li><li>链表的数量大于窗口，则删除最左侧的值</li><li>链表中有值，且有些值小于即将加入的值，则这些小于的值都被抛弃</li><li>链表中的值均大于即将加入的值，则不进行任何操作</li></ul><p><strong>代码</strong>： 可以用deque</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;nums.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(list.size() != <span class="number">0</span> &amp;&amp; list.getFirst() &lt; i-k+<span class="number">1</span>)&#123;</span><br><span class="line">            list.remove(<span class="number">0</span>);<span class="comment">//deq.poll()</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(list.size()!=<span class="number">0</span> &amp;&amp; nums[list.getLast()] &lt; nums[i])&#123;</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);<span class="comment">//deq.pollLast()</span></span><br><span class="line">        &#125;</span><br><span class="line">        list.addLast(i);</span><br><span class="line">        <span class="keyword">if</span>(i - k + <span class="number">1</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            result[i-k+<span class="number">1</span>] = nums[list.getFirst()];<span class="comment">//deq.peek()</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="480-Sliding-Window-Median"><a href="#480-Sliding-Window-Median" class="headerlink" title="480.Sliding Window Median"></a>480.Sliding Window Median</h3><blockquote><p>与上一题不同的是这次找的是中位数</p></blockquote><p>For example,<br>Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.</p><pre><code>Window position                Median---------------               -----[1  3  -1] -3  5  3  6  7       1 1 [3  -1  -3] 5  3  6  7       -1 1  3 [-1  -3  5] 3  6  7       -1 1  3  -1 [-3  5  3] 6  7       3 1  3  -1  -3 [5  3  6] 7       5 1  3  -1  -3  5 [3  6  7]      6</code></pre><p>Therefore, return the median sliding window as [1,-1,-1,3,5,6].</p><ul><li>minHeap和maxHeap，maxHeap在保存较小的一半元素，minHeap保存较大的一半元素</li><li>然后调整最大堆和最小堆的大小。根据k值可以分两种情况讨论：<ul><li>若k为偶数，则需要最大堆中元素和最小堆中元素数量相等</li><li>若k为奇数，此时最小堆的堆顶元素即为此时窗口元素的median</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;Integer&gt; minHeap;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; maxHeap;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] medianSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">double</span>[] result = <span class="keyword">new</span> <span class="keyword">double</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k/<span class="number">2</span> + <span class="number">1</span>, (a, b) -&gt; b.compareTo(a));</span><br><span class="line">        minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k/<span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// delete the element beyond the window</span></span><br><span class="line">            <span class="keyword">if</span>(maxHeap.size() + minHeap.size() == k) slide(nums[i - k]);</span><br><span class="line">            <span class="comment">// add new element to the window</span></span><br><span class="line">            add(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                result[i - k + <span class="number">1</span>] = getMedian();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">slide</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(minHeap.contains(target)) minHeap.remove(target);</span><br><span class="line">        <span class="keyword">else</span> maxHeap.remove(target);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        maxHeap.add(num);</span><br><span class="line">        minHeap.add(maxHeap.poll());</span><br><span class="line">        <span class="keyword">if</span>(maxHeap.size() + <span class="number">1</span> &lt; minHeap.size()) maxHeap.add(minHeap.poll());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// window size is even</span></span><br><span class="line">        <span class="keyword">if</span>(minHeap.size() == maxHeap.size()) <span class="keyword">return</span> minHeap.peek()/<span class="number">2.0</span> + maxHeap.peek()/<span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 算法 </category>
          
          <category> LeetCode Category </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HashTable</title>
      <link href="/2018/06/09/HashTable/"/>
      <url>/2018/06/09/HashTable/</url>
      <content type="html"><![CDATA[<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><h3 id="217-Contains-Duplicate"><a href="#217-Contains-Duplicate" class="headerlink" title="217.Contains Duplicate"></a>217.Contains Duplicate</h3><p>Given an array of integers, find if the array contains any duplicates.</p><p>Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p><a id="more"></a><p><strong>Example 1:</strong></p><pre><code>Input: [1,2,3,1]Output: true</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: [1,2,3,4]Output: false</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: [1,1,1,3,3,4,3,2,4,2]Output: true</code></pre><ul><li>直接使用hashset</li><li>排序，对相邻的做比较</li></ul><h3 id="219-Contains-Duplicate-II"><a href="#219-Contains-Duplicate-II" class="headerlink" title="219.Contains Duplicate II"></a>219.Contains Duplicate II</h3><blockquote><p>判断数组是否存在i,j位置相同的数，同时j-i &lt;= k</p></blockquote><ul><li>hashmap<ul><li>key: nums[i], value: i</li><li>判断是否存在key,，存在则接着比较index</li><li>无论存在与否，都需要put，相同key被覆盖</li></ul></li><li>hashset<ul><li>i&gt;k则删除nums[i-k-1]</li><li>判断!set.add(nums[i])</li></ul></li></ul><h3 id="220-Contains-Duplicate-III"><a href="#220-Contains-Duplicate-III" class="headerlink" title="220.Contains Duplicate III"></a>220.Contains Duplicate III</h3><blockquote><p>判断数组是否存在i,j位置，num[j]-nums[i] &lt;= t，同时j-i &lt;= k</p></blockquote><p>类似sliding window,移动的时候增加和减少element，但对每一个value,需要考察[value-t,value+t]，时间复杂度太高…</p><ul><li>利用Bucket Sort<ul><li>构建一个大小为t+1的bucket, 比如[0, 1, 2, 3, … , t], 最大绝对值差的两个数就是t和0. </li><li>如果两个数字出现在同一个Bucket内，说明我们已经找到了。 如果不是，则在相邻的两个bucket内再找。</li><li>如果相邻的bucket内元素绝对值只差在t以内，说明我们知道到了，返回true.</li><li>为了保证j - i &lt;= k，我们在i&gt;=k时，删除 nums[i-k]对应的Bucket.</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( k &lt; <span class="number">1</span> || t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map&lt;Long, Long&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">// [-t, 0] [0, t] 的元素都会落在bucket[0]里。</span></span><br><span class="line">            <span class="comment">// 为了解决这个问题，所有元素横移Integer.MIN_VALUE。</span></span><br><span class="line">            <span class="keyword">long</span> remappedNum = (<span class="keyword">long</span>) nums[i] - Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">long</span> bucket = remappedNum / ((<span class="keyword">long</span>)t + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(bucket) </span><br><span class="line">                ||(map.containsKey(bucket-<span class="number">1</span>) &amp;&amp; remappedNum - map.get(bucket-<span class="number">1</span>) &lt;= t)</span><br><span class="line">                    || (map.containsKey(bucket+<span class="number">1</span>) &amp;&amp; map.get(bucket+<span class="number">1</span>) - remappedNum &lt;= t) )</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastBucket = ((<span class="keyword">long</span>) nums[i-k] - Integer.MIN_VALUE) / ((<span class="keyword">long</span>)t + <span class="number">1</span>);</span><br><span class="line">                map.remove(lastBucket);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(bucket,remappedNum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用treeset</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( k &lt; <span class="number">1</span> || t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        TreeSet&lt;Long&gt; tree = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//floor() 小于等于</span></span><br><span class="line">            Long floor = tree.floor((<span class="keyword">long</span>)nums[i] + t);</span><br><span class="line">            <span class="comment">//ceiling() 大于等于</span></span><br><span class="line">            Long ceil = tree.ceiling((<span class="keyword">long</span>)nums[i] - t);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>((floor != <span class="keyword">null</span> &amp;&amp; floor &gt;= nums[i])</span><br><span class="line">                || (ceil != <span class="keyword">null</span> &amp;&amp; ceil &lt;= nums[i]) )</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">            tree.add((<span class="keyword">long</span>)nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k)&#123;</span><br><span class="line">                tree.remove((<span class="keyword">long</span>)nums[i-k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="243-Shortest-Word-Distance"><a href="#243-Shortest-Word-Distance" class="headerlink" title="243.Shortest Word Distance"></a>243.Shortest Word Distance</h3><p>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p><p>For example, Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”].</p><p>Given word1 = “coding”, word2 = “practice”, return 3. Given word1 = “makes”, word2 = “coding”, return 1.</p><p>Note: You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.</p><ul><li>双指针法 <ul><li>分别记录word1和word2的位置</li><li>更新distance</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(String[] words, String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ind1 = -<span class="number">1</span>, ind2 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> distance = Integer.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; words.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(words[i].equals(word1))&#123;</span><br><span class="line">                ind1 = i;</span><br><span class="line">                <span class="keyword">if</span>(ind2 != -<span class="number">1</span>) distance = Math.min(distance, ind1 - ind2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(words[i].equals(word2))&#123;</span><br><span class="line">                ind2 = i;</span><br><span class="line">                <span class="keyword">if</span>(ind1 != -<span class="number">1</span>) distance = Math.min(distance, ind2 - ind1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="244-Shortest-Word-Distance-II"><a href="#244-Shortest-Word-Distance-II" class="headerlink" title="244.Shortest Word Distance II"></a>244.Shortest Word Distance II</h3><p>This is a follow up of Shortest Word Distance. The only difference is now you are given the list of words and your method <strong>will be called repeatedly many times</strong> with different parameters. How would you optimize it?</p><p>Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list.</p><ul><li>多次call, 那就需要记录下所有的word的下标</li><li>同时，一个word可能出现多次，应该是个list</li><li>比较的时候，类似merge two sorted list的做法, 先比较最小的，然后把较小的去掉，接着比较</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordDistance</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    HashMap&lt;String, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String, List&lt;Integer&gt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordDistance</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 统计每个单词出现的下标存入哈希表中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">            List&lt;Integer&gt; cnt = map.get(words[i]);</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="keyword">null</span>)&#123;</span><br><span class="line">                cnt = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            cnt.add(i);</span><br><span class="line">            map.put(words[i], cnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortest</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; idx1 = map.get(word1);</span><br><span class="line">        List&lt;Integer&gt; idx2 = map.get(word2);</span><br><span class="line">        <span class="keyword">int</span> distance = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 每次比较两个下标列表最小的下标，然后把跳过较小的那个</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; idx1.size() &amp;&amp; j &lt; idx2.size())&#123;</span><br><span class="line">            distance = Math.min(Math.abs(idx1.get(i) - idx2.get(j)), distance);</span><br><span class="line">            <span class="keyword">if</span>(idx1.get(i) &lt; idx2.get(j))&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="245-Shortest-Word-Distance-III"><a href="#245-Shortest-Word-Distance-III" class="headerlink" title="245.Shortest Word Distance III"></a>245.Shortest Word Distance III</h3><p>This is a follow up of Shortest Word Distance. The only difference is now word1 <strong>could be the same</strong> as word2.</p><p>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p><p>word1 and word2 may be the same and they represent <strong>two individual words</strong> in the list.</p><p>For example, Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”].</p><p>Given word1 = “makes”, word2 = “coding”, return 1. Given word1 = “makes”, word2 = “makes”, return 3.</p><p>Note: You may assume word1 and word2 are both in the list.</p><ul><li>和I相似，区别就在于两个词可能相同</li><li>需要区分第一次遇到和第二次遇到这个词。加入一个turns，如果是相同单词的话，每次遇到一个单词turn加1，这样可以根据turn来判断是否要switch</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(String[] words, String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ind1 = -<span class="number">1</span>, ind2 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> distance = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> turns = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> inc = word1.equals(word2) ? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; words.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(words[i].equals(word1) &amp;&amp; turns % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                ind1 = i;</span><br><span class="line">                <span class="keyword">if</span>(ind2 != -<span class="number">1</span>) distance = Math.min(distance, ind1 - ind2);</span><br><span class="line">                turns += inc;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(words[i].equals(word2))&#123;</span><br><span class="line">                ind2 = i;</span><br><span class="line">                <span class="keyword">if</span>(ind1 != -<span class="number">1</span>) distance = Math.min(distance, ind2 - ind1);</span><br><span class="line">                turns += inc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><h3 id="202-Happy-Number"><a href="#202-Happy-Number" class="headerlink" title="202.Happy Number"></a>202.Happy Number</h3><p>Write an algorithm to determine if a number is “happy”.</p><p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p><p><strong>Example:</strong></p><pre><code>Input: 19Output: trueExplanation: 1^2 + 9^2 = 828^2 + 2^2 = 686^2 + 8^2 = 1001^2 + 0^2 + 0^2 = 1</code></pre><ul><li>用set记录在计算过程中出现的值</li><li>如果再次出现，说明不行</li><li>否则一直计算直到结果为1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(set.add(n))&#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> digit = n%<span class="number">10</span>;</span><br><span class="line">                res += digit * digit;</span><br><span class="line">                n /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(res == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                n = res;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="3-Longest-Substring-without-repeat-characters"><a href="#3-Longest-Substring-without-repeat-characters" class="headerlink" title="3.Longest Substring without repeat characters"></a>3.Longest Substring without repeat characters</h3><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><p><strong>Examples:</strong></p><p>Given “abcabcbb”, the answer is “abc”, which the length is 3.</p><p>Given “bbbbb”, the answer is “b”, with the length of 1.</p><p>Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p><ul><li>sliding window + set解法<ul><li>两个指针p1,p2，p1是window的左边界，p2是右边界</li><li>左边界不动时，右边界尽可能往右扩展，直到不能满足条件</li><li>左边界移动，删除set中左边的元素</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt; length)&#123;</span><br><span class="line">            <span class="keyword">while</span>(p2 &lt; length &amp;&amp; set.add(s.substring(p2, p2+<span class="number">1</span>)))&#123;</span><br><span class="line">                max = Math.max(max, p2-p1+<span class="number">1</span>);</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">            set.remove(s.substring(p1, p1+<span class="number">1</span>));</span><br><span class="line">            p1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="159-Longest-Substring-with-at-most-Two-Distinct-Characters"><a href="#159-Longest-Substring-with-at-most-Two-Distinct-Characters" class="headerlink" title="159.Longest Substring with at most Two Distinct Characters"></a>159.Longest Substring with at most Two Distinct Characters</h3><p>Given a string, find the length of the longest substring T that contains at most 2 distinct characters.</p><p>For example, Given s = “eceba”,</p><p>T is “ece” which its length is 3.</p><ul><li>两个指针，一个map来记录字符及其出现次数。</li><li>一个右指针先移动，不断更新map, </li><li>当发现map里的字符个数大于规定个数的时候，开始移动左指针，同时更新map,</li><li>直到map里的字符个数等于规定个数，</li><li>中间不断更新包含规定字符个数的最大长度。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length()) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 根据右指针指的当前字符更新map</span></span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(c)) &#123;</span><br><span class="line">                map.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(c, map.get(c) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 移动左指针，直到map中字符数量降至规定数量</span></span><br><span class="line">            <span class="keyword">while</span> (map.size() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">char</span> leftChar = s.charAt(left);</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(leftChar)) &#123;</span><br><span class="line">                </span><br><span class="line">                    <span class="comment">// 注意会有重复元素，所以先减小次数，只有次数降至0，才删除元素</span></span><br><span class="line">                    map.put(leftChar, map.get(leftChar) - <span class="number">1</span>);                     </span><br><span class="line">                    <span class="keyword">if</span> (map.get(leftChar) == <span class="number">0</span>) &#123; </span><br><span class="line">                        map.remove(leftChar);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;               </span><br><span class="line">            maxLen = Math.max(maxLen, i - left + <span class="number">1</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Follow up</strong>: 340.Longest Substring with at most k Distinct Characters</p><blockquote><p>最多允许k个字符</p></blockquote><p>上面的代码直接把2改成k即可。</p><h3 id="76-Minimum-Window-Substring"><a href="#76-Minimum-Window-Substring" class="headerlink" title="76.Minimum Window Substring"></a>76.Minimum Window Substring</h3><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p><p><strong>Example:</strong></p><pre><code>Input: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;Output: &quot;BANC&quot;</code></pre><p><strong>Note:</strong></p><ul><li>If there is no such window in S that covers all characters in T, return the empty string “”.</li><li><p>If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</p></li><li><p>类似于Longest Substring with At Most Two Distinct Characters。</p></li><li>此类window题型，我们都需要用<strong>两个指针</strong>，用<strong>一个map</strong>记录字符及其出现次数，</li><li>不同的是由于这里题目要求是覆盖字符串T中所有字符，所以我们需要用一个变量如<strong>count</strong>来记录window中覆盖字符串T中有效字符的个数。</li><li>只要count == T.length(), 便可更新window的最短长度。</li><li>同时，我们必须移动左指针，直到window中包含的字符个数小于规定的数量，我们才开始移动右指针。另外要注意何时更新count的值。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 建map, 记录被包含字符串中字符及其个数</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = t.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(c)) &#123;</span><br><span class="line">                map.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(c, map.get(c) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minStart = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minLen = s.length() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.get(c) &gt; <span class="number">0</span>)  </span><br><span class="line">                    count++; <span class="comment">// 注意count++的条件</span></span><br><span class="line">                map.put(c, map.get(c) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (count == t.length()) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 不断更新最值</span></span><br><span class="line">                <span class="keyword">if</span> (i - l + <span class="number">1</span> &lt; minLen) &#123;</span><br><span class="line">                    minLen = i - l + <span class="number">1</span>;</span><br><span class="line">                    minStart = l;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 移动左指针</span></span><br><span class="line">                <span class="keyword">char</span> leftChar = s.charAt(l);</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(leftChar)) &#123;</span><br><span class="line">                    map.put(leftChar, map.get(leftChar) + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (map.get(leftChar) &gt; <span class="number">0</span>) &#123; </span><br><span class="line">                        count--; <span class="comment">// 注意count--条件</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (minLen == s.length() + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(minStart, minLen + minStart);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="30-Substring-with-Concatenation-of-All-Words"><a href="#30-Substring-with-Concatenation-of-All-Words" class="headerlink" title="30.Substring with Concatenation of All Words"></a>30.Substring with Concatenation of All Words</h3><p>You are given a string, <strong>s</strong>, and a list of words, <strong>words</strong>, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.</p><p><strong>Example 1:</strong></p><pre><code>Input:  s = &quot;barfoothefoobarman&quot;,  words = [&quot;foo&quot;,&quot;bar&quot;]Output: [0,9]Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively.The output order does not matter, returning [9,0] is fine too.</code></pre><p><strong>Example 2:</strong></p><pre><code>Input:  s = &quot;wordgoodstudentgoodword&quot;,  words = [&quot;word&quot;,&quot;student&quot;]Output: []</code></pre><blockquote><p>输入一个字符串s和一个字符串数组words，其中words中的每个word的长度都相等。在字符串中找到所有子字符串的起始下标，只要该子字符串满足words中所有单词的连接结果（顺序无关）</p></blockquote><ul><li>把每个词当作一个字母来看待，但是要遍历K次，K是单词的长度，因为我们要分别统计从下标0开头，从下标1开头。。。直到下标K-1开头的字符串。</li><li>通过哈希表维护一个窗口，比如foo|bar|foo中，我们先拿出foo。如果foo都不在数组中，那说明根本不能拼进去，则哈希表全部清零，从下一个词开始重新匹配。</li><li>但是foo是在数组中的，所以给当前搜索的哈希表计数器加上1，如果发现当前搜索中foo出现的次数已经比给定数组中foo出现的次数多了，我们就要把上一次出现foo之前的所有词都从窗口中去掉</li><li>如果没有更多，则看下一个词bar，不过在这之前，我们还要看看窗口中有多少个词了，如果词的个数等于数组中词的个数，说明我们找到了一个结果。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(words == <span class="keyword">null</span> || words.length == <span class="number">0</span> || s == <span class="keyword">null</span> || s.equals(<span class="string">""</span>)) <span class="keyword">return</span> res;</span><br><span class="line">        HashMap&lt;String, Integer&gt; freq = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">        <span class="comment">// 统计数组中每个词出现的次数，放入哈希表中待用</span></span><br><span class="line">        <span class="keyword">for</span>(String word : words)&#123;</span><br><span class="line">            freq.put(word, freq.containsKey(word) ? freq.get(word) + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到每个词的长度</span></span><br><span class="line">        <span class="keyword">int</span> len = words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="comment">// 错开位来统计</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="comment">// 建一个新的哈希表，记录本轮搜索中窗口内单词出现次数</span></span><br><span class="line">            HashMap&lt;String, Integer&gt; currFreq = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">            <span class="comment">// start是窗口的开始，count表明窗口内有多少词</span></span><br><span class="line">            <span class="keyword">int</span> start = i, count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= s.length() - len; j += len)&#123;</span><br><span class="line">                String sub = s.substring(j, j + len);</span><br><span class="line">                <span class="comment">// 看下一个词是否是给定数组中的</span></span><br><span class="line">                <span class="keyword">if</span>(freq.containsKey(sub))&#123;</span><br><span class="line">                    <span class="comment">// 窗口中单词出现次数加1</span></span><br><span class="line">                    currFreq.put(sub, currFreq.containsKey(sub) ? currFreq.get(sub) + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="comment">// 如果该单词出现次数已经超过给定数组中的次数了，说明多来了一个该单词，所以要把窗口中该单词上次出现的位置及之前所有单词给去掉</span></span><br><span class="line">                    <span class="keyword">while</span>(currFreq.get(sub) &gt; freq.get(sub))&#123;</span><br><span class="line">                        String leftMost = s.substring(start, start + len);</span><br><span class="line">                        currFreq.put(leftMost, currFreq.get(leftMost) - <span class="number">1</span>);</span><br><span class="line">                        start = start + len;</span><br><span class="line">                        count--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果窗口内单词数和总单词数一样，则找到结果</span></span><br><span class="line">                    <span class="keyword">if</span>(count == words.length)&#123;</span><br><span class="line">                        String leftMost = s.substring(start, start + len);</span><br><span class="line">                        currFreq.put(leftMost, currFreq.get(leftMost) - <span class="number">1</span>);</span><br><span class="line">                        res.add(start);</span><br><span class="line">                        start = start + len;</span><br><span class="line">                        count--;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="comment">// 如果截出来的单词都不在数组中，前功尽弃，重新开始</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    currFreq.clear();</span><br><span class="line">                    start = j + len;</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="249-Group-Shift-Strings"><a href="#249-Group-Shift-Strings" class="headerlink" title="249.Group Shift Strings"></a>249.Group Shift Strings</h3><p>Given a string, we can “shift” each of its letter to its successive letter, for example: “abc” -&gt; “bcd”. We can keep “shifting” which forms the sequence:</p><pre><code>&quot;abc&quot; -&gt; &quot;bcd&quot; -&gt; ... -&gt; &quot;xyz&quot;</code></pre><p>Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence.</p><p>For example, given: [“abc”, “bcd”, “acef”, “xyz”, “az”, “ba”, “a”, “z”], </p><p>A solution is:</p><pre><code>[[&quot;abc&quot;,&quot;bcd&quot;,&quot;xyz&quot;],[&quot;az&quot;,&quot;ba&quot;],[&quot;acef&quot;],[&quot;a&quot;,&quot;z&quot;]]</code></pre><ul><li>同一组string, 他们的间隔是一样的</li><li>判断间隔，以间隔为key</li><li>value为相同间隔的string的list</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; groupStrings(String[] strings) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String str : strings) &#123;</span><br><span class="line">            String key = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> offset = str.charAt(i) - str.charAt(i - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//在为负数的时候，当经过z, a的时候，数值大小会很大得反转</span></span><br><span class="line">                key += offset &lt; <span class="number">0</span> ? offset + <span class="number">26</span> : offset;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(key)) map.put(key, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">            map.get(key).add(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; list : map.values()) &#123;</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="288-Unique-Word-Abbreviation"><a href="#288-Unique-Word-Abbreviation" class="headerlink" title="288.Unique Word Abbreviation"></a>288.Unique Word Abbreviation</h3><p>An abbreviation of a word follows the form <first letter=""><number><last letter="">. Below are some examples of word abbreviations:</last></number></first></p><pre><code>a) it                      --&gt; it    (no abbreviation)     1b) d|o|g                   --&gt; d1g              1    1  1     1---5----0----5--8c) i|nternationalizatio|n  --&gt; i18n              1     1---5----0d) l|ocalizatio|n          --&gt; l10n</code></pre><p>Assume you have a dictionary and given a word, find whether its abbreviation is unique in the dictionary.<br>A word abbreviation is unique if no other word from the dictionary has the same abbreviation.</p><p><strong>Example:</strong></p><pre><code>Given dictionary = [ &quot;deer&quot;, &quot;door&quot;, &quot;cake&quot;, &quot;card&quot; ]isUnique(&quot;dear&quot;) -&gt; falseisUnique(&quot;cart&quot;) -&gt; trueisUnique(&quot;cane&quot;) -&gt; falseisUnique(&quot;make&quot;) -&gt; true</code></pre><ul><li>首字母+中间str长度+尾字母</li><li>判断是否唯一</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidWordAbbr</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Set&lt;String&gt; &gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ValidWordAbbr</span><span class="params">(String[] dictionary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dictionary.length; i++) &#123;</span><br><span class="line">            String s = dictionary[i];</span><br><span class="line">            <span class="keyword">if</span>(s.length() &gt; <span class="number">2</span> ) &#123;</span><br><span class="line">                s = s.charAt(<span class="number">0</span>) + Integer.toString(s.length()-<span class="number">2</span>) + s.charAt(s.length()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s) ) &#123;</span><br><span class="line">                map.get(s).add(dictionary[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">                set.add(dictionary[i]);</span><br><span class="line">                map.put(s, set);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//input check</span></span><br><span class="line">        String s = word;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &gt; <span class="number">2</span> ) &#123;</span><br><span class="line">            s = s.charAt(<span class="number">0</span>) + Integer.toString(s.length()-<span class="number">2</span>) + s.charAt(s.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(s)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> map.get(s).contains(word) &amp;&amp; map.get(s).size()&lt;=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 算法 </category>
          
          <category> LeetCode Category </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> String </tag>
            
            <tag> HashTable </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>垃圾收集器与内存分配策略</title>
      <link href="/2018/06/06/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
      <url>/2018/06/06/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<p><strong>垃圾回收主要是对Java堆、方法区内存的回收</strong></p><h2 id="对象已死吗"><a href="#对象已死吗" class="headerlink" title="对象已死吗"></a>对象已死吗</h2><p>堆中存放着几乎所有的对象实例，回收前，需要对对象是否存活进行确定，判断是否能进行回收</p><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><ul><li>给对象添加一个引用计数器</li><li>引用则加1</li><li>引用失效，则减1</li><li>计数器为0的对象就可以被回收</li></ul><p><strong>优点：</strong><br>实现简单，效率高<br><a id="more"></a></p><p><strong>缺点：</strong><br>Java中不用，<strong>很难解决循环引用问题</strong></p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><ul><li>“GC Roots”对象为起点，开始向下搜索</li><li>搜索走过的路径称为<strong>引用链</strong></li><li>当一个对象到“GC Roots”没有引用链相连时，该对象不可用</li></ul><p><strong>Java和C#中都是采用该算法来判定对象是否存活的。</strong></p><p>Java中，可作为GC Roots的对象如下:</p><ol><li>虚拟机栈（栈桢中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI引用的对象</li></ol><h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>强引用、软引用、弱引用、虚引用，强度依次减弱</p><ul><li>强引用，类似Object obj = new Object(), 只要强引用还在，系统不会回收</li><li>软引用，还有用但非必需的对象，会在内存不足的时候释放</li><li>弱引用，非必需对象，被弱引用关联的对象只能生存到下一次垃圾回收之前</li><li>虚应用，不能用虚引用获得一个实例对象，存在是为了在对象被回收后获得系统反馈</li></ul><h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><ul><li>可达性分析算法中不可达，也不一定是“非死不可”</li><li>真正被回收，至少要经历两次标记过程：<ul><li>进行可达性分析后没有与GC Roots相连接的引用链，第一次标记并筛选，筛选的条件是对象是否有必要执行<strong>finalize()</strong>方法（对象未覆盖finalize()方法或者该方法已经被调用过，视为“没有必要执行”）</li><li>如果判定为有必要，则该对象会被放置在F-Queue队列中，会有低优先级的线程去触发</li><li>稍后GC对F-Queue中对象进行二次标记，如果对象在finalize()方法中重新产生引用链，则被移出“即将回收”集合</li></ul></li></ul><p><strong>一个对象的finalize()方法最多只会被系统自动调用一次</strong></p><h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>方法区（HotSpot中的永久代）垃圾回收率很低。</p><p>永久代垃圾回收收集废弃常量和无用的类。</p><ul><li>回收常量：没有引用即可</li><li>回收类，无用的类的判定：<ul><li>类的所有实例被回收，Java堆中不存在该类的任何实例</li><li>加载该类的ClassLoader被回收</li><li>该类对应的java.lang.Class对象没有被引用，无法通过反射访问该类的方法</li></ul></li><li>虚拟机<strong>可以</strong>对符合上述条件的类回收</li><li>是否对类回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息</li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>标记需要回收对象，统一回收，不作处理</p><p><strong>优点：</strong><br>不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效。</p><p><strong>缺点：</strong></p><ul><li>标记和清除过程的效率都不高（这种方法需要使用一个空闲列表来记录所有的空闲区域以及大小。对空闲列表的管理会增加分配对象时的工作量）</li><li>标记清除后会产生大量不连续的内存碎片。虽然空闲区域的大小是足够的，但是可能没有足够大的连续空间。</li></ul><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><ul><li>内存等量分为两块，每次只使用一块</li><li>当一块用完时，将存活对象复制到另一块上</li><li>把再把已使用过的内存空间一次清理掉</li></ul><p><strong>复制算法比较适合于新生代（短生存期的对象），在老年代（长生存期的对象）中，对象存活率比较高，如果执行较多的复制操作，效率将会变低，所以老年代一般会选用其他算法，如标记—整理算法。</strong></p><p><strong>优点：</strong></p><ul><li>标记阶段和复制阶段可以同时进行。</li><li>每次只对一块内存进行回收，运行高效。</li><li>只需移动栈顶指针，按顺序分配内存即可，实现简单。</li><li>内存回收时不用考虑内存碎片的出现（得活动对象所占的内存空间之间没有空闲间隔）。</li></ul><p><strong>缺点：</strong><br>需要一块能容纳下所有存活对象的额外的内存空间。因此，可一次性分配的最大内存缩小了一半。</p><p>HotSpot虚拟机默认Eden和Survivor的大小比例是8:1, 当Survivor内存不够时，需要依赖其他内存（老年代）进行分配担保。</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>将所有对象内存向一端移动，清除端外的。</p><p><strong>优点：</strong></p><ul><li>经过整理之后，新对象的分配只需要通过指针碰撞便能完成（Pointer Bumping），相当简单。</li><li>使用这种方法空闲区域的位置是始终可知的，也不会再有碎片的问题了。</li></ul><p><strong>缺点：</strong><br>GC暂停的时间会增长，因为你需要将所有的对象都拷贝到一个新的地方，还得更新它们的引用地址。</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>新生代：复制<br>老年代：标记-清除、标记-整理算法</p><h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><p>GC Roots找引用链，需要消耗很多时间</p><p>GC停顿需要在保持<strong>一致性</strong>的快照中进行（分析期间，对象引用关系不变），GC停顿指GC进行时停顿所有Java执行线程。</p><p>使用准确式GC，直接得知哪些地方存放着对象引用。HotSpot使用OopMap来达到这一目的，在类加载完成时，HotSpot把对象内什么偏移量时什么类型数据计算出来，在JIT编译过程中，在<strong>安全点</strong>记录下栈和寄存器中哪些位置是引用。</p><p>程序执行时在安全点才会停下来GC，安全点的选定是以程序“是否具有让程序长时间执行的特征”为标准进行选定的，“长时间执行”最明显的特征是<strong>指令序列复用</strong>，例如方法调用、循环跳转、异常跳转等。</p><p>GC发生时有两种方案让所有线程都“跑”到最近的安全点才停顿下来：</p><ul><li>抢先式中断(几乎不用)：GC发生时，把线程全部中断，如果线程不在安全点，就恢复，让它“跑”在安全点上</li><li>主动式中断：设置标志，线程去轮询，标志为真时就中断挂起。轮询标志和安全点是重合的，另外再加上创建对象需要分配内存的地方。</li></ul><p>安全点保证了<strong>程序运行时</strong>，能在不太长时间内遇到可进入GC的安全点。但程序“不执行”、<strong>没有分配CPU时</strong>，比如线程处于sleep或blocked时，就需要<strong>安全区域</strong>。</p><p>执行到Safe Region中的代码时，首先标识进入了Safe Region，线程要离开Safe Region时，检查系统是否已经完成根节点枚举（or整个GC过程）,如果完成，线程继续执行，否则必须等待知道收到可以离开的信号。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>讨论的收集器基于JDK    1.7 Update 14之后的HotSpot虚拟机，虚拟机包含的所有收集器如下图：</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG253.jpeg" alt="avatar"></p><p>如果两个收集器之前存在连线，则说明可以搭配使用。虚拟机所处的区域，表示它属于新生代还是老年代。</p><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>单线程收集器，只使用一个CPU或一条收集线程去完成垃圾收集工作，收集时，<strong>暂停其他所有工作线程</strong>，直至收集结束。</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG254.jpeg" alt="avatar"></p><p><strong>优点：</strong><br>简单而高效（与其他收集器的单线程比）</p><p><strong>缺点：</strong><br>Stop The World，其它工作线程在用户不可见时全部停掉</p><p><strong>使用场景：</strong><br>运行在Client模式下的虚拟机</p><h3 id="ParNew收集器（并行）"><a href="#ParNew收集器（并行）" class="headerlink" title="ParNew收集器（并行）"></a>ParNew收集器（并行）</h3><p>Serial收集器的多线程版本，进行垃圾收集时也会停止工作线程</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG255.jpeg" alt="avatar"></p><p>是许多运行在Server模式下的虚拟机中首选的新生代收集器，很大原因在于，只有Serial收集器和ParNew收集器能与CMS收集器配合工作</p><p><strong>注意</strong></p><ul><li><p>并行（parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；</p></li><li><p>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。</p></li></ul><h3 id="Parallel-Scavenge收集器（并行）"><a href="#Parallel-Scavenge收集器（并行）" class="headerlink" title="Parallel Scavenge收集器（并行）"></a>Parallel Scavenge收集器（并行）</h3><p>新生代收集器、使用复制算法、并行的多线程收集器</p><p>不能与CMS收集器配合使用，目标达到一个<strong>可控制的吞吐量</strong>（Throughput）。吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间)</p><p>停顿时间越短越适合需要与用户交互的程序，良好的响应时间速度能提升用户体验，而高吞吐量可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>控制最大垃圾收集停顿时间：-XX:MaxGCPauseMillis，直接设置吞吐量大小参数：-XX: GCTimeRatio（0-100）。</p><p>-XX：+UseAdaptiveSizePlicvy，开关参数，当参数打开之后，就不需要手工指定新生代大小-Xmn、Eden与Survivor区的比例-XX:SurviviorRatio、晋升到老年代对象年龄-XX:PretenureSizeThreshold等细节参数了，虚拟机会根据当前系统运行情况收集性能监控信息，动态调整这些参数以提供合适的停顿时间或者最大吞吐量，这种调节方式称为<strong>GC自适应的调节策略</strong>（GC Ergonomics）。</p><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial收集器老年代版本，也是用于给Client模式下的虚拟机使用</p><p>在Server模式下，两大用途：</p><ul><li>在JDK1.5及以上，与Parallel Scavenge收集器搭配使用（Parallel Scavenge收集器架构中本身有PS MarkSweep收集器进行老年代的收集，并非直接使用Serial Old，但Serial Old与PS MarkSweep实现非常接近）</li><li>作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用</li></ul><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Scavenge老年代版本，使用多线程和“标记-整理”算法</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG259.jpeg" alt="avatar"></p><p><strong>使用场景：</strong><br>注重高吞吐量以及CPU资源敏感的场合，可以考虑Parallel Scavenge加Parallel Old</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上。基于“标记-清除”算法实现。</p><ul><li>初始标记：Stop the World，只是标记一下GC Roots能直接关联到的对象，用户进程停顿</li><li>并发标记：进行GC Roots Tracing（追踪）的过程，并发用户进程</li><li>重新标记：Stop the World，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，用户进程停顿</li><li>并发删除：并发用户进程</li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG260.jpeg" alt="avatar"></p><p><strong>优点：</strong><br>并发收集、低停顿</p><p><strong>缺点：</strong></p><ul><li>对CPU资源敏感，并发阶段，占用线程（CPU资源）导致应用程序变慢，总吞吐量降低</li><li>无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。“浮动垃圾”指在并发清理过程中用户进程仍在运行，自然会产生垃圾，这部分垃圾出现在标记过程之后，CMS无法当次集中处理，只好留到下一次GC.</li><li>基于“标记-清除”算法，空间碎片过多，但无法找到足够大的连续空间用以分配，触发Full GC</li></ul><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>面向服务端的垃圾收集器</p><p><strong>特点：</strong></p><ul><li>并行与并发：缩短Stop the World停顿时间</li><li>分代收集：采用不同方式处理新对象和存活一段时间的对象</li><li>空间整合：与CMS的标记-清理算法不同，整体基于标记-整理算法，从局部（两个Region之间）基于复制算法。不会产生空间碎片。</li><li>可预测的停顿，之所以能做到，是因为能有计划避免在整个堆中进行全区域的垃圾收集</li></ul><p>将堆划分为等大小的独立区域（Region），跟踪各个Region里垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p><p>使用Remembered Set避免全堆扫描，处于不同的Region，则记录到被引用对象的Region中，在GC根节点枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</p><p>不计算维护Remembered Set操作，大致分为以下步骤：</p><ul><li>初始标记：标记一下GC Roots能直接关联到的对象，并修改TAMS(Next Top at Mark Start)的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，<strong>停顿</strong>线程</li><li>并发标记：进行GC Roots Tracing（追踪）的过程，<strong>并发</strong>用户进程</li><li>最终标记：修正在并发标记期间因用户程序继续运作而导致标记表动的那一部分标记记录，虚拟机将并发标记期间的对象变化记录在Remembered Set Logs中，在这阶段将这部分数据合并到Remembered Set中，<strong>停顿线程，但可并行执行</strong></li><li>筛选回收：对各Region的回收价值和成本排序，根据用户所期望的GC停顿来制定回收计划，可以做到并发，但意义不大</li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG261.jpeg" alt="avatar"></p><h3 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h3><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG262.jpeg" alt="avatar"></p><ul><li>“33.125”和“100.667”代表GC发生的<strong>时间</strong>，是从Java虚拟机启动以来经过的秒数</li><li>“[GC”和”[Full GC”说明<strong>垃圾收集的停顿类型</strong>，如果有”Full”说明是发生了Stop-The-World，如果是调用System.gc()触发的收集，则显示”[Full GC(System)”</li><li>“[DefNew”(Default New Generation)、”[ParNew”(Parallel New Generation)、”[PSYoungGen”(Parallel Scavenge)表示GC发生的<strong>区域</strong></li><li>方括号内部的”3324K-&gt;152(3712K)”指“GC前该内存区域已使用容量-&gt;GC后该内存区域已使用容量(该内存区域总容量)”;方括号之外的“3324K-&gt;152(11904K)”表示“GC前Java堆已使用容量-&gt;GC后Java堆已使用容量(Java堆总容量)”</li><li>“0.0025925secs”表示该内存区域GC所占用的时间</li></ul><h3 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h3><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG264.jpeg" alt="avatar"><br><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG263.jpeg" alt="avatar"></p><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><ul><li>对象优先在Eden分配，当Eden区没有足够空间进行分配时，虚拟机发起Minor GC，分配担保机制提前将原占用Eden的资源转移到老年代中<ul><li>新生代GC(Minor GC): 发生在新生代的垃圾收集行为，频繁，回收速度快</li><li>老年代GC(Major GC/Full GC): 发生在老年代的GC,经常伴随至少一次的Minor GC(非绝对),比Minor GC慢10倍以上</li></ul></li><li>大对象(需要大量连续内存空间的对象)直接进入老年代</li><li>长期存活的对象将进入老年代</li></ul><p>虚拟机采用<strong>分代收集</strong>思想管理内存，那么内存回收时就必须能识别对象放在哪。虚拟机给每个对象定义了一个<strong>对象年龄(Age)</strong>计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Surviror容纳得话，将被移到Surviror空间中，并且对象年龄设为1。对象在Surviror区每熬过一次Minor GC, 年龄就增加1岁，当年龄增加到一定程度(默认15岁)，就会被晋升到老年代中。</p><p>虚拟机并不是永远要求对象年龄必须达到了MaxTenuringThreshold才能晋升到老年代，如果在Surviror空间中<strong>相同年龄的所有对象大小总和大于Surviror空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代</strong>，无须等到MaxTenuringThreshold要求的年龄。</p><p>发生Minor GC前，先检查老年代最大可用连续空间是否能够存放新生代所有对象，能则确保Minor GC安全。否则，则看HandlePromotionFailure是否允许担保失败。如果允许，则继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，大于则进行Minor GC；如果小于，或者HandlePromotionFailure设置不允许冒险，则进行Full GC。</p><p>在JDK 6 Update 24后，<strong>只要老年代的联系空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则Full GC</strong>。</p>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 读书笔记 </category>
          
          <category> 深入理解Java虚拟机 </category>
          
          <category> 自动内存管理机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java内存区域与内存溢出异常</title>
      <link href="/2018/06/05/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
      <url>/2018/06/05/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
      <content type="html"><![CDATA[<h2 id="Java技术体系"><a href="#Java技术体系" class="headerlink" title="Java技术体系"></a>Java技术体系</h2><p>Java程序设计语言、Java虚拟机、Java API类库三部分统称为<strong>JDK</strong>，JDK是用于支持Java程序开发的最小环境。Java API类库中的Java SE API子集和Java虚拟机这两个部分统称为<strong>JRE</strong>，JRE是支持Java程序运行的标准环境。</p><a id="more"></a><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="http://p9fh1pach.bkt.clouddn.com/Java2.png" alt="avatar"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>线程独立，唯一没有规定OutOfMemoryError的区域</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><ul><li>线程私有，生命周期和线程相同</li><li>平时所谓的堆、栈、方法区，栈就是指<strong>虚拟机栈</strong>，或者说是其中的<strong>局部变量表</strong>部分</li><li>两种异常状况<ul><li>StackOverflowError: 线程请求栈深度大于所允许</li><li>OutOfMemoryError: 扩展无法申请足够内存</li></ul></li></ul><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>和虚拟机栈发挥作用相似</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><ul><li>线程共享，虚拟机启动时创建，<strong>存放对象实例</strong></li><li>GC管理的主要区域</li><li>内存空间不连续</li><li>OutOfMemoryError: 堆中没有内存完成实例分配并且无法扩展时</li></ul><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul><li>线程共享</li><li>存放类信息、常量、静态变量、即时编译器编译后的代码</li><li>OutOfMemoryError: 无法满足内存分配需求时</li></ul><h3 id="JVM实例"><a href="#JVM实例" class="headerlink" title="JVM实例"></a>JVM实例</h3><p><img src="http://p9fh1pach.bkt.clouddn.com/%E5%A0%86%E6%A0%88%E6%96%B9%E6%B3%95%E5%8C%BA.jpg" alt="avatar"></p><h2 id="HotSpot虚拟机对象揭秘"><a href="#HotSpot虚拟机对象揭秘" class="headerlink" title="HotSpot虚拟机对象揭秘"></a>HotSpot虚拟机对象揭秘</h2><p>HotSpot虚拟机在Java堆中对象分配、布局、访问的全过程</p><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><ul><li>虚拟机遇到new指令，检查指令的参数能否在常量池中定位到一个类的符号引用</li><li>检查所代表的类是否已被加载、解析和初始化过</li><li>没有，则先执行类加载过程</li><li>虚拟机为新生对象分配内存，对象所需内存大小在类加载完成后便可确定<ul><li>指针碰撞: 假设Java堆内存绝对规整，用过的内存和没用过的严格分开，有一个指针作为分界点的指示器，移动指针即可</li><li>空闲列表: 内存不规整，维护列表，记录是否可用，需要在列表中找一块足够大的区域</li></ul></li><li>对象创建频繁，可能会导致在并发情况下线程不安全<ul><li>对分配内存动作加上同步处理: CAS+失败重试</li><li>按线程划分在不同空间，每个线程预先分配<strong>本地线程分配缓冲(TLAB)</strong>，哪个线程需要分配内存，就在哪个线程的TLAB分配，只有在用完并分配新的TLAB时才同步锁定</li></ul></li><li>将分配到的内存空间初始化为零值</li><li>根据<strong>对象头</strong>对对象进行必要的设置</li><li>执行<init>方法</init></li></ul><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>HotSpot中分3块区域: 对象头、实例数据、对齐填充</p><ul><li>对象头<ol><li>存储对象自身运行时数据: 哈希码、GC分代年龄…</li><li>类型指针，对象指向其类原数据的指针，<strong>确定对象是哪个类的实例</strong>（不是所有虚拟机实现都必须保留该指针）</li></ol></li><li>实例数据: 在代码中定义的各种类型的字段内容<ul><li>HotSpot默认相同宽度字段被分配到一起，比如shorts/chars，父类的变量在子类之前</li></ul></li><li>对齐填充(不一定存在，占位作用)</li></ul><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>使用对象需要通过<strong>栈</strong>上的reference来操作<strong>堆</strong>上的具体对象，引用如何去定位，主流有两种：</p><ul><li>句柄（稳定）<ul><li>reference存储对象的句柄地址，句柄中包含对象实例数据和类型数据的具体信息<br><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG239.jpeg" alt="avatar"></li></ul></li><li>直接指针（速度快，HotSpot）<ul><li>reference存储对象的地址<br><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG240.jpeg" alt="avatar"></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 读书笔记 </category>
          
          <category> 深入理解Java虚拟机 </category>
          
          <category> 自动内存管理机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Quick Select</title>
      <link href="/2018/06/04/QuickSelect/"/>
      <url>/2018/06/04/QuickSelect/</url>
      <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>Quick Select是由quick sort而来，只是它只用了quick sort前面partition的部分</p><p>平均时间复杂度：O(n),最差: O(n^2)</p><a id="more"></a><h2 id="模板思路"><a href="#模板思路" class="headerlink" title="模板思路"></a>模板思路</h2><h3 id="选最后一个"><a href="#选最后一个" class="headerlink" title="选最后一个"></a>选最后一个</h3><ol><li>每次选一个pivot，可以选最后一个</li><li>两个变量，一个存比pivot小的数left，一个存比pivot大的数right</li><li>初始化: left = 0, right = length - 1</li><li>left == right则break</li></ol><p><strong>核心代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(nums[left] &lt; pivot &amp;&amp; left &lt; right)&#123;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(nums[right] &gt;= pivot &amp;&amp; left &lt; right)&#123;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left == right) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选第一个"><a href="#选第一个" class="headerlink" title="选第一个"></a>选第一个</h3><ol><li>每次选一个pivot，可以选第一个</li><li>两个变量，一个存比pivot小的数left，一个存比pivot大的数right</li><li>初始化: left = 0, right = length - 1</li><li>p从0开始遇到right结束</li></ol><p><strong>核心代码</strong></p><pre><code>while(p &lt;= right){    if(nums[left] &lt; pivot){        swap(nums, left, p);        left++;        p++;    }else if(nums[right] == pivot){        p++;    }else{        swap(nums, right, p);        right--;    }}</code></pre><h3 id="215-Kth-Largest-Element-in-an-Array"><a href="#215-Kth-Largest-Element-in-an-Array" class="headerlink" title="215.Kth Largest Element in an Array"></a>215.Kth Largest Element in an Array</h3><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p><strong>Example 1:</strong></p><pre><code>Input: [3,2,1,5,6,4] and k = 2Output: 5</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: [3,2,3,1,2,4,5,5,6] and k = 4Output: 4</code></pre><p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p><ul><li>直接排序，返回排序后nums[nums.length-k]</li><li>建小顶堆(默认)，size大于k则poll，最后返回堆顶元素</li><li>QuickSelect</li></ul><p><strong>QuickSelect方法代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[end];</span><br><span class="line">    <span class="keyword">int</span> left = start, right = end;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">       <span class="keyword">while</span>(nums[left] &lt; pivot &amp;&amp; left &lt; right)&#123;</span><br><span class="line">           left++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(nums[right] &gt;= pivot &amp;&amp; left &lt; right)&#123;</span><br><span class="line">           right--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(left == right) <span class="keyword">break</span>;</span><br><span class="line">       swap(nums,left,right);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums,left,end);</span><br><span class="line">    <span class="keyword">if</span>(left+<span class="number">1</span> == k) <span class="keyword">return</span> pivot;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(left+<span class="number">1</span> &lt; k) <span class="keyword">return</span> findKth(nums, k, left+<span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> findKth(nums, k, start, left-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="75-Sort-Color"><a href="#75-Sort-Color" class="headerlink" title="75.Sort Color"></a>75.Sort Color</h3><blockquote><p>3种颜色(0,1,2)，排序使得相同颜色相邻</p></blockquote><p>直接使用模板方法即可</p><h3 id="143-Sort-Color-II-Lintcode"><a href="#143-Sort-Color-II-Lintcode" class="headerlink" title="143.Sort Color II(Lintcode)"></a>143.Sort Color II(Lintcode)</h3><blockquote><p>k种颜色(1-k)，排序使得相同颜色相邻</p></blockquote><p>可以仍然使用以上模板方法，变化的只是需要每次找数组中的最大最小值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors2</span><span class="params">(<span class="keyword">int</span>[] colors, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>,start = <span class="number">0</span>,end = colors.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(count &lt; k)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE,max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i &lt;= end;i++)&#123;</span><br><span class="line">            min = Math.min(min,colors[i]);</span><br><span class="line">            max = Math.max(max,colors[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = start,right = end, p = start;</span><br><span class="line">        <span class="keyword">while</span>(p &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(colors[p] == min)&#123;</span><br><span class="line">                swap(colors,p,left);</span><br><span class="line">                p++;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(colors[p] &gt; min &amp;&amp; colors[p] &lt; max)&#123;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                swap(colors,p,right);</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count += <span class="number">2</span>;</span><br><span class="line">        start = left;</span><br><span class="line">        end = right;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 算法 </category>
          
          <category> LeetCode Category </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> QuickSelect </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Two Pointer</title>
      <link href="/2018/05/31/TwoPointer/"/>
      <url>/2018/05/31/TwoPointer/</url>
      <content type="html"><![CDATA[<h2 id="双指针法的常见应用"><a href="#双指针法的常见应用" class="headerlink" title="双指针法的常见应用"></a>双指针法的常见应用</h2><p>所谓双指针，指的是在<strong>遍历对象</strong>的过程中，不是普通的使用单个指针进行访问，而是使用<strong>两个</strong>相同方向或者相反方向的指针进行扫描，从而达到相应的目的。</p><p>换言之，双指针法充分使用了<strong>数组有序</strong>这一特征，从而在某些情况下能够简化一些运算。</p><p>(注：这里的<strong>指针</strong>，并非专指c中指针的概念，而是指<strong>索引，游标或指针，可迭代对象等</strong>)</p><a id="more"></a><h3 id="209-Minimum-Size-Subarray-Sum"><a href="#209-Minimum-Size-Subarray-Sum" class="headerlink" title="209.Minimum Size Subarray Sum"></a>209.Minimum Size Subarray Sum</h3><p>Given an array of n positive integers and a positive integer s, find the minimal length of a subarray of which the sum ≥ s. If there isn’t one, return 0 instead.</p><p>For example, given the array [2,3,1,2,4,3] and s = 7, the subarray [4,3] has the minimal length under the problem constraint.</p><ul><li>最短子串和</li></ul><p><strong>思路一</strong></p><ul><li>Two Pointer<ul><li>是用两个指针形成一个移动窗口</li><li>当sum的值小于s时，将右边界向右扩张，sum += arr[right++]</li><li>当sum的值大于s时，则将左边届右移，判断取较小的count</li><li>循环条件是right &lt;= length, left &lt;= right</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, sum = <span class="number">0</span>, count = nums.length + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt;= nums.length &amp;&amp; left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; s)&#123;</span><br><span class="line">                <span class="keyword">if</span>(right &lt; nums.length)&#123;</span><br><span class="line">                    sum += nums[right];</span><br><span class="line">                &#125;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count = Math.min(count,right - left);</span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &lt;= nums.length? count:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路二</strong></p><ul><li>二分法(适用subarray sum问题)<ul><li>构造sum数组，sum[i+1] = sum[i]+nums[i]</li><li>sum数组递增</li><li>遍历数组sum，对每一个i，寻找j(右边界)，使得i～j区间的值大于s</li><li>不断更新找出最小值</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, min = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] sums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            sums[i] = nums[i] + (i == <span class="number">0</span> ? <span class="number">0</span> : sums[i - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = findWindowEnd(i, sums, s);</span><br><span class="line">            <span class="keyword">if</span> (j == nums.length) <span class="keyword">break</span>;</span><br><span class="line">            min = Math.min(j - i + <span class="number">1</span>, min);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> min == Integer.MAX_VALUE ? <span class="number">0</span> : min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findWindowEnd</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span>[] sums, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = start, j = sums.length - <span class="number">1</span>, offset = start == <span class="number">0</span> ? <span class="number">0</span> : sums[start - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = sums[m] - offset;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= s) j = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> i = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Valid-Palindrome"><a href="#Valid-Palindrome" class="headerlink" title="Valid Palindrome"></a>Valid Palindrome</h3><h4 id="125-I"><a href="#125-I" class="headerlink" title="125.I"></a>125.I</h4><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p><p>Note: For the purpose of this problem, we define empty string as valid palindrome.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;A man, a plan, a canal: Panama&quot;Output: true</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: &quot;race a car&quot;Output: false</code></pre><ul><li>双指针，首尾</li><li>注意大小写转换</li><li>isValid(char c)判断是否是a-z||A-Z||0-9</li></ul><h4 id="680-II"><a href="#680-II" class="headerlink" title="680.II"></a>680.II</h4><p>Given a non-empty string s, you may delete <strong>at most one</strong> character. Judge whether you can make it a palindrome.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;aba&quot;Output: True</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: &quot;abca&quot;Output: TrueExplanation: You could delete the character &apos;c&apos;.</code></pre><ul><li>String的题</li><li>一个用于判断是否是回文的方法</li><li>主函数判断start和end的值是否相等</li><li>不相等，则判断start+1和end||start和end-1的值是否相等</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(start) != s.charAt(end))&#123;</span><br><span class="line">                <span class="keyword">return</span> isValid(s, start+<span class="number">1</span>, end) || isValid(s, start, end-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) != s.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-Container-with-Most-Water"><a href="#11-Container-with-Most-Water" class="headerlink" title="11.Container with Most Water"></a>11.Container with Most Water</h3><p>Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p>Note: You may not slant the container and n is at least 2.</p><p><strong>问题转换成数列中选两个值使得中间的面积最大</strong></p><ul><li>首尾指针，遍历</li><li>求局部面积</li><li>如果左边较低，则将左边向中间移一点，因为无论右边怎么移动，高度不变，但宽却在减小，只有将左边向中间移动，面积才有可能变大</li><li>如果右边较低，则将右边向中间移一点</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>, left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            maxArea = Math.max(maxArea,Math.min(height[left],height[right]) * (right-left));</span><br><span class="line">            <span class="keyword">if</span>(height[left] &gt; height[right])&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="42-Trapping-Rain-Water"><a href="#42-Trapping-Rain-Water" class="headerlink" title="42.Trapping Rain Water"></a>42.Trapping Rain Water</h3><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p><p><img src="http://p9fh1pach.bkt.clouddn.com/rainwatertrap.png" alt="avatar"></p><p>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p><p><strong>Example:</strong></p><pre><code>Input: [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6</code></pre><p><strong>解题方法</strong></p><p>从两边开始灌水，总是从低的一边开始灌，高的地方保持不动，同时记录下可以灌的水的总量，不断更新</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height == <span class="keyword">null</span> || height.length &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftbound = height[left], rightbound = height[right];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(leftbound &lt; rightbound)&#123;</span><br><span class="line">                <span class="comment">//左边低，从左边开始灌</span></span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span>(height[left] &lt;= leftbound)&#123;</span><br><span class="line">                    <span class="comment">//比现有的bound低，可以灌</span></span><br><span class="line">                    res += leftbound - height[left];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//比现有的bound高，更新左边的bound</span></span><br><span class="line">                    leftbound = height[left];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">                <span class="keyword">if</span>(height[right] &lt;= rightbound)&#123;</span><br><span class="line">                    res += rightbound - height[right];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    rightbound = height[right];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="61-Rotate-List"><a href="#61-Rotate-List" class="headerlink" title="61.Rotate List"></a>61.Rotate List</h3><p>Given a linked list, rotate the list to the right by k places, where k is non-negative.</p><p><strong>Example 1:</strong></p><pre><code>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULLExplanation:rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULLrotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4Output: 2-&gt;0-&gt;1-&gt;NULLExplanation:rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULLrotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULLrotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULLrotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</code></pre><ul><li>获得链表的长度n，k%n才是需要移动的</li><li>找到最后结果的链表的tail:first,循环n-k-1次找next即可</li><li>遍历找到原链表的tail:second</li><li>second.next = head</li><li>result = first.next</li><li>first.next = null</li></ul>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 算法 </category>
          
          <category> LeetCode Category </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> TwoPointer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>商汤</title>
      <link href="/2018/05/18/%E5%95%86%E6%B1%A4/"/>
      <url>/2018/05/18/%E5%95%86%E6%B1%A4/</url>
      <content type="html"><![CDATA[<p>商汤Java实习生面试<br><a id="more"></a></p><ul><li>Collections框架体系<br><img src="http://p9fh1pach.bkt.clouddn.com/20170309094509415.jpeg" alt="avatar"></li><li>HashSet的特性<ul><li>基于HashMap实现</li><li>无序不重复</li></ul></li><li>HashMap结构<ul><li>哈希表，数组+链表</li></ul></li><li>HashMap和ConcurrentHashMap区别</li><li>锁的了解</li><li>线程池有哪些？</li><li>怎么实现线程？</li><li>并发包…</li><li>SpringBoot中@ReseController注解对应哪两个<ul><li>@ResponseBody和@Controller的组合注解。</li></ul></li><li>Redis支持哪些类型？<ul><li>Strings</li><li>Lists</li><li>Sets 求交集、并集</li><li>Sorted Set</li><li>hashes</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> 面试经历 </category>
          
          <category> 2018 </category>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>简历相关准备</title>
      <link href="/2018/04/30/%E7%AE%80%E5%8E%86%E5%87%86%E5%A4%87/"/>
      <url>/2018/04/30/%E7%AE%80%E5%8E%86%E5%87%86%E5%A4%87/</url>
      <content type="html"><![CDATA[<p>简单的自我介绍<br><a id="more"></a></p><p><img src="http://p9fh1pach.bkt.clouddn.com/%E7%AE%80%E5%8E%86.png" alt="avatar"></p><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>我叫姜栋煜，现在在北京大学软件与微电子学院读研究生二年级，预计2019年6月份毕业，本科就读于北京交通大学。3月中旬结束在微软亚洲研究院的实习，主要做了课程数据的收集、维护，pipeline的日常导入以及一些数据的简单分析。此外，还做过一些导师和企业合作的项目，主要就是智慧教室，都是java web的一些项目。</p><h2 id="实习经历"><a href="#实习经历" class="headerlink" title="实习经历"></a>实习经历</h2><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>在小英组，主要产品是微软小英和Microsoft Learning Chinese，都是一些教授中小学生以及外国人学英语/中文的app，这些app会有一些对应的课程信息（json文本），课程信息的录入工具是由我去维护开发的，包括对文本、音频、视频、图片等的录入，存储主要是用了Azure Blob，音频、视频、图片存在对应的mooncake中国镜像上。</p><p>小英的用户量在200-300万左右，每天的数据量大，而且之前的pipeline导入方式费时，不易监控，就改为使用data factory,还会完成一些简单的分析工作，比如活跃用户、日留存、周留存、月留存等。。。</p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><ul><li>用于录入数据的网站，可以自动merge数据，减少人工干预</li><li>pipeline导入做到了高效，速度比原来快了3倍多，出错会发邮件</li><li>分析信息用于确定用户使用情况</li></ul><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><ul><li>内部网站数据混乱，会出现直接修改merge之后文件，而导致不一致问题的出现</li><li>data factory全靠自己看英文文档，教程少</li></ul><h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><h3 id="智慧教室"><a href="#智慧教室" class="headerlink" title="智慧教室"></a>智慧教室</h3><blockquote><p>简单而言，就是一个课堂直播的一个平台，主要分为三个端，web/phone端，树莓派，PC。web/phone端和树莓派通过websocket通信，主要传输一些控制指令，树莓派和PC通过串口直接相连。</p></blockquote><p>web端主要完成教室设备的CRUD，权限控制，还有就是给树莓派发送指令，具体的操作，比如操作教室推流真正还是由PC去完成。这个项目已经在河北邢台的一些中小学开始试用了。</p><p><strong>难点（问题）</strong></p><ul><li>SpringBoot和websocket无法注入bean的问题，其实不是不能注入，是已经注入了，但是客户端每建立一个链接就会创建一个对象，这个对象没有任何的bean注入操作,<strong>最后使用静态变量</strong></li><li>websocket不稳定，异常处理机制，树莓派定时心跳，异常重连</li></ul><h3 id="即时通讯"><a href="#即时通讯" class="headerlink" title="即时通讯"></a>即时通讯</h3><p>类似于朋友圈，可发布状态，点赞、评论等</p><p>使用MongoDB是因为便于存储点赞/评论list，非结构化<br>Redis用于缓存朋友圈动态信息，前N条经常被浏览</p><h2 id="比赛经历"><a href="#比赛经历" class="headerlink" title="比赛经历"></a>比赛经历</h2><p>Google Girl Hackthon 主题是机器学习，给了一些新闻的数据，让自己从中分析出自己想要的信息,主要是做了数据的处理，对train得到的数据，处理成前端可展示的json格式</p>]]></content>
      
      <categories>
          
          <category> Java面试 </category>
          
          <category> 简历 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简历 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>BackTracking</title>
      <link href="/2018/04/29/BackTracking/"/>
      <url>/2018/04/29/BackTracking/</url>
      <content type="html"><![CDATA[<p><strong>思想</strong></p><ol><li>试错</li><li>分步解决问题</li><li>不符合则取消上一步或上几步</li></ol><p><strong>BackTracking可大致分为全排列问题、数独等问题</strong><br><a id="more"></a></p><h2 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h2><h3 id="类型1"><a href="#类型1" class="headerlink" title="类型1"></a>类型1</h3><ul><li>subsets</li><li>subset II </li><li>permutations </li><li>permutations II </li><li>Combinations </li><li>Combinations Sum </li><li>Combinations Sum II </li><li>N Queen</li><li>N Queen II</li><li>letter combination of a phone number</li></ul><h3 id="类型2（基于全排列的问题）"><a href="#类型2（基于全排列的问题）" class="headerlink" title="类型2（基于全排列的问题）"></a>类型2（基于全排列的问题）</h3><ul><li>Next Permutation</li><li>Previous Permutation􏰍􏴤􏴥􏴓􏲌(与next permutation类似)</li><li>Permutation Sequence</li><li>Permutation Index</li><li>Permutation Index II (hard)</li></ul><p><strong>permuataions有序，subsets无序</strong></p><h4 id="Subsets"><a href="#Subsets" class="headerlink" title="Subsets"></a>Subsets</h4><ul><li>Sort原数组</li><li>dfs</li><li>判断是否取这个数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line">subset(results, result, nums, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subset</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; results, List&lt;Integer&gt; result, <span class="keyword">int</span>[] num, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">results.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(result));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; num.length; i++) &#123;</span><br><span class="line">result.add(num[i]);</span><br><span class="line">subset(results, result, num, i + <span class="number">1</span>);</span><br><span class="line">result.remove(result.size()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Subsets-II"><a href="#Subsets-II" class="headerlink" title="Subsets II"></a>Subsets II</h3><blockquote><p>contain duplicates, nums</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i != index &amp;&amp; num[i] == num[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><h3 id="Permutations"><a href="#Permutations" class="headerlink" title="Permutations"></a>Permutations</h3><p>Given a collection of distinct integers, return all possible permutations.</p><p><strong>Example:</strong></p><pre><code>Input: [1,2,3]Output:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]]</code></pre><ul><li>用一个数组记录是否被使用过</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> results;</span><br><span class="line"> List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        permute(results, result, nums, used);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">permute</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; results, List&lt;Integer&gt; result, <span class="keyword">int</span>[] num, <span class="keyword">boolean</span>[] used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num.length == result.size()) results.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(result));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[i])&#123;</span><br><span class="line">                result.add(num[i]);</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line">    permute(results, result, num, used);</span><br><span class="line">    result.remove(result.size()-<span class="number">1</span>); </span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Permutation-II"><a href="#Permutation-II" class="headerlink" title="Permutation II"></a>Permutation II</h3><blockquote><p>might contain duplicates</p></blockquote><ul><li>对数组排序</li><li>判断num[i] == num[i-1] &amp;&amp; !used[i-1]</li><li>如果前一个已经用了，当前值相同再被用，不会重复</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i !=<span class="number">0</span> &amp;&amp; num[i] == num[i-<span class="number">1</span>] &amp;&amp; !used[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><h3 id="Combinations"><a href="#Combinations" class="headerlink" title="Combinations"></a>Combinations</h3><p>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p><p><strong>Example:</strong></p><pre><code>Input: n = 4, k = 2Output:[  [2,4],  [3,4],  [2,3],  [1,2],  [1,3],  [1,4],]</code></pre><p>类似subset</p><h3 id="Combination-Sum"><a href="#Combination-Sum" class="headerlink" title="Combination Sum"></a>Combination Sum</h3><p>Given a set of candidate numbers (candidates) (<strong>without duplicates</strong>) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</p><p>The same repeated number may be chosen from candidates <strong>unlimited number of times.</strong></p><p><strong>Note:</strong></p><ul><li>All numbers (including target) will be <strong>positive integers</strong>.</li><li>The solution set must <strong>not contain duplicate combinations.</strong></li></ul><p><strong>Example 1:</strong></p><pre><code>Input: candidates = [2,3,6,7], target = 7,A solution set is:[  [7],  [2,2,3]]</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: candidates = [2,3,5], target = 8,A solution set is:[  [2,2,2,2],  [2,3,3],  [3,5]]</code></pre><ul><li>求sum</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(candidates == <span class="keyword">null</span> || candidates.length == <span class="number">0</span>) <span class="keyword">return</span> results;</span><br><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        combinationSum(results, result, candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">combinationSum</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; results, List&lt;Integer&gt; result, <span class="keyword">int</span>[] candidate, <span class="keyword">int</span> target, <span class="keyword">int</span> index, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target) results.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(result));</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; candidate.length; i++) &#123;</span><br><span class="line">            result.add(candidate[i]);</span><br><span class="line">            sum += candidate[i];</span><br><span class="line">    combinationSum(results, result, candidate, target, i, sum);</span><br><span class="line">result.remove(result.size()-<span class="number">1</span>);  </span><br><span class="line">sum -= candidate[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Combination-Sum-II"><a href="#Combination-Sum-II" class="headerlink" title="Combination Sum II"></a>Combination Sum II</h3><p>Each number in candidates may only be used <strong>once</strong> in the combination.</p><ul><li>增加sort</li><li>增加去重</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i != index &amp;&amp; candidate[i] == candidate[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><h3 id="Combination-Sum-III"><a href="#Combination-Sum-III" class="headerlink" title="Combination Sum III"></a>Combination Sum III</h3><p>Find all possible combinations of <strong>k numbers</strong> that <strong>add up to a number n</strong>, given that only numbers from <strong>1 to 9</strong> can be used and each combination should be a unique set of numbers.</p><p><strong>Note:</strong></p><ul><li>All numbers will be positive integers.</li><li>The solution set must not contain duplicate combinations.</li></ul><p><strong>Example 1:</strong></p><pre><code>Input: k = 3, n = 7Output: [[1,2,4]]</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: k = 3, n = 9Output: [[1,2,6], [1,3,5], [2,3,4]]</code></pre><ul><li>同时考虑sum和list长度</li></ul><h3 id="Letter-Combinations-of-a-Phone-Number"><a href="#Letter-Combinations-of-a-Phone-Number" class="headerlink" title="Letter Combinations of a Phone Number"></a>Letter Combinations of a Phone Number</h3><ul><li>存储对应关系</li><li>像subset那样处理即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String[] map = &#123;<span class="string">""</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span>[] resultStr= <span class="keyword">new</span> <span class="keyword">char</span>[digits.length()];</span><br><span class="line">        letterCombinations(result, digits, map, resultStr, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">letterCombinations</span><span class="params">(List&lt;String&gt; result, String digits, String[] map, <span class="keyword">char</span>[] resultStr, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(digits.length() == count)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> String(resultStr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String str = map[digits.charAt(count)-<span class="string">'0'</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; str.length();i++)&#123;</span><br><span class="line">            resultStr[count] = str.charAt(i);</span><br><span class="line">            letterCombinations(result, digits, map, resultStr, count+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Generate-Parentheses"><a href="#Generate-Parentheses" class="headerlink" title="Generate Parentheses"></a>Generate Parentheses</h3><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><p>For example, given n = 3, a solution set is:</p><pre><code>[  &quot;((()))&quot;,  &quot;(()())&quot;,  &quot;(())()&quot;,  &quot;()(())&quot;,  &quot;()()()&quot;]</code></pre><ul><li>如果左括号数量小于n，则可以再有左括号</li><li>如果左括号数量大于右括号数量，则可以再有右括号</li></ul><h3 id="Next-Permutation"><a href="#Next-Permutation" class="headerlink" title="Next Permutation"></a>Next Permutation</h3><p>输入一个整数数组，该整数数组按照下标顺序代表一个数字，例如[1,2,3]代表整数123，要求改变数组中元素的顺序，找到<strong>比当前数字大的生成数中的最小值</strong>。如果当前数字代表的整数值已经是所有排列组合中的<strong>最大值</strong>，则返回当前数字组成的<strong>最小值</strong>。</p><ul><li>从右往左扫，找到第一个满足：nums[i-1] &lt; nums[i]条件的，</li><li>再找到从右到左第一个比nums[i-1]大的数，把它们swap，</li><li>再把所有i-1之后的数字swap即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i-<span class="number">1</span>] &lt; nums[i]) <span class="keyword">break</span>;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i = 0, decreasing</span></span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; nums[i-<span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i-<span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// swap all elements after i-1</span></span><br><span class="line">        <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; end) swap(nums, i++, end--);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Permutation-Sequence"><a href="#Permutation-Sequence" class="headerlink" title="Permutation Sequence"></a>Permutation Sequence</h3><p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p><p>By listing and labeling all of the permutations in order, we get the following sequence for n = 3:</p><ol><li>“123”</li><li>“132”</li><li>“213”</li><li>“231”</li><li>“312”</li><li>“321”</li></ol><p>Given n and k, return the kth permutation sequence.</p><p><strong>Note:</strong></p><ul><li>Given n will be between 1 and 9 inclusive.</li><li>Given k will be between 1 and n! inclusive.</li></ul><p><strong>Example 1:</strong></p><pre><code>Input: n = 3, k = 3Output: &quot;213&quot;</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: n = 4, k = 9Output: &quot;2314&quot;</code></pre><p><strong>找规律！！！</strong></p><p><strong>复杂度</strong></p><p>时间 O(N) 空间 O(1)</p><p><strong>思路</strong></p><p>由于我们只要得到第K个全排列，而不是所有全排列，我们不一定要将所有可能都搜索一遍。根据全排列顺序的性质，我们可以总结出一个规律：假设全排列有n个数组成，则<strong>第k个全排列的第一位是k/(n-1)!</strong>。为了更形象一点，举例如下：</p><pre><code>123132213231312321</code></pre><p>在这种情况下，第一个数字每2!=2个情况就改变一次，<strong>假设求第6个排列，我们先将其减1，方便整除运算，然后5/2=2。对于第一位，我们有三种可选数字1、2、3，所以5/2=2意味着我们选择第3个数字，也就是3（如果商是s，则选第s+1个数字）。然后将5%2得到1，这个1就是下一轮的k。</strong></p><p><strong>注意</strong></p><p>这里有一个技巧，就是用一个列表将1到n存起来，每选用一个数就是移出那个数，就能保证不选重复数字的同时，其顺序也是一样的。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1</span>;</span><br><span class="line">        List&lt;Integer&gt; candidates = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// 先得到n!和候选数字列表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            mod = mod * i;</span><br><span class="line">            candidates.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将k先减1方便整除</span></span><br><span class="line">        k--;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            mod = mod / (n - i);</span><br><span class="line">            <span class="comment">// 得到当前应选数字的序数</span></span><br><span class="line">            <span class="keyword">int</span> first = k / mod;</span><br><span class="line">            <span class="comment">// 得到用于计算下一位的k</span></span><br><span class="line">            k = k % mod;</span><br><span class="line">            sb.append(candidates.get(first));</span><br><span class="line">            <span class="comment">// 在列表中移出该数字</span></span><br><span class="line">            candidates.remove(first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Permutation-Index"><a href="#Permutation-Index" class="headerlink" title="Permutation Index"></a>Permutation Index</h3><blockquote><p>给定一个排列数，每位都不重复，返回它在全排列中的index,index从1开始</p></blockquote><ul><li>对于某一个给定的位数A[i],需要判断在它后面有几个小于它的数，记下这个数字和A[i]所在的位置。</li><li>比如对于一个四位数，5316，第一位后面有2小于它的数，如果这两个数排在第一位，那么（1和3）各有3！的排列组合数小于（5316）.</li><li>同理，对于第二位，其后有1个小于它的数，如果它放在第二位，那么有2！种排列。</li><li>因此判断一个给定数位于排列组合的第几位，则可以按照以下公式进行</li></ul><p><strong>count1*(A.length-1)!+count2*(A.length-2)!+……+countn*(0)!</strong></p><p>为方便计算，从右往左遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">permutationIndex</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> fact = <span class="number">1</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> rank = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; A.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[j] &lt; A[i]) rank++;</span><br><span class="line">            &#125;</span><br><span class="line">            index += rank * fact;</span><br><span class="line">            fact *= (A.length-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Permutation-Index-II"><a href="#Permutation-Index-II" class="headerlink" title="Permutation Index II"></a>Permutation Index II</h3><blockquote><p>存在重复</p></blockquote><ul><li>与上一题的不同之处时会有<strong>重复的数。</strong></li><li>在发现是重复数的那一位用(rank * fact)/dup+index即可。</li><li>当然，每个重复数的dup都要阶乘，例如有3个2，4个8，dup就是3! * 4! = 144。</li><li>index是所有previous排列的次数和，返回下一次index+1。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">permutationIndexII</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> index = <span class="number">0</span>, fact = <span class="number">1</span>, dup = <span class="number">1</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(A[i])) map.put(A[i], <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(A[i], map.get(A[i])+<span class="number">1</span>);</span><br><span class="line">                dup *= map.get(A[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> rank = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; A.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[j] &lt; A[i]) rank++;</span><br><span class="line">            &#125;</span><br><span class="line">            index += rank * fact / dup;</span><br><span class="line">            fact *= (A.length - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sudoku"><a href="#Sudoku" class="headerlink" title="Sudoku"></a>Sudoku</h2><h3 id="Valid-Sudoku"><a href="#Valid-Sudoku" class="headerlink" title="Valid Sudoku"></a>Valid Sudoku</h3><p>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:</p><ol><li>Each row must contain the digits 1-9 without repetition.</li><li>Each column must contain the digits 1-9 without repetition.</li><li>Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.</li></ol><p><img src="http://p9fh1pach.bkt.clouddn.com/250px-Sudoku-by-L2G-20050714.svg.png" alt="avatar"></p><p>A partially filled sudoku which is valid.</p><p>The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’.</p><p><strong>Example 1:</strong></p><pre><code>Input:[  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]Output: true</code></pre><p><strong>Example 2:</strong></p><pre><code>Input:[  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]Output: falseExplanation: Same as Example 1, except with the 5 in the top left corner being     modified to 8. Since there are two 8&apos;s in the top left 3x3 sub-box, it is invalid.</code></pre><p><strong>Note:</strong></p><ul><li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li><li>Only the filled cells need to be validated according to the mentioned rules.</li><li>The given board contain only digits 1-9 and the character ‘.’.</li><li>The given board size is always 9x9.</li></ul><p><strong>解题思路</strong></p><ul><li>9行9列</li><li>每行1-9，每列1-9，9个3*3的小数独，也是1-9，均不重复</li></ul><p><strong>方法</strong></p><ul><li>遍历每个格子判断是否合法</li><li>如果格子的值相同且不是”.”，但是行，列不同则不合法</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span> &amp;&amp; !isvalid(board, i, j)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isvalid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[row][col] == board[i][col] &amp;&amp; row != i) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[row][col] == board[row][i] &amp;&amp; col != i) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row/<span class="number">3</span>*<span class="number">3</span>; i &lt; row/<span class="number">3</span>*<span class="number">3</span>+<span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = col/<span class="number">3</span>*<span class="number">3</span>; j &lt; col/<span class="number">3</span>*<span class="number">3</span>+<span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == board[row][col] &amp;&amp; !(i == row &amp;&amp; j == col)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sudoku-Solver"><a href="#Sudoku-Solver" class="headerlink" title="Sudoku Solver"></a>Sudoku Solver</h3><p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p><p>A sudoku solution must satisfy all of the following rules:</p><ol><li>Each of the digits 1-9 must occur exactly once in each row.</li><li>Each of the digits 1-9 must occur exactly once in each column.</li><li>Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.</li></ol><p>Empty cells are indicated by the character ‘.’.</p><ul><li>dfs</li><li>对”.”的位置尝试填入1-9，待下次判断</li><li>可使用上一题的<strong>isvalid(char[][] board, int row, int col)</strong>方法剪枝</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length != <span class="number">9</span> || board[<span class="number">0</span>].length != <span class="number">9</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        solve(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">9</span>)</span><br><span class="line">            <span class="keyword">return</span> solve(board, i + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">9</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">9</span>; k++) &#123;</span><br><span class="line">                board[i][j] = (<span class="keyword">char</span>) (k + <span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">if</span> (isValid(board, i, j)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (solve(board, i, j + <span class="number">1</span>))</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> solve(board, i, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k != i &amp;&amp; board[k][j] == board[i][j])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k != j &amp;&amp; board[i][k] == board[i][j])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = i / <span class="number">3</span> * <span class="number">3</span>; row &lt; i / <span class="number">3</span> * <span class="number">3</span> + <span class="number">3</span>; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = j / <span class="number">3</span> * <span class="number">3</span>; col &lt; j / <span class="number">3</span> * <span class="number">3</span> + <span class="number">3</span>; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row != i &amp;&amp; col != j &amp;&amp; board[i][j] == board[row][col])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Flip-Game"><a href="#Flip-Game" class="headerlink" title="Flip Game"></a>Flip Game</h3><h4 id="I"><a href="#I" class="headerlink" title="I"></a>I</h4><p>You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip twoconsecutive “++” into “–”. The game ends when a person can no longer make a move and therefore the other person will be the winner.</p><p>Write a function to compute all possible states of the string after one valid move.</p><p>For example, given s = “++++”, after one move, it may become one of the following states:</p><pre><code>[  &quot;--++&quot;,  &quot;+--+&quot;,  &quot;++--&quot;]</code></pre><p>If there is no valid move, return an empty list [].</p><ul><li>直接遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">generatePossibleNextMoves</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || s.length() == <span class="number">1</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &lt; s.length() &amp;&amp; s.substring(i,i+<span class="number">2</span>).equals(<span class="string">"++"</span>))&#123;</span><br><span class="line">            res.add(s.substring(<span class="number">0</span>,i)+<span class="string">"--"</span>+s.substring(i+<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="II"><a href="#II" class="headerlink" title="II"></a>II</h4><blockquote><p>需要确保开始的人能赢</p></blockquote><ul><li>和I的做法类似</li><li>增加下一步替换后不能赢的判断即可</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canWin</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || s.length() == <span class="number">1</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &lt; s.length() &amp;&amp; s.substring(i,i+<span class="number">2</span>).equals(<span class="string">"++"</span>) &amp;&amp; !canWin(s.substring(<span class="number">0</span>,i)+<span class="string">"--"</span>+s.substring(i+<span class="number">2</span>)))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Nim-Game"><a href="#Nim-Game" class="headerlink" title="Nim Game"></a>Nim Game</h3><p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p><p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p><p><strong>Example:</strong></p><pre><code>Input: 4Output: false Explanation: If there are 4 stones in the heap, then you will never win the game;             No matter 1, 2, or 3 stones you remove, the last stone will always be              removed by your friend.</code></pre><ul><li>找规律的题</li><li>如果是4的倍数就输</li></ul><h3 id="N-Queen"><a href="#N-Queen" class="headerlink" title="N Queen"></a>N Queen</h3><ul><li>Queen不能在同一行，同一列，对角线上</li><li>也就是说可以将N Queen放置在数组中，一个数组下标表示行值，数组下标对应的数组值可表示其所属列 </li></ul><h4 id="I-1"><a href="#I-1" class="headerlink" title="I"></a>I</h4><blockquote><p>给出所有解</p></blockquote><p>类似用一个全局static的list存储结果</p><h4 id="II-1"><a href="#II-1" class="headerlink" title="II"></a>II</h4><blockquote><p>给出解的数量</p></blockquote><p>用一个全局static变量计数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveNQueens</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n, List&lt;Integer&gt; matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(matrix)) count++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n;k++)&#123;</span><br><span class="line">            matrix.add(k);</span><br><span class="line">            <span class="keyword">if</span>(isValid(matrix))&#123;</span><br><span class="line">                solveNQueens(i+<span class="number">1</span>, n, matrix);</span><br><span class="line">            &#125;</span><br><span class="line">            matrix.remove(matrix.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断queen是否合法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(List&lt;Integer&gt; matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> col = matrix.get(row);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; row;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> row1 = i;</span><br><span class="line">            <span class="keyword">int</span> col1 =  matrix.get(i);</span><br><span class="line">            <span class="keyword">if</span>(col1 == col) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(row - row1 == col - col1) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(row - row1 == col1 - col) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Palindrome-Partitioning"><a href="#Palindrome-Partitioning" class="headerlink" title="Palindrome Partitioning"></a>Palindrome Partitioning</h3><h4 id="I-2"><a href="#I-2" class="headerlink" title="I"></a>I</h4><p>Given a string s, partition s such that every substring of the partition is a palindrome.</p><p>Return all possible palindrome partitioning of s.</p><p><strong>Example:</strong></p><pre><code>Input: &quot;aab&quot;Output:[  [&quot;aa&quot;,&quot;b&quot;],  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]]</code></pre><ul><li>dfs+判断回文回溯</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(result, list, s);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;String&gt;&gt; result, List&lt;String&gt; list, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isPalindrome(s.substring(<span class="number">0</span>,i)))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(s.substring(<span class="number">0</span>, i));</span><br><span class="line">            helper(result, list, s.substring(i));</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(l) != s.charAt(r))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="II-2"><a href="#II-2" class="headerlink" title="II"></a>II</h4><p>Given a string s, partition s such that every substring of the partition is a palindrome.</p><p>Return the minimum cuts needed for a palindrome partitioning of s.</p><p><strong>Example:</strong></p><pre><code>Input: &quot;aab&quot;Output: 1Explanation: The palindrome partitioning [&quot;aa&quot;,&quot;b&quot;] could be produced using 1 cut.</code></pre><ul><li>DFS + backtracking<ul><li>按照I求出所有解，再找出长度最少的</li></ul></li><li>DP<ul><li>用cuts[i]表示当前位置最少需要切几次使每个部分都是回文。</li><li>如果s(j,i)这部分是回文，就有cuts[i] = cuts[j-1] + 1。</li><li>matrix[j] [i]表示j到i这部分是回文。</li><li>如果s.charAt(i) == s.charAt(j) &amp;&amp; isPalindrome[j+1] [i-1]是回文，则不需重复该部分的搜索。isPalindrome[j] [i]也是回文。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] cuts = <span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">// cuts[i] = cut[j-1] + 1 if [j,i] is panlindrome</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] isPalindrome = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n]; <span class="comment">// isPalindrome[j][i] means  [j,i] is panlidrome</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;       <span class="comment">// maximun cuts for position i, each panlidrome only length of one</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j) &amp;&amp; ( j + <span class="number">1</span> &gt; i - <span class="number">1</span> || isPalindrome[j+<span class="number">1</span>][i-<span class="number">1</span>]) )&#123;</span><br><span class="line">                    isPalindrome[j][i] = <span class="keyword">true</span>;</span><br><span class="line">                    min = j == <span class="number">0</span> ? <span class="number">0</span> : Math.min(min, cuts[j-<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cuts[i] = min;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cuts[n-<span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Palindrome-Permutation"><a href="#Palindrome-Permutation" class="headerlink" title="Palindrome Permutation"></a>Palindrome Permutation</h3><h4 id="I-3"><a href="#I-3" class="headerlink" title="I"></a>I</h4><p>Given a string, determine if a permutation of the string could form a palindrome.</p><p>For example, “code” -&gt; False, “aab” -&gt; True, “carerac” -&gt; True.</p><ul><li>根据回文性质，只有出现在中心的数是奇数</li></ul><p><strong>思路</strong></p><ul><li>HashMap计数，判断奇数是否最多出现了一次</li><li>HashSet消除，出现第偶数次消除，第奇数次加入Set，最后判断set的size是否不大于1</li></ul><h4 id="II-3"><a href="#II-3" class="headerlink" title="II"></a>II</h4><p>Given a string s, return all the palindromic permutations (without duplicates) of it. Return an empty list if no palindromic permutation could be form.</p><pre><code>For example:Given s = &quot;aabb&quot;, return [&quot;abba&quot;, &quot;baab&quot;].Given s = &quot;abc&quot;, return [].</code></pre><p><strong>Hint:</strong></p><ul><li>If a palindromic permutation exists, we just need to generate the first half of the string.</li><li>To generate all distinct permutations of a (half of) string, use a similar approach from: Permutations II or Next Permutation.</li></ul><p><strong>思路</strong></p><ul><li>回文分为三部分，在s中出现了偶数次的一半+奇数次的+一半的reverse</li><li>对在s中出现了偶数次的一半找全排列类似Permutations II</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">generatePalindromes</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        String mid = <span class="string">""</span>;</span><br><span class="line">        List&lt;Character&gt; list = <span class="keyword">new</span> ArrayList&lt;Character&gt;();</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character,Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            map.put(c,map.containsKey(c)?map.get(c)+<span class="number">1</span>:<span class="number">1</span>);</span><br><span class="line">            odd=odd+(map.get(c)%<span class="number">2</span>==<span class="number">1</span>?<span class="number">1</span>:-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(odd&gt;<span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Character,Integer&gt; entry:map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">char</span> key = entry.getKey();</span><br><span class="line">            <span class="keyword">int</span> val = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span>(val%<span class="number">2</span>==<span class="number">1</span>) mid=mid+key;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;val/<span class="number">2</span>;i++)&#123;</span><br><span class="line">                list.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        backtracking(res,mid,list,<span class="keyword">new</span> StringBuilder(),<span class="keyword">new</span> <span class="keyword">boolean</span>[list.size()]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(List&lt;String&gt; res,String mid,List&lt;Character&gt; list,StringBuilder sb,<span class="keyword">boolean</span>[] used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sb.length()==list.size())&#123;</span><br><span class="line">            res.add(sb.toString()+mid+sb.reverse().toString());</span><br><span class="line">            sb.reverse();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(used[i]||i&gt;<span class="number">0</span>&amp;&amp;list.get(i)==list.get(i-<span class="number">1</span>)&amp;&amp;!used[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line">                sb.append(list.get(i));</span><br><span class="line">                backtracking(res,mid,list,sb,used);</span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">                sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Additive-Number"><a href="#Additive-Number" class="headerlink" title="Additive Number"></a>Additive Number</h3><p>Additive number is a string whose digits can form additive sequence.</p><p>A valid additive sequence should contain <strong>at least</strong> three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.</p><p>Given a string containing only digits ‘0’-‘9’, write a function to determine if it’s an additive number.</p><p><strong>Note</strong>: Numbers in the additive sequence <strong>cannot</strong> have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;112358&quot;Output: true Explanation: The digits can form an additive sequence: 1, 1, 2, 3, 5, 8.              1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: &quot;199100199&quot;Output: true Explanation: The additive sequence is: 1, 99, 100, 199.              1 + 99 = 100, 99 + 100 = 199</code></pre><p><strong>Follow up:</strong><br>How would you handle overflow for very large input integers?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAdditiveNumber</span><span class="params">(String num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num.charAt(<span class="number">0</span>) == <span class="string">'0'</span> &amp;&amp; i &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            BigInteger x1 = <span class="keyword">new</span> BigInteger(num.substring(<span class="number">0</span>, i));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; Math.max(j, i) &lt;= n - i - j; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num.charAt(i) == <span class="string">'0'</span> &amp;&amp; j &gt; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                BigInteger x2 = <span class="keyword">new</span> BigInteger(num.substring(i, i + j));</span><br><span class="line">                <span class="keyword">if</span> (isValid(x1, x2, j + i, num)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(BigInteger x1, BigInteger x2, <span class="keyword">int</span> start, String num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == num.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        x2 = x2.add(x1);</span><br><span class="line">        x1 = x2.subtract(x1);</span><br><span class="line">        String sum = x2.toString();</span><br><span class="line">        <span class="keyword">return</span> num.startsWith(sum, start) &amp;&amp; isValid(x1, x2, start + sum.length(), num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 算法 </category>
          
          <category> LeetCode Category </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> BackTracking </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dynamic Programming</title>
      <link href="/2018/04/29/DynamicProgramming/"/>
      <url>/2018/04/29/DynamicProgramming/</url>
      <content type="html"><![CDATA[<blockquote><p>利用存储历史信息来减少重复计算，以空间换时间</p></blockquote><h2 id="DP四要素"><a href="#DP四要素" class="headerlink" title="DP四要素"></a>DP四要素</h2><ul><li><strong>function</strong> 方程，如何从子问题到父问题</li><li><strong>state</strong>    状态，存储子问题的结果</li><li><strong>init</strong>        初始化，最小问题</li><li><strong>result</strong>    结果，最大问题</li></ul><h2 id="标记函数"><a href="#标记函数" class="headerlink" title="标记函数"></a>标记函数</h2><p>要先想好标记数组到底标记的是什么。<br>最标准的：问的什么就标记什么。</p><a id="more"></a><h2 id="常见的四种DP类型"><a href="#常见的四种DP类型" class="headerlink" title="常见的四种DP类型"></a>常见的四种DP类型</h2><ul><li>Sequence DP</li><li>2 Sequence DP</li><li>Matrix DP</li><li>Others<ul><li>背包类</li><li>区间类</li></ul></li></ul><h2 id="什么时候可能使用DP"><a href="#什么时候可能使用DP" class="headerlink" title="什么时候可能使用DP"></a>什么时候可能使用DP</h2><ul><li>求max/min</li><li>yes/no 求能否达到</li><li>count(*) 求数量</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>多空一位0.</p><h2 id="一维DP"><a href="#一维DP" class="headerlink" title="一维DP"></a>一维DP</h2><h3 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h3><ul><li>Climbing Stairs</li><li>Decode Ways</li><li>Unique Binary Search Trees </li><li>Maximum Subarray</li><li>Maximum Product Subarray </li><li>Best Time to Buy and Sell Stock</li></ul><h3 id="什么时候可能不是DP"><a href="#什么时候可能不是DP" class="headerlink" title="什么时候可能不是DP"></a>什么时候可能不是DP</h3><ul><li>要求给出具体解决方案</li><li>输入的是集合而不是序列</li></ul><h3 id="类型一"><a href="#类型一" class="headerlink" title="类型一"></a>类型一</h3><ul><li>climbing chairs</li><li>jump game</li><li>decode ways</li><li>unique binary search trees</li></ul><h3 id="类型二-global-local"><a href="#类型二-global-local" class="headerlink" title="类型二 global,local"></a>类型二 global,local</h3><ul><li>maximum subarray</li><li>maximum product subarray </li><li>best time to but and sell stock</li></ul><p><strong>思路</strong></p><ul><li>当看到题目是选择包含还是不包含当前value[i]时</li><li>需要维护两个DP，global(全局最优，不一定包含当前值)，local(包含当前值的局部最优)</li><li>找出递推关系</li></ul><h3 id="Triangle"><a href="#Triangle" class="headerlink" title="Triangle"></a>Triangle</h3><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p><p>For example, given the following triangle</p><pre><code>[     [2],    [3,4],   [6,5,7],  [4,1,8,3]]</code></pre><p>The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</p><p>Note:</p><p>Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</p><p><strong>dp[i][j] 以 tri[i][j]为终点的path sum的最小值</strong></p><ul><li>state </li><li>function: <strong>dp[i][j] = min(dp[i-1][j],dp[i-1][j-1])+tri[i][j]</strong></li><li>init state </li><li>result</li></ul><p><strong>漂亮的代码：</strong>省去二维，不断更新，自底向上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] A = <span class="keyword">new</span> <span class="keyword">int</span>[triangle.size()+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=triangle.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;triangle.get(i).size();j++)&#123;</span><br><span class="line">            A[j] = Math.min(A[j],A[j+<span class="number">1</span>])+triangle.get(i).get(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Pascal’s-Triangle-I-amp-II"><a href="#Pascal’s-Triangle-I-amp-II" class="headerlink" title="Pascal’s Triangle I &amp; II"></a>Pascal’s Triangle I &amp; II</h3><blockquote><p>I：给定行数，输出三角</p></blockquote><p>每一层元素是它上面两个元素的和</p><blockquote><p>II:给定某一行行号，输出这一行</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        cur.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= rowIndex;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i-<span class="number">1</span>;j &gt; <span class="number">0</span>;j--)&#123;</span><br><span class="line">                cur.set(j,cur.get(j-<span class="number">1</span>)+cur.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">            cur.add(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="House-Robber"><a href="#House-Robber" class="headerlink" title="House Robber"></a>House Robber</h3><blockquote><p>相邻房子不能抢，global，local问题</p></blockquote><p><strong>dp[i]打劫到第i间时的最大值</strong></p><ul><li>state </li><li>function: <strong>dp[i] = max(dp[i-1],dp[i-2]+nums[i-1])</strong></li><li>init state: <strong>dp[0] = nums[0],dp[1] = max(nums[0],nums[1])</strong></li><li>result: <strong>dp[length-1]</strong></li></ul><h3 id="House-Robber-II"><a href="#House-Robber-II" class="headerlink" title="House Robber II"></a>House Robber II</h3><blockquote><p>房子是一个环，也就是说第一间和最后一间不能同时抢</p></blockquote><ul><li>拆分成两个数组</li><li>一个包含第一间，一个包含最后一间</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> Math.max(rob(nums,<span class="number">0</span>,n-<span class="number">2</span>),rob(nums,<span class="number">1</span>,n-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rob = <span class="number">0</span>,notRob = <span class="number">0</span>,preNot = <span class="number">0</span>,preYes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = lo;i &lt;= hi;i++)&#123;</span><br><span class="line">            rob = preNot + nums[i];</span><br><span class="line">            notRob = Math.max(preYes,preNot);</span><br><span class="line">            preNot = notRob;</span><br><span class="line">            preYes = rob;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(rob,notRob);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Best-Time-to-Buy-and-Sell-Stock"><a href="#Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Best Time to Buy and Sell Stock"></a>Best Time to Buy and Sell Stock</h3><h4 id="I"><a href="#I" class="headerlink" title="I"></a>I</h4><blockquote><p>交易一次</p></blockquote><p>略</p><h4 id="II"><a href="#II" class="headerlink" title="II"></a>II</h4><blockquote><p>不限交易次数，买入前必须不持有</p></blockquote><ul><li>贪心</li><li>方法一<ul><li>计算局部的峰值，谷值</li><li>求和</li></ul></li><li>方法二<ul><li>循环，只要prices[i] &gt; prices[i-1],求差值</li><li>求和</li></ul></li></ul><h4 id="III"><a href="#III" class="headerlink" title="III"></a>III</h4><blockquote><p>最多交易两次，买入前必须不持有</p></blockquote><p><strong>思路1</strong>：双向动态规划</p><ul><li>构造两个数组，left和right，left[i]表示从0到i天的最大获益，right[i]表示从i到最后一天的最大获益。</li><li>求left时，记录前i天的最低价minPrice与最大获益max，求left[i]：考虑要在第i天卖出，那么买进的时间必然是在0到i之间（闭区间），这个时候只需要比较prices[i]-minPrice和max就可以求出截止到第i天的最大获益，然后根据需要更新minPrice。</li><li>求right时，记录从第i天往后的最高价maxPrice与最大获益max，求right[i]：考虑要再第i天买进，那么卖出时间必然是在i到最后一天之间（闭区间），这个时候只需要比较maxPrice-prices[i]和max就可以求出从第i天开始的最大获益，然后根据需要更新maxPrice。</li><li>对于left和right的构造算法复杂度都是O(n)。</li><li>构造完left和right之后，只要求left[i]+right[i]的最大值就行了。</li></ul><p><strong>思路2</strong>：滚动扫描法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hold1 = Integer.MIN_VALUE, hold2 = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> release1 = <span class="number">0</span>, release2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="comment">//在该价格点卖出第二笔股票后手里剩的钱，等于上一轮买入第二笔股票后手里剩的钱加上卖出当前股票价格的钱，或者上一轮卖出第二笔股票后手里剩的钱两者中较大的</span></span><br><span class="line">            release2 = Math.max(release2, hold2 + prices[i]);</span><br><span class="line">            <span class="comment">//在该价格点买入第二笔股票后手里剩的钱，等于上一轮卖出第一笔股票后手里剩的钱减去买入当前股票价格的钱，或者上一轮买入第二笔股票后手里剩的钱两者中较大的</span></span><br><span class="line">            hold2 = Math.max(hold2, release1 - prices[i]);</span><br><span class="line">            <span class="comment">//在该价格点卖出第一笔股票后手里剩的钱，等于上一轮买入第一笔股票后手里剩的钱加上卖出当前股票价格的钱，或者上一轮卖出第一笔股票后手里剩的钱两者中较大的</span></span><br><span class="line">            release1 = Math.max(release1, hold1 + prices[i]);</span><br><span class="line">            <span class="comment">//在该价格点买入第一笔股票后手里剩的钱，等于初始资金减去买入当前股票价格的钱或者初始资金（不买）中较大的</span></span><br><span class="line">            hold1 = Math.max(hold1, -prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> release2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="IV"><a href="#IV" class="headerlink" title="IV"></a>IV</h4><blockquote><p>最多k次交易，III的延伸</p></blockquote><p><strong>动态规划</strong></p><ul><li>复杂度<ul><li>时间 O(Nk) 空间 O(Nk)</li></ul></li><li>思路<ul><li>第i天已经执行j笔交易的<strong>最大收益</strong>作为全局变量global，将第i天<strong>正好</strong>完成第j笔交易的最大收益作为局部变量local。</li><li>int diff = prices[i] - prices[i-1];</li><li>global[i][j] = max(global[i-1][j], local[i][j])</li><li>local[i][j] = max(global[i-1][j-1]+max(0, diff), local[i-1][j]+diff)</li><li>对于local，第i天正好完成第j笔交易的最大收益，可以基于第i-1天正好完成第j-1笔交易的最大收益加上当天交易的差值，还有第i-1天正好完成第j笔交易的最大收益加上当天交易的差值。</li><li>要注意的是，第i-1天正好完成第j-1笔交易这种情况，当前交易的差值取0和实际昨天今天差价中较大的，因为我们还有一次自由交易的余地，所以如果亏的话完全可以当天买卖避免损失。</li><li>但第i-1天正好完成第j笔交易这种情况来推导第i天正好完成第j笔交易时，相当于第i天已经要连着第i-1天交易，使得第i-1天正好完成的第j笔交易和第i天正好完成的第j笔交易是同一个交易。</li></ul></li><li>注意<ul><li>对于k &gt; prices.length / 2的情况，我们可以用II的解法来节省空间。因为按照题意必须先买后卖，那么对于n天交易，能够产生有效收益的交易次数是小于等于n/2的，只有不同天买卖才能产生差价。对于大于n/2的那部分交易，必定是当天买卖没有任何收益的，无论交易多少次都是一样的。所以如果k &gt; prices.length / 2，就相当于无限次交易。</li><li>数组的第二维初始化长度是k+1，因为我们要预留完成0笔交易的收益，是0。</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//用II的解法优化k &gt; prices.length / 2的情况</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt; prices.length / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(prices[i]&gt;prices[i-<span class="number">1</span>]) sum += prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化全局变量和局部变量</span></span><br><span class="line">        <span class="keyword">int</span>[][] global = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[][] local = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> diff = prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; k + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="comment">//更新局部变量</span></span><br><span class="line">                local[i][j] = Math.max(global[i-<span class="number">1</span>][j-<span class="number">1</span>]+Math.max(<span class="number">0</span>, diff), local[i-<span class="number">1</span>][j]+diff);</span><br><span class="line">                <span class="comment">//更新全局变量</span></span><br><span class="line">                global[i][j] = Math.max(global[i-<span class="number">1</span>][j], local[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> global[prices.length - <span class="number">1</span>][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>滚动扫描法</strong></p><p>时间 O(N) 空间 O(k)</p><blockquote><p>需要2k个变量来记录k次交易。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用II的解法优化k &gt; prices.length / 2的情况</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt; prices.length / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(prices[i]&gt;prices[i-<span class="number">1</span>]) sum += prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化买卖股票后剩余金钱的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] release = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] hold = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            hold[i]=Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; k+<span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="comment">//卖出第j笔交易，所剩余的钱</span></span><br><span class="line">                release[j] = Math.max(release[j], hold[j]+prices[i]);</span><br><span class="line">                <span class="comment">//买入第j笔交易，所剩余的钱</span></span><br><span class="line">                hold[j] = Math.max(hold[j], release[j-<span class="number">1</span>]-prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> release[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Best-time-to-buy-and-sell-stock-with-cool-down"><a href="#Best-time-to-buy-and-sell-stock-with-cool-down" class="headerlink" title="Best time to buy and sell stock with cool down"></a>Best time to buy and sell stock with cool down</h3><blockquote><p>不限交易次数，卖出后需要一天冷却</p></blockquote><p><strong>动态规划</strong></p><p>股票有<strong>三种</strong>状态: buy, sell, cooldown, sell与cooldown我们可以合并成一种状态，因为手里最终都<strong>没股票</strong>，最终需要的结果是sell，即手里股票卖了获得最大利润。所以我们可以用两个DP数组分别记录当前持股跟未持股的状态。然后根据题目中的限制条件，理清两个DP数组的表达式。</p><p>对于当天最终未持股的状态，最终最大利润有两种可能，一是今天没动作跟昨天未持股状态一样，二是昨天持股了，今天卖了。所以我们只要取这两者之间最大值即可，表达式如下：</p><pre><code>sellDp[i] = Math.max(sellDp[i - 1], buyDp[i - 1] + prices[i]);</code></pre><p>对于当天最终持股的状态，最终最大利润有两种可能，一是今天没动作跟昨天持股状态一样，二是前天还没持股，今天买了股票，这里是因为cooldown的原因，所以今天买股要追溯到前天的状态。我们只要取这两者之间最大值即可，表达式如下：</p><pre><code>buyDp[i] = Math.max(buyDp[i - 1], sellDp[i - 2] - prices[i]);</code></pre><p>最终我们要求的结果是</p><pre><code>sellDp[n - 1] 表示最后一天结束时手里没股票时的累积最大利润</code></pre><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 表示当天最终未持股的情况下，当天结束后的累计最大利润</span></span><br><span class="line">        <span class="keyword">int</span>[] sellDp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        <span class="comment">// 表示当天最终持股的情况下，当天结束后的累计最大利润</span></span><br><span class="line">        <span class="keyword">int</span>[] buyDp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 考虑初始情况</span></span><br><span class="line">        buyDp[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        sellDp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            sellDp[i] = Math.max(sellDp[i - <span class="number">1</span>], buyDp[i - <span class="number">1</span>] + prices[i]);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                buyDp[i] = Math.max(buyDp[i - <span class="number">1</span>], sellDp[i - <span class="number">2</span>] - prices[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buyDp[i] = Math.max(buyDp[i - <span class="number">1</span>], -prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sellDp[prices.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>滚动扫描法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* sell[i] = Math.max(sell[i-1], buy[i-1] + prices[i])</span></span><br><span class="line"><span class="comment">         * buy[i] = Math.max(sell[i-2]-prices[i], buy[i-1])</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> preBuy = Integer.MIN_VALUE, curBuy = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> preSell = <span class="number">0</span>, curSell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            preBuy = curBuy;</span><br><span class="line">            curBuy = Math.max(preSell - price, preBuy);</span><br><span class="line">            preSell = curSell;</span><br><span class="line">            curSell = Math.max(preSell, preBuy + price);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> curSell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Word-Break"><a href="#Word-Break" class="headerlink" title="Word Break"></a>Word Break</h3><h4 id="I-1"><a href="#I-1" class="headerlink" title="I"></a>I</h4><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p><p><strong>Note:</strong></p><ul><li>The same word in the dictionary may be reused multiple times in the segmentation.</li><li>You may assume the dictionary does not contain duplicate words.</li></ul><p><strong>Example 1:</strong></p><pre><code>Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]Output: trueExplanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]Output: trueExplanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.Note that you are allowed to reuse a dictionary word.</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]Output: false</code></pre><ul><li>state <ul><li>dp[i] 表示前i个字符能否做Word Break</li></ul></li><li>function <ul><li>canBreak[i] = True if canBreak[j] and dict.contains(s.substring(j, i)) j from 0 to i</li></ul></li><li>result<ul><li>canBreak[len(s)]</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; dicts)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String str: dicts)&#123;</span><br><span class="line">           dict.add(str); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &amp;&amp; dict.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="II-1"><a href="#II-1" class="headerlink" title="II"></a>II</h4><p>Given a string s and a dictionary of words dict, add spaces in s to construct a sentence where each word is a valid dictionary word.</p><p>Return all such possible sentences.</p><pre><code>For example, givens = &quot;catsanddog&quot;,dict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;].A solution is [&quot;cats and dog&quot;, &quot;cat sand dog&quot;].</code></pre><ul><li>如果要返回所有组合的话，我们可以考虑两种方法，</li><li>一种是DP，时间复杂度较低，但是比较耗内存，意味着对于每个Index, 我们可能都要存其对应所有解。</li><li>另一种是DFS，空间复杂度较低，但是时间时间复杂度较高，我们可以采用memorization优化时间复杂度。</li></ul><p><strong>复杂度</strong></p><ul><li>DP: time: O(n^2*k), space: O(nk), 假设k表示平均每个长度对应解的个数</li><li>DFS: time: O(2^n), space: O(n)</li></ul><p><strong>动态规划</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否能够分解</span></span><br><span class="line">        <span class="keyword">if</span> (!helper(s, wordDict)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录字符串s.substring(0, i)对应的解</span></span><br><span class="line">        HashMap&lt;Integer, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, List&lt;String&gt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        map.get(<span class="number">0</span>).add(<span class="string">""</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(j) &amp;&amp; wordDict.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!map.containsKey(i))</span><br><span class="line">                        map.put(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                    <span class="keyword">for</span> (String str : map.get(j)) &#123;</span><br><span class="line">                        map.get(i).add(str + (str.equals(<span class="string">""</span>) ? <span class="string">""</span> : <span class="string">" "</span>) + s.substring(j, i));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> map.get(s.length());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> dp[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; wordDict.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DFS</strong></p><ul><li>从头开始扫描，dict包含则对接下来的递归dfs</li><li>直至返回的str的长度等于s</li><li>接着返回上一层递归</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来记录s.substring(i)这个字符串能否分解</span></span><br><span class="line">        <span class="keyword">boolean</span>[] possible = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(possible, <span class="keyword">true</span>);</span><br><span class="line">        dfs(res, <span class="string">""</span>, s, wordDict,  <span class="number">0</span>, possible);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;String&gt; res, String cur, String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> start, <span class="keyword">boolean</span>[] possible)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">            res.add(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            String str = s.substring(start, i);</span><br><span class="line">            <span class="keyword">if</span> (wordDict.contains(str) &amp;&amp; possible[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> prevSize = res.size();</span><br><span class="line">                dfs(res, cur + (cur.equals(<span class="string">""</span>) ? <span class="string">""</span> : <span class="string">" "</span>) + str, s, wordDict, i, possible);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// DFS后面部分结果没有变化，说明后面是没有解的</span></span><br><span class="line">                <span class="keyword">if</span> (res.size() == prevSize)</span><br><span class="line">                    possible[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维DP"><a href="#二维DP" class="headerlink" title="二维DP"></a>二维DP</h2><h3 id="Dungeon-Game"><a href="#Dungeon-Game" class="headerlink" title="Dungeon Game"></a>Dungeon Game</h3><p>The demons had captured the princess (<strong>P</strong>) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (<strong>K</strong>) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.</p><p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.</p><p>Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0’s) or contain magic orbs that increase the knight’s health (positive integers).</p><p>In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.</p><p><strong>Write a function to determine the knight’s minimum initial health so that he is able to rescue the princess.</strong></p><p><strong>Notes:</strong></p><ul><li>The knight’s health has no upper bound.</li><li>Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.</li></ul><p><strong>动态规划</strong></p><ul><li>state : dp[i][j] 表示从i,j出发到终点所需要的最少的体力值</li><li>init: dp[m-1][n-1] = max(-dungeon[m-1][n-1],0)+1</li><li>function : dp[i][j] = min(dp[i+1][j],dp[i][j+1]) - dungeon[i][j]</li></ul><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = dungeon.length;</span><br><span class="line">        <span class="keyword">int</span> n = dungeon[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        dp[m-<span class="number">1</span>][n-<span class="number">1</span>] = Math.max(- dungeon[m-<span class="number">1</span>][n-<span class="number">1</span>], <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt;= m-<span class="number">1</span> &amp;&amp; j + <span class="number">1</span> &lt;= n-<span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i+<span class="number">1</span>][j], dp[i][j+<span class="number">1</span>]) - dungeon[i][j];;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( i + <span class="number">1</span> &lt;= m-<span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j] - dungeon[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= n-<span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j+<span class="number">1</span>] - dungeon[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &lt;= <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Maximal-Rectangle"><a href="#Maximal-Rectangle" class="headerlink" title="Maximal Rectangle"></a>Maximal Rectangle</h3><p>是Largest Rectangle in Histogram的晋升题</p><h4 id="Largest-Rectangle-in-Histogram"><a href="#Largest-Rectangle-in-Histogram" class="headerlink" title="Largest Rectangle in Histogram"></a>Largest Rectangle in Histogram</h4><p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. </p><p><img src="http://p9fh1pach.bkt.clouddn.com/1418713310-55de4fd532244.png" alt="avatar"></p><p>Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].</p><p><img src="http://p9fh1pach.bkt.clouddn.com/765770818-55de4fe7f3337.png" alt="avatar"></p><p>The largest rectangle is shown in the shaded area, which has area = 10 unit.</p><ul><li>栈，存放数组的index</li><li>判断遍历的数是否大于等于栈顶元素，大于则直接push</li><li>小于则pop，直到数组的下一个元素大于栈顶元素</li></ul><p>把数组中的每个元素都作为矩形高度，计算了一遍该高度下矩形的最大面积。只是每次都<strong>贪心</strong>最大，避免了重复计算，所以效率高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>, largestArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; height.length || (index == height.length &amp;&amp; !stack.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index != height.length &amp;&amp; (stack.isEmpty() || height[stack.peek()] &lt; height[index])) &#123;</span><br><span class="line">                stack.push(index++);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = height[stack.pop()];</span><br><span class="line">                <span class="keyword">int</span> w = stack.isEmpty() ? index : index - stack.peek() - <span class="number">1</span>;</span><br><span class="line">                largestArea = Math.max(largestArea, h * w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> largestArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Maximal-Rectangle-1"><a href="#Maximal-Rectangle-1" class="headerlink" title="Maximal Rectangle"></a>Maximal Rectangle</h4><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing all 1’s and return its area.</p><ul><li>要求最大的矩形，实际上可以将矩阵的每一行，转化为上一题的直方图，</li><li>而直方图的每个竖条的数字，就是该行对应坐标正上方，向上方向有多少个连续的1。</li><li>要转化为直方图，方法是每一行的数值都累加上一行计算出来的数值，而第一行的数值就是本身。如果原始矩阵中遇到0，则累加中断，重新置0。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 0 1 1 0 -&gt; 0 0 1 1 0</span><br><span class="line">0 0 1 1 0 -&gt; 0 0 2 2 0</span><br><span class="line">1 1 0 0 0 -&gt; 1 1 0 0 0</span><br><span class="line">1 1 1 0 0 -&gt; 2 2 1 0 0</span><br></pre></td></tr></table></figure><ul><li>dp[i][j]化为直方图的值</li><li>接着对dp[i][j]进行Largest Rectangle in Histogram计算即可</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i == 0 --&gt; dp[i][j] = matrix[i][j] - &apos;0&apos;</span><br><span class="line">i != 0 --&gt; </span><br><span class="line">matrix[i][j] == 1 --&gt; dp[i][j] = dp[i-1][j] + matrix[i][j] - &apos;0&apos;</span><br><span class="line">matrix[i][j] != 1 --&gt; dp[i][j] = 0</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="comment">// 如果是第一行就是自身，如果遇到0则停止累加</span></span><br><span class="line">                dp[i][j] =  i == <span class="number">0</span> ? matrix[i][j] - <span class="string">'0'</span> : matrix[i][j] == <span class="string">'1'</span> ? dp[i-<span class="number">1</span>][j] + matrix[i][j] - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++)&#123;</span><br><span class="line">            <span class="comment">//找每行的最大矩形</span></span><br><span class="line">            <span class="keyword">int</span> tmp = findRowMax(i, dp);</span><br><span class="line">            max = Math.max(max, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findRowMax</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span>[][] matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[row].length== <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stk = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, max = matrix[row][<span class="number">0</span>];</span><br><span class="line">        stk.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(i &lt; matrix[row].length || (i == matrix[row].length &amp;&amp; !stk.isEmpty()))&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != matrix[row].length &amp;&amp; ( stk.isEmpty() || matrix[row][i] &gt;= matrix[row][stk.peek()] ))&#123;</span><br><span class="line">                stk.push(i);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> top = matrix[row][stk.pop()];</span><br><span class="line">                <span class="keyword">int</span> currMax = !stk.isEmpty() ? top * (i - stk.peek() - <span class="number">1</span>) : top * i;</span><br><span class="line">                max = Math.max(currMax, max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Maximal-Square"><a href="#Maximal-Square" class="headerlink" title="Maximal Square"></a>Maximal Square</h3><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p><p><strong>Example:</strong></p><pre><code>Input: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0Output: 4</code></pre><ul><li>构造传递方程：用dp[i][j]存储以当前点matrix[i][j]作为正方形右下角顶点，所存在的最大正方形的边长，由matrix[i][j]左、上、左上三点的dp值共同判定；</li><li>初始化边界：matrix的第一列和第一行；</li><li>自顶向下递推dp并更新max，找到max的最大值求平方得最优解。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//State: dp[i][j] is max length of matrix until (i, j);</span></span><br><span class="line">       <span class="comment">//Function: dp[i][j] = min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + 1 if matrix[i - 1][j - 1] == '1';</span></span><br><span class="line">       <span class="comment">//Initialize: dp[0][0] = 0;</span></span><br><span class="line">       <span class="comment">//Result: dp[matrix.length][matrix[0].length];</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSquare</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i-<span class="number">1</span>][j-<span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>], Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]))+<span class="number">1</span>;</span><br><span class="line">                    mLen = Math.max(mLen, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mLen * mLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Edit-Distance"><a href="#Edit-Distance" class="headerlink" title="Edit Distance"></a>Edit Distance</h3><p>Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.</p><p>You have the following 3 operations permitted on a word:</p><p>Insert a character<br>Delete a character<br>Replace a character</p><p><strong>Example 1:</strong></p><pre><code>Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;Output: 3Explanation: horse -&gt; rorse (replace &apos;h&apos; with &apos;r&apos;)rorse -&gt; rose (remove &apos;r&apos;)rose -&gt; ros (remove &apos;e&apos;)</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;Output: 5Explanation: intention -&gt; inention (remove &apos;t&apos;)inention -&gt; enention (replace &apos;i&apos; with &apos;e&apos;)enention -&gt; exention (replace &apos;n&apos; with &apos;x&apos;)exention -&gt; exection (replace &apos;n&apos; with &apos;c&apos;)exection -&gt; execution (insert &apos;u&apos;)</code></pre><ul><li>典型的动态规划题目。</li><li>维护一个二维数组dis[][]，dis[i][j]表示：word1的前i个元素与word2的前j个元素的edit distance值。递推关系为：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">word1[i] == word2[j] --&gt; dis[i][j] = dis[i][j - <span class="number">1</span>]。</span><br><span class="line">word1[i] != word2[j] --&gt; dis[i][j] = min(dis[i - <span class="number">1</span>][j - <span class="number">1</span>], dis[i] [j - <span class="number">1</span>], dis[i - <span class="number">1</span>][j]) + <span class="number">1</span>。</span><br></pre></td></tr></table></figure><p>解释一下第二种情况下的递推公式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dis[i][j] = dis[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>意味着替换字符</span><br><span class="line">dis[i][j] = dis[i - <span class="number">1</span>][j] + <span class="number">1</span>意味着删除字符</span><br><span class="line">dis[i][j] = dis[i][j - <span class="number">1</span>] + <span class="number">1</span>意味着插入字符</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = word1.length() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l2 = word2.length() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dis = <span class="keyword">new</span> <span class="keyword">int</span>[l1][l2];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; l2; j++) &#123; dis[<span class="number">0</span>][j] = j; &#125; <span class="comment">// 插入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l1; i++) &#123; dis[i][<span class="number">0</span>] = i; &#125; <span class="comment">// 删除</span></span><br><span class="line">        <span class="keyword">char</span>[] arr1 = word1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] arr2 = word2.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; l1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; l2; j++) &#123;</span><br><span class="line">                dis[i][j] = Math.min(Math.min(dis[i-<span class="number">1</span>][j]+<span class="number">1</span>, dis[i][j-<span class="number">1</span>]+<span class="number">1</span>), dis[i-<span class="number">1</span>][j-<span class="number">1</span>] + (arr1[i-<span class="number">1</span>] == arr2[j-<span class="number">1</span>] ? <span class="number">0</span> : <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[l1-<span class="number">1</span>][l2-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hard-problems"><a href="#Hard-problems" class="headerlink" title="Hard problems"></a>Hard problems</h2><h3 id="Regular-Expression-Matching"><a href="#Regular-Expression-Matching" class="headerlink" title="Regular Expression Matching"></a>Regular Expression Matching</h3><ul><li>动态规划</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>, If p.charAt(j) == s.charAt(i) :  dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line"><span class="number">2</span>, If p.charAt(j) == <span class="string">'.'</span> : dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line"><span class="number">3</span>, If p.charAt(j) == <span class="string">'\*'</span>: </span><br><span class="line">   here are two sub conditions:</span><br><span class="line">       <span class="number">1</span> <span class="keyword">if</span> p.charAt(j-<span class="number">1</span>) != s.charAt(i) : dp[i][j] = dp[i][j-<span class="number">2</span>]  <span class="comment">//in this case, a* only counts as empty</span></span><br><span class="line">       <span class="number">2</span> <span class="keyword">if</span> p.charAt(i-<span class="number">1</span>) == s.charAt(i) or p.charAt(i-<span class="number">1</span>) == <span class="string">'.'</span>:</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j]    <span class="comment">//in this case, a* counts as multiple a </span></span><br><span class="line">            or dp[i][j] = dp[i][j-<span class="number">1</span>]   <span class="comment">// in this case, a* counts as single a</span></span><br><span class="line">            or dp[i][j] = dp[i][j-<span class="number">2</span>]   <span class="comment">// in this case, a* counts as empty</span></span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>][p.length()+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.charAt(i) == <span class="string">'*'</span> &amp;&amp; dp[<span class="number">0</span>][i-<span class="number">1</span>]) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j) == <span class="string">'.'</span>) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j) == s.charAt(i)) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j-<span class="number">1</span>) != s.charAt(i) &amp;&amp; p.charAt(j-<span class="number">1</span>) != <span class="string">'.'</span>) &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = (dp[i+<span class="number">1</span>][j] || dp[i][j+<span class="number">1</span>] || dp[i+<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()][p.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>递归</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern.isEmpty()) <span class="keyword">return</span> text.isEmpty();</span><br><span class="line">        <span class="keyword">boolean</span> first_match = (!text.isEmpty() &amp;&amp; </span><br><span class="line">                               (pattern.charAt(<span class="number">0</span>) == text.charAt(<span class="number">0</span>) || pattern.charAt(<span class="number">0</span>) == <span class="string">'.'</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pattern.length() &gt;= <span class="number">2</span> &amp;&amp; pattern.charAt(<span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (isMatch(text, pattern.substring(<span class="number">2</span>)) || </span><br><span class="line">                    (first_match &amp;&amp; isMatch(text.substring(<span class="number">1</span>), pattern)));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> first_match &amp;&amp; isMatch(text.substring(<span class="number">1</span>), pattern.substring(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Wildcard-Matching"><a href="#Wildcard-Matching" class="headerlink" title="Wildcard Matching"></a>Wildcard Matching</h3><p>Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for ‘?’ and ‘*’.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;?&apos; Matches any single character.</span><br><span class="line">&apos;*&apos; Matches any sequence of characters (including the empty sequence).</span><br></pre></td></tr></table></figure><p>The matching should cover the entire input string (not partial).</p><p><strong>Note:</strong></p><ul><li>s could be empty and contains only lowercase letters a-z.</li><li>p could be empty and contains only lowercase letters a-z, and characters like ? or *.</li></ul><p><strong>动态规划</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* boolean dp[len(s) + 1][len(p) + 1] </span></span><br><span class="line"><span class="comment">     * dp[i+1][j+1] means if s[0, i] match p[0, j]</span></span><br><span class="line"><span class="comment">     * function: dp[i+1][j+1] </span></span><br><span class="line"><span class="comment">     *         a. p[j] = * =&gt; 1. empty: dp[i+1][j]</span></span><br><span class="line"><span class="comment">     *                        2. one: dp[i][j]</span></span><br><span class="line"><span class="comment">     *                        3. multiple: dp[i][j+1]</span></span><br><span class="line"><span class="comment">     *         b. p[j] = s[i] | p[j] = ? =&gt; dp[i][j]</span></span><br><span class="line"><span class="comment">     * start: dp[0][0] = true, dp[0][j+1] = dp[0][j] &amp; p[j] = *</span></span><br><span class="line"><span class="comment">     * result: dp[len(s)][len(p)]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">         </span><br><span class="line">     <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>][p.length() + <span class="number">1</span>];</span><br><span class="line">     <span class="comment">// start</span></span><br><span class="line">     dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.length(); j++) </span><br><span class="line">         dp[<span class="number">0</span>][j+<span class="number">1</span>] = dp[<span class="number">0</span>][j] &amp; (p.charAt(j) == <span class="string">'*'</span>);</span><br><span class="line">         </span><br><span class="line">     <span class="comment">// loop</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.length(); j++) &#123;</span><br><span class="line">             <span class="keyword">if</span>(p.charAt(j) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                 dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j] | dp[i][j] | dp[i][j+<span class="number">1</span>];</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span>(p.charAt(j) == s.charAt(i) || p.charAt(j) == <span class="string">'?'</span>)</span><br><span class="line">                 dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> dp[s.length()][p.length()];        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>贪心</strong></p><ul><li>star符号和前面的character没有关系</li><li>用两个指针i和j分别扫描s和p，loop过程中有以下几种情况：<ul><li>成功匹配：s[i] == p[j] or p[j] == ‘?’ =&gt; i++, j++</li><li>出现星号：p[j] == ‘*’</li><li>p[j]匹配0个 =&gt; j++； p[j]匹配1个 =&gt; j++, i += 1； p[j]匹配2个 =&gt; j++, i += 2；……</li><li>匹配不上：return false</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> stari = -<span class="number">1</span>, starj = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.length()) &#123;</span><br><span class="line">            <span class="comment">// 1. match</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; p.length() &amp;&amp; (s.charAt(i) == p.charAt(j) || p.charAt(j) == <span class="string">'?'</span>)) &#123;</span><br><span class="line">                i++; j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. star</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &lt; p.length() &amp;&amp; p.charAt(j) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="comment">// first match 0</span></span><br><span class="line">                stari = i;</span><br><span class="line">                starj = ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// different number that '*' matches </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(stari != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// match number +1</span></span><br><span class="line">                i = ++stari;</span><br><span class="line">                j = starj;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3. not match and no star</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// remove last '*' in p</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt; p.length() &amp;&amp; p.charAt(j) == <span class="string">'*'</span>) j++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> j == p.length();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>递归</strong></p><p><strong>思路</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(s[l] == p[r] || p[r] == <span class="string">'?'</span>) match(l, r) = match(l + <span class="number">1</span>, r + <span class="number">1</span>) 。</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(p[r] == <span class="string">'*'</span>) &#123;</span><br><span class="line">     <span class="keyword">while</span>(l &lt; s.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(match(l, r)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        l++;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(r == p.length()) <span class="keyword">return</span> l == s.length();  </span><br><span class="line">    <span class="keyword">if</span>(p.charAt(r) == <span class="string">'*'</span>) &#123;  </span><br><span class="line">        <span class="keyword">while</span>(r &lt; p.length() &amp;&amp; p.charAt(r) == <span class="string">'*'</span>) r++;   <span class="comment">// Move the index at p to a non-start char.  </span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; s.length()) &#123;  </span><br><span class="line">            <span class="keyword">if</span>(isMatch(s, p, l, r)) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// Find one match, return true.  </span></span><br><span class="line">            l++; <span class="comment">// Try the next one.  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> isMatch(s, p, l, r);  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(l &lt; s.length() &amp;&amp; (p.charAt(r) == <span class="string">'?'</span> || s.charAt(l) == p.charAt(r)))  </span><br><span class="line">        <span class="keyword">return</span> isMatch(s, p, l + <span class="number">1</span>, r + <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 算法 </category>
          
          <category> LeetCode Category </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> DynamicProgramming </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微软Office STCA</title>
      <link href="/2018/04/24/%E5%BE%AE%E8%BD%AFOffice%20STCA/"/>
      <url>/2018/04/24/%E5%BE%AE%E8%BD%AFOffice%20STCA/</url>
      <content type="html"><![CDATA[<p>微软Office STCA暑期实习面试<br><a id="more"></a></p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ul><li>介绍azure table为什么能做到一个用户的数据在一台机器上</li><li>介绍datafactory入hive的过程，如果将copy和hive分开，怎么做？用socket？为什么websocket能做到双方发消息？</li><li>多态是在编译时知道？还是<em>运行时</em>？ B extends A;<ul><li>A a = new A() <strong>编译时</strong></li><li>A a = new B() <strong>运行时</strong></li></ul></li><li><p>给定一个正整数，求阶乘？ 越界？ 非递归？</p><ul><li>n较小时</li></ul><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getNFactorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>{     <span class="keyword">if</span>(n==<span class="number">0</span>){         <span class="keyword">return</span> <span class="number">1l</span>;     }     <span class="keyword">return</span> n*getNFactorial1(n-<span class="number">1</span>);}</code></pre><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getNFactorial1</span><span class="params">(<span class="keyword">int</span> n)</span></span>{      <span class="keyword">if</span>(n==<span class="number">0</span>){          <span class="keyword">return</span> <span class="number">1l</span>;      }      <span class="keyword">long</span> sum=<span class="number">1l</span>;      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){          sum=sum*i;      }      <span class="keyword">return</span> sum;} </code></pre><ul><li>n较大时</li></ul><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getNFactorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{      <span class="keyword">int</span> num[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000</span>];      <span class="keyword">int</span> i, j;      <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">0</span>) {          System.out.println(<span class="number">1</span>);      } <span class="keyword">else</span> {          <span class="keyword">int</span> p, h;<span class="comment">// p 存放当前结果的位数，h为进位；</span>          p = <span class="number">1</span>;          h = <span class="number">0</span>;          num[<span class="number">1</span>] = <span class="number">1</span>;          <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) {              <span class="comment">// 使得a[]的每位与i相乘</span>              <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= p; j++) {                  num[j] = num[j] * i + h;                  h = num[j] / <span class="number">10</span>;                  num[j] = num[j] % <span class="number">10</span>;              }              <span class="comment">// 表示向新的位置进位</span>              <span class="keyword">while</span> (h &gt; <span class="number">0</span>) {                  num[j] = h % <span class="number">10</span>;                  h = h / <span class="number">10</span>;                  j++;              }              p = j - <span class="number">1</span>;          }          <span class="keyword">for</span> (i = p; i &gt;= <span class="number">1</span>; i--) {              System.out.print(num[i]);          }      }  }</code></pre></li></ul><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ul><li>2 Sum &amp; 3 Sum</li><li>int parse(String str)的测试用例</li><li>为什么用azure？</li></ul>]]></content>
      
      <categories>
          
          <category> 面试经历 </category>
          
          <category> 2018 </category>
          
          <category> 暑期 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Sort</title>
      <link href="/2018/04/22/Sort/"/>
      <url>/2018/04/22/Sort/</url>
      <content type="html"><![CDATA[<p>Sort可分为基于比较和非基于比较两大类排序<br><a id="more"></a></p><h2 id="非基于比较的排序"><a href="#非基于比较的排序" class="headerlink" title="非基于比较的排序"></a>非基于比较的排序</h2><p><strong>基于比较的排序是不可能突破O(NlogN)􏰑的</strong></p><ul><li>计数排序<ul><li><a href="http://www.cs.usfca.edu/~galles/visualization/CountingSort.html" target="_blank" rel="noopener">直接看教学吧</a></li><li>适合数的范围比较小的情况</li></ul></li><li>桶排序<ul><li>尽量增大桶的数量，但是不能有太多无效桶）（将所有的元素分到一定区间条件的桶里，在桶里执行其他排序方法</li></ul></li><li>基数排序<ul><li>拓展的桶排序</li><li>多关键字</li></ul></li></ul><h2 id="基本排序算法"><a href="#基本排序算法" class="headerlink" title="基本排序算法"></a>基本排序算法</h2><table><thead><tr><th style="text-align:center">Algorithm</th><th style="text-align:center">Average Time</th><th style="text-align:center">Worst Time</th><th style="text-align:center">Space</th><th style="text-align:center">Stable</th></tr></thead><tbody><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">n^2</td><td style="text-align:center">n^2</td><td style="text-align:center">1</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">选择排序</td><td style="text-align:center">n^2</td><td style="text-align:center">n^2</td><td style="text-align:center">1</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">插入排序</td><td style="text-align:center">n^2</td><td style="text-align:center">n^2</td><td style="text-align:center"></td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center">nlog(n)</td><td style="text-align:center">n^2</td><td style="text-align:center"></td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center">nlog(n)</td><td style="text-align:center">nlog(n)</td><td style="text-align:center"></td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">nlog(n)</td><td style="text-align:center">nlog(n)</td><td style="text-align:center"></td><td style="text-align:center">N</td></tr></tbody></table><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><pre><code>public static void sort(int[] nums, int left,int right){        if(left &lt; right){            int mid = partition(nums,left,right);            sort(nums,left,mid-1);            sort(nums,mid+1,right);        }    }    public static int partition(int[] nums,int low,int high){        int pivot = nums[low];        while(low &lt; high){            while(nums[high] &gt;= pivot &amp;&amp; low &lt; high){                high--;            }            nums[low] = nums[high];            while(nums[low] &lt;= pivot &amp;&amp; low &lt; high){                low++;            }            nums[high] = nums[low];        }        nums[low] = pivot;        return low;}</code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><pre><code>public static void sort(int[] nums, int left,int right){            int mid = (left + right)/2;            if(left &lt; right){                sort(nums,left,mid);                sort(nums,mid+1,right);                merge(nums,left,mid,right);            }    }    public static void merge(int[] nums,int low,int mid,int high){            int[] tem = new int[high-low+1];            int i = low;            int j = mid+1;            int k = 0;            while(i &lt;= mid &amp;&amp; j &lt;= high){                if(nums[i] &lt; nums[j]) tem[k++] = nums[i++];                else tem[k++] = nums[j++];            }            while(i &lt;= mid) tem[k++] = nums[i++];            while(j &lt;= high) tem[k++] = nums[j++];            for(int m = 0;m &lt; tem.length;m++){                nums[m+low] = tem[m];            }    }</code></pre><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> n = nums.length;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = n/<span class="number">2</span> -<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">      heapify(nums,n,i);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">      swap(nums,<span class="number">0</span>,i);</span><br><span class="line">      heapify(nums,i,<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> n,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> largest = i;</span><br><span class="line"> <span class="keyword">int</span> l = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">int</span> r = <span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(l &lt; n &amp;&amp; nums[l] &gt; nums[largest])&#123;</span><br><span class="line">      largest = l;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(r &lt; n &amp;&amp; nums[r] &gt; nums[largest])&#123;</span><br><span class="line">      largest = r;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(largest != i)&#123;</span><br><span class="line">      swap(nums,i,largest);</span><br><span class="line">      heapify(nums,n,largest);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> tem = nums[i];</span><br><span class="line"> nums[i] = nums[j];</span><br><span class="line"> nums[j] = tem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Wiggle-Sort"><a href="#Wiggle-Sort" class="headerlink" title="Wiggle Sort"></a>Wiggle Sort</h3><blockquote><p>Given an unsorted array nums, reorder it in-place such that nums[0] &lt;= nums[1] &gt;= nums[2] &lt;= nums[3]….</p><p>For example, given nums = [3, 5, 2, 1, 6, 4], one possible answer is [1, 6, 2, 5, 3, 4].</p></blockquote><ul><li>排序法<ul><li>先将数组排序，</li><li>这时候从第3个元素开始，将第3个元素和第2个元素交换。</li><li>然后再从第5个元素开始，将第5个元素和第4个元素交换，</li><li>以此类推。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先将数组排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// 将数组中一对一对交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[i-<span class="number">1</span>];</span><br><span class="line">            nums[i-<span class="number">1</span>] = nums[i];</span><br><span class="line">            nums[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>交换法<ul><li>如果i是奇数，nums[i] &gt;= nums[i - 1]</li><li>如果i是偶数，nums[i] &lt;= nums[i - 1]</li><li>遍历一遍数组，把不符合的情况交换一下就行了。</li><li>具体来说，如果nums[i] &gt; nums[i - 1]， 则交换以后肯定有nums[i] &lt;= nums[i - 1]。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 需要交换的情况：奇数时nums[i] &lt; nums[i - 1]或偶数时nums[i] &gt; nums[i - 1]</span></span><br><span class="line">            <span class="keyword">if</span>((i % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; nums[i] &lt; nums[i-<span class="number">1</span>]) || (i % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; nums[i] &gt; nums[i-<span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[i-<span class="number">1</span>];</span><br><span class="line">                nums[i-<span class="number">1</span>] = nums[i];</span><br><span class="line">                nums[i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sort-Colors"><a href="#Sort-Colors" class="headerlink" title="Sort Colors"></a>Sort Colors</h3><blockquote><p>给定一组分别具有红白蓝颜色的对象，重新排序他们使得相同颜色的对象相邻。排序后的顺序是红白蓝。</p></blockquote><blockquote><p>这里我们用 0, 1, and 2 来分别表示红白蓝三个颜色。</p></blockquote><p><strong>注意：不能用库中的排序函数。</strong></p><ul><li>遍历，计数</li><li>类似快排的partition<ul><li>左边存放0和1，右边存放2.两边往中间靠。</li><li>设置两个index，left记录第一个1的位置，left左边为0，right记录第一个非2的位置，right右边为2.</li><li>然后使用i从头到尾扫一遍，直到与right相遇。</li><li>i遇到0就换到左边去，遇到2就换到右边去，遇到1就跳过。</li><li>需要注意的是：由于left记录第一个1的位置，因此A[left]与A[i]交换后，A[left]为0,A[i]为1，因此i++；</li><li>而right记录第一个非2的位置，可能为0或1，因此A[right]与A[i]交换后，A[right]为2,A[i]为0或1，i不能前进，要后续判断。</li><li>由此该数组分为4段：[0,left)–&gt;0; [left,i)–&gt;1; [i,right]–&gt;乱序; (right,n-1]–&gt;2</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums,i,left);</span><br><span class="line">                i++;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                swap(nums,i,right);</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tem = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sort-List"><a href="#Sort-List" class="headerlink" title="Sort List"></a>Sort List</h3><ul><li>归并排序<ul><li>快慢指针将链表分为两个部分</li><li>慢指针的next为null</li><li>再合并两个排序好的链表</li></ul></li></ul><h3 id="Insertion-Sort-List"><a href="#Insertion-Sort-List" class="headerlink" title="Insertion Sort List"></a>Insertion Sort List</h3><ul><li>选择排序，i前有序，i后无序，两层循环</li><li>链表的插入排序，同样两层循环，考虑到头指针也需要被排序，需要新增一个fakeHead。</li><li>链表的插入需要维护三个指针，pre，cur，next，</li><li>pre始终指向有序链表的fakeHead，cur指向当前需要排序的节点，next指向下一个待排序的节点。</li><li>当有序链表为空或者pre.next所指向的元素的值比当前节点的值大时，需要将cur插入到pre.next之前的位置，</li><li>否则，则将pre指针后移，最后返回fakeHead.next即可。</li></ul><h3 id="Maximum-Gap"><a href="#Maximum-Gap" class="headerlink" title="Maximum Gap"></a>Maximum Gap</h3><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p><p>Return 0 if the array contains less than 2 elements.</p><p>Example 1:</p><pre><code>Input: [3,9,6,1]Output: 3Explanation: The sorted form of the array is [1,3,6,9], either 3,6 or 6,9 has the maximum difference 3. </code></pre><p>Example 2:</p><pre><code>Input: [10]Output: 0Explanation: The array contains less than 2 elements, therefore return 0.</code></pre><p>Notes:</p><p>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.</p><p>Try to solve it in linear time/space.</p><ul><li>直接排序</li><li>桶排序，取相邻两个桶，后一个桶的最小值和前一个桶的最大值可能就是那个值</li></ul><h3 id="Best-Meeting-Point"><a href="#Best-Meeting-Point" class="headerlink" title="Best Meeting Point"></a>Best Meeting Point</h3><blockquote><p>A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.</p></blockquote><p>For example, given three people living at (0,0), (0,4), and (2,2):</p><pre><code>1 - 0 - 0 - 0 - 1|   |   |   |   |0 - 0 - 0 - 0 - 0|   |   |   |   |0 - 0 - 1 - 0 - 0</code></pre><p>The point (0,2) is an ideal meeting point, as the total travel<br>distance of 2+2+2=6 is minimal. So return 6.</p><ul><li>曼哈顿距离，我们可以分开计算横坐标和纵坐标</li><li>算出各个横坐标到中点横坐标的距离，加上各个纵坐标到中点纵坐标的距离，就是结果</li></ul><h2 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h2><h3 id="Meeting-Rooms"><a href="#Meeting-Rooms" class="headerlink" title="Meeting Rooms"></a>Meeting Rooms</h3><blockquote><p>Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],…] (si &lt; ei), determine if a person could attend all meetings.</p></blockquote><ul><li>判断区间是否重合</li><li>先对数组按照开始时间排序，如果下一个的开始时间早于前一个的结束时间则不行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canAttendMeetings</span><span class="params">(Interval[] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span>(intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// sort</span></span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; a.start == b.start ? a.end - b.end : a.start - b.start);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//or</span></span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;Interval&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Interval i1, Interval i2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i1.start-i2.start;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i].end &gt; intervals[i+<span class="number">1</span>].start) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Meeting-Rooms-II"><a href="#Meeting-Rooms-II" class="headerlink" title="Meeting Rooms II"></a>Meeting Rooms II</h3><blockquote><p>Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],…] (si &lt; ei), find the minimum number of conference rooms required.</p></blockquote><p><strong>思路</strong></p><p>overlap的条件依然是：intervals[i].end &gt; intervals[j].start<br>不同的是这题需要求房间数。还是先sort，i指向之前有overlap的最小end的那一个。</p><p><strong>复杂度</strong></p><p>Time Complexity: O(NlogN)，Space: O(N)。</p><p><strong>heap</strong></p><p>因为要知道之前有overlap的最小的end，所以可以用一个min heap。每次检查新的start是否比heap的top元素小，是的话就把保存原来的end，同时放进新的end；否则就放新的end同时poll出原来的，因为没有overlap且新的end较大。最后heap的大小就是需要的房间数。比如：</p><p>[1, 5], [2, 4], [3, 6], [5, 7]</p><pre><code>heap: [5]。[2, 4]的start是2，比5小，所以放入4。heap: [4, 5]。接着[3 ,6]的start是3，比4小，所以又放入6。heap: [4, 5, 6]。[5, 7]的start是5，比4大，因此poll出4，放入7。heap: [5, 6, 7]。最后heap的size为3。</code></pre><p>4被pop出来是因为[2, 4]和[5, 7]公用一个房间，只要放7进去就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(Interval[] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span>(intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// sort</span></span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; a.start == b.start ? a.end - b.end : a.start - b.start);</span><br><span class="line">        <span class="comment">// min heap to store the end</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        minHeap.offer(intervals[<span class="number">0</span>].end);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="comment">// no overlap</span></span><br><span class="line">            <span class="keyword">if</span>(minHeap.peek() &lt;= intervals[i].start) minHeap.poll();</span><br><span class="line">            minHeap.offer(intervals[i].end);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> minHeap.size();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Insert-Intervals"><a href="#Insert-Intervals" class="headerlink" title="Insert Intervals"></a>Insert Intervals</h3><blockquote><p>即向有序、不重叠的区间序列中插入一个区间。如区间产生重叠，则合并。求插入新区间后的区间序列。</p><p>如：A = [1,3],[6,9]，插入[2,6]，插入后新序列为[1,9]。</p></blockquote><ul><li>对新给的序列，有三种对应情况</li><li>旧区间在新区间之前</li><li>新区间在旧区间之前</li><li>有重叠</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">insert</span><span class="params">(List&lt;Interval&gt; intervals, Interval newInterval)</span> </span>&#123;</span><br><span class="line">        List&lt;Interval&gt; ans = <span class="keyword">new</span> ArrayList&lt;Interval&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; intervals.size() ;i++)&#123;</span><br><span class="line">            Interval now = intervals.get(i);</span><br><span class="line">            <span class="keyword">if</span>(now.end &lt; newInterval.start)&#123; <span class="comment">//intervals before the newInterval</span></span><br><span class="line">                ans.add(now);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(now.start &gt; newInterval.end)&#123; <span class="comment">//intervals after the newInterval</span></span><br><span class="line">                ans.add(newInterval);</span><br><span class="line">                ans.addAll(intervals.subList(i,intervals.size())); <span class="comment">//add all remaining intervals and return</span></span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">//intervals overlap the newInterval , update the interval range</span></span><br><span class="line">                newInterval.start = Math.min(newInterval.start, now.start);</span><br><span class="line">                newInterval.end = Math.max(newInterval.end, now.end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(newInterval); <span class="comment">//if there are no intervals after the newInterval, than add it and return</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Merge-Intervals"><a href="#Merge-Intervals" class="headerlink" title="Merge Intervals"></a>Merge Intervals</h3><p>Given a collection of intervals, merge all overlapping intervals.</p><p>Example 1:</p><pre><code>Input: [[1,3],[2,6],[8,10],[15,18]]Output: [[1,6],[8,10],[15,18]]Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</code></pre><p>Example 2:</p><pre><code>Input: [[1,4],[4,5]]Output: [[1,5]]Explanation: Intervals [1,4] and [4,5] are considerred overlapping.</code></pre><ul><li>先根据start排序</li><li>再遍历判断是否重叠，interval.start &lt;= end重叠</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * public class Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() &#123; start = 0; end = 0; &#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) &#123; start = s; end = e; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">merge</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">        </span><br><span class="line">        Collections.sort(intervals, (a, b) -&gt; a.start == b.start ? a.end - b.end : a.start - b.start);</span><br><span class="line">        List&lt;Interval&gt; merged = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start = intervals.get(<span class="number">0</span>).start;</span><br><span class="line">        <span class="keyword">int</span> end = intervals.get(<span class="number">0</span>).end;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(Interval interval:intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span>(interval.start &lt;= end )&#123;</span><br><span class="line">                end = Math.max(interval.end,end);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                merged.add(<span class="keyword">new</span> Interval(start,end));</span><br><span class="line">                start = interval.start;</span><br><span class="line">                end = interval.end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        merged.add(<span class="keyword">new</span> Interval(start,end));</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Largest-Number"><a href="#Largest-Number" class="headerlink" title="Largest Number"></a>Largest Number</h3><p>Given a list of non negative integers, arrange them such that they form the largest number.</p><p>Example 1:</p><pre><code>Input: [10,2]Output: 210</code></pre><p>Example 2:</p><pre><code>Input: [3,30,34,5,9]Output: 9534330</code></pre><p>Note: The result may be very large, so you need to return a string instead of an integer.</p><ul><li>对哪个数放在前面的问题，其实对ab两个数进行排序</li><li>如果ab &gt; ba，那么a应该在b之前，写一个符合条件的comparator即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            arr[i] = String.valueOf(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//逆序，方便之后append</span></span><br><span class="line">        Arrays.sort(arr, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span></span>&#123;</span><br><span class="line">                String s1 = a+b;</span><br><span class="line">                String s2 = b+a;</span><br><span class="line">                <span class="keyword">return</span> s2.compareTo(s1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">0</span>].equals(<span class="string">"0"</span>)) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span>(String s: arr)&#123;</span><br><span class="line">        sb.append(s);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bucket-Sort"><a href="#Bucket-Sort" class="headerlink" title="Bucket Sort"></a>Bucket Sort</h2><h3 id="First-Missing-Positive"><a href="#First-Missing-Positive" class="headerlink" title="First Missing Positive"></a>First Missing Positive</h3><p>Given an unsorted integer array, find the smallest missing positive integer.</p><p>Example 1:</p><pre><code>Input: [1,2,0]Output: 3</code></pre><p>Example 2:</p><pre><code>Input: [3,4,-1,1]Output: 2</code></pre><p>Example 3:</p><pre><code>Input: [7,8,9,11,12]Output: 1</code></pre><p>Note:</p><p>Your algorithm should run in O(n) time and uses constant extra space.</p><ul><li>交换数组元素，使得数组中第i位存放数值(i+1)。</li><li>最后遍历数组，寻找第一个不符合此要求的元素，返回其下标。</li><li>整个过程需要遍历两次数组，复杂度为O(n)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i+<span class="number">1</span> &amp;&amp; nums[i] &gt;= <span class="number">1</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[i] != nums[nums[i]-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> tem = nums[nums[i]-<span class="number">1</span>];</span><br><span class="line">                nums[nums[i]-<span class="number">1</span>] = nums[i];</span><br><span class="line">                nums[i] = tem;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] != j+<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> j+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 算法 </category>
          
          <category> LeetCode Category </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>BFS</title>
      <link href="/2018/04/18/BFS/"/>
      <url>/2018/04/18/BFS/</url>
      <content type="html"><![CDATA[<p><strong>题目列表</strong></p><h3 id="Binary-Tree-Right-Side-View"><a href="#Binary-Tree-Right-Side-View" class="headerlink" title="Binary Tree Right Side View"></a>Binary Tree Right Side View</h3><blockquote><p>层次遍历，输出最右边的数</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// reverse level traversal</span></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">                TreeNode cur = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) result.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Populating-Next-Right-Pointers-in-Each-Node"><a href="#Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="Populating Next Right Pointers in Each Node"></a>Populating Next Right Pointers in Each Node</h3><p>For example,<br>Given the following perfect binary tree,</p><pre><code>     1   /  \  2    3 / \  / \4  5  6  7</code></pre><p>After calling your function, the tree should look like:</p><pre><code>     1 -&gt; NULL   /  \  2 -&gt; 3 -&gt; NULL / \  / \4-&gt;5-&gt;6-&gt;7 -&gt; NULL</code></pre><ul><li>由于是<strong>完全二叉树</strong>，所以若节点的<strong>左子结点存在的话，其右子节点必定存在</strong>，</li><li>所以<strong>左子结点的next指针可以直接指向其右子节点</strong>，</li><li>对于其右子节点的处理方法是，判断其<strong>父节点的next</strong>是否为空，若不为空，则指向其next指针指向的节点的左子结点，若为空则指向NULL</li></ul><h3 id="Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="Populating Next Right Pointers in Each Node II"></a>Populating Next Right Pointers in Each Node II</h3><blockquote><p>不是完全二叉树</p></blockquote><p>借助dummy结点的解法！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</span><br><span class="line">        TreeLinkNode dummy = <span class="keyword">new</span> TreeLinkNode(<span class="number">0</span>);</span><br><span class="line">        TreeLinkNode cur = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                cur.next = root.left;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                cur.next = root.right;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root.next;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">                cur = dummy;</span><br><span class="line">                root = cur.next;</span><br><span class="line">                cur.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Word-Ladder"><a href="#Word-Ladder" class="headerlink" title="Word Ladder"></a>Word Ladder</h3><p>For example,</p><p>Given:</p><p>beginWord = “hit”</p><p>endWord = “cog”</p><p>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</p><p>As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,</p><p>return its length 5.</p><p><strong>Note:</strong></p><ul><li>Return 0 if there is no such transformation sequence.</li><li>All words have the same length.</li><li>All words contain only lowercase alphabetic characters.</li><li>You may assume no duplicates in the word list.</li><li>You may assume beginWord and endWord are non-empty and are not the same.</li></ul><p><strong>解题思路</strong></p><ul><li>BFS</li><li>可以想象成一棵树，根节点是start字符串，</li><li>第二层是所有的和它相差一个字母的字符串（之前出现过的，之后就没有必要出现了，因为出现的话，也是abc变成bbc又变回abs，没有意义），</li><li>需要一个队列来实现广度优先搜索，因为是从顶层到底层来遍历的，所以发现等于end的时候的层数值就是最小的，返回即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(beginWord);</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">0</span>; q &lt; size; q++) &#123;</span><br><span class="line">                <span class="keyword">char</span>[] cur = queue.poll().toCharArray();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; cur.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">char</span> tmp = cur[i];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">char</span> chr=<span class="string">'a'</span>; chr &lt;= <span class="string">'z'</span>; chr++) &#123;</span><br><span class="line">                        cur[i] = chr;</span><br><span class="line">                        String dest = <span class="keyword">new</span> String(cur);</span><br><span class="line">                        <span class="keyword">if</span> (dict.contains(dest)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (dest.equals(endWord)) <span class="keyword">return</span> level+<span class="number">1</span>;</span><br><span class="line">                            queue.add(dest);</span><br><span class="line">                            dict.remove(dest);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur[i] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Word-Ladder-II"><a href="#Word-Ladder-II" class="headerlink" title="Word Ladder II"></a>Word Ladder II</h3><blockquote><p>需要返回所有的最短路径</p></blockquote><p>呃，有点难。。。</p>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 算法 </category>
          
          <category> LeetCode Category </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> BinaryTree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Binary Search</title>
      <link href="/2018/04/18/BinarySearch/"/>
      <url>/2018/04/18/BinarySearch/</url>
      <content type="html"><![CDATA[<blockquote><p>有序数组，用于查找</p></blockquote><h2 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h2><p>需要优化O(n)复杂度时，一般只能二分法</p><a id="more"></a><h2 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">int</span> high = arr.length-<span class="number">1</span>;   </span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high) &#123;   </span><br><span class="line">        <span class="keyword">int</span> middle = low + (high - low)/<span class="number">2</span>;   </span><br><span class="line">        <span class="keyword">if</span>(x == arr[middle]) &#123;   </span><br><span class="line">             <span class="keyword">return</span> middle;   </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x &lt;arr[middle]) &#123;   </span><br><span class="line">             high = middle - <span class="number">1</span>;   </span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;   </span><br><span class="line">             low = middle + <span class="number">1</span>;   </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h2><h3 id="第一类"><a href="#第一类" class="headerlink" title="第一类"></a>第一类</h3><blockquote><p>考察基本用法，题目并没有说明没有重复值，需要继续查找</p></blockquote><ul><li>search insert position</li><li>search for a range</li><li>isBadVersion</li><li>Closest Binary Search Tree Value <ul><li>二叉搜索树找离target最近的node的值</li><li>二分判断左右</li></ul></li><li>Find Peak Element<ul><li><strong>二分查找折半</strong>后中间那个元素后，</li><li>和<strong>紧跟</strong>的那个元素比较下大小，</li><li>如果<strong>大于</strong>，则说明峰值在前面，</li><li>如果<strong>小于</strong>则在后面。这样就可以找到一个峰值了</li></ul></li><li>Median of Two Sorted Arrays</li></ul><h4 id="Search-for-a-range"><a href="#Search-for-a-range" class="headerlink" title="Search for a range"></a>Search for a range</h4><blockquote><p>查找等于target的一个范围，即找到最先出现的target和最后出现的target</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = &#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = nums.length-<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(nums[low] &lt; nums[high])&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>; </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[low] &lt; target) low++;</span><br><span class="line">                <span class="keyword">if</span>(nums[high] &gt; target) high--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[low] == target)&#123;</span><br><span class="line">            res[<span class="number">0</span>] = low;</span><br><span class="line">            res[<span class="number">1</span>] = high;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Median-of-Two-Sorted-Arrays"><a href="#Median-of-Two-Sorted-Arrays" class="headerlink" title="Median of Two Sorted Arrays"></a>Median of Two Sorted Arrays</h4><h3 id="第二类"><a href="#第二类" class="headerlink" title="第二类"></a>第二类</h3><blockquote><p>和数学相关</p></blockquote><ul><li>sqrt(X) </li><li>pow(x, n) </li><li>fastPower</li></ul><h4 id="sqrt-X"><a href="#sqrt-X" class="headerlink" title="sqrt(X)"></a>sqrt(X)</h4><blockquote><p>i * i &lt;= x &amp;&amp; (i+1)(i+1) &gt; x</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">1</span>, end = x;</span><br><span class="line"><span class="keyword">while</span> (start &lt; end) &#123; </span><br><span class="line"><span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (mid &lt;= x / mid &amp;&amp; (mid + <span class="number">1</span>) &gt; x / (mid + <span class="number">1</span>))<span class="comment">// Found the result</span></span><br><span class="line"><span class="keyword">return</span> mid; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mid &gt; x / mid)<span class="comment">// Keep checking the left part</span></span><br><span class="line">end = mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">start = mid + <span class="number">1</span>;<span class="comment">// Keep checking the right part</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pow-x-n"><a href="#pow-x-n" class="headerlink" title="pow(x, n)"></a>pow(x, n)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            n = -n;</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (n%<span class="number">2</span> == <span class="number">0</span>) ? pow(x*x, n/<span class="number">2</span>) : x*pow(x*x, n/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三类"><a href="#第三类" class="headerlink" title="第三类"></a>第三类</h3><blockquote><p>二维上运用</p></blockquote><ul><li>Search a 2d Matrix <ul><li>矩阵从左到右递增，第二行最小值比第一行最大值大</li><li>可转化为一维的二分，matrix[mid/col][mid%col] == target</li></ul></li><li>Search a 2d Matrix II<ul><li>矩阵从左到右递增，从上到下递增</li></ul></li></ul><h3 id="第四类"><a href="#第四类" class="headerlink" title="第四类"></a>第四类</h3><blockquote><p>部分sorted的数组或者rotated的数组</p></blockquote><ul><li>search in rotated sorted array</li><li>search in rotated sorted array II(duplicate allowed) </li><li>find min in rotated sorted array</li><li>find min in rotated sorted array II(duplicate allowed)</li></ul><h4 id="Search-in-Rotated-Sorted-Array"><a href="#Search-in-Rotated-Sorted-Array" class="headerlink" title="Search in Rotated Sorted Array"></a>Search in Rotated Sorted Array</h4><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>解题方案</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (nums[start] &lt;= nums[mid])&#123;</span><br><span class="line">                 <span class="keyword">if</span> (target &lt; nums[mid] &amp;&amp; target &gt;= nums[start]) </span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= nums[end])&#123;</span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end])</span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Search-in-rotated-sorted-array-II-duplicate-allowed"><a href="#Search-in-rotated-sorted-array-II-duplicate-allowed" class="headerlink" title="Search in rotated sorted array II(duplicate allowed)"></a>Search in rotated sorted array II(duplicate allowed)</h4><p>nums may contain duplicates.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[start] == nums[mid])&#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[start] &lt; nums[mid])&#123;</span><br><span class="line">                 <span class="keyword">if</span> (target &lt; nums[mid] &amp;&amp; target &gt;= nums[start]) </span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end])</span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Find-min-in-rotated-sorted-array"><a href="#Find-min-in-rotated-sorted-array" class="headerlink" title="Find min in rotated sorted array"></a>Find min in rotated sorted array</h4><blockquote><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p></blockquote><blockquote><p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p></blockquote><blockquote><p>Find the minimum element.</p></blockquote><ul><li>If rotate, A[min] &lt; A[min - 1]; </li><li>If not, A[0]. </li><li>If not, there are 2 conditions as well: </li><li>If it is greater than both left and right element, then minimum element should be on its right, otherwise on its left.</li></ul><h4 id="Find-Minimum-in-Rotated-Sorted-Array-II"><a href="#Find-Minimum-in-Rotated-Sorted-Array-II" class="headerlink" title="Find Minimum in Rotated Sorted Array II"></a>Find Minimum in Rotated Sorted Array II</h4><blockquote><p>The array may contain duplicates.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[end])&#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[end])&#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Longest-Increasing-Subsequence"><a href="#Longest-Increasing-Subsequence" class="headerlink" title="Longest Increasing Subsequence"></a>Longest Increasing Subsequence</h4><p><strong>动态规划</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxval = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    maxval = Math.max(maxval, dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = maxval + <span class="number">1</span>;</span><br><span class="line">            maxans = Math.max(maxans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二分查找</strong></p><ul><li>if x is larger than all tails, append it, increase the size by 1</li><li>if tails[i-1] &lt; x &lt;= tails[i], update tails[i]</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPositionToReplace</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid;</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (a[mid] == x)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; x)</span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> | nums.length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = nums.length, len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] increasingSequence = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">increasingSequence[len++] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; increasingSequence[len - <span class="number">1</span>])</span><br><span class="line">increasingSequence[len++] = nums[i];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> position = findPositionToReplace(increasingSequence, <span class="number">0</span>, len - <span class="number">1</span>, nums[i]);</span><br><span class="line">increasingSequence[position] = nums[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 算法 </category>
          
          <category> LeetCode Category </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> BinarySearch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DFS</title>
      <link href="/2018/04/18/DFS/"/>
      <url>/2018/04/18/DFS/</url>
      <content type="html"><![CDATA[<p>遇到要求所有组合，可能，排列等解集的问题，一般都是用DFS/BFS + backtracking来做</p><a id="more"></a><h3 id="Path-Sum"><a href="#Path-Sum" class="headerlink" title="Path Sum"></a>Path Sum</h3><blockquote><p>给定一个值，判断是否有一个从根到叶子的路径的value之和等于这个值</p></blockquote><ul><li>非递归<ul><li>DFS，两个栈，一个放node，一个放到当前node的curSum</li><li>如果node是叶子结点，并且curSum等于给定的那个值时，返回true</li></ul></li><li>递归<ul><li>判断root为null</li><li>判断左右子树为null，且该值等于root.val</li><li>减去root.val对左右子树递归判断</li></ul></li></ul><h3 id="Path-Sum-II"><a href="#Path-Sum-II" class="headerlink" title="Path Sum II"></a>Path Sum II</h3><blockquote><p>需要返回所有可能的路径</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    pathSum(ans, path, root, sum);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pathSum</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; path,</span></span></span><br><span class="line"><span class="function"><span class="params">TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">List&lt;Integer&gt; newPath = <span class="keyword">new</span> ArrayList&lt;&gt;(path);</span><br><span class="line">newPath.add(root.val);</span><br><span class="line"><span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == sum) &#123;</span><br><span class="line">ans.add(newPath);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">pathSum(ans, newPath, root.left, sum - root.val);</span><br><span class="line">pathSum(ans, newPath, root.right, sum - root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sum-Root-to-Leaf-Numbers"><a href="#Sum-Root-to-Leaf-Numbers" class="headerlink" title="Sum Root to Leaf Numbers"></a>Sum Root to Leaf Numbers</h3><p>Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.</p><p>An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123.</p><p>Find the total sum of all root-to-leaf numbers.</p><p>For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br></pre></td></tr></table></figure><p>The root-to-leaf path 1-&gt;2 represents the number 12.</p><p>The root-to-leaf path 1-&gt;3 represents the number 13.</p><p>Return the sum = 12 + 13 = 25.</p><ul><li>和上一题类似</li></ul>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 算法 </category>
          
          <category> LeetCode Category </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>腾讯</title>
      <link href="/2018/04/16/%E8%85%BE%E8%AE%AF/"/>
      <url>/2018/04/16/%E8%85%BE%E8%AE%AF/</url>
      <content type="html"><![CDATA[<p>腾讯后台开发实习生暑期实习面试<br><a id="more"></a></p><ul><li>自我介绍</li><li>写hql <ul><li>给定腾讯新闻数据，三个表</li><li>第一个表：腾讯新闻版面id，文章id</li><li>第二个表，浏览行为数据：时间戳，版面id，文章id</li><li>第三个表，评论行为数据：时间戳，版面id，文章id</li><li>求每天文章/版面的曝光</li><li>曝光 = 评论/浏览</li></ul></li><li>求两个数组的交集<ul><li>hashset</li><li>排序，再比较</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> 面试经历 </category>
          
          <category> 2018 </category>
          
          <category> 暑期 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Binary Tree</title>
      <link href="/2018/04/12/BinaryTree/"/>
      <url>/2018/04/12/BinaryTree/</url>
      <content type="html"><![CDATA[<h2 id="Binary-Tree遍历"><a href="#Binary-Tree遍历" class="headerlink" title="Binary Tree遍历"></a>Binary Tree遍历</h2><p>前序、中序、后序遍历</p><a id="more"></a><p><strong>解法</strong></p><ul><li>递归</li><li>非递归，用stack</li><li>Morris解法，非递归，不用栈，O(1)空间，二叉搜索树</li></ul><h3 id="Binary-Tree-Preorder-Traversal"><a href="#Binary-Tree-Preorder-Traversal" class="headerlink" title="Binary Tree Preorder Traversal"></a>Binary Tree Preorder Traversal</h3><p>根-左-右</p><ul><li>递归</li><li>非递归<ul><li>根先入栈</li><li>右孩子不为空则入栈</li><li>左孩子不为空则入栈</li><li>循环跳出条件为栈为空</li></ul></li></ul><h3 id="Inorder-Traversal"><a href="#Inorder-Traversal" class="headerlink" title="Inorder Traversal"></a>Inorder Traversal</h3><p>左-根-右</p><ul><li>递归</li><li>非递归<ul><li>root入栈</li><li>不断找root = root.left入栈</li><li>当root为null时出栈，同时root = root.right</li></ul></li></ul><h3 id="postOrder-Traversal"><a href="#postOrder-Traversal" class="headerlink" title="postOrder Traversal"></a>postOrder Traversal</h3><p>左-右-根</p><ul><li>递归</li><li>非递归<ul><li>根入栈</li><li>当栈不为空时，判断栈顶元素node的左右孩子，都为null，则出栈</li><li>右孩子不为空，右孩子入栈,node.right = null</li><li>左孩子不为空，左孩子入栈,node.left = null</li></ul></li></ul><h3 id="Binary-Tree-Level-Order-Traversal-amp-II"><a href="#Binary-Tree-Level-Order-Traversal-amp-II" class="headerlink" title="Binary Tree Level Order Traversal &amp; II"></a>Binary Tree Level Order Traversal &amp; II</h3><h3 id="Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="Binary Tree Zigzag Level Order Traversal"></a>Binary Tree Zigzag Level Order Traversal</h3><p><strong>层次遍历</strong></p><ul><li>queue</li><li>根入队列</li><li>当队列不为空时，node出队列并打印结点，判断左右孩子，分别入队列</li></ul><p>将List顺序反转</p><p>Collections.reverse(subList);</p><h2 id="Binary-Tree-Recursion"><a href="#Binary-Tree-Recursion" class="headerlink" title="Binary Tree Recursion"></a>Binary Tree Recursion</h2><ul><li>pre order </li><li>in order </li><li>post order</li></ul><hr><ul><li>Max Depth</li><li>Min Depth</li><li>Is Balanced Tree</li></ul><hr><ul><li>Same Tree</li></ul><hr><ul><li>Symmetric Tree</li><li>Validate Binary Search Tree</li></ul><hr><ul><li>Recover Binary Search Tree</li></ul><hr><ul><li>Construct Binary Tree from pre-order and in-order </li><li>Construct Binary Tree from post-order and in-order </li><li>Convert Sorted Array to BST</li><li>Convert Sorted LinkedList to BST</li></ul><h3 id="Max-Depth-of-Binary-Tree"><a href="#Max-Depth-of-Binary-Tree" class="headerlink" title="Max Depth of Binary Tree"></a>Max Depth of Binary Tree</h3><ul><li>递归<ul><li>对左右子树深度求Max</li></ul></li><li>非递归<ul><li>层次遍历</li></ul></li></ul><h3 id="Minimum-Depth-of-Binary-Tree"><a href="#Minimum-Depth-of-Binary-Tree" class="headerlink" title="Minimum Depth of Binary Tree"></a>Minimum Depth of Binary Tree</h3><ul><li>递归<ul><li>左右孩子都不为空时，取Min()</li><li>否则，取Max</li></ul></li><li>非递归<ul><li>层次遍历</li><li>当左右孩子都为空时return当前深度</li><li>否则入队列，深度++</li></ul></li></ul><h3 id="Balanced-Binary-Tree"><a href="#Balanced-Binary-Tree" class="headerlink" title="Balanced Binary Tree"></a>Balanced Binary Tree</h3><blockquote><p>平衡二叉树每一个结点的左右子树的深度相差不超过1</p></blockquote><ul><li>递归求深度差是否满足即可</li></ul><h3 id="Symmetric-Tree"><a href="#Symmetric-Tree" class="headerlink" title="Symmetric Tree"></a>Symmetric Tree</h3><blockquote><p>二叉树是否镜像对称</p></blockquote><ul><li>递归<ul><li>停止条件是 left==None &amp; right==None</li><li>left.val==right.val 比较left.left right.right &amp; left.right right.left</li></ul></li><li>非递归</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.add(root);</span><br><span class="line">    q.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        TreeNode t1 = q.poll();</span><br><span class="line">        TreeNode t2 = q.poll();</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1.val != t2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        q.add(t1.left);</span><br><span class="line">        q.add(t2.right);</span><br><span class="line">        q.add(t1.right);</span><br><span class="line">        q.add(t2.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Valid-Binary-Search-Tree"><a href="#Valid-Binary-Search-Tree" class="headerlink" title="Valid Binary Search Tree"></a>Valid Binary Search Tree</h3><blockquote><p>是否满足结点的值左&lt;根&lt;右</p></blockquote><ul><li>递归<ul><li>判断结点的值是否在取值范围内</li></ul></li><li>非递归<ul><li>中序遍历</li><li>一旦出现先pop的node的值比后面的大，则不是</li></ul></li></ul><h3 id="Flatten-Binary-Tree-to-Linked-List"><a href="#Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="Flatten Binary Tree to Linked List"></a>Flatten Binary Tree to Linked List</h3><p>For example,</p><p>Given</p><pre><code>    1   / \  2   5 / \   \3   4   6 </code></pre><p>The flattened tree should look like:</p><pre><code>1 \  2   \    3     \      4       \        5         \          6</code></pre><p><strong>思路1</strong></p><ul><li>递归<ul><li>DFS找到最左结点，然后返回其父结点</li><li>把其父节点和右子节点断开</li><li>将原左子结点连上父节点的右子节点上</li><li>然后再把原右子节点连到新右子节点的右子节点上</li><li>然后再回到上一父节点做相同操作</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) flatten(root.left);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) flatten(root.right);</span><br><span class="line">        </span><br><span class="line">        TreeNode tem = root.right;</span><br><span class="line">        root.right = root.left;</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">           root =  root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        root.right = tem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路2</strong></p><ul><li>非递归<ul><li>从根节点开始出发，先检测其左子结点是否存在</li><li>如存在则将根节点和其右子节点断开，</li><li>将左子结点及其后面所有结构一起连到原右子节点的位置，</li><li>把原右子节点连到元左子结点最后面的右子节点之后</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                TreeNode p = cur.left;</span><br><span class="line">                <span class="keyword">while</span>(p.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    p = p.right;</span><br><span class="line">                &#125;</span><br><span class="line">                p.right = cur.right;</span><br><span class="line">                cur.right = cur.left;</span><br><span class="line">                cur.left = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="Lowest Common Ancestor of a Binary Tree"></a>Lowest Common Ancestor of a Binary Tree</h3><blockquote><p>给定两个结点，求最小公共祖先</p></blockquote><p><strong>代码</strong></p><pre><code>public class Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        //发现目标节点则通过返回值标记该子树发现了某个目标结点        if(root == null || root == p || root == q) return root;        //查看左子树中是否有目标结点，没有为null        TreeNode left = lowestCommonAncestor(root.left, p, q);        //查看右子树是否有目标节点，没有为null        TreeNode right = lowestCommonAncestor(root.right, p, q);        //都不为空，说明做右子树都有目标结点，则公共祖先就是本身        if(left!=null&amp;&amp;right!=null) return root;        //如果发现了目标节点，则继续向上标记为该目标节点        return left == null ? right : left;    }}</code></pre><h3 id="Binary-Tree-Longest-Consecutive-Sequence"><a href="#Binary-Tree-Longest-Consecutive-Sequence" class="headerlink" title="Binary Tree Longest Consecutive Sequence"></a>Binary Tree Longest Consecutive Sequence</h3><p>For example,</p><pre><code>1 \  3 / \2   4     \      5</code></pre><p>Longest consecutive sequence path is 3-4-5, so return 3.</p><pre><code>  2   \    3   /   2     / 1</code></pre><p>Longest consecutive sequence path is 2-3,not3-2-1, so return 2.</p><p><strong>解题思路</strong></p><ul><li>先序遍历</li><li>判断后一个结点是否比前一个结点的值大一</li><li>如果是则长度加1，否则长度重置为1，然后更新结果res</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> result = Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root, <span class="number">0</span>, root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> cur, TreeNode pre)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val == pre.val+<span class="number">1</span>)</span><br><span class="line">            cur++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur = <span class="number">1</span>;</span><br><span class="line">        result = Math.max(result, cur);</span><br><span class="line">        dfs(root.left, cur, root);</span><br><span class="line">        dfs(root.right, cur, root);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Recover-Binary-Search-Tree"><a href="#Recover-Binary-Search-Tree" class="headerlink" title="Recover Binary Search Tree"></a>Recover Binary Search Tree</h3><blockquote><p>二叉排序树中有两个节点被交换了，要求把树恢复成二叉排序树。空间复杂度为常数</p></blockquote><ul><li><p>递归中序遍历二叉树，空间复杂度是O(logn)，最差仍是O(n)</p><ul><li>设置一个pre指针，记录当前节点中序遍历时的前节点，</li><li>如果当前节点大于pre节点的值，说明需要调整次序。</li><li>有一个技巧是如果遍历整个序列过程中只出现了一次次序错误，说明就是这两个相邻节点需要被交换。</li></ul></li><li><p>非递归，空间复杂度是O(logn)，最差仍是O(n)</p><ul><li>栈</li><li>中序遍历</li></ul></li><li><p>Morris<br>待更新</p></li></ul><h3 id="Count-Complete-Tree-Nodes"><a href="#Count-Complete-Tree-Nodes" class="headerlink" title="Count Complete Tree Nodes"></a>Count Complete Tree Nodes</h3><p>最后一层结点可能是1～2^(树的深度-1)</p><ul><li>获得最左子树的深度和最右子树的深度，判断是否相同，相同则直接返回2^（深度）-1</li><li>如果不是，则递归计算左右子树，再加1</li></ul><h3 id="Binary-Tree-Maximum-Path-Sum"><a href="#Binary-Tree-Maximum-Path-Sum" class="headerlink" title="Binary Tree Maximum Path Sum"></a>Binary Tree Maximum Path Sum</h3><blockquote><p>路径至少包含一个结点，可以不包含根结点，求path中结点的值的最大和</p></blockquote><p>思路：递归求一条经过root的最大路径，这条路径可能是：</p><p>1) 左边某条路径 + root + 右边某条路径</p><p>2) 左边某条路径 + root</p><p>3) root + 右边某条路径</p><p>4) root</p><p><strong>对left和right与0比较，可MMath.max(maxValue, left + right + node.val)</strong></p><p>递归函数的返回值是<strong>以当前node为根的最大path sum</strong>,相当于local max<br>最后计算global的时候需要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxValue;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        maxValue = Integer.MIN_VALUE;</span><br><span class="line">        maxPathDown(root);</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxPathDown</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = Math.max(<span class="number">0</span>, maxPathDown(node.left));</span><br><span class="line">        <span class="keyword">int</span> right = Math.max(<span class="number">0</span>, maxPathDown(node.right));</span><br><span class="line">        maxValue = Math.max(maxValue, left + right + node.val);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + node.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Construct-Binary-Tree-from-Inorder-and-Preorder"><a href="#Construct-Binary-Tree-from-Inorder-and-Preorder" class="headerlink" title="Construct Binary Tree from Inorder and Preorder"></a>Construct Binary Tree from Inorder and Preorder</h3><ul><li>有两个矩阵，则对前序遍历的矩阵pre,根结点即为pre[0]</li><li>那么对应的中序遍历矩阵，找到根结点，假设是in[4]，那么in[0-3]即为左子树，in[5-length]即为右子树</li><li>递归即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length != inorder.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(<span class="number">0</span>,preorder.length-<span class="number">1</span>,preorder,<span class="number">0</span>,inorder.length-<span class="number">1</span>,inorder);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span> preStart,<span class="keyword">int</span> preEnd,<span class="keyword">int</span>[] preorder,<span class="keyword">int</span> instart,<span class="keyword">int</span> inEnd,<span class="keyword">int</span>[] inorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart&gt;preEnd || instart&gt;inEnd) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = instart; i &lt;= inEnd; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == root.val) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> lengthLeft = index - instart;</span><br><span class="line">        root.left = build(preStart+<span class="number">1</span>,preStart+lengthLeft,preorder,instart,index-<span class="number">1</span>,inorder);</span><br><span class="line">        root.right = build(preStart+lengthLeft+<span class="number">1</span>,preEnd,preorder,index+<span class="number">1</span>,inEnd,inorder);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Construct-Binary-Tree-from-Inorder-and-Postorder"><a href="#Construct-Binary-Tree-from-Inorder-and-Postorder" class="headerlink" title="Construct Binary Tree from Inorder and Postorder"></a>Construct Binary Tree from Inorder and Postorder</h3><ul><li>和上一个类似</li><li>对后序遍历的矩阵post,根结点即为post[length-1]</li><li>那么对应的中序遍历矩阵，找到根结点，假设是in[4]，那么in[0-3]即为左子树，in[5-length]即为右子树</li><li>递归即可</li></ul><h3 id="Unique-Binary-Search-Tree"><a href="#Unique-Binary-Search-Tree" class="headerlink" title="Unique Binary Search Tree"></a>Unique Binary Search Tree</h3><blockquote><p>当给定 n 时，要求出有 n 个节点的不重复的二叉查找树</p></blockquote><p><strong>动态规划</strong></p><ul><li>卡特兰数</li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/catalan.png" alt="avatar"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从节点数2开始计算到节点数为n的BST</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//计算根是第一个数的BST数量，直到根是最后一个数的BST数量，这里j可以理解为根左边的节点数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="comment">//有n的节点的BST一共有 G(n)=F(1,n-1)+F(2,n-1)+...+F(n-1,n-1)个</span></span><br><span class="line">                <span class="comment">//以i为根总共n个节点的BST有 F(i,n)=G(i-1)*G(i+1-&gt;n)个</span></span><br><span class="line">                <span class="comment">//BST形态数量之和一共有多少个节点有关 G(i+1-&gt;n)=G(n-i)</span></span><br><span class="line">                <span class="comment">//所以G(n)= G(0)*G(n-1)+G(1)*G(n-2)+...</span></span><br><span class="line">                dp[i] += dp[j] * dp[i - j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数学方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) </span><br><span class="line">         c = <span class="number">2</span>*(<span class="number">2</span>*i-<span class="number">1</span>)*c/(i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归</strong></p><ul><li>求出以 i 为根节点的所有不重复二叉查找树的和，其中 i 从 1 到 n。</li><li>当 i 为根节点时，1~i-1 都在根节点的左子树上，i+1~n 都在根节点的右子树上。</li><li>左右子树也都是二叉查找树。根据排列组合可以知道，当i为根节点时，不重复二叉查找树的数量因该是左子树的数量乘以右子树的数量。<strong>即Root( i ) = numTrees( i - 1 ) * numTrees( n - i )。</strong></li><li>numTrees( n ) = Root( 1 ) + Root( 2 ) + Root( 3 ) + …… + Root( n ).</li></ul><h3 id="Unique-Binary-Search-Tree-II"><a href="#Unique-Binary-Search-Tree-II" class="headerlink" title="Unique Binary Search Tree II"></a>Unique Binary Search Tree II</h3><blockquote><p>和上一题不一样在于需要输出所有情况</p></blockquote><ul><li>边界条件的处理<ul><li>当start &lt; end时，正常处理</li><li>当start = end时，说明只剩下一个数字可用，也就只有一种子树了</li><li>当start &gt; end时，说明上一个递归里选了start或者end做root，那么左右子树就是null，返回null</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; result = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            result.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;TreeNode&gt; left =  generateTrees(start, i-<span class="number">1</span>);</span><br><span class="line">            List&lt;TreeNode&gt; right = generateTrees(i+<span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; left.size(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; right.size(); k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root.left = left.get(j);</span><br><span class="line">                    root.right = right.get(k);</span><br><span class="line">                    result.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 算法 </category>
          
          <category> LeetCode Category </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> BinaryTree </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Greedy</title>
      <link href="/2018/04/11/Greedy/"/>
      <url>/2018/04/11/Greedy/</url>
      <content type="html"><![CDATA[<p>贪心的奥义就是每一步都选择<strong>当前</strong>回合”可见范围“（即可得知的信息）内的<strong>最优</strong>，而在每一步都仅选择当前回合”可见范围“内的最优这一策略下能够导致<strong>全局最优</strong>的结果的情况使用贪心就会是正确的，否则不适用贪心（或不适用当前对贪心中的最优的定义）。</p><p>因此，贪心一个点是选择<strong>当前最优</strong>，另一个点是这个最优要怎么定义，比如是选使得A最小的还是选使得A-B或A/B最小的等等。</p><p>贪心的正确性其实都要通过<strong>归纳法或反证法</strong>等手段进行严格地证明，而这也是算法分析课程的一个重要讲授内容。</p><a id="more"></a><h2 id="Jump-Game"><a href="#Jump-Game" class="headerlink" title="Jump Game"></a>Jump Game</h2><blockquote><p>For example:</p><p>A = [2,3,1,1,4], return true.</p><p>A = [3,2,1,0,4], return false.</p></blockquote><p>数组里的每个元素表示从该位置可以跳出的最远距离，要求问从第一个元素（index=0）开始，能否达到数组的最后一个元素</p><ul><li>贪心<ul><li>设一个值max，遍历更新max = Math.max(max,i+nums[i])</li><li>最后判断max是否大于等于nums.length-1</li></ul></li><li>动态规划<ul><li>dp[i] i处可到的最远距离</li><li>dp[i] = Math.max(dp[i-1],i+nums[i]) i可达</li><li>dp[i] = dp[i-1] i不可达</li></ul></li></ul><h2 id="Jump-Game-II"><a href="#Jump-Game-II" class="headerlink" title="Jump Game II"></a>Jump Game II</h2><blockquote><p>给定一个非负整数数组，给定的初始化位置在数组的起始位置。数组中的每个元素代表着你能都在此位置跳跃的最大的距离。你的目标是用最少的跳跃数达到数组的末尾</p></blockquote><ul><li>贪心<ul><li>一次循环判断，当前所能到达的最远位置</li><li>如果到不了当前位置，则step加1</li></ul></li></ul><ul><li>动态规划<ul><li>dp[i] 到达i处的最少步数</li><li>两重循环，dp[i]&gt;dp[j]+1 ？dp[i]=dp[j]+1：dp[i] （i &gt; j ,i from 0 to n, j+nums[j] &gt;= i）</li></ul></li></ul><h2 id="Gas-Station"><a href="#Gas-Station" class="headerlink" title="Gas Station"></a>Gas Station</h2><blockquote><p>在一个圆形路径上有N个加油站，在位置 i 上的汽油的数目为gas[i].</p></blockquote><blockquote><p>你有一个汽车，这个汽车的油箱是无限容量的，它从加油站 i 到 加油站 （i+1）需要耗费的汽油数为cost[i]. 开始这段旅程的时候，你的起始状态是在加油站中的一个，油箱为空的.</p></blockquote><blockquote><p>若一次性完成整个的圆形路途，返回你的其实加油站的序号，若不能完成整个路途，返回-1.</p></blockquote><ol><li><p>如果total为<strong>负数</strong>，则无论如何都开不完一圈。</p></li><li><p><strong>如果从一个加油站i出发，开到加油站j所属路段的时候油耗尽，那么从i,j之间的任一个加油站出发都会在j路段或j之前路段耗尽油(相邻的加油站到达必须剩余油量&gt;=0)</strong></p></li></ol><ul><li>循环计算走一环的total和到某站点i的sum</li><li>如果sum&lt;0，则开始的站点变为i+1</li><li>最后判断total</li></ul><h2 id="Candy"><a href="#Candy" class="headerlink" title="Candy"></a>Candy</h2><blockquote><p>多个小朋友站成一排，根据他们的得分分发糖果，得分高的小朋友要比旁边得分低的小朋友得到的糖果多，每个小朋友至少得到一枚糖果，问最少要准备多少糖果？</p></blockquote><ul><li>每个人初始为1</li><li>先从左到右扫描一遍，使得右边比左边得分高的小朋友糖果数比左边多。</li><li>再从右到左扫描一遍，使得左边比右边得分高的小朋友糖果数比右边多。</li></ul><h2 id="Product-of-Array-Except-Self"><a href="#Product-of-Array-Except-Self" class="headerlink" title="Product of Array Except Self"></a>Product of Array Except Self</h2><blockquote><p>除本身之外的数组之积 O(n) 不能用除法</p></blockquote><ul><li>两次遍历</li><li>对result[i]来说，先保存从左到右计算0 ~ i-1的乘积x</li><li>再从右到左计算i+1 ~ n的乘积y,计算x与y的乘积即可</li></ul><h2 id="Meeting-Rooms-II"><a href="#Meeting-Rooms-II" class="headerlink" title="Meeting Rooms II"></a>Meeting Rooms II</h2><p>因为要知道之前有overlap的最小的end，所以可以用一个<strong>min heap</strong>。每次检查<strong>新的start是否比heap的top元素小，是的话就把保存原来的end，同时放进新的end；否则就放新的end同时poll出原来的</strong>，因为没有overlap且新的end较大。最后heap的大小就是需要的房间数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(Interval[] intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(intervals==<span class="keyword">null</span>||intervals.length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;Interval&gt;()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Interval i1, Interval i2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i1.start-i2.start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Arrays.sort可替换成：</span></span><br><span class="line">    <span class="comment">//Arrays.sort(intervals, (a, b) -&gt; a.start == b.start ? a.end - b.end : a.start - b.start);</span></span><br><span class="line"> </span><br><span class="line">    PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">    queue.offer(intervals[<span class="number">0</span>].end);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;intervals.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals[i].start &gt;= queue.peek())&#123;</span><br><span class="line">            queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        queue.offer(intervals[i].end);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> queue.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Task-Scheduler"><a href="#Task-Scheduler" class="headerlink" title="Task Scheduler"></a>Task Scheduler</h2><blockquote><p>安排CPU的任务，规定在两个相同任务之间至少隔n个时间点</p></blockquote><p>Input: tasks = [‘A’,’A’,’A’,’B’,’B’,’B’], n = 2</p><p>Output: 8</p><p>Explanation: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B.</p><p>我们首先考虑出现<strong>频率最高</strong>的task，我们仍假设为A，出现的频率为x，我们知道，要满足A的时间需求，我们至少应该有 x-1个n的间隔。对于频率小于x的任务，假设为B，我们按序插入任务B，可以发现，这样的插入也是满足要求的。</p><p>AB-AB-AB<br><strong>模块的次数为任务最大次数减1，模块的长度为n+1，最后加上的字母个数为出现次数最多的任务，可能有多个并列。</strong></p><p>如例题中模块AB-的次数为2，长度为3，结果即为2*3+2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> t : tasks)&#123;  </span><br><span class="line">            c[t - <span class="string">'A'</span>]++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        Arrays.sort(c);  </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">25</span>;  </span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; c[i] == c[<span class="number">25</span>]) i--;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> Math.max(tasks.length, (c[<span class="number">25</span>] - <span class="number">1</span>) * (n + <span class="number">1</span>) + <span class="number">25</span> - i);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 算法 </category>
          
          <category> LeetCode Category </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> Greedy </tag>
            
            <tag> Sort </tag>
            
            <tag> DynamicProgramming </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>腾讯云</title>
      <link href="/2018/04/10/%E8%85%BE%E8%AE%AF%E4%BA%91/"/>
      <url>/2018/04/10/%E8%85%BE%E8%AE%AF%E4%BA%91/</url>
      <content type="html"><![CDATA[<p>腾讯云后台开发实习生暑期实习面试<br><a id="more"></a></p><ul><li>介绍项目</li><li>多线程的实现方式，线程的状态<ul><li>new Thread / implements Runnable</li></ul></li><li>gc,什么时候gc，内存溢出<ul><li><a href="http://blog.jiangdongyu.space/2018/03/18/Java%20JVM/">Java GC</a></li></ul></li><li>Linux指令，怎么查看内存线程使用情况</li><li>Mysql索引，group by &amp; union</li><li>TCP的…四次挥手，为什么等待2MSL?</li><li>用过哪些大数据框架</li><li>怎么判断一棵二叉树是镜像的？<ul><li>层次遍历，每次取左子树左右结点，右子树右左结点，判断是否相同</li></ul></li><li><p>栈实现O(1)获得最小的数getMin()</p><ul><li>非常棒的一道题。原理很简单，但是需要思考清楚为什么可以。原理可以参考下图：<br><img src="http://p9fh1pach.bkt.clouddn.com/%E6%A0%88%E6%9C%80%E5%B0%8F.png" alt="avatar"></li><li>准备两个栈，一个正常栈，一个辅助栈，正常栈做pop和push。辅助栈push更新最小值，pop出正常栈的最小值。</li><li>过程很简单，当正常栈push的时候，查看辅助栈的栈顶元素，如果是比辅助栈栈顶还小或者等于，那么更新到栈顶。否则不加如辅助栈。<ul><li>当正常栈做pop，查看辅助栈栈顶是否相等，相等的话一起pop，否则不动。</li></ul></li><li><p>PS：注意当做push的时候，辅助栈栈顶元素和新元素相等，还是要入栈，因为再做pop把元素出栈后，正常栈其实后面还是有这个元素。</p></li><li><p>原理：其实就是类似动态规划的原理，辅助栈里的元素，全是到正常栈该元素位置的最小值是谁。所以除非正常栈做出栈弹出到这个值，否则辅助栈的栈顶就是当前的最小值。</p></li></ul></li><li>1000瓶水，1瓶有毒，一只小白鼠喝了有毒的一周死亡，现给10只小白鼠一周时间，怎么做？<ul><li>二进制 标记</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> 面试经历 </category>
          
          <category> 2018 </category>
          
          <category> 暑期 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>今日头条</title>
      <link href="/2018/04/09/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1/"/>
      <url>/2018/04/09/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1/</url>
      <content type="html"><![CDATA[<p>今日头条后台开发面试<br><a id="more"></a></p><ul><li>自我介绍</li><li>给定一个结点，确定二叉树中序遍历的后继结点（结点有左指针，右指针，父亲指针）<ul><li>判断是否有右子树，有就找右子树最左的结点</li><li>没有，则不断找父亲结点，直到当前结点是父亲结点的左孩子</li></ul></li><li>介绍项目</li><li>hashmap的equals和hashcode方法，怎么判断key存在（底层）<ul><li>首先<strong>hash(key)得到key的hashcode()</strong>，hashmap根据获得的hashcode找到要插入的位置所在的链，在这个链里面放的都是hashcode相同的Entry键值对，在找到这个链之后，会通过<strong>equals()</strong>方法判断是否已经存在要插入的键值对，而这个equals比较的其实就是key。</li><li>判断key是否存在的时候是先比较key的hashCode，再比较相等或equals的</li></ul></li><li>Http的keep-alive长连接的特性，多个json怎么区分（content-length）</li><li>数据库事务的一致性<ul><li>事务执行前与执行后数据内在的逻辑始终是成立的。比如转账前与转账后两人存款的总和始终不变。</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> 面试经历 </category>
          
          <category> 2018 </category>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LinkedList</title>
      <link href="/2018/04/07/LinkedList/"/>
      <url>/2018/04/07/LinkedList/</url>
      <content type="html"><![CDATA[<ul><li>dummy node的运用</li><li>merge linked list一定要会</li></ul><p><strong>题目列表</strong><br>LinkedList题大体可分为三类：reverse类、Merge类、快慢针类<br><a id="more"></a></p><ul><li>Rotate List</li><li>Copy list with random pointers</li><li>Convert sorted list to Binary Search Tree </li><li>Remove Duplicates</li><li>Remove Duplicates II</li><li>Add Two Numbers</li><li>insertion sort list use a dummy node to add node to new list one at a time</li></ul><p><strong>reverse类</strong></p><ul><li>reverse linked list </li><li>reverse print list</li><li>reverse nodes in k group </li><li>swap nodes in pairs </li><li>palindrome list</li><li>reorder list</li></ul><p><strong>Merge类</strong></p><ul><li>merge linked list </li><li>merge K sorted List</li></ul><p><strong>快慢针类</strong></p><ul><li>list cycle I, II</li><li>get kth node ( get middle node)</li><li>intersection of two lists</li><li>remove nth node from end of list</li></ul><h2 id="Add-Two-Numbers"><a href="#Add-Two-Numbers" class="headerlink" title="Add Two Numbers"></a>Add Two Numbers</h2><blockquote><p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</p><p>Output: 7 -&gt; 0 -&gt; 8</p><p>Explanation: 342 + 465 = 807.</p></blockquote><p>dummy node的使用，sum &amp; carry</p><p>最后要对carry进行判断</p><h2 id="Remove-Duplicates"><a href="#Remove-Duplicates" class="headerlink" title="Remove Duplicates"></a>Remove Duplicates</h2><blockquote><p>For example,</p><p>Given 1-&gt;1-&gt;2, return 1-&gt;2.</p><p>Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.</p></blockquote><p>保留重复的值，可用cur = head,判断cur.val == cur.next.val ? </p><h2 id="Remove-Duplicates-II"><a href="#Remove-Duplicates-II" class="headerlink" title="Remove Duplicates II"></a>Remove Duplicates II</h2><blockquote><p>For example,</p><p>Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.</p><p>Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3.</p></blockquote><p>删除重复的值，需要dummy node，cur = dummy,需要记录cur.next.val进行循环删除</p><h2 id="Merge类"><a href="#Merge类" class="headerlink" title="Merge类"></a>Merge类</h2><h3 id="Merge-Two-Sorted-Lists"><a href="#Merge-Two-Sorted-Lists" class="headerlink" title="Merge Two Sorted Lists"></a>Merge Two Sorted Lists</h3><ul><li>递归</li><li>非递归</li></ul><h3 id="Merge-K-Sorted-Lists"><a href="#Merge-K-Sorted-Lists" class="headerlink" title="Merge K Sorted Lists"></a>Merge K Sorted Lists</h3><ul><li>二分+递归</li><li>使用堆（优先队列），将K个链表的头结点全部添加到队列，由于优先级队列采用了最小堆数据结构，堆顶为队列的最小元素，我们将其取出添加到结果链表中，取出元素对应的链表下移一个节点，并将这个节点添加到优先级队列中；然后我们继续取出堆顶元素，…，直到优先级队列为空，那么其中所有元素取尽，K个链表的元素已经全部排序到结果链表。</li></ul><h2 id="快慢针类"><a href="#快慢针类" class="headerlink" title="快慢针类"></a>快慢针类</h2><h3 id="List-Cycle"><a href="#List-Cycle" class="headerlink" title="List Cycle"></a>List Cycle</h3><ul><li>快慢指针，最后是否相遇 fast.next != null &amp;&amp; fast.next.next != null</li></ul><h3 id="List-Cycle-II"><a href="#List-Cycle-II" class="headerlink" title="List Cycle II"></a>List Cycle II</h3><blockquote><p>找到环开始的地方</p></blockquote><p><img src="http://p9fh1pach.bkt.clouddn.com/List%20Cycle%20II.png" alt="avatar"></p><p>假设从起点到环开始的地方长度为x,相遇点距离环起点为k，环长为L</p><p>d = x + m*L + k</p><p>2d = x + n*L +k</p><p>则 x + (2m -n)*L +k = 0</p><p>所以 x = (L-k) + (n-2m-1)*L</p><p>所以 一指针从开始出发，一指针从相遇点出发，最终会在环开始的地方相遇</p><h3 id="Remove-Nth-Node-From-End"><a href="#Remove-Nth-Node-From-End" class="headerlink" title="Remove Nth Node From End"></a>Remove Nth Node From End</h3><blockquote><p>删除从尾部开始数的第n个结点</p></blockquote><ul><li>快慢指针，快指针先走n步</li></ul><h3 id="Partition-List"><a href="#Partition-List" class="headerlink" title="Partition List"></a>Partition List</h3><blockquote><p>给定一个链表，一个整数x，将链表分开确定一边比x小，另一表不小于x，并保持原来的链表的相对顺序</p></blockquote><ul><li>需要dummy node</li><li>可以新建一个链表用来存小于x的node,并将原来对应的node删掉，最后将原来的list接在现在的之后</li></ul><h2 id="reverse类"><a href="#reverse类" class="headerlink" title="reverse类"></a>reverse类</h2><h3 id="Reverse-Linked-List"><a href="#Reverse-Linked-List" class="headerlink" title="Reverse Linked List"></a>Reverse Linked List</h3><ul><li>头插法</li><li>递归</li></ul><h3 id="Reverse-Linked-List-II"><a href="#Reverse-Linked-List-II" class="headerlink" title="Reverse Linked List II"></a>Reverse Linked List II</h3><blockquote><p>将链表m到n的位置的结点逆置</p></blockquote><ul><li>dummy node</li><li>找到开始反转的前一个node pre 维持不变，以及找到真正开始反转的结点start，下一个结点 then</li></ul><h3 id="Palindrome-List"><a href="#Palindrome-List" class="headerlink" title="Palindrome List"></a>Palindrome List</h3><ul><li>双指针，判断fast.next是否为null，不是则slow = slow.next</li><li>对slow进行逆置</li><li>一一比较两个链表的值</li></ul><h3 id="Swap-Nodes-in-Pairs"><a href="#Swap-Nodes-in-Pairs" class="headerlink" title="Swap Nodes in Pairs"></a>Swap Nodes in Pairs</h3><blockquote><p>For example,<br>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p></blockquote><ul><li>dummy node</li><li>三个node的使用，cur first second </li><li>cur = cur.next.next</li></ul><h3 id="Reorder-List"><a href="#Reorder-List" class="headerlink" title="Reorder List"></a>Reorder List</h3><blockquote><p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,</p><p>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p></blockquote><ul><li>找到中点，前半部分结尾设为null</li><li>将后半部分reverse</li><li>再merge</li></ul><h2 id="Rotate-List"><a href="#Rotate-List" class="headerlink" title="Rotate List"></a>Rotate List</h2><blockquote><p>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,</p></blockquote><blockquote><p>return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.</p></blockquote><ul><li>two pointer</li><li>找到length-k个，注意k可能大于length(%),并将next设为null</li><li>将原来链表的end的next设为head</li><li>返回原来的length-k+1个</li></ul><h2 id="Copy-List-with-Random-Pointer"><a href="#Copy-List-with-Random-Pointer" class="headerlink" title="Copy List with Random Pointer"></a>Copy List with Random Pointer</h2><blockquote><p>如果要copy一个带有random pointer的list，主要的问题就是有可能这个random指向的位置还没有被copy到，所以解决方法都是多次扫描list。</p></blockquote><p><strong>使用HashMap，HashMap的key存原始pointer，value存新的pointer。</strong></p><ul><li>hashmap，一次遍历put(node,new RandomListNode(node.label))</li><li>再次遍历，对next，random指针进行修改</li></ul><p><strong>3次遍历list，时间复杂度为O(3n)=O(n)。</strong></p><ul><li><p>对每个node进行复制，并插入其原始node的后面，新旧交替，变成重复链表。如：原始：1-&gt;2-&gt;3-&gt;null，复制后：1-&gt;1-&gt;2-&gt;2-&gt;3-&gt;3-&gt;null</p></li><li><p>遍历每个旧node，把旧node的random的复制给新node的random，因为链表已经是新旧交替的。所以复制方法为：</p><pre><code>node.next.random = node.random.next</code></pre><p>前面是说旧node的next的random，就是新node的random，后面是旧node的random的next，正好是新node，是从旧random复制来的。</p></li><li><p>把新旧两个表拆开，返回新的表即可。</p></li></ul><h2 id="Convert-Sorted-List-to-Binary-Search-Tree"><a href="#Convert-Sorted-List-to-Binary-Search-Tree" class="headerlink" title="Convert Sorted List to Binary Search Tree"></a>Convert Sorted List to Binary Search Tree</h2><p><strong>递归</strong></p><ul><li>找到中点</li><li>递归</li></ul><p><strong>中序遍历</strong></p><p>左子树-根-右子树</p><h2 id="Intersection-of-Two-Linked-List"><a href="#Intersection-of-Two-Linked-List" class="headerlink" title="Intersection of Two Linked List"></a>Intersection of Two Linked List</h2><p>For example, the following two linked lists:</p><blockquote><p>A:          a1 → a2 → c1 → c2 → c3  </p><p>B:      b1 → b2 → b3 → c1 → c2 → c3 </p></blockquote><p>begin to intersect at node c1.</p><p>获得两个链表的长度差x，较长的先往前x，再一起往前，直到相等</p>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 算法 </category>
          
          <category> LeetCode Category </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>位运算</title>
      <link href="/2018/04/07/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2018/04/07/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      <content type="html"><![CDATA[<p><strong>例题</strong></p><h2 id="XOR相关"><a href="#XOR相关" class="headerlink" title="XOR相关"></a>XOR相关</h2><h3 id="Single-Number"><a href="#Single-Number" class="headerlink" title="Single Number"></a>Single Number</h3><blockquote><p>找到数组中只出现一次的元素，其它出现两次，不用额外内存<br>异或XOR ^ </p></blockquote><a id="more"></a><p><strong>Concept</strong></p><ul><li>If we take XOR of zero and some bit, it will return that bit<ul><li>a⊕0=a</li></ul></li><li>If we take XOR of two same bits, it will return 0<ul><li>a⊕a=0</li></ul></li><li>a⊕b⊕a=(a⊕a)⊕b=0⊕b=b</li></ul><h3 id="Single-Number-II"><a href="#Single-Number-II" class="headerlink" title="Single Number II"></a>Single Number II</h3><blockquote><p>找到数组中只出现一次的元素，其它出现三次，不用额外内存</p></blockquote><p>利用只出现3次的特性，模3的值只可能是0或1，则第一次出现存在ones中，第二次出现存在twos中，同时清掉ones的值，第三次出现，存在ones中，但twos中有了，同时清掉ones，twos的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++)&#123;</span><br><span class="line">        ones = (ones ^ A[i]) &amp; ~twos;</span><br><span class="line">        twos = (twos ^ A[i]) &amp; ~ones;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Single-Number-III"><a href="#Single-Number-III" class="headerlink" title="Single Number III"></a>Single Number III</h3><blockquote><p>2n+2的数组，每个元素出现两次，除了两个只出现一次的数，找到这两个数</p><p>time O(n) space O(1)</p></blockquote><ul><li>遍历数组异或，得到两个只出现一次的数异或之后的值x</li><li>将该值x与~(x-1)相与，获得最后几位不同的数值y</li><li>初始化返回数组，res[2]={0,0}</li><li>遍历数组，判断num[i]&amp;y == 0? res[0]^num[i]:res[1]^num[i]</li></ul><h3 id="Missing-Number"><a href="#Missing-Number" class="headerlink" title="Missing Number"></a>Missing Number</h3><blockquote><p>给定一个0-n每个元素都不同的数组，数组元素缺了一个，比如0，1，3，缺了2，找到缺少的那个数</p></blockquote><ul><li>对0-n做异或得x</li><li>对数组做异或得y</li><li>返回x^y</li></ul><h2 id="amp-相关"><a href="#amp-相关" class="headerlink" title="&amp;相关"></a>&amp;相关</h2><h3 id="Count-of-1-bits"><a href="#Count-of-1-bits" class="headerlink" title="Count of 1 bits"></a>Count of 1 bits</h3><blockquote><p>给定一个整数，求该整数二进制表示时1的个数</p></blockquote><h4 id="检查每一位是否是1，右移"><a href="#检查每一位是否是1，右移" class="headerlink" title="检查每一位是否是1，右移"></a>检查每一位是否是1，右移</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countSetBits</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         count += n &amp; <span class="number">1</span>;</span><br><span class="line">         n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="bitwise"><a href="#bitwise" class="headerlink" title="bitwise"></a>bitwise</h4><p>从integer减1时，从右往左所有0变1，将最右边1变为0</p><p>比如110100 减1 得110011，对这两个数做&amp;，变为110000</p><p>所以n &amp; (n-1)可以将n的最后一个1消掉，用while判断是否消掉所有的1</p><h3 id="Power-of-Two"><a href="#Power-of-Two" class="headerlink" title="Power of Two"></a>Power of Two</h3><blockquote><p>给定一个整数，判断是否是2的次方</p></blockquote><p>2的power只有一位是1，利用n &amp; (n-1)将1消掉，接着判断是否为0</p><h2 id="Shift相关"><a href="#Shift相关" class="headerlink" title="Shift相关"></a>Shift相关</h2><h3 id="Reverse-Bits"><a href="#Reverse-Bits" class="headerlink" title="Reverse Bits"></a>Reverse Bits</h3><blockquote><p>0100 -&gt; 0010</p></blockquote><p>32位整数，循环32次，将当前bit赋值给res,整数右移，res左移</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>;i++)&#123;</span><br><span class="line">            res = (res&lt;&lt;<span class="number">1</span>) | (n&amp;<span class="number">1</span>);</span><br><span class="line">            n = n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Math相关"><a href="#Math相关" class="headerlink" title="Math相关"></a>Math相关</h2><h3 id="Bitwise-AND-of-Numbers-Range"><a href="#Bitwise-AND-of-Numbers-Range" class="headerlink" title="Bitwise AND of Numbers Range"></a>Bitwise AND of Numbers Range</h3><blockquote><p>给定范围[m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回范围内所有整数的按位与，包括边界。</p></blockquote><p>例如，给定范围[5, 7], 你应该返回4。</p><ul><li>[m, n]范围的按位与的结果为m与n的公共“左边首部（left header）”</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m!=n)&#123;</span><br><span class="line">            m = m&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            n = n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m&lt;&lt;count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 算法 </category>
          
          <category> LeetCode Category </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HashMap &amp; ConcurrentHashMap</title>
      <link href="/2018/04/03/HashMap&amp;ConcurrentHashMap/"/>
      <url>/2018/04/03/HashMap&amp;ConcurrentHashMap/</url>
      <content type="html"><![CDATA[<h2 id="HashMap实现原理"><a href="#HashMap实现原理" class="headerlink" title="HashMap实现原理"></a>HashMap实现原理</h2><p>HashMap即是采用了链地址法，也就是<strong>数组+链表</strong>的方式</p><p>HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。</p><a id="more"></a><p>所以，HashMap的整体结构如下</p><p><img src="http://p9fh1pach.bkt.clouddn.com/1024555-20161113235348670-746615111.png" alt="avatar"></p><p>简单来说，HashMap由数组+链表组成的，<strong>数组</strong>是HashMap的<strong>主体</strong>，<strong>链表</strong>则是主要为了解决<strong>哈希冲突</strong>而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度依然为O(1)，因为最新的Entry会插入链表头部，仅需简单改变引用链即可，而对于查找操作来讲，此时就需要遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的<strong>链表出现越少，性能才会越好</strong>。</p><p>其他几个重要字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际存储的key-value键值对的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//阈值，当table == &#123;&#125;时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//负载因子，代表了table的填充度有多少，默认是0.75</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationException</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><p>HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值</p><p><strong>initialCapacity默认为16，loadFactory默认为0.75</strong></p><p><strong>在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果table数组为空数组&#123;&#125;，进行数组填充（为table分配实际内存空间），入参为threshold，此时threshold为initialCapacity 默认是1&lt;&lt;4(24=16)</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果key为null，存储位置为table[0]或table[0]的冲突链上</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);<span class="comment">//对key的hashcode进一步计算，确保散列均匀</span></span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">//获取在table中的实际位置</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="comment">//如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value</span></span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    modCount++;<span class="comment">//保证并发访问时，若HashMap内部结构发生变化，快速响应失败</span></span><br><span class="line">    addEntry(hash, key, value, i);<span class="comment">//新增一个entry</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。</p><p><strong>HashMap的数组长度一定是2的次幂</strong></p><ul><li>如果数组进行扩容，数组长度发生变化，而存储位置 index = h&amp;(length-1),index也可能会发生变化，需要重新计算index</li><li>扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)</li><li>数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀</li></ul><p><strong>多线程下使用HashMap</strong></p><p>JDK1.7 存在死循环</p><h2 id="ConcurrentHashMap实现原理"><a href="#ConcurrentHashMap实现原理" class="headerlink" title="ConcurrentHashMap实现原理"></a>ConcurrentHashMap实现原理</h2><p><strong>分段锁</strong></p><p><img src="http://p9fh1pach.bkt.clouddn.com/1024555-20170514174100832-1891630860.png" alt="avatar"></p><p>ConcurrentHashMap采用了非常精妙的”分段锁”策略，ConcurrentHashMap的主干是个Segment数组。</p><p>在ConcurrentHashMap，一个Segment就是一个<strong>子哈希表</strong>，Segment里维护了一个HashEntry数组，并发环境下，对于不同Segment的数据进行操作是不用考虑锁竞争的。</p><p>所以，对于<strong>同一个Segment的操作才需考虑线程同步，不同的Segment则无需考虑</strong>。</p><p>Segment数组的大小ssize是由concurrentLevel来决定的，但是却不一定等于concurrentLevel，ssize一定是大于或等于concurrentLevel的最小的2的次幂。</p><p>put的主要逻辑也就两步：</p><p>1.定位segment并确保定位的Segment已初始化 </p><p>2.调用Segment的put方法。</p><p>Segment的get方法无需加锁，由于其中涉及到的共享变量都使用<strong>volatile</strong>修饰，volatile可以保证<strong>内存可见性</strong>，所以不会读取到过期数据。</p><p>Segment上的put方法，Segment中的put方法是要<strong>加锁</strong>的。只不过是<strong>锁粒度细</strong>了而已。</p>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Math相关</title>
      <link href="/2018/04/02/%E6%95%B0%E5%AD%A6%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/04/02/%E6%95%B0%E5%AD%A6%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p><strong>题型总结</strong></p><ul><li><p>第一种类型是最简单的， 就是对整数进行直接操作， 一般来说就是逐位操作， 比如反转， 比较等。 LeetCode中这类题目有Palindrome Number和Reverse Integer。</p></li><li><p>第二种题型是算术运算的题目， 比如乘除法， 阶乘， 开方等， LeetCode中这类题目有Sqrt(x)， Pow(x, n)和Divide Two Integers。 这种题目有时候看似复杂， 其实还是有几个比较通用的解法的， 下面主要介绍三种方法：</p><ul><li>二分法</li><li>牛顿法</li><li>位移法</li></ul></li><li>第三种题目是解析几何的题目， 一般来说解析几何题目的模型都比较复杂， 而且实现细节比较多， 在面试中并不常见， LeetCode中也只有Max Points on a Line是属于这种题型。</li></ul><h2 id="Math-without-Operator"><a href="#Math-without-Operator" class="headerlink" title="Math without Operator"></a>Math without Operator</h2><blockquote><p>不用operator进行数学运算</p></blockquote><a id="more"></a><h3 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h3><ul><li>对于乘除的题目，&lt;&lt;1是乘2，&gt;&gt;1是除以2</li><li>对于加减的题目，a ^ b得到sum，a &amp; b得到carry</li></ul><h3 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h3><ul><li>正负问题</li><li>是否会overflow,int的取值范围 -2147483648 ～ 2147473647</li></ul><hr><p><strong>例题</strong></p><h4 id="Divide-Two-Integers"><a href="#Divide-Two-Integers" class="headerlink" title="Divide Two Integers"></a>Divide Two Integers</h4><blockquote><p>不用乘法，除法，取余实现除法</p></blockquote><ul><li>不断减去被除数，直至小于除数，会超时</li><li>任何一个数，都可以表示成：(2^k)*除数 &lt;=  当前被除数 &lt;(2^(k+1))*除数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (divd &gt;= divs) &#123;</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// keep multiply by 2 until divs &gt; divd</span></span><br><span class="line">    <span class="keyword">while</span> (divd &gt;= (divs &lt;&lt; counter)) &#123; </span><br><span class="line">         counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// rollback counter so that (divs&lt;&lt;counter) &lt;= divd </span></span><br><span class="line">    counter--;  </span><br><span class="line">    <span class="comment">// quotient</span></span><br><span class="line">    ret += <span class="number">1</span> &lt;&lt; counter;  </span><br><span class="line">    divd -= divs &lt;&lt; counter;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="Ugly-Number"><a href="#Ugly-Number" class="headerlink" title="Ugly Number"></a>Ugly Number</h4><p>I：判断是否是丑数</p><ul><li>如果ugly number能被2,3或者5整除，那么就除以可以整除的</li><li>如果不能被2,3,􏰏5其中一个整除，则说明不是ugly number</li><li>ugly number应该可以一直被除到1，此时可以结束，说明这个数是ugly number</li></ul><p>II:找到n-th的ugly number丑陋数列可以拆分为下面3个子列表</p><blockquote><p>(1)1x2,2x2,3x2,4x2,5x2,…</p><p>(2)1x3,2x3,3x3,4x3,5x3,…</p><p>(3)1x5,2x5,3x5,4x5,5x5,…</p></blockquote><ul><li>我们􏰤􏰥发现每一个子列表都是ugly number本身(1, 2, 3, 4, 5, …) 乘以2, 3, 5</li><li>使用与归并相似的合并方法，从3个子列表中获得ugly number。每一步获得最小的，然后后移。</li><li>三个指针p2,p3,p5分别代表下一次乘以2,3,5的来比较ugly number的index，如果用过了就指向下一个ugly number</li></ul><h4 id="Add-Digits-Digit-root"><a href="#Add-Digits-Digit-root" class="headerlink" title="Add Digits (Digit root)"></a>Add Digits (Digit root)</h4><blockquote><p>如38，3+8 = 11，1+1=2</p></blockquote><p>num%9运算即可</p><h4 id="Add-Binary"><a href="#Add-Binary" class="headerlink" title="Add Binary"></a>Add Binary</h4><p>从后往前不断加，类似merge two list</p><h4 id="Trailing-Zeros"><a href="#Trailing-Zeros" class="headerlink" title="Trailing Zeros"></a>Trailing Zeros</h4><blockquote><p>n!中有几个0</p></blockquote><p>0的多少与2和5有关，而2比5多，因此只关心5即可</p><p><strong>解题方法</strong></p><ul><li>n / 5,得到所有5的一次方的数量，加到结果</li><li>n/ (5^2)，得到所有5的二次方的数量，加到结果</li><li>5的三次方…</li><li>直到n不大于下一个5的k次方则停止</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTrailingZeros</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">// Initialize result</span></span><br><span class="line">     <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Keep dividing n by powers of 5 and update count</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">5</span>; n/i&gt;=<span class="number">1</span>; i *= <span class="number">5</span>)</span><br><span class="line">          count += n/i;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Palindrome-Number"><a href="#Palindrome-Number" class="headerlink" title="Palindrome Number"></a>Palindrome Number</h4><blockquote><p>不用额外空间</p></blockquote><p>用数学方法不断获得最大位和最小位，比较之后去掉，同时除数大小也要调整</p><h4 id="Cont-Primes"><a href="#Cont-Primes" class="headerlink" title="Cont Primes"></a>Cont Primes</h4><p><a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Algorithm_complexity" target="_blank" rel="noopener">Sieve of Eratosthenes</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: an integer n &gt; 1.</span><br><span class="line"> </span><br><span class="line">Let A be an array of Boolean values, indexed by integers 2 to n,</span><br><span class="line"> initially all set to true.</span><br><span class="line"> </span><br><span class="line">for i = 2, 3, 4, ..., not exceeding √n:</span><br><span class="line">   if A[i] is true:</span><br><span class="line">     for j = i2, i2+i, i2+2i, i2+3i, ..., not exceeding n:</span><br><span class="line">       A[j] := false.</span><br><span class="line">       </span><br><span class="line">Output: all i such that A[i] is true.</span><br></pre></td></tr></table></figure><h4 id="Roman-to-Integer-amp-Integer-to-Roman"><a href="#Roman-to-Integer-amp-Integer-to-Roman" class="headerlink" title="Roman to Integer &amp; Integer to Roman"></a>Roman to Integer &amp; Integer to Roman</h4><h4 id="Multiply-Strings"><a href="#Multiply-Strings" class="headerlink" title="Multiply Strings"></a>Multiply Strings</h4><h4 id="Excel-Sheet-Column-Number"><a href="#Excel-Sheet-Column-Number" class="headerlink" title="Excel Sheet Column Number"></a>Excel Sheet Column Number</h4><p>26进制</p>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 算法 </category>
          
          <category> LeetCode Category </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>求和问题</title>
      <link href="/2018/04/01/%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2018/04/01/%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p><strong>问题描述</strong> </p><p>一般是给一组n个数字，给1个target，求出k个数字的sum为target。有变化的就是求closet，求个数，求组合等。</p><a id="more"></a><p><strong>注意事项</strong></p><ul><li>可能有重复项，注意去重，除了2Sum都可以先排序</li></ul><h2 id="2-Sum-解法"><a href="#2-Sum-解法" class="headerlink" title="2 Sum 解法"></a>2 Sum 解法</h2><ul><li><p>方法一 brute force</p><p>枚举所有的k-subset，从N中选出k个，时间复杂度O(n^k)</p></li><li><p>先sort，再two pointer</p><p>两指针之和与target比较，大于则high–,小于则low++, O(nlogn)</p></li><li><p>利用hashmap</p><p>hashmap保存nums[i],i，循环判断map中是否存在target-nums[i],O(n)</p></li></ul><p><strong>后续题目</strong></p><p>对于2Sum的题目</p><ul><li>返回index，则优先使用hashmap做，排序会打乱顺序</li><li>如果是返回value，则用先sort，再two pointer</li></ul><p>对 3sum, 3sum closest, 4sum等题目，因为大部分都是根据two sum two pointer做法的延伸，所以都是要求return value。</p><p><strong>two pointer有利于跳过重复元素，用来计算closet，smaller等不等于target的题，优先使用</strong></p><h2 id="3-Sum-解法"><a href="#3-Sum-解法" class="headerlink" title="3 Sum 解法"></a>3 Sum 解法</h2><blockquote><p>可转换为2Sum问题，先取出一个数i，在剩下的数组中找sum为target-i的</p></blockquote><p>时间复杂度为O(nlogn+n^2) = O(n^2)</p><h2 id="3-Sum-Closet"><a href="#3-Sum-Closet" class="headerlink" title="3 Sum Closet"></a>3 Sum Closet</h2><p>sort + two pointer，不断更新最接近target的值</p><h2 id="4-Sum-解法"><a href="#4-Sum-解法" class="headerlink" title="4 Sum 解法"></a>4 Sum 解法</h2><blockquote><p>退化为3sum，两层loop，内部2 sum， O(n^3)</p></blockquote><h2 id="K-Sum-解法"><a href="#K-Sum-解法" class="headerlink" title="K Sum 解法"></a>K Sum 解法</h2><blockquote><p>一步步退化，最后变为2 Sum，O(n^(k-1))</p></blockquote>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 算法 </category>
          
          <category> LeetCode Category </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K Sum </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>编程面试的10大算法概念汇总</title>
      <link href="/2018/03/31/%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E7%9A%8410%E5%A4%A7%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%E6%B1%87%E6%80%BB/"/>
      <url>/2018/03/31/%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E7%9A%8410%E5%A4%A7%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><blockquote><p>如果IDE没有代码自动补全功能，所以你应该记住下面的这些方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">toCharArray() <span class="comment">// 获得字符串对应的char数组</span></span><br><span class="line">Arrays.sort()  <span class="comment">// 数组排序</span></span><br><span class="line">Arrays.toString(<span class="keyword">char</span>[] a) <span class="comment">// 数组转成字符串</span></span><br><span class="line">charAt(<span class="keyword">int</span> x) <span class="comment">// 获得某个索引处的字符</span></span><br><span class="line">length() <span class="comment">// 字符串长度</span></span><br><span class="line">length <span class="comment">// 数组大小</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><blockquote><p>在Java中，链表的实现非常简单，每个节点Node都有一个值val和指向下个节点的链接next。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">Node next;</span><br><span class="line"> </span><br><span class="line">Node(<span class="keyword">int</span> x) &#123;</span><br><span class="line">val = x;</span><br><span class="line">next = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表两个著名的应用是栈Stack和队列Queue。</p><p>栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span>&#123;</span><br><span class="line">Node top; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(top != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(top == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Node temp = <span class="keyword">new</span> Node(top.val);</span><br><span class="line">top = top.next;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Node n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n != <span class="keyword">null</span>)&#123;</span><br><span class="line">n.next = top;</span><br><span class="line">top = n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span></span>&#123;</span><br><span class="line">    Node first, last;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first == <span class="keyword">null</span>)&#123;</span><br><span class="line">            first = n;</span><br><span class="line">            last = first;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            last.next = n;</span><br><span class="line">            last = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Node temp = <span class="keyword">new</span> Node(first.val);</span><br><span class="line">            first = first.next;</span><br><span class="line">            <span class="keyword">if</span>(last == temp) last = first;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><blockquote><p>这里的树通常是指二叉树，每个节点都包含一个左孩子节点和右孩子节点，像下面这样：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line">TreeNode left;</span><br><span class="line">TreeNode right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是与树相关的一些概念：</p><ul><li>平衡 vs. 非平衡：平衡二叉树中，每个节点的左右子树的<strong>深度相差至多为1（1或0）</strong>。</li><li>满二叉树（Full Binary Tree）：除叶子节点以外的每个节点都有<strong>两个孩子</strong>。</li><li>完美二叉树（Perfect Binary Tree）：是具有下列性质的满二叉树：所有的叶子节点都有相同的深度或处在同一层次，且每个父节点都必须有两个孩子。</li><li>完全二叉树（Complete Binary Tree）：二叉树中，可能除了最后一个，每一层都被完全填满，且所有节点都必须尽可能向左靠。</li></ul><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><blockquote><p>图相关的问题主要集中在深度优先搜索（depth first search）和广度优先搜索（breath first search）。</p></blockquote><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><table><thead><tr><th style="text-align:center">Algorithm</th><th style="text-align:center">Average Time</th><th style="text-align:center">Worst Time</th><th style="text-align:center">Space</th><th style="text-align:center">Stable</th></tr></thead><tbody><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">n^2</td><td style="text-align:center">n^2</td><td style="text-align:center">1</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">选择排序</td><td style="text-align:center">n^2</td><td style="text-align:center">n^2</td><td style="text-align:center">1</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">插入排序</td><td style="text-align:center">n^2</td><td style="text-align:center">n^2</td><td style="text-align:center"></td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center">nlog(n)</td><td style="text-align:center">n^2</td><td style="text-align:center"></td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center">nlog(n)</td><td style="text-align:center">nlog(n)</td><td style="text-align:center"></td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">nlog(n)</td><td style="text-align:center">nlog(n)</td><td style="text-align:center"></td><td style="text-align:center">N</td></tr></tbody></table><h2 id="递归-vs-迭代"><a href="#递归-vs-迭代" class="headerlink" title="递归 vs. 迭代"></a>递归 vs. 迭代</h2><blockquote><p>对程序员来说，递归应该是一个与生俱来的思想（a built-in thought），可以通过一个简单的例子来说明。</p></blockquote><p>问题： 有n步台阶，一次只能上1步或2步，共有多少种走法。</p><p>步骤1:找到走完前n步台阶和前n-1步台阶之间的关系。</p><blockquote><p>为了走完n步台阶，只有两种方法：从n-1步台阶爬1步走到或从n-2步台阶处爬2步走到。如果f(n)是爬到第n步台阶的方法数，那么f(n) = f(n-1) + f(n-2)。</p></blockquote><p>步骤2: 确保开始条件是正确的。</p><blockquote><p>f(0) = 0;<br>f(1) = 1;</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line"><span class="keyword">int</span> x = f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归方法的时间复杂度是n的指数级，因为有很多冗余的计算，如下：</p><p>f(5)</p><p>f(4) + f(3)</p><p>f(3) + f(2) + f(2) + f(1)</p><p>f(2) + f(1) + f(1) + f(0) + f(1) + f(0) + f(1)</p><p>f(1) + f(0) + f(1) + f(1) + f(0) + f(1) + f(0) + f(1)</p><p>直接的想法是将递归转换为迭代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> first = <span class="number">1</span>, second = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> third = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">third = first + second;</span><br><span class="line">first = second;</span><br><span class="line">second = third;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> third;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对这个例子而言，迭代花费的时间更少</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划是解决下面这些性质类问题的技术：</p><p>一个问题可以通过更小子问题的解决方法来解决（译者注：即问题的最优解包含了其子问题的最优解，也就是最优子结构性质）。<br>有些子问题的解可能需要计算多次（译者注：也就是子问题重叠性质）。<br>子问题的解存储在一张表格里，这样每个子问题只用计算一次。<br>需要额外的空间以节省时间。</p><h2 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h2><p>位操作符：</p><table><thead><tr><th style="text-align:center">OR ()</th><th style="text-align:center">AND (&amp;)</th><th style="text-align:center">XOR (^)</th><th style="text-align:center">Left Shift (&lt;&lt;)</th><th style="text-align:center">Right Shift (&gt;&gt;)</th><th style="text-align:center">Not (~)</th></tr></thead><tbody><tr><td style="text-align:center">1OR0=1</td><td style="text-align:center">1&amp;0=0</td><td style="text-align:center">1^0=1</td><td style="text-align:center">0010&lt;&lt;2=1000</td><td style="text-align:center">1100&gt;&gt;2=0011</td><td style="text-align:center">~1=0</td></tr></tbody></table><p><strong>按位与&amp;，全为1才是1</strong></p><h2 id="概率问题"><a href="#概率问题" class="headerlink" title="概率问题"></a>概率问题</h2><blockquote><p>善于转换成对立的问题</p></blockquote><p>比如求50个人至少有两个人生日相同的概率（忽略闰年） ——-&gt; </p><p>计算所有人生日都互不相同的概率，也就是：365/365 <em> 364/365 </em> 363/365 <em> … </em> (365-49)/365，这样至少两个人生日相同的概率就是1 – 这个值。     </p><h2 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h2>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 算法 </category>
          
          <category> LeetCode Category </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法概念 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>蚂蚁金服</title>
      <link href="/2018/03/30/%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D/"/>
      <url>/2018/03/30/%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D/</url>
      <content type="html"><![CDATA[<p>蚂蚁金服Java暑期实习生面试<br><a id="more"></a></p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ul><li>介绍项目，主要介绍在微软的实习，要注意项目讲得对方能理解</li><li>10亿条文件排序，外部归并，merge时堆内部排序</li><li>一堆运动员的成绩排序，如a:10,b:20,c:5，排序并保证新来的一个运动员也是有序的 用treemap, map底层怎么实现的，哈希表或红黑树</li><li>白板写代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设用一组字符串表示一个目录下的层级结构:</span></span><br><span class="line"><span class="comment">//如"dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"</span></span><br><span class="line"><span class="comment">//表示的结构为</span></span><br><span class="line"><span class="comment">// dir</span></span><br><span class="line"><span class="comment">//    subdir1</span></span><br><span class="line"><span class="comment">//        file1.ext</span></span><br><span class="line"><span class="comment">//        subsubdir1</span></span><br><span class="line"><span class="comment">//    subdir2</span></span><br><span class="line"><span class="comment">//        subsubdir2</span></span><br><span class="line"><span class="comment">//            file2.ext   </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Value</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">15</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getLargestLength(<span class="string">"dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLargestLength</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String arr []  = str.split(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">0</span>].contains(<span class="string">"\t"</span>))</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; dirLength = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dirLength.add(arr[<span class="number">0</span>].length());</span><br><span class="line">        max = arr[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> length = arr[i].replaceAll(<span class="string">"\t"</span>, <span class="string">""</span>).length();</span><br><span class="line">            <span class="keyword">int</span> count = arr[i].length() - length;</span><br><span class="line">            <span class="keyword">if</span> (dirLength.size() &lt; count) &#123;</span><br><span class="line">                <span class="comment">//输入欠缺中间目录</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//新的根目录</span></span><br><span class="line">                dirLength = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dirLength = dirLength.subList(<span class="number">0</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">            dirLength.add(length + dirLength.get(count - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (dirLength.get(count) &gt; max)&#123;</span><br><span class="line">                max = dirLength.get(count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ul><li>介绍项目</li><li>给一个二维数组代表会议室的预定时间区间，比如[1,2],[2,3],[1,3]，则最少需要的会议室的数量为2<ul><li>贪心 转换为一个会议室利用率最高的问题，对开始时间排序，选择下一个开始时间离结束时间最近的</li></ul></li><li>数学题，给1-5五个数字，全排列，[12345,12354,…,54312,54321],求中间两个数的差值</li><li>hiveql和sql是一样的么？不一样，举例说明，并说明理由</li><li>hiveql数据表的join,map reduce的过程？<br><img src="http://p9fh1pach.bkt.clouddn.com/hive%20map%20reduce.png" alt="avatar"></li><li>给一个整数数组[x1,x2…xi,…xn]，求X+Y+Z&lt;N的所有可能性，不能重复<ul><li>3sum 的变体，先排序，外层循环，内层两个指针判断，如果和&gt; N-Z，则尾指针前移</li></ul></li><li><p>HTTP怎么做到有状态？</p><ul><li>我们要实现的是一种web应用，实现这种应用的协议我们选择了http这种本质上是无状态的通信协议。但是事实上，我们需要我们的web应用是有状态的。所以我们加入了<strong>cookies、session</strong>等机制去实现由状态的web应用</li><li><strong>Web应用=http协议+session、cookies等状态机制+其他辅助的机制</strong></li></ul></li><li><p>MySQL数据库引擎，innoDB的特点？别的引擎？</p><ul><li>InnoDB：该存储引擎为MySQL表提供了<strong>ACID事务支持</strong>、系统崩溃修复能力和多版本并发控制（即MVCC Multi-Version Concurrency Control）的<strong>行级锁</strong>;该引擎支持<strong>自增长列（auto_increment）</strong>,自增长列的值不能为空，如果在使用的时候为空则自动从现有值开始增值，如果有但是比现在的还大，则直接保存这个值; 该引擎存储引擎支持<strong>外键（foreign key）</strong>,外键所在的表称为子表而所依赖的表称为父表。该引擎在5.5后的MySQL数据库中为<strong>默认</strong>存储引擎。</li><li>ISAM：该引擎在<strong>读取数据</strong>方面速度很快，而且不占用大量的内存和存储资源；但是ISAM<strong>不支持事务处理、不支持外来键、不能够容错、也不支持索引</strong>。该引擎在包括MySQL 5.1及其以上版本的数据库中不再支持。</li><li>MyISAM：该引擎基于ISAM数据库引擎，除了提供ISAM里所没有的<strong>索引和字段管理</strong>等大量功能，MyISAM还使用一种<strong>表格锁定的机制</strong>来优化多个并发的读写操作，但是需要经常运行<strong>OPTIMIZE TABLE</strong>命令，来恢复被更新机制所浪费的空间，否则碎片也会随之增加，最终影响数据访问性能。MyISAM还有一些有用的扩展，例如用来修复数据库文件的MyISAMChk工具和用来恢复浪费空间的 MyISAMPack工具。MyISAM强调了快速读取操作，主要用于高负载的select，这可能也是MySQL深受Web开发的主要原因：在Web开发中进行的大量数据操作都是读取操作，所以大多数虚拟主机提供商和Internet平台提供商（Internet Presence Provider，IPP）只允许使用MyISAM格式。</li><li>HEAP（也称为MEMORY）：该存储引擎通过在<strong>内存中创建临时表</strong>来存储数据。每个基于该存储引擎的表实际对应一个磁盘文件，该文件的文件名和表名是相同的，类型为.frm。该磁盘文件只存储表的结构，而其数据存储在内存中，所以使用该种引擎的表拥有极高的插入、更新和查询效率。这种存储引擎默认使用<strong>哈希（HASH）索引</strong>，其速度比使用B-+Tree型要快，但也可以使用B树型索引。由于这种存储引擎所存储的数据保存在内存中，所以其保存的数据具有不稳定性，比如如果mysqld进程发生异常、重启或计算机关机等等都会造成这些数据的消失，所以这种存储引擎中的表的<strong>生命周期很短，一般只使用一次</strong>。</li><li>CSV（Comma-Separated Values逗号分隔值）：使用该引擎的MySQL数据库表会在MySQL安装目录data文件夹中的和该表所在数据库名相同的目录中生成一个.CSV文件（所以，它可以将CSV类型的文件当做表进行处理），这种文件是一种普通文本文件，每个数据行占用一个文本行。该种类型的存储引擎<strong>不支持索引，即使用该种类型的表没有主键列；另外也不允许表中的字段为null</strong>。</li></ul></li><li>小英的用户数据一台机器放不下的时候，怎么办？</li></ul>]]></content>
      
      <categories>
          
          <category> 面试经历 </category>
          
          <category> 2018 </category>
          
          <category> 暑期 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>搜狐智能媒体研发中心</title>
      <link href="/2018/03/28/%E6%90%9C%E7%8B%90%E6%99%BA%E8%83%BD%E5%AA%92%E4%BD%93%E7%A0%94%E5%8F%91%E4%B8%AD%E5%BF%83/"/>
      <url>/2018/03/28/%E6%90%9C%E7%8B%90%E6%99%BA%E8%83%BD%E5%AA%92%E4%BD%93%E7%A0%94%E5%8F%91%E4%B8%AD%E5%BF%83/</url>
      <content type="html"><![CDATA[<p>搜狐智能媒体研发中心Java实习生面试<br><a id="more"></a></p><ul><li>并发编程，能并发的数据结构</li><li>Springboot为什么能做到不配置一些xml？</li><li>1.0版本的智慧教室会遇到哪些问题？并发？底层的哪些不够用了，才会出现这些问题？</li><li>JVM参数调优，怎么做？参数的意义？</li><li>HTTP要了解得更深入一些</li><li>服务器怎么判断是某个用户，用户登录的时候怎么返回该用户的信息，session怎么做安全？</li><li>MySQL建表的时候需要注意什么？long类型在mysql中怎么存？</li><li>Redis适合存一些什么样的数据？在什么场合使用？</li><li>Spring的IOC、AOP需要知道流程，Java基础，NIO等…</li><li>单链表反转，递归，非递归</li></ul>]]></content>
      
      <categories>
          
          <category> 面试经历 </category>
          
          <category> 2018 </category>
          
          <category> 暑期 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>搜狐汽车</title>
      <link href="/2018/03/23/%E6%90%9C%E7%8B%90%E6%B1%BD%E8%BD%A6/"/>
      <url>/2018/03/23/%E6%90%9C%E7%8B%90%E6%B1%BD%E8%BD%A6/</url>
      <content type="html"><![CDATA[<p>搜狐汽车Java后台开发实习生面试<br><a id="more"></a></p><ul><li>介绍简历</li><li>String为什么是final的,Enum,数据库连接（左外，右外，内连接）</li><li>用栈实现队列(时间复杂度),数组找出只出现一次的元素(时间复杂度),手写快排</li><li>Java运行时的编译情况，大的项目是怎么编译的</li><li>Spring的文档什么的有没有看过</li><li>确定自己喜欢的是什么，有没有兴趣，自驱动能力</li></ul><ol><li>String为什么是final的？<blockquote><p>不可变final指不在原内存地址上修改数据，而是重新指向一个新对象，新地址</p></blockquote></li></ol><ul><li><p>JDK源码，java.lang.String前三行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class"> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,<span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;,<span class="title">CharSequence</span></span>&#123;  </span><br><span class="line"> </span><br><span class="line"> <span class="comment">/** String本质是个char数组，而且用final修饰*/</span>  </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Array可变，只是在后面的String的所有方法里没有动数组的元素，没有暴露内部成员。<strong>String不可变的关键都在底层实现，而不是一个final</strong></p><ul><li>不可变是为了安全</li></ul><ol start="2"><li><p>SQL四种连接</p><ul><li><p>内联接（典型的联接运算，使用像 =  或 &lt;&gt; 之类的比较运算符）。包括相等联接和自然联接。<br>内联接使用比较运算符根据每个表共有的列的值匹配两个表中的行。例如，检索 students和courses表中学生标识号相同的所有行。   </p></li><li><p>外联接。外联接可以是左向外联接、右向外联接或完整外部联接。<br>在 FROM子句中指定外联接时，可以由下列几组关键字中的一组指定：     </p><ul><li><p>1）LEFT  JOIN或LEFT OUTER JOIN<br>左向外联接的结果集包括  LEFT OUTER子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值。       </p></li><li><p>2）RIGHT  JOIN 或 RIGHT  OUTER  JOIN<br>右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。       </p></li><li>3）FULL  JOIN 或 FULL OUTER JOIN<br>完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。   </li></ul></li><li>交叉联接<br>交叉联接返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉联接也称作笛卡尔积。</li></ul></li></ol>]]></content>
      
      <categories>
          
          <category> 面试经历 </category>
          
          <category> 2018 </category>
          
          <category> 暑期 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面试宝典</title>
      <link href="/2018/03/19/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
      <url>/2018/03/19/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/</url>
      <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="Java程序设计基本概念"><a href="#Java程序设计基本概念" class="headerlink" title="Java程序设计基本概念"></a>Java程序设计基本概念</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><blockquote><p>JVM使用Unicode字符表示</p></blockquote><h4 id="ClassLoader知识"><a href="#ClassLoader知识" class="headerlink" title="ClassLoader知识"></a>ClassLoader知识</h4><blockquote><p>Java程序并不是一个可执行文件，而是由许多独立的类文件组成，每个文件对应一个Java类。这些类文件不是全部装入内存，程序根据需要载入。</p></blockquote><a id="more"></a><ul><li>基本概念<ul><li>JVM实现的一部分</li><li>包括bootstrap classloader(启动类加载器)</li><li>在JVM运行时加载Java核心API，其中包括用户定义ClassLoader（用户定义，指通过java程序实现的ClassLoader，ExtClassLoader和AppClassLoader）</li></ul></li><li>加载流程（父类委托模式）<ul><li>JVM启动，运行bootstrap classloader，加载Java核心API（ExtClassLoader和AppClassLoader也被加载）</li><li>调用ExtClassLoader加载扩展API</li><li>AppClassLoader加载CLASSPATH目录下定义的Class</li></ul></li></ul><h3 id="i"><a href="#i" class="headerlink" title="i++"></a>i++</h3><blockquote><p>i++；先赋值在自加；++i；先自加在赋值</p></blockquote><p><strong>java中间变量缓存机制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)   </span><br><span class="line">        j = j++;   </span><br><span class="line">    System.out.println(j);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的输出结果是？   0！！！</p><p>因为java的中间缓存变量机制使j=j++语句看以分解成如下操作：</p><blockquote><p>temp = j;<br>j = j + 1;<br>j = temp; </p></blockquote><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="java的数据类型转换"><a href="#java的数据类型转换" class="headerlink" title="java的数据类型转换"></a>java的数据类型转换</h4><blockquote><p>三大类，布尔型、字符型、数值型，数值型分为整型和浮点型</p></blockquote><ul><li>简单数据类型之间的转换、字符串与其他数据类型的转换、其他实用数据类型的转换</li><li>简单数据类型之间的转换<ul><li>低级-&gt;高级</li><li>（byte、short、char）- int - long - float - double</li><li>可分为三种<ul><li>自动类型转换<br>e.g. char-&gt;int 转换为对应ASCII码值</li><li>强制类型转换 （溢出或精读下降）</li><li>包装类过渡类型转换<br>6个包装类: Boolean Character Integer Long Float Double</li></ul></li></ul></li></ul><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>&amp;&amp;，|| 短路运算符，符合前面，后面就不做了<br>&amp;，|非短路</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="Java中的异常"><a href="#Java中的异常" class="headerlink" title="Java中的异常"></a>Java中的异常</h4><blockquote><p>所有抛出的异常必须从Throwable派生而来，Error，死循环、内存泄漏等，不处理；Exception分为RuntimeException（不处理）和非运行时异常（捕获、声明）</p></blockquote><h4 id="final、finally、finalize的区别"><a href="#final、finally、finalize的区别" class="headerlink" title="final、finally、finalize的区别"></a>final、finally、finalize的区别</h4><ul><li>final关键字<ul><li>修饰类，不能派生新子类，不能被继承，类不能同时被abstract和final修饰</li><li>修饰变量或方法，保证在使用中不被改变。变量只能在定义或构造函数赋值，方法不能重写（override）</li></ul></li><li>finally<ul><li>异常处理时</li></ul></li><li>finalize<ul><li>方法名 在垃圾收集器将对象从内存中清除出去之前做必要的清理工作</li></ul></li></ul><h2 id="传递与引用"><a href="#传递与引用" class="headerlink" title="传递与引用"></a>传递与引用</h2><h3 id="传值与传引用"><a href="#传值与传引用" class="headerlink" title="传值与传引用"></a>传值与传引用</h3><ul><li>基本类型变量，传值的副本；引用类型变量，传引用的副本</li></ul><h3 id="静态修饰符-static"><a href="#静态修饰符-static" class="headerlink" title="静态修饰符 static"></a>静态修饰符 static</h3><ul><li>静态变量（类变量） 静态成员属于整个类</li><li>静态方法（类方法） 静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员</li></ul><h3 id="输入-输出流"><a href="#输入-输出流" class="headerlink" title="输入/输出流"></a>输入/输出流</h3><p><img src="http://p9fh1pach.bkt.clouddn.com/1.png" alt="本地图片链接"></p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><blockquote><p>Java在对象创建时自动分配内存，当对象引用不存在时释放内存。</p></blockquote><p>Java实用垃圾回收技术监视程序运行，当对象不再使用时自动释放内存。使用软指针跟踪对象的各个引用，并用对象表将软指针映射为对象的引用。使用软指针，垃圾回收器能以单独的线程在后台运行，依次检查每个对象。通过改变对象表项，可标记、移除、移动、检查对象。</p><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p>clone方法是object的方法，所以任何一个类都会自动拥有这个方法。但这并不说明就可以调用clone了，需要显示指明可以调用clone，需要写上字符串“implements Cloneable”。该字符串只是起指示作用。</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h3><p><img src="http://p9fh1pach.bkt.clouddn.com/2.png" alt="本地图片链接"></p><h4 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h4><ul><li>HashMap允许null值，null键</li><li>Hashtable不允许null值和null键</li><li>Hashtable方法是同步的</li></ul><h3 id="多态的概念"><a href="#多态的概念" class="headerlink" title="多态的概念"></a>多态的概念</h3>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 读书笔记 </category>
          
          <category> Java面试宝典 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM垃圾回收</title>
      <link href="/2018/03/18/Java%20JVM/"/>
      <url>/2018/03/18/Java%20JVM/</url>
      <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h2><h2 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h2><p>每个线程执行每个方法的时候都会在栈中申请一个栈帧，每个栈帧包括局部变量区和操作数栈，用于存放此次方法调用过程中的临时变量、参数和中间结果。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>存放了要加载的类信息、静态变量、final类型的常量、属性和方法信息。JVM用持久代(PermanetGeneration)来存放方法区，</p><a id="more"></a><p><img src="http://p9fh1pach.bkt.clouddn.com/%E5%A0%86%E6%A0%88%E6%96%B9%E6%B3%95%E5%8C%BA.jpg" alt="avatar"></p><h1 id="垃圾回收GC"><a href="#垃圾回收GC" class="headerlink" title="垃圾回收GC"></a>垃圾回收GC</h1><p><a href="http://www.jianshu.com/p/5261a62e4d29" target="_blank" rel="noopener">http://www.jianshu.com/p/5261a62e4d29</a><br>垃圾回收(Garbage Collection)是Java虚拟机(JVM)垃圾回收器提供的一种用于在空闲时间不定时回收无任何对象引用的对象占据的内存空间的一种机制。</p><p>内存不足或应用程序空闲时会触发</p><p>可以手动调用system.gc或finalize方法。</p><h2 id="java的对象引用"><a href="#java的对象引用" class="headerlink" title="java的对象引用"></a>java的对象引用</h2><p><strong>引用</strong>：如果Reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。  </p><ul><li>强引用：对象实例化</li><li>软引用：可能还有用的对象，会在内存不足的时候释放</li><li>弱引用：比软引用还弱，只能生存到下次垃圾回收</li><li>虚引用：最弱，甚至不能用虚引用获得一个实例对象，存在是为了在对象被回收后获得系统反馈</li></ul><p><strong>垃圾</strong>：无任何对象引用的对象  </p><p><strong>回收</strong>：清理“垃圾”占用的内存空间而非对象本身  </p><p><strong>发生地点</strong>：一般发生在堆内存中，因为大部分的对象都储存在堆内存中  </p><p><strong>发生时间</strong>：程序空闲时间不定时回收  </p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>（1）找到所有存活对象<br>（2）回收被无用对象占用的内存空间，使该空间可被程序再次使用。</p><h3 id="1-判断是否是垃圾对象的算法"><a href="#1-判断是否是垃圾对象的算法" class="headerlink" title="1. 判断是否是垃圾对象的算法"></a>1. 判断是否是垃圾对象的算法</h3><h4 id="1-1-引用计数算法"><a href="#1-1-引用计数算法" class="headerlink" title="1.1 引用计数算法"></a>1.1 引用计数算法</h4><p>堆中每个对象（不是引用）都有一个引用计数器。当一个对象被创建并初始化赋值后，该变量计数设置为1。每当有一个地方引用它时，计数器值就加1（a = b， b被引用，则b引用的对象计数+1）。当引用失效时（一个对象的某个引用超过了生命周期（出作用域后）或者被设置为一个新值时），计数器值就减1。任何引用计数为0的对象可以被当作垃圾收集。当一个对象被垃圾收集时，它引用的任何对象计数减1。</p><p>优点：引用计数收集器执行简单，判定效率高，交织在程序运行中。对程序不被长时间打断的实时环境比较有利（OC的内存管理使用该算法）。</p><p>缺点： 难以检测出对象之间的循环引用。同时，引用计数器增加了程序执行的开销。所以Java语言并没有选择这种算法进行垃圾回收。</p><p>早期的JVM使用引用计数，现在大多数JVM采用对象引用遍历（根搜索算法）。</p><h4 id="1-2-根搜索算法"><a href="#1-2-根搜索算法" class="headerlink" title="1.2 根搜索算法"></a>1.2 根搜索算法</h4><p><strong>根集(Root Set)</strong>是正在执行的Java程序可以访问的引用变量（注意：不是对象）的集合(包括局部变量、参数、类变量)，程序可以使用引用变量访问对象的属性和调用对象的方法。</p><p>（1）通过一系列名为“GC Roots”的对象作为起始点，寻找对应的引用节点。<br>（2）找到这些引用节点后，从这些节点开始向下继续寻找它们的引用节点。<br>（3）重复（2）。<br>（4）搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，就证明此对象是不可用的。</p><p> Java和C#中都是采用根搜索算法来判定对象是否存活的。</p><p> 首先，垃圾回收器将某些特殊的对象定义为GC根对象。<br> （所谓的GC根对象包括：<br>（1）虚拟机栈中引用的对象（栈帧中的本地变量表）；<br>（2）方法区中的常量引用的对象；<br>（3）方法区中的类静态属性引用的对象；<br>（4）本地方法栈中JNI（Native方法）的引用对象。<br>（5）活跃线程。）</p><p>接下来，垃圾回收器会对内存中的整个对象图进行遍历，它先从GC根对象开始，然后是根对象引用的其它对象，比如实例变量。回收器将访问到的所有对象都标记为存活。<br>（标记过程中有许多复杂的规则和操作）<br>当标记阶段完成后，GC开始进入下一阶段，删除不可达对象。</p><h3 id="2-回收垃圾对象内存的算法"><a href="#2-回收垃圾对象内存的算法" class="headerlink" title="2. 回收垃圾对象内存的算法"></a>2. 回收垃圾对象内存的算法</h3><h4 id="2-1-Tracing算法（标记-清除）"><a href="#2-1-Tracing算法（标记-清除）" class="headerlink" title="2.1 Tracing算法（标记-清除）"></a>2.1 Tracing算法（标记-清除）</h4><p>就直接删除标记的内存，不做处理</p><p>优点：不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效。</p><p>缺点：（1）标记和清除过程的效率都不高。（这种方法需要使用一个空闲列表来记录所有的空闲区域以及大小。对空闲列表的管理会增加分配对象时的工作量。）。（2）标记清除后会产生大量不连续的内存碎片。虽然空闲区域的大小是足够的，但是可能没有足够大的连续空间。</p><h4 id="2-2-Compacting算法（标记-整理）"><a href="#2-2-Compacting算法（标记-整理）" class="headerlink" title="2.2 Compacting算法（标记-整理）"></a>2.2 Compacting算法（标记-整理）</h4><p>将所有对象内存向一端移动，清除端外的。</p><p>优点：（1）经过整理之后，新对象的分配只需要通过指针碰撞便能完成（Pointer Bumping），相当简单。（2）使用这种方法空闲区域的位置是始终可知的，也不会再有碎片的问题了。</p><p>缺点：GC暂停的时间会增长，因为你需要将所有的对象都拷贝到一个新的地方，还得更新它们的引用地址。</p><h4 id="2-3-Copying算法"><a href="#2-3-Copying算法" class="headerlink" title="2.3 Copying算法"></a>2.3 Copying算法</h4><p>将内存按容量分为大小相等的两块，每次只使用其中的一块（对象面），当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面（空闲面），然后再把已使用过的内存空间一次清理掉。</p><p><strong>复制算法比较适合于新生代（短生存期的对象），在老年代（长生存期的对象）中，对象存活率比较高，如果执行较多的复制操作，效率将会变低，所以老年代一般会选用其他算法，如标记—整理算法。</strong></p><p>优点：（1）标记阶段和复制阶段可以同时进行。（2）每次只对一块内存进行回收，运行高效。（3）只需移动栈顶指针，按顺序分配内存即可，实现简单。（4）内存回收时不用考虑内存碎片的出现（得活动对象所占的内存空间之间没有空闲间隔）。</p><p>缺点：需要一块能容纳下所有存活对象的额外的内存空间。因此，可一次性分配的最大内存缩小了一半。</p><h4 id="2-4-Adaptive算法"><a href="#2-4-Adaptive算法" class="headerlink" title="2.4 Adaptive算法"></a>2.4 Adaptive算法</h4><p>监控情况并选择最合适的垃圾回收算法</p><p>在特定的情况下，一些垃圾收集算法会优于其它算法。基于Adaptive算法的垃圾收集器就是监控当前堆的使用情况，并将选择适当算法的垃圾收集器。</p><h2 id="java的堆内存"><a href="#java的堆内存" class="headerlink" title="java的堆内存"></a>java的堆内存</h2><p>Java的堆内存基于Generation算法（Generational Collector）划分为<strong>新生代、年老代和持久代</strong>。新生代又被进一步划分为Eden和Survivor区，最后Survivor由FromSpace（Survivor0）和ToSpace（Survivor1）组成。所有通过new创建的对象的内存都在堆中分配，其大小可以通过-Xmx和-Xms来控制。</p><p>分代收集，因为不同的对象的生命周期是不一样的。因此，可以将不同生命周期的对象分代，不同的代采取不同的回收算法（4.1-4.3）进行垃圾回收（GC），以便提高回收效率。</p><p>（1）对象优先在Eden分配。</p><p>（2）大对象直接进入老年代。</p><p>（3）长期存活的对象将进入老年代。</p><h3 id="年轻代young-generation"><a href="#年轻代young-generation" class="headerlink" title="年轻代young generation"></a>年轻代young generation</h3><p>Minor GC/Scavenge GC（非常频繁，并不是eden满了才发生）<br>几乎所有新生成的对象首先都是放在年轻代的。新生代内存按照8:1:1的比例分为一个Eden区和两个Survivor(Survivor0,Survivor1)区。大部分对象在Eden区中生成。当新对象生成，Eden Space申请失败（因为空间不足等），则会发起一次GC(Scavenge GC)。回收时先将Eden区存活对象复制到一个Survivor0区，然后清空Eden区，当这个Survivor0区也存放满了时，则将Eden区和Survivor0区存活对象复制到另一个Survivor1区，然后清空Eden和这个Survivor0区，此时Survivor0区是空的，然后将Survivor0区和Survivor1区交换，即保持Survivor1区为空， 如此往复。当Survivor1区不足以存放 Eden和Survivor0的存活对象时，就将存活对象直接存放到老年代。当对象在Survivor区躲过一次GC的话，其对象年龄便会加1，默认情况下，如果对象年龄达到15岁，就会移动到老年代中。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。</p><h3 id="年老代old-generation"><a href="#年老代old-generation" class="headerlink" title="年老代old generation"></a>年老代old generation</h3><p>Major GC/Full GC（老年代满了才发生）<br>在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。一般来说，大对象会被直接分配到老年代。所谓的大对象是指需要大量连续存储空间的对象，最常见的一种大对象就是大数组。</p><h3 id="持久代permanent-generation"><a href="#持久代permanent-generation" class="headerlink" title="持久代permanent generation"></a>持久代permanent generation</h3><p>用于存放静态文件（class类、方法）和常量等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。对永久代的回收主要回收两部分内容：废弃常量和无用的类。 </p><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>不同的垃圾回收器算法不同，可能同时有不同的回收器多线程运行。<br>（1）串行垃圾回收器（Serial Garbage Collector）</p><p>（2）并行垃圾回收器（Parallel Garbage Collector）</p><p>（3）并发标记扫描垃圾回收器（CMS Garbage Collector）</p><p>（4）G1垃圾回收器（G1 Garbage Collector）</p><h2 id="如何降低垃圾回收开销"><a href="#如何降低垃圾回收开销" class="headerlink" title="如何降低垃圾回收开销"></a>如何降低垃圾回收开销</h2><p>(1)不要显式调用System.gc()<br>(2)尽量减少临时对象的使用<br>(3)对象不用时最好显式置为Null<br>(4)尽量使用StringBuffer,而不用String来累加字符串<br>(5)能用基本类型如Int,Long,就不用Integer,Long对象<br>(6)尽量少用静态对象变量<br>(7)分散对象创建或删除的时间</p><h2 id="版本变化"><a href="#版本变化" class="headerlink" title="版本变化"></a>版本变化</h2><p>永久代空间在Java SE8特性中已经被移除。取而代之的是元空间（MetaSpace）。</p><p>JVM的参数：PermSize 和 MaxPermSize 会被忽略并给出警告（如果在启用时设置了这两个参数）。</p><h3 id="元空间-Metaspace"><a href="#元空间-Metaspace" class="headerlink" title="元空间 Metaspace"></a>元空间 Metaspace</h3><p>大部分类元数据都在本地内存中分配。  </p><p>一个新的参数 (MaxMetaspaceSize)可以使用。允许你来限制用于类元数据的本地内存。如果没有特别指定，元空间将会根据应用程序在运行时的需求动态设置大小。   </p><p>如果类元数据的空间占用达到参数“MaxMetaspaceSize”设置的值，将会触发对死亡对象和类加载器的垃圾回收。<br>一些各种各样的数据已经转移到Java堆空间。</p><p>Java 元空间为无限（默认值） ，永久代有大小限制。<br>元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。</p>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>求职分享</title>
      <link href="/2018/03/03/%E5%BE%AE%E8%BD%AF%E6%B1%82%E8%81%8C%E5%88%86%E4%BA%AB/"/>
      <url>/2018/03/03/%E5%BE%AE%E8%BD%AF%E6%B1%82%E8%81%8C%E5%88%86%E4%BA%AB/</url>
      <content type="html"><![CDATA[<p>IEG组求职分享<br><a id="more"></a></p><h3 id="留在微软的人儿"><a href="#留在微软的人儿" class="headerlink" title="留在微软的人儿"></a>留在微软的人儿</h3><h4 id="product组内部tansfer到IEG的小哥哥"><a href="#product组内部tansfer到IEG的小哥哥" class="headerlink" title="product组内部tansfer到IEG的小哥哥"></a>product组内部tansfer到IEG的小哥哥</h4><ul><li>基础知识准备：leetcode,geeksforgeeks</li><li>简历：要根据不同公司不同岗位有针对性地准备</li></ul><h5 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h5><ul><li>微软，谷歌，对用过哪些框架不在意，注重基础，算法，数学等，主要看自学能力</li><li>如果遇到实在不会的题，学会从别的角度出发，说出自己的想法，即使给出的解决方案不好，也比不说强</li><li>微软产品组 秋招，summer intern 在线面试，两轮技术面（基础算法+机器学习算法），manager面等，表现优秀转正几率大</li></ul><h4 id="product组的小姐姐"><a href="#product组的小姐姐" class="headerlink" title="product组的小姐姐"></a>product组的小姐姐</h4><ul><li>自我介绍，突出重点，别光说简历上的</li><li>一般算法面试的难度在leetcode的中等难度</li><li>重复强调stc的summer intern！</li><li>可以准备暑期实习，感受下流程，或者找一些不会去的公司参加春招</li><li>阿里的Java岗问得比较底层，小米，微软更侧重于算法</li></ul><h4 id="IEG做语音的小姐姐"><a href="#IEG做语音的小姐姐" class="headerlink" title="IEG做语音的小姐姐"></a>IEG做语音的小姐姐</h4><ul><li>计算机基础：牛客网</li><li>算法：剑指offer，leetcode</li><li>求职公众号推荐：柠檬offer，职场薪火，互联派    </li></ul><h3 id="没留下的人儿"><a href="#没留下的人儿" class="headerlink" title="没留下的人儿"></a>没留下的人儿</h3><h4 id="算法-何"><a href="#算法-何" class="headerlink" title="算法-何"></a>算法-何</h4><ul><li>选定自己想要干啥，一般算法和开发分开，只攻一个</li><li>外企：MSRA,Google,Amazon,IBM,Airbnb,FreeWheel 算法！！！</li><li>MSRA：四轮面试 2技术+1研究+1leader (研究会问一些论文或项目，外加一些数据逻辑思维题)</li><li>Google：OnlineTest + 技术面试 （在线建议不要组团做，容易被禁，一般做对一题就行） 技术面试题，如：先二维动归入门，再四维，再最大流算法</li></ul><h5 id="常考点："><a href="#常考点：" class="headerlink" title="常考点："></a>常考点：</h5><ul><li>国内互联网常考：手写排序算法</li><li>算法岗常考：简单统计模型公式推导、模型的优缺点；特征工程的经验；深度学习模型的原理；数理统计题；开放题：1.如何统计北京有多少个红绿灯 2.如何找出意思相同的不同表达（“周杰伦的老婆”，“昆凌”）</li><li>有意思的题：1. 给一把有刻度的尺子，把任意凸多边形二等分；2. 烧一根绳子需要半小时，如何用两根确定45分钟；3. A,B两人随机在3点～4点之间到C地，每个人最多停留15分钟，问两个人可以在C地碰到的概率</li></ul>]]></content>
      
      <categories>
          
          <category> 前辈经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LinkedList题</title>
      <link href="/2017/09/30/LinkedList%E9%A2%98/"/>
      <url>/2017/09/30/LinkedList%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h2><h3 id="83-Remove-Duplicates-from-Sorted-List"><a href="#83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="83.Remove Duplicates from Sorted List"></a>83.Remove Duplicates from Sorted List</h3><p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p><a id="more"></a><blockquote><p>For example,<br>Given 1-&gt;1-&gt;2, return 1-&gt;2.<br>Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.val == cur.next.val)&#123;</span><br><span class="line">           cur.next = cur.next.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="82-Remove-Duplicates-from-Sorted-List-II"><a href="#82-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="82.Remove Duplicates from Sorted List II"></a>82.Remove Duplicates from Sorted List II</h3><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p><blockquote><p>For example,<br>Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.<br>Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);  </span><br><span class="line">    dummy.next = head; </span><br><span class="line">    ListNode cur = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span>(cur.next.val == cur.next.next.val)&#123;</span><br><span class="line">           <span class="keyword">int</span> temp = cur.next.val;</span><br><span class="line">           <span class="keyword">while</span>(cur.next ！= <span class="keyword">null</span> &amp;&amp; cur.next.val == temp)&#123;</span><br><span class="line">              cur.next = cur.next.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          cur = cur.next;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="147-Insertion-Sort-List"><a href="#147-Insertion-Sort-List" class="headerlink" title="147.Insertion Sort List"></a>147.Insertion Sort List</h3><p>Sort a linked list using insertion sort.</p><blockquote><p>插入排序：两层循环，将数插入到已经排序的数组中合适的位置去</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Function to sort array using insertion sort*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> key = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j = i-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Move elements of arr[0..i-1], that are</span></span><br><span class="line"><span class="comment">               greater than key, to one position ahead</span></span><br><span class="line"><span class="comment">               of their current position */</span></span><br><span class="line">            <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; arr[j] &gt; key)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                j = j-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j+<span class="number">1</span>] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>链表的插入排序，同样两层循环，考虑到头指针也需要被排序，需要新增一个fakeHead。</p><p>链表的插入需要维护三个指针，pre，cur，next，<br>pre始终指向有序链表的fakeHead，cur指向当前需要排序的节点，next指向下一个待排序的节点。</p><p>当有序链表为空或者pre.next所指向的元素的值比当前节点的值大时，需要将cur插入到pre.next之前的位置，<br>否则，则将pre指针后移，最后返回fakeHead.next即可。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);  </span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode next= cur.next;</span><br><span class="line">        <span class="keyword">while</span>(pre.next != <span class="keyword">null</span> &amp;&amp; pre.next.val &lt; cur.val)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = pre.next;</span><br><span class="line">        pre.next = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> dummy.next; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="92-Reverse-Linked-List-II"><a href="#92-Reverse-Linked-List-II" class="headerlink" title="92.Reverse Linked List II"></a>92.Reverse Linked List II</h3><p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p><blockquote><p>For example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,<br>return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL.</p></blockquote><p>Note:<br>Given m, n satisfy the following condition:<br>1 ≤ m ≤ n ≤ length of list.</p><blockquote><p>指定位置的链表部分逆转，考虑到头指针也可能被逆转，新建fakeHead。</p><p>维护三个指针，pre永远指向m-1个位置的节点，start指向m位置的节点，then指向start.next</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">        </span><br><span class="line">   ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">   dummy.next = head;</span><br><span class="line">   ListNode pre = dummy;</span><br><span class="line">        </span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m-<span class="number">1</span>;i++)&#123;</span><br><span class="line">       pre = pre.next;</span><br><span class="line">   &#125;</span><br><span class="line">        </span><br><span class="line">   ListNode start = pre.next;</span><br><span class="line">   ListNode then = start.next;</span><br><span class="line">        </span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n-m ;i++)&#123;</span><br><span class="line">       start.next = then.next;</span><br><span class="line">       then.next = pre.next;</span><br><span class="line">       pre.next = then;</span><br><span class="line">       then = start.next;</span><br><span class="line">   &#125;</span><br><span class="line">        </span><br><span class="line">   <span class="keyword">return</span> dummy.next;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="148-Sort-List"><a href="#148-Sort-List" class="headerlink" title="148.Sort List"></a>148.Sort List</h3><p>Sort a linked list in O(n log n) time using constant space complexity.</p><blockquote><p>归并排序</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode pre = head;</span><br><span class="line">    ListNode slower = head;</span><br><span class="line">    ListNode faster = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(faster !=<span class="keyword">null</span> &amp;&amp; faster.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        pre = slower;</span><br><span class="line">        slower = slower.next;</span><br><span class="line">        faster = faster.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pre.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ListNode h1 = sortList(head);</span><br><span class="line">    ListNode h2 = sortList(slower);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge(h1,h2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode head1,ListNode head2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> head2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(head2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> head1;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode mergeHead  = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(head1.val &lt; head2.val)&#123;</span><br><span class="line">       mergeHead = head1;</span><br><span class="line">       mergeHead.next = merge(head1.next,head2);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       mergeHead = head2;</span><br><span class="line">       mergeHead.next = merge(head1,head2.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mergeHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="23.Merge k Sorted Lists"></a>23.Merge k Sorted Lists</h3><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p><blockquote><p>递归转化为已知问题，合并两个有序链表</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> partition(lists,<span class="number">0</span>,lists.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode[] lists,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">       <span class="keyword">return</span> lists[start];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(start &lt; end)&#123;</span><br><span class="line">       <span class="keyword">int</span> middle = (start+end)/<span class="number">2</span>;</span><br><span class="line">       ListNode l1 = partition(lists,start,middle);</span><br><span class="line">       ListNode l2 = partition(lists,middle+<span class="number">1</span>,end);</span><br><span class="line">       <span class="keyword">return</span> merge(l1,l2);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode head1,ListNode head2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> head2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(head2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> head1;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode mergeHead = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(head1.val &lt; head2.val)&#123;</span><br><span class="line">       mergeHead = head1;</span><br><span class="line">       mergeHead.next = merge(head1.next,head2);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       mergeHead = head2;</span><br><span class="line">       mergeHead.next = merge(head1,head2.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mergeHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="143-Reorder-List"><a href="#143-Reorder-List" class="headerlink" title="143.Reorder List"></a>143.Reorder List</h3><p>Given a singly linked list L: L0?L1?…?Ln-1?Ln,<br>reorder it to: L0?Ln?L1?Ln-1?L2?Ln-2?…</p><blockquote><p>For example,<br>Given {1,2,3,4}, reorder it to {1,4,2,3}.</p></blockquote><p>You must do this in-place without altering the nodes’ values.</p><blockquote><p>找到中心节点，将后半段链表反转变成一个新链表，再合并即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    ListNode slower = head;</span><br><span class="line">    ListNode faster = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(faster != <span class="keyword">null</span> &amp;&amp; faster.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        pre = slower;</span><br><span class="line">        slower = slower.next;</span><br><span class="line">        faster = faster.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    ListNode head2 = reverse(slower);</span><br><span class="line"></span><br><span class="line">    merge(head,head2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode temp = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(ListNode h1,ListNode h2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(h1 != <span class="keyword">null</span> &amp;&amp; h1.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">       ListNode n1 = h1.next;</span><br><span class="line">       ListNode n2 = h2.next;</span><br><span class="line">     </span><br><span class="line">       h1.next = h2;</span><br><span class="line">       <span class="keyword">if</span>(n1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       h2.next = n1;</span><br><span class="line">       h1 = n1;</span><br><span class="line">       h2 = n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2.Add Two Numbers"></a>2.Add Two Numbers</h3><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><blockquote><p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">   ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">   ListNode cur = dummy;</span><br><span class="line">   ListNode p1 = l1;</span><br><span class="line">   ListNode p2 = l2;</span><br><span class="line">   <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(p1 != <span class="keyword">null</span> || p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">int</span> x = p1 == <span class="keyword">null</span> ? <span class="number">0</span>:p1.val;</span><br><span class="line">       <span class="keyword">int</span> y = p2 == <span class="keyword">null</span> ? <span class="number">0</span>:p2.val;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line">       carry = sum/<span class="number">10</span>;</span><br><span class="line">       cur.next = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line">       cur = cur.next;</span><br><span class="line">       <span class="keyword">if</span>(p1 != <span class="keyword">null</span>) p1 = p1.next;</span><br><span class="line">       <span class="keyword">if</span>(p2 != <span class="keyword">null</span>) p2 = p2.next;</span><br><span class="line">   &#125;</span><br><span class="line">        </span><br><span class="line">   <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      cur.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">   &#125;     </span><br><span class="line">   <span class="keyword">return</span> dummy.next;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="86-Partition-List"><a href="#86-Partition-List" class="headerlink" title="86.Partition List"></a>86.Partition List</h3><p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.<br>给定一个单链表和数值x，划分链表使得所有小于x的节点排在大于等于x的节点之前。</p><p>You should preserve the original relative order of the nodes in each of the two partitions.<br>你应该保留两部分内链表节点原有的相对顺序。</p><blockquote><p>For example,<br>Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,<br>return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br><span class="line">   ListNode leftDummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">   ListNode rightDummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">   ListNode left = leftDummy;</span><br><span class="line">   ListNode right = rightDummy;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span>(head.val &lt; x)&#123;</span><br><span class="line">          left.next = head;</span><br><span class="line">          left = head;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          right.next = head;</span><br><span class="line">          right = head;</span><br><span class="line">       &#125;</span><br><span class="line">       head = head.next;</span><br><span class="line">   &#125;</span><br><span class="line">   right.next = <span class="keyword">null</span>;     </span><br><span class="line">   left.next = rightDummy.next;    </span><br><span class="line">   <span class="keyword">return</span> leftDummy.next;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="138-Copy-List-with-Random-Pointer"><a href="#138-Copy-List-with-Random-Pointer" class="headerlink" title="138.Copy List with Random Pointer"></a>138.Copy List with Random Pointer</h3><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.<br>Return a deep copy of the list.</p><blockquote><p>浅拷贝是指源对象与拷贝对象共用一份实体，仅仅是引用的变量不同（名称不同）。对其中任何一个对象的改动都会影响另外一个对象。举个例子，一个人一开始叫张三，后来改名叫李四了，可是还是同一个人，不管是张三缺胳膊少腿还是李四缺胳膊少腿，都是这个人倒霉。</p></blockquote><p>深拷贝是指源对象与拷贝对象<strong>互相独立</strong>，其中任何一个对象的改动都不会对另外一个对象造成影响。举个例子，一个人名叫张三，后来用他克隆（假设法律允许）了另外一个人，叫李四，不管是张三缺胳膊少腿还是李四缺胳膊少腿都不会影响另外一个人。</p><p><strong>因此，本题转换为拷贝原链表为一个新链表，next，random都得符合</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * class RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     RandomListNode next, random;</span></span><br><span class="line"><span class="comment"> *     RandomListNode(int x) &#123; this.label = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;RandomListNode,RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;RandomListNode,RandomListNode&gt;(); </span><br><span class="line">    RandomListNode node = head;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        map.put(node,<span class="keyword">new</span> RandomListNode(node.label));</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;  </span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">       map.get(node).next = map.get(node.next);</span><br><span class="line">       map.get(node).random = map.get(node.random);</span><br><span class="line">       node = node.next;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="445-Add-Two-Numbers-II"><a href="#445-Add-Two-Numbers-II" class="headerlink" title="445.Add Two Numbers II"></a>445.Add Two Numbers II</h3><p>假定用一个链表表示两个数，其中每个节点仅包含一个数字。假设这两个数的数字顺序排列，请设计一种方法将两个数相加，并将其结果表现为链表的形式。</p><blockquote><p>样例<br>给出 6-&gt;1-&gt;7 + 2-&gt;9-&gt;5。即，617 + 295。<br>返回 9-&gt;1-&gt;2。即，912 。</p></blockquote><p><strong>将链表放入栈操作，利用栈的特性，进行加法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;      </span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @param l1: The first list.</span></span><br><span class="line"><span class="comment">     * @param l2: The second list.</span></span><br><span class="line"><span class="comment">     * @return: the sum list of l1 and l2.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addLists2</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        Stack&lt;Integer&gt; s1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; s2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            s1.push(l1.val);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            s2.push(l2.val);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        ListNode cur = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!s1.isEmpty()||!s2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!s1.isEmpty())&#123;</span><br><span class="line">                sum += s1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!s2.isEmpty())&#123;</span><br><span class="line">                sum += s2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            cur.val = sum%<span class="number">10</span>;</span><br><span class="line">            ListNode head = <span class="keyword">new</span> ListNode(sum/<span class="number">10</span>);</span><br><span class="line">            head.next = cur;</span><br><span class="line">            cur = head;</span><br><span class="line">            sum = sum/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val == <span class="number">0</span>?cur.next:cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LintCode"><a href="#LintCode" class="headerlink" title="LintCode"></a>LintCode</h2><h3 id="交换链表当中两个节点"><a href="#交换链表当中两个节点" class="headerlink" title="交换链表当中两个节点"></a>交换链表当中两个节点</h3><p>给你一个链表以及两个权值v1和v2，交换链表中权值为v1和v2的这两个节点。保证链表中节点权值各不相同，如果没有找到对应节点，那么什么也不用做。</p><blockquote><p>样例<br>给出链表 1-&gt;2-&gt;3-&gt;4-&gt;null ，以及 v1 = 2 ， v2 = 4<br>返回结果 1-&gt;4-&gt;3-&gt;2-&gt;null。</p></blockquote><p><strong>头节点，相邻情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @param head: a ListNode</span></span><br><span class="line"><span class="comment">     * @param v1: An integer</span></span><br><span class="line"><span class="comment">     * @param v2: An integer</span></span><br><span class="line"><span class="comment">     * @return: a new head of singly-linked list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapNodes</span><span class="params">(ListNode head, <span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        ListNode p1 = <span class="keyword">null</span>;</span><br><span class="line">        ListNode p2 = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == v1)&#123;</span><br><span class="line">                p1 = cur;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.next.val == v2)&#123;</span><br><span class="line">                p2 = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p1 == <span class="keyword">null</span> || p2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dummy.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode n1 = p1.next;</span><br><span class="line">        ListNode n2 = p2.next;</span><br><span class="line">        ListNode x1 = n1.next;</span><br><span class="line">        ListNode x2 = n2.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p1.next == p2)&#123;</span><br><span class="line">            p1.next = n2;</span><br><span class="line">            n2.next = n1;</span><br><span class="line">            n1.next = x2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p2.next == p1)&#123;</span><br><span class="line">            p2.next = n1;</span><br><span class="line">            n1.next = n2;</span><br><span class="line">            n2.next = x1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p1.next = n2;</span><br><span class="line">            n2.next = x1;</span><br><span class="line">            p2.next = n1;</span><br><span class="line">            n1.next = x2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h3><p>设计一种方式检查一个链表是否为回文链表。</p><blockquote><p>样例<br>1-&gt;2-&gt;1 就是一个回文链表。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @param head: A ListNode.</span></span><br><span class="line"><span class="comment">     * @return: A boolean.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slower = head;</span><br><span class="line">        ListNode faster = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(faster.next != <span class="keyword">null</span> &amp;&amp; faster.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slower = slower.next;</span><br><span class="line">            faster = faster.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode mid = slower;</span><br><span class="line">        ListNode first = mid.next;</span><br><span class="line">        ListNode cur = first.next;</span><br><span class="line">        first.next = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">           ListNode tem =  cur.next;</span><br><span class="line">           cur.next = mid.next;</span><br><span class="line">           mid.next = cur;</span><br><span class="line">           cur = tem;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        slower = mid.next;</span><br><span class="line">        faster = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(slower != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(faster.val != slower.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            faster = faster.next;</span><br><span class="line">            slower = slower.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h3><p>给定一个单链表L: L0→L1→…→Ln-1→Ln,</p><p>重新排列后为：L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>必须在不改变节点值的情况下进行原地操作。</p><blockquote><p>样例<br>给出链表 1-&gt;2-&gt;3-&gt;4-&gt;null，重新排列后为1-&gt;4-&gt;2-&gt;3-&gt;null。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for ListNode.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @param head: The head of linked list.</span></span><br><span class="line"><span class="comment">     * @return: nothing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode p1 = head;</span><br><span class="line">        ListNode p2 = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(p2.next != <span class="keyword">null</span> &amp;&amp; p2.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode preM = p1;</span><br><span class="line">        ListNode pre = p1.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pre.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode cur = pre.next;</span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">            cur.next = preM.next;</span><br><span class="line">            preM.next = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        p1 = head;</span><br><span class="line">        p2 = preM.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(p1 != preM)&#123;</span><br><span class="line">            preM.next = p2.next;</span><br><span class="line">            p2.next = p1.next;</span><br><span class="line">            p1.next = p2;</span><br><span class="line">            p1 = p2.next;</span><br><span class="line">            p2 = preM.next;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 算法 </category>
          
          <category> 刷题打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
