<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>M&amp;Y</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="blog.jiangdongyu.space/"/>
  <updated>2018-05-28T10:51:52.810Z</updated>
  <id>blog.jiangdongyu.space/</id>
  
  <author>
    <name>Agnes</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>商汤</title>
    <link href="blog.jiangdongyu.space/2018/05/18/%E5%95%86%E6%B1%A4Java%E5%AE%9E%E4%B9%A0%E7%94%9F/"/>
    <id>blog.jiangdongyu.space/2018/05/18/商汤Java实习生/</id>
    <published>2018-05-18T10:26:00.000Z</published>
    <updated>2018-05-28T10:51:52.810Z</updated>
    
    <content type="html"><![CDATA[<p>商汤Java实习生面试<br><a id="more"></a></p><ul><li>Collections框架体系<br><img src="http://p9fh1pach.bkt.clouddn.com/20170309094509415.jpeg" alt="avatar"></li><li>HashSet的特性<ul><li>基于HashMap实现</li><li>无序不重复</li></ul></li><li>HashMap结构<ul><li>哈希表，数组+链表</li></ul></li><li>HashMap和ConcurrentHashMap区别</li><li>锁的了解</li><li>线程池有哪些？</li><li>怎么实现线程？</li><li>并发包…</li><li>SpringBoot中@ReseController注解对应哪两个<ul><li>@ResponseBody和@Controller的组合注解。</li></ul></li><li>Redis支持哪些类型？<ul><li>Strings</li><li>Lists</li><li>Sets 求交集、并集</li><li>Sorted Set</li><li>hashes</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;商汤Java实习生面试&lt;br&gt;
    
    </summary>
    
      <category term="实习面试经历" scheme="blog.jiangdongyu.space/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    
      <category term="2018" scheme="blog.jiangdongyu.space/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>简历相关准备</title>
    <link href="blog.jiangdongyu.space/2018/04/30/%E7%AE%80%E5%8E%86%E5%87%86%E5%A4%87/"/>
    <id>blog.jiangdongyu.space/2018/04/30/简历准备/</id>
    <published>2018-04-30T08:30:00.000Z</published>
    <updated>2018-05-28T08:06:09.972Z</updated>
    
    <content type="html"><![CDATA[<p>简单的自我介绍<br><a id="more"></a></p><p><img src="http://p9fh1pach.bkt.clouddn.com/%E7%AE%80%E5%8E%86.png" alt="avatar"></p><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>我叫姜栋煜，现在在北京大学软件与微电子学院读研究生二年级，预计2019年6月份毕业，本科就读于北京交通大学。3月中旬结束在微软亚洲研究院的实习，主要做了课程数据的收集、维护，pipeline的日常导入以及一些数据的简单分析。此外，还做过一些导师和企业合作的项目，主要就是智慧教室，都是java web的一些项目。</p><h2 id="实习经历"><a href="#实习经历" class="headerlink" title="实习经历"></a>实习经历</h2><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>在小英组，主要产品是微软小英和Microsoft Learning Chinese，都是一些教授中小学生以及外国人学英语/中文的app，这些app会有一些对应的课程信息（json文本），课程信息的录入工具是由我去维护开发的，包括对文本、音频、视频、图片等的录入，存储主要是用了Azure Blob，音频、视频、图片存在对应的mooncake中国镜像上。</p><p>小英的用户量在200-300万左右，每天的数据量大，而且之前的pipeline导入方式费时，不易监控，就改为使用data factory,还会完成一些简单的分析工作，比如活跃用户、日留存、周留存、月留存等。。。</p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><ul><li>用于录入数据的网站，可以自动merge数据，减少人工干预</li><li>pipeline导入做到了高效，速度比原来快了3倍多，出错会发邮件</li><li>分析信息用于确定用户使用情况</li></ul><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><ul><li>内部网站数据混乱，会出现直接修改merge之后文件，而导致不一致问题的出现</li><li>data factory全靠自己看英文文档，教程少</li></ul><h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><h3 id="智慧教室"><a href="#智慧教室" class="headerlink" title="智慧教室"></a>智慧教室</h3><blockquote><p>简单而言，就是一个课堂直播的一个平台，主要分为三个端，web/phone端，树莓派，PC。web/phone端和树莓派通过websocket通信，主要传输一些控制指令，树莓派和PC通过串口直接相连。</p></blockquote><p>web端主要完成教室设备的CRUD，权限控制，还有就是给树莓派发送指令，具体的操作，比如操作教室推流真正还是由PC去完成。这个项目已经在河北邢台的一些中小学开始试用了。</p><p><strong>难点（问题）</strong></p><ul><li>SpringBoot和websocket无法注入bean的问题，其实不是不能注入，是已经注入了，但是客户端每建立一个链接就会创建一个对象，这个对象没有任何的bean注入操作,<strong>最后使用静态变量</strong></li><li>websocket不稳定，异常处理机制，树莓派定时心跳，异常重连</li></ul><h3 id="即时通讯"><a href="#即时通讯" class="headerlink" title="即时通讯"></a>即时通讯</h3><p>类似于朋友圈，可发布状态，点赞、评论等</p><p>使用MongoDB是因为便于存储点赞/评论list，非结构化<br>Redis用于缓存朋友圈动态信息，前N条经常被浏览</p><h2 id="比赛经历"><a href="#比赛经历" class="headerlink" title="比赛经历"></a>比赛经历</h2><p>Google Girl Hackthon 主题是机器学习，给了一些新闻的数据，让自己从中分析出自己想要的信息,主要是做了数据的处理，对train得到的数据，处理成前端可展示的json格式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单的自我介绍&lt;br&gt;
    
    </summary>
    
      <category term="Java面试" scheme="blog.jiangdongyu.space/categories/Java%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="简历" scheme="blog.jiangdongyu.space/tags/%E7%AE%80%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>BackTracking</title>
    <link href="blog.jiangdongyu.space/2018/04/29/BackTracking/"/>
    <id>blog.jiangdongyu.space/2018/04/29/BackTracking/</id>
    <published>2018-04-29T15:32:00.000Z</published>
    <updated>2018-05-28T10:04:34.391Z</updated>
    
    <content type="html"><![CDATA[<p><strong>思想</strong></p><ol><li>试错</li><li>分步解决问题</li><li>不符合则取消上一步或上几步</li></ol><p><strong>BackTracking可大致分为全排列问题、数独等问题</strong><br><a id="more"></a></p><h2 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h2><h3 id="类型1"><a href="#类型1" class="headerlink" title="类型1"></a>类型1</h3><ul><li>subsets</li><li>subset II </li><li>permutations </li><li>permutations II </li><li>Combinations </li><li>Combinations Sum </li><li>Combinations Sum II </li><li>N Queen</li><li>N Queen II</li><li>letter combination of a phone number</li></ul><h3 id="类型2（基于全排列的问题）"><a href="#类型2（基于全排列的问题）" class="headerlink" title="类型2（基于全排列的问题）"></a>类型2（基于全排列的问题）</h3><ul><li>Next Permutation</li><li>Previous Permutation􏲇􏰇（与next permuataion􏰍􏴤􏴥类似）􏴓􏲌 </li><li>Permutation Sequence</li><li>Permutation Index</li><li>Permutation Index II (hard)</li></ul><p><strong>permuataions有序，subsets无序</strong></p><h4 id="Subsets"><a href="#Subsets" class="headerlink" title="Subsets"></a>Subsets</h4><ul><li>Sort原数组</li><li>dfs</li><li>判断是否取这个数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line">subset(results, result, nums, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subset</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; results, List&lt;Integer&gt; result, <span class="keyword">int</span>[] num, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">results.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(result));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; num.length; i++) &#123;</span><br><span class="line">result.add(num[i]);</span><br><span class="line">subset(results, result, num, i + <span class="number">1</span>);</span><br><span class="line">result.remove(result.size()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Subsets-II"><a href="#Subsets-II" class="headerlink" title="Subsets II"></a>Subsets II</h3><blockquote><p>contain duplicates, nums</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i != index &amp;&amp; num[i] == num[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><h3 id="Permutations"><a href="#Permutations" class="headerlink" title="Permutations"></a>Permutations</h3><p>Given a collection of distinct integers, return all possible permutations.</p><p><strong>Example:</strong></p><pre><code>Input: [1,2,3]Output:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]]</code></pre><ul><li>用一个数组记录是否被使用过</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> results;</span><br><span class="line"> List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        permute(results, result, nums, used);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">permute</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; results, List&lt;Integer&gt; result, <span class="keyword">int</span>[] num, <span class="keyword">boolean</span>[] used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num.length == result.size()) results.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(result));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[i])&#123;</span><br><span class="line">                result.add(num[i]);</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line">    permute(results, result, num, used);</span><br><span class="line">    result.remove(result.size()-<span class="number">1</span>); </span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Permutation-II"><a href="#Permutation-II" class="headerlink" title="Permutation II"></a>Permutation II</h3><blockquote><p>might contain duplicates</p></blockquote><ul><li>对数组排序</li><li>判断num[i] == num[i-1] &amp;&amp; !used[i-1]</li><li>如果前一个已经用了，当前值相同再被用，不会重复</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i !=<span class="number">0</span> &amp;&amp; num[i] == num[i-<span class="number">1</span>] &amp;&amp; !used[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><h3 id="Combinations"><a href="#Combinations" class="headerlink" title="Combinations"></a>Combinations</h3><p>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p><p><strong>Example:</strong></p><pre><code>Input: n = 4, k = 2Output:[  [2,4],  [3,4],  [2,3],  [1,2],  [1,3],  [1,4],]</code></pre><p>类似subset</p><h3 id="Combination-Sum"><a href="#Combination-Sum" class="headerlink" title="Combination Sum"></a>Combination Sum</h3><p>Given a set of candidate numbers (candidates) (<strong>without duplicates</strong>) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</p><p>The same repeated number may be chosen from candidates <strong>unlimited number of times.</strong></p><p><strong>Note:</strong></p><ul><li>All numbers (including target) will be <strong>positive integers</strong>.</li><li>The solution set must <strong>not contain duplicate combinations.</strong></li></ul><p><strong>Example 1:</strong></p><pre><code>Input: candidates = [2,3,6,7], target = 7,A solution set is:[  [7],  [2,2,3]]</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: candidates = [2,3,5], target = 8,A solution set is:[  [2,2,2,2],  [2,3,3],  [3,5]]</code></pre><ul><li>求sum</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(candidates == <span class="keyword">null</span> || candidates.length == <span class="number">0</span>) <span class="keyword">return</span> results;</span><br><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        combinationSum(results, result, candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">combinationSum</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; results, List&lt;Integer&gt; result, <span class="keyword">int</span>[] candidate, <span class="keyword">int</span> target, <span class="keyword">int</span> index, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target) results.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(result));</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; candidate.length; i++) &#123;</span><br><span class="line">            result.add(candidate[i]);</span><br><span class="line">            sum += candidate[i];</span><br><span class="line">    combinationSum(results, result, candidate, target, i, sum);</span><br><span class="line">result.remove(result.size()-<span class="number">1</span>);  </span><br><span class="line">sum -= candidate[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Combination-Sum-II"><a href="#Combination-Sum-II" class="headerlink" title="Combination Sum II"></a>Combination Sum II</h3><p>Each number in candidates may only be used <strong>once</strong> in the combination.</p><ul><li>增加sort</li><li>增加去重</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i != index &amp;&amp; candidate[i] == candidate[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><h3 id="Combination-Sum-III"><a href="#Combination-Sum-III" class="headerlink" title="Combination Sum III"></a>Combination Sum III</h3><p>Find all possible combinations of <strong>k numbers</strong> that <strong>add up to a number n</strong>, given that only numbers from <strong>1 to 9</strong> can be used and each combination should be a unique set of numbers.</p><p><strong>Note:</strong></p><ul><li>All numbers will be positive integers.</li><li>The solution set must not contain duplicate combinations.</li></ul><p><strong>Example 1:</strong></p><pre><code>Input: k = 3, n = 7Output: [[1,2,4]]</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: k = 3, n = 9Output: [[1,2,6], [1,3,5], [2,3,4]]</code></pre><ul><li>同时考虑sum和list长度</li></ul><h3 id="Letter-Combinations-of-a-Phone-Number"><a href="#Letter-Combinations-of-a-Phone-Number" class="headerlink" title="Letter Combinations of a Phone Number"></a>Letter Combinations of a Phone Number</h3><ul><li>存储对应关系</li><li>像subset那样处理即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String[] map = &#123;<span class="string">""</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span>[] resultStr= <span class="keyword">new</span> <span class="keyword">char</span>[digits.length()];</span><br><span class="line">        letterCombinations(result, digits, map, resultStr, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">letterCombinations</span><span class="params">(List&lt;String&gt; result, String digits, String[] map, <span class="keyword">char</span>[] resultStr, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(digits.length() == count)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> String(resultStr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String str = map[digits.charAt(count)-<span class="string">'0'</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; str.length();i++)&#123;</span><br><span class="line">            resultStr[count] = str.charAt(i);</span><br><span class="line">            letterCombinations(result, digits, map, resultStr, count+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Generate-Parentheses"><a href="#Generate-Parentheses" class="headerlink" title="Generate Parentheses"></a>Generate Parentheses</h3><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><p>For example, given n = 3, a solution set is:</p><pre><code>[  &quot;((()))&quot;,  &quot;(()())&quot;,  &quot;(())()&quot;,  &quot;()(())&quot;,  &quot;()()()&quot;]</code></pre><ul><li>如果左括号数量小于n，则可以再有左括号</li><li>如果左括号数量大于右括号数量，则可以再有右括号</li></ul><h3 id="Next-Permutation"><a href="#Next-Permutation" class="headerlink" title="Next Permutation"></a>Next Permutation</h3><p>输入一个整数数组，该整数数组按照下标顺序代表一个数字，例如[1,2,3]代表整数123，要求改变数组中元素的顺序，找到<strong>比当前数字大的生成数中的最小值</strong>。如果当前数字代表的整数值已经是所有排列组合中的<strong>最大值</strong>，则返回当前数字组成的<strong>最小值</strong>。</p><ul><li>从右往左扫，找到第一个满足：nums[i-1] &lt; nums[i]条件的，</li><li>再找到从右到左第一个比nums[i-1]大的数，把它们swap，</li><li>再把所有i-1之后的数字swap即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i-<span class="number">1</span>] &lt; nums[i]) <span class="keyword">break</span>;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i = 0, decreasing</span></span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; nums[i-<span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i-<span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// swap all elements after i-1</span></span><br><span class="line">        <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; end) swap(nums, i++, end--);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Permutation-Sequence"><a href="#Permutation-Sequence" class="headerlink" title="Permutation Sequence"></a>Permutation Sequence</h3><p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p><p>By listing and labeling all of the permutations in order, we get the following sequence for n = 3:</p><ol><li>“123”</li><li>“132”</li><li>“213”</li><li>“231”</li><li>“312”</li><li>“321”</li></ol><p>Given n and k, return the kth permutation sequence.</p><p><strong>Note:</strong></p><ul><li>Given n will be between 1 and 9 inclusive.</li><li>Given k will be between 1 and n! inclusive.</li></ul><p><strong>Example 1:</strong></p><pre><code>Input: n = 3, k = 3Output: &quot;213&quot;</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: n = 4, k = 9Output: &quot;2314&quot;</code></pre><p><strong>找规律！！！</strong></p><p><strong>复杂度</strong></p><p>时间 O(N) 空间 O(1)</p><p><strong>思路</strong></p><p>由于我们只要得到第K个全排列，而不是所有全排列，我们不一定要将所有可能都搜索一遍。根据全排列顺序的性质，我们可以总结出一个规律：假设全排列有n个数组成，则<strong>第k个全排列的第一位是k/(n-1)!</strong>。为了更形象一点，举例如下：</p><pre><code>123132213231312321</code></pre><p>在这种情况下，第一个数字每2!=2个情况就改变一次，<strong>假设求第6个排列，我们先将其减1，方便整除运算，然后5/2=2。对于第一位，我们有三种可选数字1、2、3，所以5/2=2意味着我们选择第3个数字，也就是3（如果商是s，则选第s+1个数字）。然后将5%2得到1，这个1就是下一轮的k。</strong></p><p><strong>注意</strong></p><p>这里有一个技巧，就是用一个列表将1到n存起来，每选用一个数就是移出那个数，就能保证不选重复数字的同时，其顺序也是一样的。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1</span>;</span><br><span class="line">        List&lt;Integer&gt; candidates = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// 先得到n!和候选数字列表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            mod = mod * i;</span><br><span class="line">            candidates.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将k先减1方便整除</span></span><br><span class="line">        k--;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            mod = mod / (n - i);</span><br><span class="line">            <span class="comment">// 得到当前应选数字的序数</span></span><br><span class="line">            <span class="keyword">int</span> first = k / mod;</span><br><span class="line">            <span class="comment">// 得到用于计算下一位的k</span></span><br><span class="line">            k = k % mod;</span><br><span class="line">            sb.append(candidates.get(first));</span><br><span class="line">            <span class="comment">// 在列表中移出该数字</span></span><br><span class="line">            candidates.remove(first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Permutation-Index"><a href="#Permutation-Index" class="headerlink" title="Permutation Index"></a>Permutation Index</h3><blockquote><p>给定一个排列数，每位都不重复，返回它在全排列中的index,index从1开始</p></blockquote><ul><li>对于某一个给定的位数A[i],需要判断在它后面有几个小于它的数，记下这个数字和A[i]所在的位置。</li><li>比如对于一个四位数，5316，第一位后面有2小于它的数，如果这两个数排在第一位，那么（1和3）各有3！的排列组合数小于（5316）.</li><li>同理，对于第二位，其后有1个小于它的数，如果它放在第二位，那么有2！种排列。</li><li>因此判断一个给定数位于排列组合的第几位，则可以按照以下公式进行</li></ul><p><strong>count1*(A.length-1)!+count2*(A.length-2)!+……+countn*(0)!</strong></p><p>为方便计算，从右往左遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">permutationIndex</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> fact = <span class="number">1</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> rank = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; A.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[j] &lt; A[i]) rank++;</span><br><span class="line">            &#125;</span><br><span class="line">            index += rank * fact;</span><br><span class="line">            fact *= (A.length-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Permutation-Index-II"><a href="#Permutation-Index-II" class="headerlink" title="Permutation Index II"></a>Permutation Index II</h3><blockquote><p>存在重复</p></blockquote><ul><li>与上一题的不同之处时会有<strong>重复的数。</strong></li><li>在发现是重复数的那一位用(rank * fact)/dup+index即可。</li><li>当然，每个重复数的dup都要阶乘，例如有3个2，4个8，dup就是3! * 4! = 144。</li><li>index是所有previous排列的次数和，返回下一次index+1。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">permutationIndexII</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> index = <span class="number">0</span>, fact = <span class="number">1</span>, dup = <span class="number">1</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(A[i])) map.put(A[i], <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(A[i], map.get(A[i])+<span class="number">1</span>);</span><br><span class="line">                dup *= map.get(A[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> rank = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; A.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[j] &lt; A[i]) rank++;</span><br><span class="line">            &#125;</span><br><span class="line">            index += rank * fact / dup;</span><br><span class="line">            fact *= (A.length - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sudoku"><a href="#Sudoku" class="headerlink" title="Sudoku"></a>Sudoku</h2><h3 id="Valid-Sudoku"><a href="#Valid-Sudoku" class="headerlink" title="Valid Sudoku"></a>Valid Sudoku</h3><p>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:</p><ol><li>Each row must contain the digits 1-9 without repetition.</li><li>Each column must contain the digits 1-9 without repetition.</li><li>Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.</li></ol><p><img src="http://p9fh1pach.bkt.clouddn.com/250px-Sudoku-by-L2G-20050714.svg.png" alt="avatar"></p><p>A partially filled sudoku which is valid.</p><p>The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’.</p><p><strong>Example 1:</strong></p><pre><code>Input:[  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]Output: true</code></pre><p><strong>Example 2:</strong></p><pre><code>Input:[  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]Output: falseExplanation: Same as Example 1, except with the 5 in the top left corner being     modified to 8. Since there are two 8&apos;s in the top left 3x3 sub-box, it is invalid.</code></pre><p><strong>Note:</strong></p><ul><li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li><li>Only the filled cells need to be validated according to the mentioned rules.</li><li>The given board contain only digits 1-9 and the character ‘.’.</li><li>The given board size is always 9x9.</li></ul><p><strong>解题思路</strong></p><ul><li>9行9列</li><li>每行1-9，每列1-9，9个3*3的小数独，也是1-9，均不重复</li></ul><p><strong>方法</strong></p><ul><li>遍历每个格子判断是否合法</li><li>如果格子的值相同且不是”.”，但是行，列不同则不合法</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span> &amp;&amp; !isvalid(board, i, j)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isvalid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[row][col] == board[i][col] &amp;&amp; row != i) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[row][col] == board[row][i] &amp;&amp; col != i) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row/<span class="number">3</span>*<span class="number">3</span>; i &lt; row/<span class="number">3</span>*<span class="number">3</span>+<span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = col/<span class="number">3</span>*<span class="number">3</span>; j &lt; col/<span class="number">3</span>*<span class="number">3</span>+<span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == board[row][col] &amp;&amp; !(i == row &amp;&amp; j == col)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sudoku-Solver"><a href="#Sudoku-Solver" class="headerlink" title="Sudoku Solver"></a>Sudoku Solver</h3><p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p><p>A sudoku solution must satisfy all of the following rules:</p><ol><li>Each of the digits 1-9 must occur exactly once in each row.</li><li>Each of the digits 1-9 must occur exactly once in each column.</li><li>Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.</li></ol><p>Empty cells are indicated by the character ‘.’.</p><ul><li>dfs</li><li>对”.”的位置尝试填入1-9，待下次判断</li><li>可使用上一题的<strong>isvalid(char[][] board, int row, int col)</strong>方法剪枝</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length != <span class="number">9</span> || board[<span class="number">0</span>].length != <span class="number">9</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        solve(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">9</span>)</span><br><span class="line">            <span class="keyword">return</span> solve(board, i + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">9</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">9</span>; k++) &#123;</span><br><span class="line">                board[i][j] = (<span class="keyword">char</span>) (k + <span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">if</span> (isValid(board, i, j)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (solve(board, i, j + <span class="number">1</span>))</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> solve(board, i, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k != i &amp;&amp; board[k][j] == board[i][j])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k != j &amp;&amp; board[i][k] == board[i][j])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = i / <span class="number">3</span> * <span class="number">3</span>; row &lt; i / <span class="number">3</span> * <span class="number">3</span> + <span class="number">3</span>; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = j / <span class="number">3</span> * <span class="number">3</span>; col &lt; j / <span class="number">3</span> * <span class="number">3</span> + <span class="number">3</span>; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row != i &amp;&amp; col != j &amp;&amp; board[i][j] == board[row][col])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Flip-Game"><a href="#Flip-Game" class="headerlink" title="Flip Game"></a>Flip Game</h3><h4 id="I"><a href="#I" class="headerlink" title="I"></a>I</h4><p>You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip twoconsecutive “++” into “–”. The game ends when a person can no longer make a move and therefore the other person will be the winner.</p><p>Write a function to compute all possible states of the string after one valid move.</p><p>For example, given s = “++++”, after one move, it may become one of the following states:</p><pre><code>[  &quot;--++&quot;,  &quot;+--+&quot;,  &quot;++--&quot;]</code></pre><p>If there is no valid move, return an empty list [].</p><ul><li>直接遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">generatePossibleNextMoves</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || s.length() == <span class="number">1</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &lt; s.length() &amp;&amp; s.substring(i,i+<span class="number">2</span>).equals(<span class="string">"++"</span>))&#123;</span><br><span class="line">            res.add(s.substring(<span class="number">0</span>,i)+<span class="string">"--"</span>+s.substring(i+<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="II"><a href="#II" class="headerlink" title="II"></a>II</h4><blockquote><p>需要确保开始的人能赢</p></blockquote><ul><li>和I的做法类似</li><li>增加下一步替换后不能赢的判断即可</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canWin</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || s.length() == <span class="number">1</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &lt; s.length() &amp;&amp; s.substring(i,i+<span class="number">2</span>).equals(<span class="string">"++"</span>) &amp;&amp; !canWin(s.substring(<span class="number">0</span>,i)+<span class="string">"--"</span>+s.substring(i+<span class="number">2</span>)))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Nim-Game"><a href="#Nim-Game" class="headerlink" title="Nim Game"></a>Nim Game</h3><p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p><p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p><p><strong>Example:</strong></p><pre><code>Input: 4Output: false Explanation: If there are 4 stones in the heap, then you will never win the game;             No matter 1, 2, or 3 stones you remove, the last stone will always be              removed by your friend.</code></pre><ul><li>找规律的题</li><li>如果是4的倍数就输</li></ul><h3 id="N-Queen"><a href="#N-Queen" class="headerlink" title="N Queen"></a>N Queen</h3><ul><li>Queen不能在同一行，同一列，对角线上</li><li>也就是说可以将N Queen放置在数组中，一个数组下标表示行值，数组下标对应的数组值可表示其所属列 </li></ul><h4 id="I-1"><a href="#I-1" class="headerlink" title="I"></a>I</h4><blockquote><p>给出所有解</p></blockquote><p>类似用一个全局static的list存储结果</p><h4 id="II-1"><a href="#II-1" class="headerlink" title="II"></a>II</h4><blockquote><p>给出解的数量</p></blockquote><p>用一个全局static变量计数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveNQueens</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n, List&lt;Integer&gt; matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(matrix)) count++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n;k++)&#123;</span><br><span class="line">            matrix.add(k);</span><br><span class="line">            <span class="keyword">if</span>(isValid(matrix))&#123;</span><br><span class="line">                solveNQueens(i+<span class="number">1</span>, n, matrix);</span><br><span class="line">            &#125;</span><br><span class="line">            matrix.remove(matrix.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断queen是否合法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(List&lt;Integer&gt; matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> col = matrix.get(row);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; row;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> row1 = i;</span><br><span class="line">            <span class="keyword">int</span> col1 =  matrix.get(i);</span><br><span class="line">            <span class="keyword">if</span>(col1 == col) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(row - row1 == col - col1) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(row - row1 == col1 - col) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Palindrome-Partitioning"><a href="#Palindrome-Partitioning" class="headerlink" title="Palindrome Partitioning"></a>Palindrome Partitioning</h3><h4 id="I-2"><a href="#I-2" class="headerlink" title="I"></a>I</h4><p>Given a string s, partition s such that every substring of the partition is a palindrome.</p><p>Return all possible palindrome partitioning of s.</p><p><strong>Example:</strong></p><pre><code>Input: &quot;aab&quot;Output:[  [&quot;aa&quot;,&quot;b&quot;],  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]]</code></pre><ul><li>dfs+判断回文回溯</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(result, list, s);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;String&gt;&gt; result, List&lt;String&gt; list, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isPalindrome(s.substring(<span class="number">0</span>,i)))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(s.substring(<span class="number">0</span>, i));</span><br><span class="line">            helper(result, list, s.substring(i));</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(l) != s.charAt(r))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="II-2"><a href="#II-2" class="headerlink" title="II"></a>II</h4><p>Given a string s, partition s such that every substring of the partition is a palindrome.</p><p>Return the minimum cuts needed for a palindrome partitioning of s.</p><p><strong>Example:</strong></p><pre><code>Input: &quot;aab&quot;Output: 1Explanation: The palindrome partitioning [&quot;aa&quot;,&quot;b&quot;] could be produced using 1 cut.</code></pre><ul><li>DFS + backtracking<ul><li>按照I求出所有解，再找出长度最少的</li></ul></li><li>DP<ul><li>用cuts[i]表示当前位置最少需要切几次使每个部分都是回文。</li><li>如果s(j,i)这部分是回文，就有cuts[i] = cuts[j-1] + 1。</li><li>matrix[j] [i]表示j到i这部分是回文。</li><li>如果s.charAt(i) == s.charAt(j) &amp;&amp; isPalindrome[j+1] [i-1]是回文，则不需重复该部分的搜索。isPalindrome[j] [i]也是回文。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] cuts = <span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">// cuts[i] = cut[j-1] + 1 if [j,i] is panlindrome</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] isPalindrome = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n]; <span class="comment">// isPalindrome[j][i] means  [j,i] is panlidrome</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;       <span class="comment">// maximun cuts for position i, each panlidrome only length of one</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j) &amp;&amp; ( j + <span class="number">1</span> &gt; i - <span class="number">1</span> || isPalindrome[j+<span class="number">1</span>][i-<span class="number">1</span>]) )&#123;</span><br><span class="line">                    isPalindrome[j][i] = <span class="keyword">true</span>;</span><br><span class="line">                    min = j == <span class="number">0</span> ? <span class="number">0</span> : Math.min(min, cuts[j-<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cuts[i] = min;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cuts[n-<span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Palindrome-Permutation"><a href="#Palindrome-Permutation" class="headerlink" title="Palindrome Permutation"></a>Palindrome Permutation</h3><h4 id="I-3"><a href="#I-3" class="headerlink" title="I"></a>I</h4><p>Given a string, determine if a permutation of the string could form a palindrome.</p><p>For example, “code” -&gt; False, “aab” -&gt; True, “carerac” -&gt; True.</p><ul><li>根据回文性质，只有出现在中心的数是奇数</li></ul><p><strong>思路</strong></p><ul><li>HashMap计数，判断奇数是否最多出现了一次</li><li>HashSet消除，出现第偶数次消除，第奇数次加入Set，最后判断set的size是否不大于1</li></ul><h4 id="II-3"><a href="#II-3" class="headerlink" title="II"></a>II</h4><p>Given a string s, return all the palindromic permutations (without duplicates) of it. Return an empty list if no palindromic permutation could be form.</p><pre><code>For example:Given s = &quot;aabb&quot;, return [&quot;abba&quot;, &quot;baab&quot;].Given s = &quot;abc&quot;, return [].</code></pre><p><strong>Hint:</strong></p><ul><li>If a palindromic permutation exists, we just need to generate the first half of the string.</li><li>To generate all distinct permutations of a (half of) string, use a similar approach from: Permutations II or Next Permutation.</li></ul><p><strong>思路</strong></p><ul><li>回文分为三部分，在s中出现了偶数次的一半+奇数次的+一半的reverse</li><li>对在s中出现了偶数次的一半找全排列类似Permutations II</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">generatePalindromes</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        String mid = <span class="string">""</span>;</span><br><span class="line">        List&lt;Character&gt; list = <span class="keyword">new</span> ArrayList&lt;Character&gt;();</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character,Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            map.put(c,map.containsKey(c)?map.get(c)+<span class="number">1</span>:<span class="number">1</span>);</span><br><span class="line">            odd=odd+(map.get(c)%<span class="number">2</span>==<span class="number">1</span>?<span class="number">1</span>:-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(odd&gt;<span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Character,Integer&gt; entry:map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">char</span> key = entry.getKey();</span><br><span class="line">            <span class="keyword">int</span> val = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span>(val%<span class="number">2</span>==<span class="number">1</span>) mid=mid+key;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;val/<span class="number">2</span>;i++)&#123;</span><br><span class="line">                list.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        backtracking(res,mid,list,<span class="keyword">new</span> StringBuilder(),<span class="keyword">new</span> <span class="keyword">boolean</span>[list.size()]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(List&lt;String&gt; res,String mid,List&lt;Character&gt; list,StringBuilder sb,<span class="keyword">boolean</span>[] used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sb.length()==list.size())&#123;</span><br><span class="line">            res.add(sb.toString()+mid+sb.reverse().toString());</span><br><span class="line">            sb.reverse();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(used[i]||i&gt;<span class="number">0</span>&amp;&amp;list.get(i)==list.get(i-<span class="number">1</span>)&amp;&amp;!used[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line">                sb.append(list.get(i));</span><br><span class="line">                backtracking(res,mid,list,sb,used);</span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">                sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Additive-Number"><a href="#Additive-Number" class="headerlink" title="Additive Number"></a>Additive Number</h3><p>Additive number is a string whose digits can form additive sequence.</p><p>A valid additive sequence should contain <strong>at least</strong> three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.</p><p>Given a string containing only digits ‘0’-‘9’, write a function to determine if it’s an additive number.</p><p><strong>Note</strong>: Numbers in the additive sequence <strong>cannot</strong> have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;112358&quot;Output: true Explanation: The digits can form an additive sequence: 1, 1, 2, 3, 5, 8.              1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: &quot;199100199&quot;Output: true Explanation: The additive sequence is: 1, 99, 100, 199.              1 + 99 = 100, 99 + 100 = 199</code></pre><p><strong>Follow up:</strong><br>How would you handle overflow for very large input integers?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAdditiveNumber</span><span class="params">(String num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num.charAt(<span class="number">0</span>) == <span class="string">'0'</span> &amp;&amp; i &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            BigInteger x1 = <span class="keyword">new</span> BigInteger(num.substring(<span class="number">0</span>, i));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; Math.max(j, i) &lt;= n - i - j; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num.charAt(i) == <span class="string">'0'</span> &amp;&amp; j &gt; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                BigInteger x2 = <span class="keyword">new</span> BigInteger(num.substring(i, i + j));</span><br><span class="line">                <span class="keyword">if</span> (isValid(x1, x2, j + i, num)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(BigInteger x1, BigInteger x2, <span class="keyword">int</span> start, String num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == num.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        x2 = x2.add(x1);</span><br><span class="line">        x1 = x2.subtract(x1);</span><br><span class="line">        String sum = x2.toString();</span><br><span class="line">        <span class="keyword">return</span> num.startsWith(sum, start) &amp;&amp; isValid(x1, x2, start + sum.length(), num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;思想&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;试错&lt;/li&gt;
&lt;li&gt;分步解决问题&lt;/li&gt;
&lt;li&gt;不符合则取消上一步或上几步&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;BackTracking可大致分为全排列问题、数独等问题&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="BackTracking" scheme="blog.jiangdongyu.space/tags/BackTracking/"/>
    
      <category term="Array" scheme="blog.jiangdongyu.space/tags/Array/"/>
    
      <category term="DFS" scheme="blog.jiangdongyu.space/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Dynamic Programming</title>
    <link href="blog.jiangdongyu.space/2018/04/29/DynamicProgramming/"/>
    <id>blog.jiangdongyu.space/2018/04/29/DynamicProgramming/</id>
    <published>2018-04-29T15:31:00.000Z</published>
    <updated>2018-05-28T11:09:07.818Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>利用存储历史信息来减少重复计算，以空间换时间</p></blockquote><h2 id="DP四要素"><a href="#DP四要素" class="headerlink" title="DP四要素"></a>DP四要素</h2><ul><li><strong>function</strong> 方程，如何从子问题到父问题</li><li><strong>state</strong>    状态，存储子问题的结果</li><li><strong>init</strong>        初始化，最小问题</li><li><strong>result</strong>    结果，最大问题</li></ul><h2 id="标记函数"><a href="#标记函数" class="headerlink" title="标记函数"></a>标记函数</h2><p>要先想好标记数组到底标记的是什么。<br>最标准的：问的什么就标记什么。</p><a id="more"></a><h2 id="常见的四种DP类型"><a href="#常见的四种DP类型" class="headerlink" title="常见的四种DP类型"></a>常见的四种DP类型</h2><ul><li>Sequence DP</li><li>2 Sequence DP</li><li>Matrix DP</li><li>Others<ul><li>背包类</li><li>区间类</li></ul></li></ul><h2 id="什么时候可能使用DP"><a href="#什么时候可能使用DP" class="headerlink" title="什么时候可能使用DP"></a>什么时候可能使用DP</h2><ul><li>求max/min</li><li>yes/no 求能否达到</li><li>count(*) 求数量</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>多空一位0.</p><h2 id="一维DP"><a href="#一维DP" class="headerlink" title="一维DP"></a>一维DP</h2><h3 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h3><ul><li>Climbing Stairs</li><li>Decode Ways</li><li>Unique Binary Search Trees </li><li>Maximum Subarray</li><li>Maximum Product Subarray </li><li>Best Time to Buy and Sell Stock</li></ul><h3 id="什么时候可能不是DP"><a href="#什么时候可能不是DP" class="headerlink" title="什么时候可能不是DP"></a>什么时候可能不是DP</h3><ul><li>要求给出具体解决方案</li><li>输入的是集合而不是序列</li></ul><h3 id="类型一"><a href="#类型一" class="headerlink" title="类型一"></a>类型一</h3><ul><li>climbing chairs</li><li>jump game</li><li>decode ways</li><li>unique binary search trees</li></ul><h3 id="类型二-global-local"><a href="#类型二-global-local" class="headerlink" title="类型二 global,local"></a>类型二 global,local</h3><ul><li>maximum subarray</li><li>maximum product subarray </li><li>best time to but and sell stock</li></ul><p><strong>思路</strong></p><ul><li>当看到题目是选择包含还是不包含当前value[i]时</li><li>需要维护两个DP，global(全局最优，不一定包含当前值)，local(包含当前值的局部最优)</li><li>找出递推关系</li></ul><h3 id="Triangle"><a href="#Triangle" class="headerlink" title="Triangle"></a>Triangle</h3><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p><p>For example, given the following triangle</p><pre><code>[     [2],    [3,4],   [6,5,7],  [4,1,8,3]]</code></pre><p>The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</p><p>Note:</p><p>Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</p><p><strong>dp[i][j] 以 tri[i][j]为终点的path sum的最小值</strong></p><ul><li>state </li><li>function: <strong>dp[i][j] = min(dp[i-1][j],dp[i-1][j-1])+tri[i][j]</strong></li><li>init state </li><li>result</li></ul><p><strong>漂亮的代码：</strong>省去二维，不断更新，自底向上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] A = <span class="keyword">new</span> <span class="keyword">int</span>[triangle.size()+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=triangle.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;triangle.get(i).size();j++)&#123;</span><br><span class="line">            A[j] = Math.min(A[j],A[j+<span class="number">1</span>])+triangle.get(i).get(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Pascal’s-Triangle-I-amp-II"><a href="#Pascal’s-Triangle-I-amp-II" class="headerlink" title="Pascal’s Triangle I &amp; II"></a>Pascal’s Triangle I &amp; II</h3><blockquote><p>I：给定行数，输出三角</p></blockquote><p>每一层元素是它上面两个元素的和</p><blockquote><p>II:给定某一行行号，输出这一行</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        cur.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= rowIndex;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i-<span class="number">1</span>;j &gt; <span class="number">0</span>;j--)&#123;</span><br><span class="line">                cur.set(j,cur.get(j-<span class="number">1</span>)+cur.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">            cur.add(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="House-Robber"><a href="#House-Robber" class="headerlink" title="House Robber"></a>House Robber</h3><blockquote><p>相邻房子不能抢，global，local问题</p></blockquote><p><strong>dp[i]打劫到第i间时的最大值</strong></p><ul><li>state </li><li>function: <strong>dp[i] = max(dp[i-1],dp[i-2]+nums[i-1])</strong></li><li>init state: <strong>dp[0] = nums[0],dp[1] = max(nums[0],nums[1])</strong></li><li>result: <strong>dp[length-1]</strong></li></ul><h3 id="House-Robber-II"><a href="#House-Robber-II" class="headerlink" title="House Robber II"></a>House Robber II</h3><blockquote><p>房子是一个环，也就是说第一间和最后一间不能同时抢</p></blockquote><ul><li>拆分成两个数组</li><li>一个包含第一间，一个包含最后一间</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> Math.max(rob(nums,<span class="number">0</span>,n-<span class="number">2</span>),rob(nums,<span class="number">1</span>,n-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rob = <span class="number">0</span>,notRob = <span class="number">0</span>,preNot = <span class="number">0</span>,preYes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = lo;i &lt;= hi;i++)&#123;</span><br><span class="line">            rob = preNot + nums[i];</span><br><span class="line">            notRob = Math.max(preYes,preNot);</span><br><span class="line">            preNot = notRob;</span><br><span class="line">            preYes = rob;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(rob,notRob);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Best-Time-to-Buy-and-Sell-Stock"><a href="#Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Best Time to Buy and Sell Stock"></a>Best Time to Buy and Sell Stock</h3><h4 id="I"><a href="#I" class="headerlink" title="I"></a>I</h4><blockquote><p>交易一次</p></blockquote><p>略</p><h4 id="II"><a href="#II" class="headerlink" title="II"></a>II</h4><blockquote><p>不限交易次数，买入前必须不持有</p></blockquote><ul><li>贪心</li><li>方法一<ul><li>计算局部的峰值，谷值</li><li>求和</li></ul></li><li>方法二<ul><li>循环，只要prices[i] &gt; prices[i-1],求差值</li><li>求和</li></ul></li></ul><h4 id="III"><a href="#III" class="headerlink" title="III"></a>III</h4><blockquote><p>最多交易两次，买入前必须不持有</p></blockquote><p><strong>思路1</strong>：双向动态规划</p><ul><li>构造两个数组，left和right，left[i]表示从0到i天的最大获益，right[i]表示从i到最后一天的最大获益。</li><li>求left时，记录前i天的最低价minPrice与最大获益max，求left[i]：考虑要在第i天卖出，那么买进的时间必然是在0到i之间（闭区间），这个时候只需要比较prices[i]-minPrice和max就可以求出截止到第i天的最大获益，然后根据需要更新minPrice。</li><li>求right时，记录从第i天往后的最高价maxPrice与最大获益max，求right[i]：考虑要再第i天买进，那么卖出时间必然是在i到最后一天之间（闭区间），这个时候只需要比较maxPrice-prices[i]和max就可以求出从第i天开始的最大获益，然后根据需要更新maxPrice。</li><li>对于left和right的构造算法复杂度都是O(n)。</li><li>构造完left和right之后，只要求left[i]+right[i]的最大值就行了。</li></ul><p><strong>思路2</strong>：滚动扫描法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hold1 = Integer.MIN_VALUE, hold2 = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> release1 = <span class="number">0</span>, release2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="comment">//在该价格点卖出第二笔股票后手里剩的钱，等于上一轮买入第二笔股票后手里剩的钱加上卖出当前股票价格的钱，或者上一轮卖出第二笔股票后手里剩的钱两者中较大的</span></span><br><span class="line">            release2 = Math.max(release2, hold2 + prices[i]);</span><br><span class="line">            <span class="comment">//在该价格点买入第二笔股票后手里剩的钱，等于上一轮卖出第一笔股票后手里剩的钱减去买入当前股票价格的钱，或者上一轮买入第二笔股票后手里剩的钱两者中较大的</span></span><br><span class="line">            hold2 = Math.max(hold2, release1 - prices[i]);</span><br><span class="line">            <span class="comment">//在该价格点卖出第一笔股票后手里剩的钱，等于上一轮买入第一笔股票后手里剩的钱加上卖出当前股票价格的钱，或者上一轮卖出第一笔股票后手里剩的钱两者中较大的</span></span><br><span class="line">            release1 = Math.max(release1, hold1 + prices[i]);</span><br><span class="line">            <span class="comment">//在该价格点买入第一笔股票后手里剩的钱，等于初始资金减去买入当前股票价格的钱或者初始资金（不买）中较大的</span></span><br><span class="line">            hold1 = Math.max(hold1, -prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> release2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="IV"><a href="#IV" class="headerlink" title="IV"></a>IV</h4><blockquote><p>最多k次交易，III的延伸</p></blockquote><p><strong>动态规划</strong></p><ul><li>复杂度<ul><li>时间 O(Nk) 空间 O(Nk)</li></ul></li><li>思路<ul><li>第i天已经执行j笔交易的<strong>最大收益</strong>作为全局变量global，将第i天<strong>正好</strong>完成第j笔交易的最大收益作为局部变量local。</li><li>int diff = prices[i] - prices[i-1];</li><li>global[i][j] = max(global[i-1][j], local[i][j])</li><li>local[i][j] = max(global[i-1][j-1]+max(0, diff), local[i-1][j]+diff)</li><li>对于local，第i天正好完成第j笔交易的最大收益，可以基于第i-1天正好完成第j-1笔交易的最大收益加上当天交易的差值，还有第i-1天正好完成第j笔交易的最大收益加上当天交易的差值。</li><li>要注意的是，第i-1天正好完成第j-1笔交易这种情况，当前交易的差值取0和实际昨天今天差价中较大的，因为我们还有一次自由交易的余地，所以如果亏的话完全可以当天买卖避免损失。</li><li>但第i-1天正好完成第j笔交易这种情况来推导第i天正好完成第j笔交易时，相当于第i天已经要连着第i-1天交易，使得第i-1天正好完成的第j笔交易和第i天正好完成的第j笔交易是同一个交易。</li></ul></li><li>注意<ul><li>对于k &gt; prices.length / 2的情况，我们可以用II的解法来节省空间。因为按照题意必须先买后卖，那么对于n天交易，能够产生有效收益的交易次数是小于等于n/2的，只有不同天买卖才能产生差价。对于大于n/2的那部分交易，必定是当天买卖没有任何收益的，无论交易多少次都是一样的。所以如果k &gt; prices.length / 2，就相当于无限次交易。</li><li>数组的第二维初始化长度是k+1，因为我们要预留完成0笔交易的收益，是0。</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//用II的解法优化k &gt; prices.length / 2的情况</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt; prices.length / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(prices[i]&gt;prices[i-<span class="number">1</span>]) sum += prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化全局变量和局部变量</span></span><br><span class="line">        <span class="keyword">int</span>[][] global = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[][] local = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> diff = prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; k + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="comment">//更新局部变量</span></span><br><span class="line">                local[i][j] = Math.max(global[i-<span class="number">1</span>][j-<span class="number">1</span>]+Math.max(<span class="number">0</span>, diff), local[i-<span class="number">1</span>][j]+diff);</span><br><span class="line">                <span class="comment">//更新全局变量</span></span><br><span class="line">                global[i][j] = Math.max(global[i-<span class="number">1</span>][j], local[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> global[prices.length - <span class="number">1</span>][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>滚动扫描法</strong></p><p>时间 O(N) 空间 O(k)</p><blockquote><p>需要2k个变量来记录k次交易。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用II的解法优化k &gt; prices.length / 2的情况</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt; prices.length / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(prices[i]&gt;prices[i-<span class="number">1</span>]) sum += prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化买卖股票后剩余金钱的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] release = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] hold = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            hold[i]=Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; k+<span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="comment">//卖出第j笔交易，所剩余的钱</span></span><br><span class="line">                release[j] = Math.max(release[j], hold[j]+prices[i]);</span><br><span class="line">                <span class="comment">//买入第j笔交易，所剩余的钱</span></span><br><span class="line">                hold[j] = Math.max(hold[j], release[j-<span class="number">1</span>]-prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> release[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Best-time-to-buy-and-sell-stock-with-cool-down"><a href="#Best-time-to-buy-and-sell-stock-with-cool-down" class="headerlink" title="Best time to buy and sell stock with cool down"></a>Best time to buy and sell stock with cool down</h3><blockquote><p>不限交易次数，卖出后需要一天冷却</p></blockquote><p><strong>动态规划</strong></p><p>股票有<strong>三种</strong>状态: buy, sell, cooldown, sell与cooldown我们可以合并成一种状态，因为手里最终都<strong>没股票</strong>，最终需要的结果是sell，即手里股票卖了获得最大利润。所以我们可以用两个DP数组分别记录当前持股跟未持股的状态。然后根据题目中的限制条件，理清两个DP数组的表达式。</p><p>对于当天最终未持股的状态，最终最大利润有两种可能，一是今天没动作跟昨天未持股状态一样，二是昨天持股了，今天卖了。所以我们只要取这两者之间最大值即可，表达式如下：</p><pre><code>sellDp[i] = Math.max(sellDp[i - 1], buyDp[i - 1] + prices[i]);</code></pre><p>对于当天最终持股的状态，最终最大利润有两种可能，一是今天没动作跟昨天持股状态一样，二是前天还没持股，今天买了股票，这里是因为cooldown的原因，所以今天买股要追溯到前天的状态。我们只要取这两者之间最大值即可，表达式如下：</p><pre><code>buyDp[i] = Math.max(buyDp[i - 1], sellDp[i - 2] - prices[i]);</code></pre><p>最终我们要求的结果是</p><pre><code>sellDp[n - 1] 表示最后一天结束时手里没股票时的累积最大利润</code></pre><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 表示当天最终未持股的情况下，当天结束后的累计最大利润</span></span><br><span class="line">        <span class="keyword">int</span>[] sellDp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        <span class="comment">// 表示当天最终持股的情况下，当天结束后的累计最大利润</span></span><br><span class="line">        <span class="keyword">int</span>[] buyDp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 考虑初始情况</span></span><br><span class="line">        buyDp[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        sellDp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            sellDp[i] = Math.max(sellDp[i - <span class="number">1</span>], buyDp[i - <span class="number">1</span>] + prices[i]);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                buyDp[i] = Math.max(buyDp[i - <span class="number">1</span>], sellDp[i - <span class="number">2</span>] - prices[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buyDp[i] = Math.max(buyDp[i - <span class="number">1</span>], -prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sellDp[prices.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>滚动扫描法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* sell[i] = Math.max(sell[i-1], buy[i-1] + prices[i])</span></span><br><span class="line"><span class="comment">         * buy[i] = Math.max(sell[i-2]-prices[i], buy[i-1])</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> preBuy = Integer.MIN_VALUE, curBuy = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> preSell = <span class="number">0</span>, curSell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            preBuy = curBuy;</span><br><span class="line">            curBuy = Math.max(preSell - price, preBuy);</span><br><span class="line">            preSell = curSell;</span><br><span class="line">            curSell = Math.max(preSell, preBuy + price);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> curSell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Word-Break"><a href="#Word-Break" class="headerlink" title="Word Break"></a>Word Break</h3><h4 id="I-1"><a href="#I-1" class="headerlink" title="I"></a>I</h4><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p><p><strong>Note:</strong></p><ul><li>The same word in the dictionary may be reused multiple times in the segmentation.</li><li>You may assume the dictionary does not contain duplicate words.</li></ul><p><strong>Example 1:</strong></p><pre><code>Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]Output: trueExplanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]Output: trueExplanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.Note that you are allowed to reuse a dictionary word.</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]Output: false</code></pre><ul><li>state <ul><li>dp[i] 表示前i个字符能否做Word Break</li></ul></li><li>function <ul><li>canBreak[i] = True if canBreak[j] and dict.contains(s.substring(j, i)) j from 0 to i</li></ul></li><li>result<ul><li>canBreak[len(s)]</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; dicts)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String str: dicts)&#123;</span><br><span class="line">           dict.add(str); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &amp;&amp; dict.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="II-1"><a href="#II-1" class="headerlink" title="II"></a>II</h4><p>Given a string s and a dictionary of words dict, add spaces in s to construct a sentence where each word is a valid dictionary word.</p><p>Return all such possible sentences.</p><pre><code>For example, givens = &quot;catsanddog&quot;,dict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;].A solution is [&quot;cats and dog&quot;, &quot;cat sand dog&quot;].</code></pre><ul><li>如果要返回所有组合的话，我们可以考虑两种方法，</li><li>一种是DP，时间复杂度较低，但是比较耗内存，意味着对于每个Index, 我们可能都要存其对应所有解。</li><li>另一种是DFS，空间复杂度较低，但是时间时间复杂度较高，我们可以采用memorization优化时间复杂度。</li></ul><p><strong>复杂度</strong></p><ul><li>DP: time: O(n^2*k), space: O(nk), 假设k表示平均每个长度对应解的个数</li><li>DFS: time: O(2^n), space: O(n)</li></ul><p><strong>动态规划</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否能够分解</span></span><br><span class="line">        <span class="keyword">if</span> (!helper(s, wordDict)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录字符串s.substring(0, i)对应的解</span></span><br><span class="line">        HashMap&lt;Integer, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, List&lt;String&gt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        map.get(<span class="number">0</span>).add(<span class="string">""</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(j) &amp;&amp; wordDict.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!map.containsKey(i))</span><br><span class="line">                        map.put(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                    <span class="keyword">for</span> (String str : map.get(j)) &#123;</span><br><span class="line">                        map.get(i).add(str + (str.equals(<span class="string">""</span>) ? <span class="string">""</span> : <span class="string">" "</span>) + s.substring(j, i));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> map.get(s.length());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> dp[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; wordDict.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DFS</strong></p><ul><li>从头开始扫描，dict包含则对接下来的递归dfs</li><li>直至返回的str的长度等于s</li><li>接着返回上一层递归</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来记录s.substring(i)这个字符串能否分解</span></span><br><span class="line">        <span class="keyword">boolean</span>[] possible = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(possible, <span class="keyword">true</span>);</span><br><span class="line">        dfs(res, <span class="string">""</span>, s, wordDict,  <span class="number">0</span>, possible);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;String&gt; res, String cur, String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> start, <span class="keyword">boolean</span>[] possible)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">            res.add(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            String str = s.substring(start, i);</span><br><span class="line">            <span class="keyword">if</span> (wordDict.contains(str) &amp;&amp; possible[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> prevSize = res.size();</span><br><span class="line">                dfs(res, cur + (cur.equals(<span class="string">""</span>) ? <span class="string">""</span> : <span class="string">" "</span>) + str, s, wordDict, i, possible);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// DFS后面部分结果没有变化，说明后面是没有解的</span></span><br><span class="line">                <span class="keyword">if</span> (res.size() == prevSize)</span><br><span class="line">                    possible[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维DP"><a href="#二维DP" class="headerlink" title="二维DP"></a>二维DP</h2><h3 id="Dungeon-Game"><a href="#Dungeon-Game" class="headerlink" title="Dungeon Game"></a>Dungeon Game</h3><p>The demons had captured the princess (<strong>P</strong>) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (<strong>K</strong>) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.</p><p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.</p><p>Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0’s) or contain magic orbs that increase the knight’s health (positive integers).</p><p>In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.</p><p><strong>Write a function to determine the knight’s minimum initial health so that he is able to rescue the princess.</strong></p><p><strong>Notes:</strong></p><ul><li>The knight’s health has no upper bound.</li><li>Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.</li></ul><p><strong>动态规划</strong></p><ul><li>state : dp[i][j] 表示从i,j出发到终点所需要的最少的体力值</li><li>init: dp[m-1][n-1] = max(-dungeon[m-1][n-1],0)+1</li><li>function : dp[i][j] = min(dp[i+1][j],dp[i][j+1]) - dungeon[i][j]</li></ul><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = dungeon.length;</span><br><span class="line">        <span class="keyword">int</span> n = dungeon[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        dp[m-<span class="number">1</span>][n-<span class="number">1</span>] = Math.max(- dungeon[m-<span class="number">1</span>][n-<span class="number">1</span>], <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt;= m-<span class="number">1</span> &amp;&amp; j + <span class="number">1</span> &lt;= n-<span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i+<span class="number">1</span>][j], dp[i][j+<span class="number">1</span>]) - dungeon[i][j];;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( i + <span class="number">1</span> &lt;= m-<span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j] - dungeon[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= n-<span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j+<span class="number">1</span>] - dungeon[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &lt;= <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Maximal-Rectangle"><a href="#Maximal-Rectangle" class="headerlink" title="Maximal Rectangle"></a>Maximal Rectangle</h3><p>是Largest Rectangle in Histogram的晋升题</p><h4 id="Largest-Rectangle-in-Histogram"><a href="#Largest-Rectangle-in-Histogram" class="headerlink" title="Largest Rectangle in Histogram"></a>Largest Rectangle in Histogram</h4><p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. </p><p><img src="http://p9fh1pach.bkt.clouddn.com/1418713310-55de4fd532244.png" alt="avatar"></p><p>Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].</p><p><img src="http://p9fh1pach.bkt.clouddn.com/765770818-55de4fe7f3337.png" alt="avatar"></p><p>The largest rectangle is shown in the shaded area, which has area = 10 unit.</p><ul><li>栈，存放数组的index</li><li>判断遍历的数是否大于等于栈顶元素，大于则直接push</li><li>小于则pop，直到数组的下一个元素大于栈顶元素</li></ul><p>把数组中的每个元素都作为矩形高度，计算了一遍该高度下矩形的最大面积。只是每次都<strong>贪心</strong>最大，避免了重复计算，所以效率高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>, largestArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; height.length || (index == height.length &amp;&amp; !stack.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index != height.length &amp;&amp; (stack.isEmpty() || height[stack.peek()] &lt; height[index])) &#123;</span><br><span class="line">                stack.push(index++);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = height[stack.pop()];</span><br><span class="line">                <span class="keyword">int</span> w = stack.isEmpty() ? index : index - stack.peek() - <span class="number">1</span>;</span><br><span class="line">                largestArea = Math.max(largestArea, h * w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> largestArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Maximal-Rectangle-1"><a href="#Maximal-Rectangle-1" class="headerlink" title="Maximal Rectangle"></a>Maximal Rectangle</h4><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing all 1’s and return its area.</p><ul><li>要求最大的矩形，实际上可以将矩阵的每一行，转化为上一题的直方图，</li><li>而直方图的每个竖条的数字，就是该行对应坐标正上方，向上方向有多少个连续的1。</li><li>要转化为直方图，方法是每一行的数值都累加上一行计算出来的数值，而第一行的数值就是本身。如果原始矩阵中遇到0，则累加中断，重新置0。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 0 1 1 0 -&gt; 0 0 1 1 0</span><br><span class="line">0 0 1 1 0 -&gt; 0 0 2 2 0</span><br><span class="line">1 1 0 0 0 -&gt; 1 1 0 0 0</span><br><span class="line">1 1 1 0 0 -&gt; 2 2 1 0 0</span><br></pre></td></tr></table></figure><ul><li>dp[i][j]化为直方图的值</li><li>接着对dp[i][j]进行Largest Rectangle in Histogram计算即可</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i == 0 --&gt; dp[i][j] = matrix[i][j] - &apos;0&apos;</span><br><span class="line">i != 0 --&gt; </span><br><span class="line">matrix[i][j] == 1 --&gt; dp[i][j] = dp[i-1][j] + matrix[i][j] - &apos;0&apos;</span><br><span class="line">matrix[i][j] != 1 --&gt; dp[i][j] = 0</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="comment">// 如果是第一行就是自身，如果遇到0则停止累加</span></span><br><span class="line">                dp[i][j] =  i == <span class="number">0</span> ? matrix[i][j] - <span class="string">'0'</span> : matrix[i][j] == <span class="string">'1'</span> ? dp[i-<span class="number">1</span>][j] + matrix[i][j] - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++)&#123;</span><br><span class="line">            <span class="comment">//找每行的最大矩形</span></span><br><span class="line">            <span class="keyword">int</span> tmp = findRowMax(i, dp);</span><br><span class="line">            max = Math.max(max, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findRowMax</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span>[][] matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[row].length== <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stk = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, max = matrix[row][<span class="number">0</span>];</span><br><span class="line">        stk.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(i &lt; matrix[row].length || (i == matrix[row].length &amp;&amp; !stk.isEmpty()))&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != matrix[row].length &amp;&amp; ( stk.isEmpty() || matrix[row][i] &gt;= matrix[row][stk.peek()] ))&#123;</span><br><span class="line">                stk.push(i);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> top = matrix[row][stk.pop()];</span><br><span class="line">                <span class="keyword">int</span> currMax = !stk.isEmpty() ? top * (i - stk.peek() - <span class="number">1</span>) : top * i;</span><br><span class="line">                max = Math.max(currMax, max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Maximal-Square"><a href="#Maximal-Square" class="headerlink" title="Maximal Square"></a>Maximal Square</h3><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p><p><strong>Example:</strong></p><pre><code>Input: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0Output: 4</code></pre><ul><li>构造传递方程：用dp[i][j]存储以当前点matrix[i][j]作为正方形右下角顶点，所存在的最大正方形的边长，由matrix[i][j]左、上、左上三点的dp值共同判定；</li><li>初始化边界：matrix的第一列和第一行；</li><li>自顶向下递推dp并更新max，找到max的最大值求平方得最优解。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//State: dp[i][j] is max length of matrix until (i, j);</span></span><br><span class="line">       <span class="comment">//Function: dp[i][j] = min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + 1 if matrix[i - 1][j - 1] == '1';</span></span><br><span class="line">       <span class="comment">//Initialize: dp[0][0] = 0;</span></span><br><span class="line">       <span class="comment">//Result: dp[matrix.length][matrix[0].length];</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSquare</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i-<span class="number">1</span>][j-<span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>], Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]))+<span class="number">1</span>;</span><br><span class="line">                    mLen = Math.max(mLen, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mLen * mLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Edit-Distance"><a href="#Edit-Distance" class="headerlink" title="Edit Distance"></a>Edit Distance</h3><p>Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.</p><p>You have the following 3 operations permitted on a word:</p><p>Insert a character<br>Delete a character<br>Replace a character</p><p><strong>Example 1:</strong></p><pre><code>Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;Output: 3Explanation: horse -&gt; rorse (replace &apos;h&apos; with &apos;r&apos;)rorse -&gt; rose (remove &apos;r&apos;)rose -&gt; ros (remove &apos;e&apos;)</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;Output: 5Explanation: intention -&gt; inention (remove &apos;t&apos;)inention -&gt; enention (replace &apos;i&apos; with &apos;e&apos;)enention -&gt; exention (replace &apos;n&apos; with &apos;x&apos;)exention -&gt; exection (replace &apos;n&apos; with &apos;c&apos;)exection -&gt; execution (insert &apos;u&apos;)</code></pre><ul><li>典型的动态规划题目。</li><li>维护一个二维数组dis[][]，dis[i][j]表示：word1的前i个元素与word2的前j个元素的edit distance值。递推关系为：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">word1[i] == word2[j] --&gt; dis[i][j] = dis[i][j - <span class="number">1</span>]。</span><br><span class="line">word1[i] != word2[j] --&gt; dis[i][j] = min(dis[i - <span class="number">1</span>][j - <span class="number">1</span>], dis[i] [j - <span class="number">1</span>], dis[i - <span class="number">1</span>][j]) + <span class="number">1</span>。</span><br></pre></td></tr></table></figure><p>解释一下第二种情况下的递推公式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dis[i][j] = dis[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>意味着替换字符</span><br><span class="line">dis[i][j] = dis[i - <span class="number">1</span>][j] + <span class="number">1</span>意味着删除字符</span><br><span class="line">dis[i][j] = dis[i][j - <span class="number">1</span>] + <span class="number">1</span>意味着插入字符</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = word1.length() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l2 = word2.length() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dis = <span class="keyword">new</span> <span class="keyword">int</span>[l1][l2];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; l2; j++) &#123; dis[<span class="number">0</span>][j] = j; &#125; <span class="comment">// 插入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l1; i++) &#123; dis[i][<span class="number">0</span>] = i; &#125; <span class="comment">// 删除</span></span><br><span class="line">        <span class="keyword">char</span>[] arr1 = word1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] arr2 = word2.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; l1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; l2; j++) &#123;</span><br><span class="line">                dis[i][j] = Math.min(Math.min(dis[i-<span class="number">1</span>][j]+<span class="number">1</span>, dis[i][j-<span class="number">1</span>]+<span class="number">1</span>), dis[i-<span class="number">1</span>][j-<span class="number">1</span>] + (arr1[i-<span class="number">1</span>] == arr2[j-<span class="number">1</span>] ? <span class="number">0</span> : <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[l1-<span class="number">1</span>][l2-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hard-problems"><a href="#Hard-problems" class="headerlink" title="Hard problems"></a>Hard problems</h2><h3 id="Regular-Expression-Matching"><a href="#Regular-Expression-Matching" class="headerlink" title="Regular Expression Matching"></a>Regular Expression Matching</h3><ul><li>动态规划</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>, If p.charAt(j) == s.charAt(i) :  dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line"><span class="number">2</span>, If p.charAt(j) == <span class="string">'.'</span> : dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line"><span class="number">3</span>, If p.charAt(j) == <span class="string">'\*'</span>: </span><br><span class="line">   here are two sub conditions:</span><br><span class="line">       <span class="number">1</span> <span class="keyword">if</span> p.charAt(j-<span class="number">1</span>) != s.charAt(i) : dp[i][j] = dp[i][j-<span class="number">2</span>]  <span class="comment">//in this case, a* only counts as empty</span></span><br><span class="line">       <span class="number">2</span> <span class="keyword">if</span> p.charAt(i-<span class="number">1</span>) == s.charAt(i) or p.charAt(i-<span class="number">1</span>) == <span class="string">'.'</span>:</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j]    <span class="comment">//in this case, a* counts as multiple a </span></span><br><span class="line">            or dp[i][j] = dp[i][j-<span class="number">1</span>]   <span class="comment">// in this case, a* counts as single a</span></span><br><span class="line">            or dp[i][j] = dp[i][j-<span class="number">2</span>]   <span class="comment">// in this case, a* counts as empty</span></span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>][p.length()+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.charAt(i) == <span class="string">'*'</span> &amp;&amp; dp[<span class="number">0</span>][i-<span class="number">1</span>]) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j) == <span class="string">'.'</span>) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j) == s.charAt(i)) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j-<span class="number">1</span>) != s.charAt(i) &amp;&amp; p.charAt(j-<span class="number">1</span>) != <span class="string">'.'</span>) &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = (dp[i+<span class="number">1</span>][j] || dp[i][j+<span class="number">1</span>] || dp[i+<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()][p.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>递归</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern.isEmpty()) <span class="keyword">return</span> text.isEmpty();</span><br><span class="line">        <span class="keyword">boolean</span> first_match = (!text.isEmpty() &amp;&amp; </span><br><span class="line">                               (pattern.charAt(<span class="number">0</span>) == text.charAt(<span class="number">0</span>) || pattern.charAt(<span class="number">0</span>) == <span class="string">'.'</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pattern.length() &gt;= <span class="number">2</span> &amp;&amp; pattern.charAt(<span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (isMatch(text, pattern.substring(<span class="number">2</span>)) || </span><br><span class="line">                    (first_match &amp;&amp; isMatch(text.substring(<span class="number">1</span>), pattern)));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> first_match &amp;&amp; isMatch(text.substring(<span class="number">1</span>), pattern.substring(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Wildcard-Matching"><a href="#Wildcard-Matching" class="headerlink" title="Wildcard Matching"></a>Wildcard Matching</h3><p>Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for ‘?’ and ‘*’.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;?&apos; Matches any single character.</span><br><span class="line">&apos;*&apos; Matches any sequence of characters (including the empty sequence).</span><br></pre></td></tr></table></figure><p>The matching should cover the entire input string (not partial).</p><p><strong>Note:</strong></p><ul><li>s could be empty and contains only lowercase letters a-z.</li><li>p could be empty and contains only lowercase letters a-z, and characters like ? or *.</li></ul><p><strong>动态规划</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* boolean dp[len(s) + 1][len(p) + 1] </span></span><br><span class="line"><span class="comment">     * dp[i+1][j+1] means if s[0, i] match p[0, j]</span></span><br><span class="line"><span class="comment">     * function: dp[i+1][j+1] </span></span><br><span class="line"><span class="comment">     *         a. p[j] = * =&gt; 1. empty: dp[i+1][j]</span></span><br><span class="line"><span class="comment">     *                        2. one: dp[i][j]</span></span><br><span class="line"><span class="comment">     *                        3. multiple: dp[i][j+1]</span></span><br><span class="line"><span class="comment">     *         b. p[j] = s[i] | p[j] = ? =&gt; dp[i][j]</span></span><br><span class="line"><span class="comment">     * start: dp[0][0] = true, dp[0][j+1] = dp[0][j] &amp; p[j] = *</span></span><br><span class="line"><span class="comment">     * result: dp[len(s)][len(p)]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">         </span><br><span class="line">     <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>][p.length() + <span class="number">1</span>];</span><br><span class="line">     <span class="comment">// start</span></span><br><span class="line">     dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.length(); j++) </span><br><span class="line">         dp[<span class="number">0</span>][j+<span class="number">1</span>] = dp[<span class="number">0</span>][j] &amp; (p.charAt(j) == <span class="string">'*'</span>);</span><br><span class="line">         </span><br><span class="line">     <span class="comment">// loop</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.length(); j++) &#123;</span><br><span class="line">             <span class="keyword">if</span>(p.charAt(j) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                 dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j] | dp[i][j] | dp[i][j+<span class="number">1</span>];</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span>(p.charAt(j) == s.charAt(i) || p.charAt(j) == <span class="string">'?'</span>)</span><br><span class="line">                 dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> dp[s.length()][p.length()];        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>贪心</strong></p><ul><li>star符号和前面的character没有关系</li><li>用两个指针i和j分别扫描s和p，loop过程中有以下几种情况：<ul><li>成功匹配：s[i] == p[j] or p[j] == ‘?’ =&gt; i++, j++</li><li>出现星号：p[j] == ‘*’</li><li>p[j]匹配0个 =&gt; j++； p[j]匹配1个 =&gt; j++, i += 1； p[j]匹配2个 =&gt; j++, i += 2；……</li><li>匹配不上：return false</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> stari = -<span class="number">1</span>, starj = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.length()) &#123;</span><br><span class="line">            <span class="comment">// 1. match</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; p.length() &amp;&amp; (s.charAt(i) == p.charAt(j) || p.charAt(j) == <span class="string">'?'</span>)) &#123;</span><br><span class="line">                i++; j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. star</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &lt; p.length() &amp;&amp; p.charAt(j) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="comment">// first match 0</span></span><br><span class="line">                stari = i;</span><br><span class="line">                starj = ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// different number that '*' matches </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(stari != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// match number +1</span></span><br><span class="line">                i = ++stari;</span><br><span class="line">                j = starj;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3. not match and no star</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// remove last '*' in p</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt; p.length() &amp;&amp; p.charAt(j) == <span class="string">'*'</span>) j++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> j == p.length();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>递归</strong></p><p><strong>思路</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(s[l] == p[r] || p[r] == <span class="string">'?'</span>) match(l, r) = match(l + <span class="number">1</span>, r + <span class="number">1</span>) 。</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(p[r] == <span class="string">'*'</span>) &#123;</span><br><span class="line">     <span class="keyword">while</span>(l &lt; s.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(match(l, r)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        l++;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(r == p.length()) <span class="keyword">return</span> l == s.length();  </span><br><span class="line">    <span class="keyword">if</span>(p.charAt(r) == <span class="string">'*'</span>) &#123;  </span><br><span class="line">        <span class="keyword">while</span>(r &lt; p.length() &amp;&amp; p.charAt(r) == <span class="string">'*'</span>) r++;   <span class="comment">// Move the index at p to a non-start char.  </span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; s.length()) &#123;  </span><br><span class="line">            <span class="keyword">if</span>(isMatch(s, p, l, r)) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// Find one match, return true.  </span></span><br><span class="line">            l++; <span class="comment">// Try the next one.  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> isMatch(s, p, l, r);  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(l &lt; s.length() &amp;&amp; (p.charAt(r) == <span class="string">'?'</span> || s.charAt(l) == p.charAt(r)))  </span><br><span class="line">        <span class="keyword">return</span> isMatch(s, p, l + <span class="number">1</span>, r + <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;利用存储历史信息来减少重复计算，以空间换时间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;DP四要素&quot;&gt;&lt;a href=&quot;#DP四要素&quot; class=&quot;headerlink&quot; title=&quot;DP四要素&quot;&gt;&lt;/a&gt;DP四要素&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;function&lt;/strong&gt; 方程，如何从子问题到父问题&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;state&lt;/strong&gt;    状态，存储子问题的结果&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;init&lt;/strong&gt;        初始化，最小问题&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;result&lt;/strong&gt;    结果，最大问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;标记函数&quot;&gt;&lt;a href=&quot;#标记函数&quot; class=&quot;headerlink&quot; title=&quot;标记函数&quot;&gt;&lt;/a&gt;标记函数&lt;/h2&gt;&lt;p&gt;要先想好标记数组到底标记的是什么。&lt;br&gt;最标准的：问的什么就标记什么。&lt;/p&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Array" scheme="blog.jiangdongyu.space/tags/Array/"/>
    
      <category term="DynamicProgramming" scheme="blog.jiangdongyu.space/tags/DynamicProgramming/"/>
    
  </entry>
  
  <entry>
    <title>微软Office STCA</title>
    <link href="blog.jiangdongyu.space/2018/04/24/%E5%BE%AE%E8%BD%AFOffice%20STCA/"/>
    <id>blog.jiangdongyu.space/2018/04/24/微软Office STCA/</id>
    <published>2018-04-24T10:26:00.000Z</published>
    <updated>2018-05-28T10:56:09.817Z</updated>
    
    <content type="html"><![CDATA[<p>微软Office STCA暑期实习面试<br><a id="more"></a></p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ul><li>介绍azure table为什么能做到一个用户的数据在一台机器上</li><li>介绍datafactory入hive的过程，如果将copy和hive分开，怎么做？用socket？为什么websocket能做到双方发消息？</li><li>多态是在编译时知道？还是<em>运行时</em>？ B extends A;<ul><li>A a = new A() <strong>编译时</strong></li><li>A a = new B() <strong>运行时</strong></li></ul></li><li><p>给定一个正整数，求阶乘？ 越界？ 非递归？</p><ul><li>n较小时</li></ul><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getNFactorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>{     <span class="keyword">if</span>(n==<span class="number">0</span>){         <span class="keyword">return</span> <span class="number">1l</span>;     }     <span class="keyword">return</span> n*getNFactorial1(n-<span class="number">1</span>);}</code></pre><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getNFactorial1</span><span class="params">(<span class="keyword">int</span> n)</span></span>{      <span class="keyword">if</span>(n==<span class="number">0</span>){          <span class="keyword">return</span> <span class="number">1l</span>;      }      <span class="keyword">long</span> sum=<span class="number">1l</span>;      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){          sum=sum*i;      }      <span class="keyword">return</span> sum;} </code></pre><ul><li>n较大时</li></ul><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getNFactorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{      <span class="keyword">int</span> num[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000</span>];      <span class="keyword">int</span> i, j;      <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">0</span>) {          System.out.println(<span class="number">1</span>);      } <span class="keyword">else</span> {          <span class="keyword">int</span> p, h;<span class="comment">// p 存放当前结果的位数，h为进位；</span>          p = <span class="number">1</span>;          h = <span class="number">0</span>;          num[<span class="number">1</span>] = <span class="number">1</span>;          <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) {              <span class="comment">// 使得a[]的每位与i相乘</span>              <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= p; j++) {                  num[j] = num[j] * i + h;                  h = num[j] / <span class="number">10</span>;                  num[j] = num[j] % <span class="number">10</span>;              }              <span class="comment">// 表示向新的位置进位</span>              <span class="keyword">while</span> (h &gt; <span class="number">0</span>) {                  num[j] = h % <span class="number">10</span>;                  h = h / <span class="number">10</span>;                  j++;              }              p = j - <span class="number">1</span>;          }          <span class="keyword">for</span> (i = p; i &gt;= <span class="number">1</span>; i--) {              System.out.print(num[i]);          }      }  }</code></pre></li></ul><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ul><li>2 Sum &amp; 3 Sum</li><li>int parse(String str)的测试用例</li><li>为什么用azure？</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微软Office STCA暑期实习面试&lt;br&gt;
    
    </summary>
    
      <category term="实习面试经历" scheme="blog.jiangdongyu.space/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    
      <category term="2018" scheme="blog.jiangdongyu.space/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Sort</title>
    <link href="blog.jiangdongyu.space/2018/04/22/Sort/"/>
    <id>blog.jiangdongyu.space/2018/04/22/Sort/</id>
    <published>2018-04-22T09:52:00.000Z</published>
    <updated>2018-05-28T11:32:38.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="非基于比较的排序"><a href="#非基于比较的排序" class="headerlink" title="非基于比较的排序"></a>非基于比较的排序</h2><p><strong>基于比较的排序是不可能突破O(NlogN)􏰑的</strong></p><ul><li>计数排序<ul><li><a href="http://www.cs.usfca.edu/~galles/visualization/CountingSort.html" target="_blank" rel="noopener">直接看教学吧</a></li><li>适合数的范围比较小的情况</li></ul></li><li>桶排序<ul><li>尽量增大桶的数量，但是不能有太多无效桶）（将所有的元素分到一定区间条件的桶里，在桶里执行其他排序方法</li></ul></li><li>基数排序<ul><li>拓展的桶排序</li><li>多关键字</li></ul></li></ul><h2 id="基本排序算法"><a href="#基本排序算法" class="headerlink" title="基本排序算法"></a>基本排序算法</h2><table><thead><tr><th style="text-align:center">Algorithm</th><th style="text-align:center">Average Time</th><th style="text-align:center">Worst Time</th><th style="text-align:center">Space</th><th style="text-align:center">Stable</th></tr></thead><tbody><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">n^2</td><td style="text-align:center">n^2</td><td style="text-align:center">1</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">选择排序</td><td style="text-align:center">n^2</td><td style="text-align:center">n^2</td><td style="text-align:center">1</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">插入排序</td><td style="text-align:center">n^2</td><td style="text-align:center">n^2</td><td style="text-align:center"></td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center">nlog(n)</td><td style="text-align:center">n^2</td><td style="text-align:center"></td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center">nlog(n)</td><td style="text-align:center">nlog(n)</td><td style="text-align:center"></td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">nlog(n)</td><td style="text-align:center">nlog(n)</td><td style="text-align:center"></td><td style="text-align:center">N</td></tr></tbody></table><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><pre><code>public static void sort(int[] nums, int left,int right){        if(left &lt; right){            int mid = partition(nums,left,right);            sort(nums,left,mid-1);            sort(nums,mid+1,right);        }    }    public static int partition(int[] nums,int low,int high){        int pivot = nums[low];        while(low &lt; high){            while(nums[high] &gt;= pivot &amp;&amp; low &lt; high){                high--;            }            nums[low] = nums[high];            while(nums[low] &lt;= pivot &amp;&amp; low &lt; high){                low++;            }            nums[high] = nums[low];        }        nums[low] = pivot;        return low;}</code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><pre><code>public static void sort(int[] nums, int left,int right){            int mid = (left + right)/2;            if(left &lt; right){                sort(nums,left,mid);                sort(nums,mid+1,right);                merge(nums,left,mid,right);            }    }    public static void merge(int[] nums,int low,int mid,int high){            int[] tem = new int[high-low+1];            int i = low;            int j = mid+1;            int k = 0;            while(i &lt;= mid &amp;&amp; j &lt;= high){                if(nums[i] &lt; nums[j]) tem[k++] = nums[i++];                else tem[k++] = nums[j++];            }            while(i &lt;= mid) tem[k++] = nums[i++];            while(j &lt;= high) tem[k++] = nums[j++];            for(int m = 0;m &lt; tem.length;m++){                nums[m+low] = tem[m];            }    }</code></pre><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> n = nums.length;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = n/<span class="number">2</span> -<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">      heapify(nums,n,i);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">      swap(nums,<span class="number">0</span>,i);</span><br><span class="line">      heapify(nums,i,<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> n,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> largest = i;</span><br><span class="line"> <span class="keyword">int</span> l = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">int</span> r = <span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(l &lt; n &amp;&amp; nums[l] &gt; nums[largest])&#123;</span><br><span class="line">      largest = l;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(r &lt; n &amp;&amp; nums[r] &gt; nums[largest])&#123;</span><br><span class="line">      largest = r;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(largest != i)&#123;</span><br><span class="line">      swap(nums,i,largest);</span><br><span class="line">      heapify(nums,n,largest);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> tem = nums[i];</span><br><span class="line"> nums[i] = nums[j];</span><br><span class="line"> nums[j] = tem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Wiggle-Sort"><a href="#Wiggle-Sort" class="headerlink" title="Wiggle Sort"></a>Wiggle Sort</h3><blockquote><p>Given an unsorted array nums, reorder it in-place such that nums[0] &lt;= nums[1] &gt;= nums[2] &lt;= nums[3]….</p><p>For example, given nums = [3, 5, 2, 1, 6, 4], one possible answer is [1, 6, 2, 5, 3, 4].</p></blockquote><ul><li>排序法<ul><li>先将数组排序，</li><li>这时候从第3个元素开始，将第3个元素和第2个元素交换。</li><li>然后再从第5个元素开始，将第5个元素和第4个元素交换，</li><li>以此类推。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先将数组排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// 将数组中一对一对交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[i-<span class="number">1</span>];</span><br><span class="line">            nums[i-<span class="number">1</span>] = nums[i];</span><br><span class="line">            nums[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>交换法<ul><li>如果i是奇数，nums[i] &gt;= nums[i - 1]</li><li>如果i是偶数，nums[i] &lt;= nums[i - 1]</li><li>遍历一遍数组，把不符合的情况交换一下就行了。</li><li>具体来说，如果nums[i] &gt; nums[i - 1]， 则交换以后肯定有nums[i] &lt;= nums[i - 1]。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 需要交换的情况：奇数时nums[i] &lt; nums[i - 1]或偶数时nums[i] &gt; nums[i - 1]</span></span><br><span class="line">            <span class="keyword">if</span>((i % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; nums[i] &lt; nums[i-<span class="number">1</span>]) || (i % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; nums[i] &gt; nums[i-<span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[i-<span class="number">1</span>];</span><br><span class="line">                nums[i-<span class="number">1</span>] = nums[i];</span><br><span class="line">                nums[i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sort-Colors"><a href="#Sort-Colors" class="headerlink" title="Sort Colors"></a>Sort Colors</h3><blockquote><p>给定一组分别具有红白蓝颜色的对象，重新排序他们使得相同颜色的对象相邻。排序后的顺序是红白蓝。</p></blockquote><blockquote><p>这里我们用 0, 1, and 2 来分别表示红白蓝三个颜色。</p></blockquote><p><strong>注意：不能用库中的排序函数。</strong></p><ul><li>遍历，计数</li><li>类似快排的partition<ul><li>左边存放0和1，右边存放2.两边往中间靠。</li><li>设置两个index，left记录第一个1的位置，left左边为0，right记录第一个非2的位置，right右边为2.</li><li>然后使用i从头到尾扫一遍，直到与right相遇。</li><li>i遇到0就换到左边去，遇到2就换到右边去，遇到1就跳过。</li><li>需要注意的是：由于left记录第一个1的位置，因此A[left]与A[i]交换后，A[left]为0,A[i]为1，因此i++；</li><li>而right记录第一个非2的位置，可能为0或1，因此A[right]与A[i]交换后，A[right]为2,A[i]为0或1，i不能前进，要后续判断。</li><li>由此该数组分为4段：[0,left)–&gt;0; [left,i)–&gt;1; [i,right]–&gt;乱序; (right,n-1]–&gt;2</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums,i,left);</span><br><span class="line">                i++;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                swap(nums,i,right);</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tem = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sort-List"><a href="#Sort-List" class="headerlink" title="Sort List"></a>Sort List</h3><ul><li>归并排序<ul><li>快慢指针将链表分为两个部分</li><li>慢指针的next为null</li><li>再合并两个排序好的链表</li></ul></li></ul><h3 id="Insertion-Sort-List"><a href="#Insertion-Sort-List" class="headerlink" title="Insertion Sort List"></a>Insertion Sort List</h3><ul><li>选择排序，i前有序，i后无序，两层循环</li><li>链表的插入排序，同样两层循环，考虑到头指针也需要被排序，需要新增一个fakeHead。</li><li>链表的插入需要维护三个指针，pre，cur，next，</li><li>pre始终指向有序链表的fakeHead，cur指向当前需要排序的节点，next指向下一个待排序的节点。</li><li>当有序链表为空或者pre.next所指向的元素的值比当前节点的值大时，需要将cur插入到pre.next之前的位置，</li><li>否则，则将pre指针后移，最后返回fakeHead.next即可。</li></ul><h3 id="Maximum-Gap"><a href="#Maximum-Gap" class="headerlink" title="Maximum Gap"></a>Maximum Gap</h3><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p><p>Return 0 if the array contains less than 2 elements.</p><p>Example 1:</p><pre><code>Input: [3,9,6,1]Output: 3Explanation: The sorted form of the array is [1,3,6,9], either 3,6 or 6,9 has the maximum difference 3. </code></pre><p>Example 2:</p><pre><code>Input: [10]Output: 0Explanation: The array contains less than 2 elements, therefore return 0.</code></pre><p>Notes:</p><p>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.</p><p>Try to solve it in linear time/space.</p><ul><li>直接排序</li><li>桶排序，取相邻两个桶，后一个桶的最小值和前一个桶的最大值可能就是那个值</li></ul><h3 id="Best-Meeting-Point"><a href="#Best-Meeting-Point" class="headerlink" title="Best Meeting Point"></a>Best Meeting Point</h3><blockquote><p>A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.</p></blockquote><p>For example, given three people living at (0,0), (0,4), and (2,2):</p><pre><code>1 - 0 - 0 - 0 - 1|   |   |   |   |0 - 0 - 0 - 0 - 0|   |   |   |   |0 - 0 - 1 - 0 - 0</code></pre><p>The point (0,2) is an ideal meeting point, as the total travel<br>distance of 2+2+2=6 is minimal. So return 6.</p><ul><li>曼哈顿距离，我们可以分开计算横坐标和纵坐标</li><li>算出各个横坐标到中点横坐标的距离，加上各个纵坐标到中点纵坐标的距离，就是结果</li></ul><h2 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h2><h3 id="Meeting-Rooms"><a href="#Meeting-Rooms" class="headerlink" title="Meeting Rooms"></a>Meeting Rooms</h3><blockquote><p>Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],…] (si &lt; ei), determine if a person could attend all meetings.</p></blockquote><ul><li>判断区间是否重合</li><li>先对数组按照开始时间排序，如果下一个的开始时间早于前一个的结束时间则不行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canAttendMeetings</span><span class="params">(Interval[] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span>(intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// sort</span></span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; a.start == b.start ? a.end - b.end : a.start - b.start);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//or</span></span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;Interval&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Interval i1, Interval i2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i1.start-i2.start;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i].end &gt; intervals[i+<span class="number">1</span>].start) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Meeting-Rooms-II"><a href="#Meeting-Rooms-II" class="headerlink" title="Meeting Rooms II"></a>Meeting Rooms II</h3><blockquote><p>Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],…] (si &lt; ei), find the minimum number of conference rooms required.</p></blockquote><p><strong>思路</strong></p><p>overlap的条件依然是：intervals[i].end &gt; intervals[j].start<br>不同的是这题需要求房间数。还是先sort，i指向之前有overlap的最小end的那一个。</p><p><strong>复杂度</strong></p><p>Time Complexity: O(NlogN)，Space: O(N)。</p><p><strong>heap</strong></p><p>因为要知道之前有overlap的最小的end，所以可以用一个min heap。每次检查新的start是否比heap的top元素小，是的话就把保存原来的end，同时放进新的end；否则就放新的end同时poll出原来的，因为没有overlap且新的end较大。最后heap的大小就是需要的房间数。比如：</p><p>[1, 5], [2, 4], [3, 6], [5, 7]</p><pre><code>heap: [5]。[2, 4]的start是2，比5小，所以放入4。heap: [4, 5]。接着[3 ,6]的start是3，比4小，所以又放入6。heap: [4, 5, 6]。[5, 7]的start是5，比4大，因此poll出4，放入7。heap: [5, 6, 7]。最后heap的size为3。</code></pre><p>4被pop出来是因为[2, 4]和[5, 7]公用一个房间，只要放7进去就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(Interval[] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span>(intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// sort</span></span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; a.start == b.start ? a.end - b.end : a.start - b.start);</span><br><span class="line">        <span class="comment">// min heap to store the end</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        minHeap.offer(intervals[<span class="number">0</span>].end);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="comment">// no overlap</span></span><br><span class="line">            <span class="keyword">if</span>(minHeap.peek() &lt;= intervals[i].start) minHeap.poll();</span><br><span class="line">            minHeap.offer(intervals[i].end);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> minHeap.size();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Insert-Intervals"><a href="#Insert-Intervals" class="headerlink" title="Insert Intervals"></a>Insert Intervals</h3><blockquote><p>即向有序、不重叠的区间序列中插入一个区间。如区间产生重叠，则合并。求插入新区间后的区间序列。</p><p>如：A = [1,3],[6,9]，插入[2,6]，插入后新序列为[1,9]。</p></blockquote><ul><li>对新给的序列，有三种对应情况</li><li>旧区间在新区间之前</li><li>新区间在旧区间之前</li><li>有重叠</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">insert</span><span class="params">(List&lt;Interval&gt; intervals, Interval newInterval)</span> </span>&#123;</span><br><span class="line">        List&lt;Interval&gt; ans = <span class="keyword">new</span> ArrayList&lt;Interval&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; intervals.size() ;i++)&#123;</span><br><span class="line">            Interval now = intervals.get(i);</span><br><span class="line">            <span class="keyword">if</span>(now.end &lt; newInterval.start)&#123; <span class="comment">//intervals before the newInterval</span></span><br><span class="line">                ans.add(now);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(now.start &gt; newInterval.end)&#123; <span class="comment">//intervals after the newInterval</span></span><br><span class="line">                ans.add(newInterval);</span><br><span class="line">                ans.addAll(intervals.subList(i,intervals.size())); <span class="comment">//add all remaining intervals and return</span></span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">//intervals overlap the newInterval , update the interval range</span></span><br><span class="line">                newInterval.start = Math.min(newInterval.start, now.start);</span><br><span class="line">                newInterval.end = Math.max(newInterval.end, now.end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(newInterval); <span class="comment">//if there are no intervals after the newInterval, than add it and return</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Merge-Intervals"><a href="#Merge-Intervals" class="headerlink" title="Merge Intervals"></a>Merge Intervals</h3><p>Given a collection of intervals, merge all overlapping intervals.</p><p>Example 1:</p><pre><code>Input: [[1,3],[2,6],[8,10],[15,18]]Output: [[1,6],[8,10],[15,18]]Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</code></pre><p>Example 2:</p><pre><code>Input: [[1,4],[4,5]]Output: [[1,5]]Explanation: Intervals [1,4] and [4,5] are considerred overlapping.</code></pre><ul><li>先根据start排序</li><li>再遍历判断是否重叠，interval.start &lt;= end重叠</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * public class Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() &#123; start = 0; end = 0; &#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) &#123; start = s; end = e; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">merge</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">        </span><br><span class="line">        Collections.sort(intervals, (a, b) -&gt; a.start == b.start ? a.end - b.end : a.start - b.start);</span><br><span class="line">        List&lt;Interval&gt; merged = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start = intervals.get(<span class="number">0</span>).start;</span><br><span class="line">        <span class="keyword">int</span> end = intervals.get(<span class="number">0</span>).end;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(Interval interval:intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span>(interval.start &lt;= end )&#123;</span><br><span class="line">                end = Math.max(interval.end,end);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                merged.add(<span class="keyword">new</span> Interval(start,end));</span><br><span class="line">                start = interval.start;</span><br><span class="line">                end = interval.end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        merged.add(<span class="keyword">new</span> Interval(start,end));</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Largest-Number"><a href="#Largest-Number" class="headerlink" title="Largest Number"></a>Largest Number</h3><p>Given a list of non negative integers, arrange them such that they form the largest number.</p><p>Example 1:</p><pre><code>Input: [10,2]Output: 210</code></pre><p>Example 2:</p><pre><code>Input: [3,30,34,5,9]Output: 9534330</code></pre><p>Note: The result may be very large, so you need to return a string instead of an integer.</p><ul><li>对哪个数放在前面的问题，其实对ab两个数进行排序</li><li>如果ab &gt; ba，那么a应该在b之前，写一个符合条件的comparator即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            arr[i] = String.valueOf(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//逆序，方便之后append</span></span><br><span class="line">        Arrays.sort(arr, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span></span>&#123;</span><br><span class="line">                String s1 = a+b;</span><br><span class="line">                String s2 = b+a;</span><br><span class="line">                <span class="keyword">return</span> s2.compareTo(s1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">0</span>].equals(<span class="string">"0"</span>)) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span>(String s: arr)&#123;</span><br><span class="line">        sb.append(s);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bucket-Sort"><a href="#Bucket-Sort" class="headerlink" title="Bucket Sort"></a>Bucket Sort</h2><h3 id="First-Missing-Positive"><a href="#First-Missing-Positive" class="headerlink" title="First Missing Positive"></a>First Missing Positive</h3><p>Given an unsorted integer array, find the smallest missing positive integer.</p><p>Example 1:</p><pre><code>Input: [1,2,0]Output: 3</code></pre><p>Example 2:</p><pre><code>Input: [3,4,-1,1]Output: 2</code></pre><p>Example 3:</p><pre><code>Input: [7,8,9,11,12]Output: 1</code></pre><p>Note:</p><p>Your algorithm should run in O(n) time and uses constant extra space.</p><ul><li>交换数组元素，使得数组中第i位存放数值(i+1)。</li><li>最后遍历数组，寻找第一个不符合此要求的元素，返回其下标。</li><li>整个过程需要遍历两次数组，复杂度为O(n)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i+<span class="number">1</span> &amp;&amp; nums[i] &gt;= <span class="number">1</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[i] != nums[nums[i]-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> tem = nums[nums[i]-<span class="number">1</span>];</span><br><span class="line">                nums[nums[i]-<span class="number">1</span>] = nums[i];</span><br><span class="line">                nums[i] = tem;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] != j+<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> j+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;非基于比较的排序&quot;&gt;&lt;a href=&quot;#非基于比较的排序&quot; class=&quot;headerlink&quot; title=&quot;非基于比较的排序&quot;&gt;&lt;/a&gt;非基于比较的排序&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;基于比较的排序是不可能突破O(NlogN)􏰑的&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Array" scheme="blog.jiangdongyu.space/tags/Array/"/>
    
      <category term="Sort" scheme="blog.jiangdongyu.space/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>BFS</title>
    <link href="blog.jiangdongyu.space/2018/04/18/BFS/"/>
    <id>blog.jiangdongyu.space/2018/04/18/BFS/</id>
    <published>2018-04-18T12:52:00.000Z</published>
    <updated>2018-05-28T11:08:17.140Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目列表</strong></p><h3 id="Binary-Tree-Right-Side-View"><a href="#Binary-Tree-Right-Side-View" class="headerlink" title="Binary Tree Right Side View"></a>Binary Tree Right Side View</h3><blockquote><p>层次遍历，输出最右边的数</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// reverse level traversal</span></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">                TreeNode cur = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) result.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Populating-Next-Right-Pointers-in-Each-Node"><a href="#Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="Populating Next Right Pointers in Each Node"></a>Populating Next Right Pointers in Each Node</h3><p>For example,<br>Given the following perfect binary tree,</p><pre><code>     1   /  \  2    3 / \  / \4  5  6  7</code></pre><p>After calling your function, the tree should look like:</p><pre><code>     1 -&gt; NULL   /  \  2 -&gt; 3 -&gt; NULL / \  / \4-&gt;5-&gt;6-&gt;7 -&gt; NULL</code></pre><ul><li>由于是<strong>完全二叉树</strong>，所以若节点的<strong>左子结点存在的话，其右子节点必定存在</strong>，</li><li>所以<strong>左子结点的next指针可以直接指向其右子节点</strong>，</li><li>对于其右子节点的处理方法是，判断其<strong>父节点的next</strong>是否为空，若不为空，则指向其next指针指向的节点的左子结点，若为空则指向NULL</li></ul><h3 id="Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="Populating Next Right Pointers in Each Node II"></a>Populating Next Right Pointers in Each Node II</h3><blockquote><p>不是完全二叉树</p></blockquote><p>借助dummy结点的解法！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</span><br><span class="line">        TreeLinkNode dummy = <span class="keyword">new</span> TreeLinkNode(<span class="number">0</span>);</span><br><span class="line">        TreeLinkNode cur = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                cur.next = root.left;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                cur.next = root.right;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root.next;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">                cur = dummy;</span><br><span class="line">                root = cur.next;</span><br><span class="line">                cur.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Word-Ladder"><a href="#Word-Ladder" class="headerlink" title="Word Ladder"></a>Word Ladder</h3><p>For example,</p><p>Given:</p><p>beginWord = “hit”</p><p>endWord = “cog”</p><p>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</p><p>As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,</p><p>return its length 5.</p><p><strong>Note:</strong></p><ul><li>Return 0 if there is no such transformation sequence.</li><li>All words have the same length.</li><li>All words contain only lowercase alphabetic characters.</li><li>You may assume no duplicates in the word list.</li><li>You may assume beginWord and endWord are non-empty and are not the same.</li></ul><p><strong>解题思路</strong></p><ul><li>BFS</li><li>可以想象成一棵树，根节点是start字符串，</li><li>第二层是所有的和它相差一个字母的字符串（之前出现过的，之后就没有必要出现了，因为出现的话，也是abc变成bbc又变回abs，没有意义），</li><li>需要一个队列来实现广度优先搜索，因为是从顶层到底层来遍历的，所以发现等于end的时候的层数值就是最小的，返回即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(beginWord);</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">0</span>; q &lt; size; q++) &#123;</span><br><span class="line">                <span class="keyword">char</span>[] cur = queue.poll().toCharArray();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; cur.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">char</span> tmp = cur[i];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">char</span> chr=<span class="string">'a'</span>; chr &lt;= <span class="string">'z'</span>; chr++) &#123;</span><br><span class="line">                        cur[i] = chr;</span><br><span class="line">                        String dest = <span class="keyword">new</span> String(cur);</span><br><span class="line">                        <span class="keyword">if</span> (dict.contains(dest)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (dest.equals(endWord)) <span class="keyword">return</span> level+<span class="number">1</span>;</span><br><span class="line">                            queue.add(dest);</span><br><span class="line">                            dict.remove(dest);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur[i] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Word-Ladder-II"><a href="#Word-Ladder-II" class="headerlink" title="Word Ladder II"></a>Word Ladder II</h3><blockquote><p>需要返回所有的最短路径</p></blockquote><p>呃，有点难。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目列表&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;Binary-Tree-Right-Side-View&quot;&gt;&lt;a href=&quot;#Binary-Tree-Right-Side-View&quot; class=&quot;headerlink&quot; title=&quot;Binary Tree Right Side View&quot;&gt;&lt;/a&gt;Binary Tree Right Side View&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;层次遍历，输出最右边的数&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="BFS" scheme="blog.jiangdongyu.space/tags/BFS/"/>
    
      <category term="BinaryTree" scheme="blog.jiangdongyu.space/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search</title>
    <link href="blog.jiangdongyu.space/2018/04/18/BinarySearch/"/>
    <id>blog.jiangdongyu.space/2018/04/18/BinarySearch/</id>
    <published>2018-04-18T12:34:00.000Z</published>
    <updated>2018-05-28T11:08:27.743Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有序数组，用于查找</p></blockquote><h2 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h2><p>需要优化O(n)复杂度时，一般只能二分法</p><a id="more"></a><h2 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">int</span> high = arr.length-<span class="number">1</span>;   </span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high) &#123;   </span><br><span class="line">        <span class="keyword">int</span> middle = low + (high - low)/<span class="number">2</span>;   </span><br><span class="line">        <span class="keyword">if</span>(x == arr[middle]) &#123;   </span><br><span class="line">             <span class="keyword">return</span> middle;   </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x &lt;arr[middle]) &#123;   </span><br><span class="line">             high = middle - <span class="number">1</span>;   </span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;   </span><br><span class="line">             low = middle + <span class="number">1</span>;   </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h2><h3 id="第一类"><a href="#第一类" class="headerlink" title="第一类"></a>第一类</h3><blockquote><p>考察基本用法，题目并没有说明没有重复值，需要继续查找</p></blockquote><ul><li>search insert position</li><li>search for a range</li><li>isBadVersion</li><li>Closest Binary Search Tree Value <ul><li>二叉搜索树找离target最近的node的值</li><li>二分判断左右</li></ul></li><li>Find Peak Element<ul><li><strong>二分查找折半</strong>后中间那个元素后，</li><li>和<strong>紧跟</strong>的那个元素比较下大小，</li><li>如果<strong>大于</strong>，则说明峰值在前面，</li><li>如果<strong>小于</strong>则在后面。这样就可以找到一个峰值了</li></ul></li><li>Median of Two Sorted Arrays</li></ul><h4 id="Search-for-a-range"><a href="#Search-for-a-range" class="headerlink" title="Search for a range"></a>Search for a range</h4><blockquote><p>查找等于target的一个范围，即找到最先出现的target和最后出现的target</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = &#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = nums.length-<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(nums[low] &lt; nums[high])&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>; </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[low] &lt; target) low++;</span><br><span class="line">                <span class="keyword">if</span>(nums[high] &gt; target) high--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[low] == target)&#123;</span><br><span class="line">            res[<span class="number">0</span>] = low;</span><br><span class="line">            res[<span class="number">1</span>] = high;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Median-of-Two-Sorted-Arrays"><a href="#Median-of-Two-Sorted-Arrays" class="headerlink" title="Median of Two Sorted Arrays"></a>Median of Two Sorted Arrays</h4><h3 id="第二类"><a href="#第二类" class="headerlink" title="第二类"></a>第二类</h3><blockquote><p>和数学相关</p></blockquote><ul><li>sqrt(X) </li><li>pow(x, n) </li><li>fastPower</li></ul><h4 id="sqrt-X"><a href="#sqrt-X" class="headerlink" title="sqrt(X)"></a>sqrt(X)</h4><blockquote><p>i * i &lt;= x &amp;&amp; (i+1)(i+1) &gt; x</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">1</span>, end = x;</span><br><span class="line"><span class="keyword">while</span> (start &lt; end) &#123; </span><br><span class="line"><span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (mid &lt;= x / mid &amp;&amp; (mid + <span class="number">1</span>) &gt; x / (mid + <span class="number">1</span>))<span class="comment">// Found the result</span></span><br><span class="line"><span class="keyword">return</span> mid; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mid &gt; x / mid)<span class="comment">// Keep checking the left part</span></span><br><span class="line">end = mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">start = mid + <span class="number">1</span>;<span class="comment">// Keep checking the right part</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pow-x-n"><a href="#pow-x-n" class="headerlink" title="pow(x, n)"></a>pow(x, n)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            n = -n;</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (n%<span class="number">2</span> == <span class="number">0</span>) ? pow(x*x, n/<span class="number">2</span>) : x*pow(x*x, n/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三类"><a href="#第三类" class="headerlink" title="第三类"></a>第三类</h3><blockquote><p>二维上运用</p></blockquote><ul><li>Search a 2d Matrix <ul><li>矩阵从左到右递增，第二行最小值比第一行最大值大</li><li>可转化为一维的二分，matrix[mid/col][mid%col] == target</li></ul></li><li>Search a 2d Matrix II<ul><li>矩阵从左到右递增，从上到下递增</li></ul></li></ul><h3 id="第四类"><a href="#第四类" class="headerlink" title="第四类"></a>第四类</h3><blockquote><p>部分sorted的数组或者rotated的数组</p></blockquote><ul><li>search in rotated sorted array</li><li>search in rotated sorted array II(duplicate allowed) </li><li>find min in rotated sorted array</li><li>find min in rotated sorted array II(duplicate allowed)</li></ul><h4 id="Search-in-Rotated-Sorted-Array"><a href="#Search-in-Rotated-Sorted-Array" class="headerlink" title="Search in Rotated Sorted Array"></a>Search in Rotated Sorted Array</h4><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>解题方案</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (nums[start] &lt;= nums[mid])&#123;</span><br><span class="line">                 <span class="keyword">if</span> (target &lt; nums[mid] &amp;&amp; target &gt;= nums[start]) </span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= nums[end])&#123;</span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end])</span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Search-in-rotated-sorted-array-II-duplicate-allowed"><a href="#Search-in-rotated-sorted-array-II-duplicate-allowed" class="headerlink" title="Search in rotated sorted array II(duplicate allowed)"></a>Search in rotated sorted array II(duplicate allowed)</h4><p>nums may contain duplicates.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[start] == nums[mid])&#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[start] &lt; nums[mid])&#123;</span><br><span class="line">                 <span class="keyword">if</span> (target &lt; nums[mid] &amp;&amp; target &gt;= nums[start]) </span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end])</span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Find-min-in-rotated-sorted-array"><a href="#Find-min-in-rotated-sorted-array" class="headerlink" title="Find min in rotated sorted array"></a>Find min in rotated sorted array</h4><blockquote><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p></blockquote><blockquote><p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p></blockquote><blockquote><p>Find the minimum element.</p></blockquote><ul><li>If rotate, A[min] &lt; A[min - 1]; </li><li>If not, A[0]. </li><li>If not, there are 2 conditions as well: </li><li>If it is greater than both left and right element, then minimum element should be on its right, otherwise on its left.</li></ul><h4 id="Find-Minimum-in-Rotated-Sorted-Array-II"><a href="#Find-Minimum-in-Rotated-Sorted-Array-II" class="headerlink" title="Find Minimum in Rotated Sorted Array II"></a>Find Minimum in Rotated Sorted Array II</h4><blockquote><p>The array may contain duplicates.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[end])&#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[end])&#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Longest-Increasing-Subsequence"><a href="#Longest-Increasing-Subsequence" class="headerlink" title="Longest Increasing Subsequence"></a>Longest Increasing Subsequence</h4><p><strong>动态规划</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxval = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    maxval = Math.max(maxval, dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = maxval + <span class="number">1</span>;</span><br><span class="line">            maxans = Math.max(maxans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二分查找</strong></p><ul><li>if x is larger than all tails, append it, increase the size by 1</li><li>if tails[i-1] &lt; x &lt;= tails[i], update tails[i]</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPositionToReplace</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid;</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (a[mid] == x)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; x)</span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> | nums.length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = nums.length, len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] increasingSequence = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">increasingSequence[len++] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; increasingSequence[len - <span class="number">1</span>])</span><br><span class="line">increasingSequence[len++] = nums[i];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> position = findPositionToReplace(increasingSequence, <span class="number">0</span>, len - <span class="number">1</span>, nums[i]);</span><br><span class="line">increasingSequence[position] = nums[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有序数组，用于查找&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;何时使用&quot;&gt;&lt;a href=&quot;#何时使用&quot; class=&quot;headerlink&quot; title=&quot;何时使用&quot;&gt;&lt;/a&gt;何时使用&lt;/h2&gt;&lt;p&gt;需要优化O(n)复杂度时，一般只能二分法&lt;/p&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Array" scheme="blog.jiangdongyu.space/tags/Array/"/>
    
      <category term="Binary Search" scheme="blog.jiangdongyu.space/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>DFS</title>
    <link href="blog.jiangdongyu.space/2018/04/18/DFS/"/>
    <id>blog.jiangdongyu.space/2018/04/18/DFS/</id>
    <published>2018-04-18T12:33:00.000Z</published>
    <updated>2018-05-28T11:08:58.693Z</updated>
    
    <content type="html"><![CDATA[<p>遇到要求所有组合，可能，排列等解集的问题，一般都是用DFS/BFS + backtracking来做</p><a id="more"></a><h3 id="Path-Sum"><a href="#Path-Sum" class="headerlink" title="Path Sum"></a>Path Sum</h3><blockquote><p>给定一个值，判断是否有一个从根到叶子的路径的value之和等于这个值</p></blockquote><ul><li>非递归<ul><li>DFS，两个栈，一个放node，一个放到当前node的curSum</li><li>如果node是叶子结点，并且curSum等于给定的那个值时，返回true</li></ul></li><li>递归<ul><li>判断root为null</li><li>判断左右子树为null，且该值等于root.val</li><li>减去root.val对左右子树递归判断</li></ul></li></ul><h3 id="Path-Sum-II"><a href="#Path-Sum-II" class="headerlink" title="Path Sum II"></a>Path Sum II</h3><blockquote><p>需要返回所有可能的路径</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    pathSum(ans, path, root, sum);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pathSum</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; path,</span></span></span><br><span class="line"><span class="function"><span class="params">TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">List&lt;Integer&gt; newPath = <span class="keyword">new</span> ArrayList&lt;&gt;(path);</span><br><span class="line">newPath.add(root.val);</span><br><span class="line"><span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == sum) &#123;</span><br><span class="line">ans.add(newPath);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">pathSum(ans, newPath, root.left, sum - root.val);</span><br><span class="line">pathSum(ans, newPath, root.right, sum - root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sum-Root-to-Leaf-Numbers"><a href="#Sum-Root-to-Leaf-Numbers" class="headerlink" title="Sum Root to Leaf Numbers"></a>Sum Root to Leaf Numbers</h3><p>Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.</p><p>An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123.</p><p>Find the total sum of all root-to-leaf numbers.</p><p>For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br></pre></td></tr></table></figure><p>The root-to-leaf path 1-&gt;2 represents the number 12.</p><p>The root-to-leaf path 1-&gt;3 represents the number 13.</p><p>Return the sum = 12 + 13 = 25.</p><ul><li>和上一题类似</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;遇到要求所有组合，可能，排列等解集的问题，一般都是用DFS/BFS + backtracking来做&lt;/p&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Array" scheme="blog.jiangdongyu.space/tags/Array/"/>
    
      <category term="DFS" scheme="blog.jiangdongyu.space/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>腾讯</title>
    <link href="blog.jiangdongyu.space/2018/04/16/%E8%85%BE%E8%AE%AF/"/>
    <id>blog.jiangdongyu.space/2018/04/16/腾讯/</id>
    <published>2018-04-16T03:26:00.000Z</published>
    <updated>2018-05-28T10:54:24.511Z</updated>
    
    <content type="html"><![CDATA[<p>腾讯后台开发实习生暑期实习面试<br><a id="more"></a></p><ul><li>自我介绍</li><li>写hql <ul><li>给定腾讯新闻数据，三个表</li><li>第一个表：腾讯新闻版面id，文章id</li><li>第二个表，浏览行为数据：时间戳，版面id，文章id</li><li>第三个表，评论行为数据：时间戳，版面id，文章id</li><li>求每天文章/版面的曝光</li><li>曝光 = 评论/浏览</li></ul></li><li>求两个数组的交集<ul><li>hashset</li><li>排序，再比较</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;腾讯后台开发实习生暑期实习面试&lt;br&gt;
    
    </summary>
    
      <category term="实习面试经历" scheme="blog.jiangdongyu.space/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    
      <category term="2018" scheme="blog.jiangdongyu.space/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree</title>
    <link href="blog.jiangdongyu.space/2018/04/12/BinaryTree/"/>
    <id>blog.jiangdongyu.space/2018/04/12/BinaryTree/</id>
    <published>2018-04-12T12:00:00.000Z</published>
    <updated>2018-05-28T11:08:48.536Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Binary-Tree遍历"><a href="#Binary-Tree遍历" class="headerlink" title="Binary Tree遍历"></a>Binary Tree遍历</h2><p>前序、中序、后序遍历</p><a id="more"></a><p><strong>解法</strong></p><ul><li>递归</li><li>非递归，用stack</li><li>Morris解法，非递归，不用栈，O(1)空间，二叉搜索树</li></ul><h3 id="Binary-Tree-Preorder-Traversal"><a href="#Binary-Tree-Preorder-Traversal" class="headerlink" title="Binary Tree Preorder Traversal"></a>Binary Tree Preorder Traversal</h3><p>根-左-右</p><ul><li>递归</li><li>非递归<ul><li>根先入栈</li><li>右孩子不为空则入栈</li><li>左孩子不为空则入栈</li><li>循环跳出条件为栈为空</li></ul></li></ul><h3 id="Inorder-Traversal"><a href="#Inorder-Traversal" class="headerlink" title="Inorder Traversal"></a>Inorder Traversal</h3><p>左-根-右</p><ul><li>递归</li><li>非递归<ul><li>root入栈</li><li>不断找root = root.left入栈</li><li>当root为null时出栈，同时root = root.right</li></ul></li></ul><h3 id="postOrder-Traversal"><a href="#postOrder-Traversal" class="headerlink" title="postOrder Traversal"></a>postOrder Traversal</h3><p>左-右-根</p><ul><li>递归</li><li>非递归<ul><li>根入栈</li><li>当栈不为空时，判断栈顶元素node的左右孩子，都为null，则出栈</li><li>右孩子不为空，右孩子入栈,node.right = null</li><li>左孩子不为空，左孩子入栈,node.left = null</li></ul></li></ul><h3 id="Binary-Tree-Level-Order-Traversal-amp-II"><a href="#Binary-Tree-Level-Order-Traversal-amp-II" class="headerlink" title="Binary Tree Level Order Traversal &amp; II"></a>Binary Tree Level Order Traversal &amp; II</h3><h3 id="Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="Binary Tree Zigzag Level Order Traversal"></a>Binary Tree Zigzag Level Order Traversal</h3><p><strong>层次遍历</strong></p><ul><li>queue</li><li>根入队列</li><li>当队列不为空时，node出队列并打印结点，判断左右孩子，分别入队列</li></ul><p>将List顺序反转</p><p>Collections.reverse(subList);</p><h2 id="Binary-Tree-Recursion"><a href="#Binary-Tree-Recursion" class="headerlink" title="Binary Tree Recursion"></a>Binary Tree Recursion</h2><ul><li>pre order </li><li>in order </li><li>post order</li></ul><hr><ul><li>Max Depth</li><li>Min Depth</li><li>Is Balanced Tree</li></ul><hr><ul><li>Same Tree</li></ul><hr><ul><li>Symmetric Tree</li><li>Validate Binary Search Tree</li></ul><hr><ul><li>Recover Binary Search Tree</li></ul><hr><ul><li>Construct Binary Tree from pre-order and in-order </li><li>Construct Binary Tree from post-order and in-order </li><li>Convert Sorted Array to BST</li><li>Convert Sorted LinkedList to BST</li></ul><h3 id="Max-Depth-of-Binary-Tree"><a href="#Max-Depth-of-Binary-Tree" class="headerlink" title="Max Depth of Binary Tree"></a>Max Depth of Binary Tree</h3><ul><li>递归<ul><li>对左右子树深度求Max</li></ul></li><li>非递归<ul><li>层次遍历</li></ul></li></ul><h3 id="Minimum-Depth-of-Binary-Tree"><a href="#Minimum-Depth-of-Binary-Tree" class="headerlink" title="Minimum Depth of Binary Tree"></a>Minimum Depth of Binary Tree</h3><ul><li>递归<ul><li>左右孩子都不为空时，取Min()</li><li>否则，取Max</li></ul></li><li>非递归<ul><li>层次遍历</li><li>当左右孩子都为空时return当前深度</li><li>否则入队列，深度++</li></ul></li></ul><h3 id="Balanced-Binary-Tree"><a href="#Balanced-Binary-Tree" class="headerlink" title="Balanced Binary Tree"></a>Balanced Binary Tree</h3><blockquote><p>平衡二叉树每一个结点的左右子树的深度相差不超过1</p></blockquote><ul><li>递归求深度差是否满足即可</li></ul><h3 id="Symmetric-Tree"><a href="#Symmetric-Tree" class="headerlink" title="Symmetric Tree"></a>Symmetric Tree</h3><blockquote><p>二叉树是否镜像对称</p></blockquote><ul><li>递归<ul><li>停止条件是 left==None &amp; right==None</li><li>left.val==right.val 比较left.left right.right &amp; left.right right.left</li></ul></li><li>非递归</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.add(root);</span><br><span class="line">    q.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        TreeNode t1 = q.poll();</span><br><span class="line">        TreeNode t2 = q.poll();</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1.val != t2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        q.add(t1.left);</span><br><span class="line">        q.add(t2.right);</span><br><span class="line">        q.add(t1.right);</span><br><span class="line">        q.add(t2.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Valid-Binary-Search-Tree"><a href="#Valid-Binary-Search-Tree" class="headerlink" title="Valid Binary Search Tree"></a>Valid Binary Search Tree</h3><blockquote><p>是否满足结点的值左&lt;根&lt;右</p></blockquote><ul><li>递归<ul><li>判断结点的值是否在取值范围内</li></ul></li><li>非递归<ul><li>中序遍历</li><li>一旦出现先pop的node的值比后面的大，则不是</li></ul></li></ul><h3 id="Flatten-Binary-Tree-to-Linked-List"><a href="#Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="Flatten Binary Tree to Linked List"></a>Flatten Binary Tree to Linked List</h3><p>For example,</p><p>Given</p><pre><code>    1   / \  2   5 / \   \3   4   6 </code></pre><p>The flattened tree should look like:</p><pre><code>1 \  2   \    3     \      4       \        5         \          6</code></pre><p><strong>思路1</strong></p><ul><li>递归<ul><li>DFS找到最左结点，然后返回其父结点</li><li>把其父节点和右子节点断开</li><li>将原左子结点连上父节点的右子节点上</li><li>然后再把原右子节点连到新右子节点的右子节点上</li><li>然后再回到上一父节点做相同操作</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) flatten(root.left);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) flatten(root.right);</span><br><span class="line">        </span><br><span class="line">        TreeNode tem = root.right;</span><br><span class="line">        root.right = root.left;</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">           root =  root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        root.right = tem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路2</strong></p><ul><li>非递归<ul><li>从根节点开始出发，先检测其左子结点是否存在</li><li>如存在则将根节点和其右子节点断开，</li><li>将左子结点及其后面所有结构一起连到原右子节点的位置，</li><li>把原右子节点连到元左子结点最后面的右子节点之后</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                TreeNode p = cur.left;</span><br><span class="line">                <span class="keyword">while</span>(p.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    p = p.right;</span><br><span class="line">                &#125;</span><br><span class="line">                p.right = cur.right;</span><br><span class="line">                cur.right = cur.left;</span><br><span class="line">                cur.left = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="Lowest Common Ancestor of a Binary Tree"></a>Lowest Common Ancestor of a Binary Tree</h3><blockquote><p>给定两个结点，求最小公共祖先</p></blockquote><p><strong>代码</strong></p><pre><code>public class Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        //发现目标节点则通过返回值标记该子树发现了某个目标结点        if(root == null || root == p || root == q) return root;        //查看左子树中是否有目标结点，没有为null        TreeNode left = lowestCommonAncestor(root.left, p, q);        //查看右子树是否有目标节点，没有为null        TreeNode right = lowestCommonAncestor(root.right, p, q);        //都不为空，说明做右子树都有目标结点，则公共祖先就是本身        if(left!=null&amp;&amp;right!=null) return root;        //如果发现了目标节点，则继续向上标记为该目标节点        return left == null ? right : left;    }}</code></pre><h3 id="Binary-Tree-Longest-Consecutive-Sequence"><a href="#Binary-Tree-Longest-Consecutive-Sequence" class="headerlink" title="Binary Tree Longest Consecutive Sequence"></a>Binary Tree Longest Consecutive Sequence</h3><p>For example,</p><pre><code>1 \  3 / \2   4     \      5</code></pre><p>Longest consecutive sequence path is 3-4-5, so return 3.</p><pre><code>  2   \    3   /   2     / 1</code></pre><p>Longest consecutive sequence path is 2-3,not3-2-1, so return 2.</p><p><strong>解题思路</strong></p><ul><li>先序遍历</li><li>判断后一个结点是否比前一个结点的值大一</li><li>如果是则长度加1，否则长度重置为1，然后更新结果res</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> result = Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root, <span class="number">0</span>, root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> cur, TreeNode pre)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val == pre.val+<span class="number">1</span>)</span><br><span class="line">            cur++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur = <span class="number">1</span>;</span><br><span class="line">        result = Math.max(result, cur);</span><br><span class="line">        dfs(root.left, cur, root);</span><br><span class="line">        dfs(root.right, cur, root);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Recover-Binary-Search-Tree"><a href="#Recover-Binary-Search-Tree" class="headerlink" title="Recover Binary Search Tree"></a>Recover Binary Search Tree</h3><blockquote><p>二叉排序树中有两个节点被交换了，要求把树恢复成二叉排序树。空间复杂度为常数</p></blockquote><ul><li><p>递归中序遍历二叉树，空间复杂度是O(logn)，最差仍是O(n)</p><ul><li>设置一个pre指针，记录当前节点中序遍历时的前节点，</li><li>如果当前节点大于pre节点的值，说明需要调整次序。</li><li>有一个技巧是如果遍历整个序列过程中只出现了一次次序错误，说明就是这两个相邻节点需要被交换。</li></ul></li><li><p>非递归，空间复杂度是O(logn)，最差仍是O(n)</p><ul><li>栈</li><li>中序遍历</li></ul></li><li><p>Morris<br>待更新</p></li></ul><h3 id="Count-Complete-Tree-Nodes"><a href="#Count-Complete-Tree-Nodes" class="headerlink" title="Count Complete Tree Nodes"></a>Count Complete Tree Nodes</h3><p>最后一层结点可能是1～2^(树的深度-1)</p><ul><li>获得最左子树的深度和最右子树的深度，判断是否相同，相同则直接返回2^（深度）-1</li><li>如果不是，则递归计算左右子树，再加1</li></ul><h3 id="Binary-Tree-Maximum-Path-Sum"><a href="#Binary-Tree-Maximum-Path-Sum" class="headerlink" title="Binary Tree Maximum Path Sum"></a>Binary Tree Maximum Path Sum</h3><blockquote><p>路径至少包含一个结点，可以不包含根结点，求path中结点的值的最大和</p></blockquote><p>思路：递归求一条经过root的最大路径，这条路径可能是：</p><p>1) 左边某条路径 + root + 右边某条路径</p><p>2) 左边某条路径 + root</p><p>3) root + 右边某条路径</p><p>4) root</p><p><strong>对left和right与0比较，可MMath.max(maxValue, left + right + node.val)</strong></p><p>递归函数的返回值是<strong>以当前node为根的最大path sum</strong>,相当于local max<br>最后计算global的时候需要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxValue;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        maxValue = Integer.MIN_VALUE;</span><br><span class="line">        maxPathDown(root);</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxPathDown</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = Math.max(<span class="number">0</span>, maxPathDown(node.left));</span><br><span class="line">        <span class="keyword">int</span> right = Math.max(<span class="number">0</span>, maxPathDown(node.right));</span><br><span class="line">        maxValue = Math.max(maxValue, left + right + node.val);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + node.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Construct-Binary-Tree-from-Inorder-and-Preorder"><a href="#Construct-Binary-Tree-from-Inorder-and-Preorder" class="headerlink" title="Construct Binary Tree from Inorder and Preorder"></a>Construct Binary Tree from Inorder and Preorder</h3><ul><li>有两个矩阵，则对前序遍历的矩阵pre,根结点即为pre[0]</li><li>那么对应的中序遍历矩阵，找到根结点，假设是in[4]，那么in[0-3]即为左子树，in[5-length]即为右子树</li><li>递归即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length != inorder.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(<span class="number">0</span>,preorder.length-<span class="number">1</span>,preorder,<span class="number">0</span>,inorder.length-<span class="number">1</span>,inorder);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span> preStart,<span class="keyword">int</span> preEnd,<span class="keyword">int</span>[] preorder,<span class="keyword">int</span> instart,<span class="keyword">int</span> inEnd,<span class="keyword">int</span>[] inorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart&gt;preEnd || instart&gt;inEnd) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = instart; i &lt;= inEnd; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == root.val) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> lengthLeft = index - instart;</span><br><span class="line">        root.left = build(preStart+<span class="number">1</span>,preStart+lengthLeft,preorder,instart,index-<span class="number">1</span>,inorder);</span><br><span class="line">        root.right = build(preStart+lengthLeft+<span class="number">1</span>,preEnd,preorder,index+<span class="number">1</span>,inEnd,inorder);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Construct-Binary-Tree-from-Inorder-and-Postorder"><a href="#Construct-Binary-Tree-from-Inorder-and-Postorder" class="headerlink" title="Construct Binary Tree from Inorder and Postorder"></a>Construct Binary Tree from Inorder and Postorder</h3><ul><li>和上一个类似</li><li>对后序遍历的矩阵post,根结点即为post[length-1]</li><li>那么对应的中序遍历矩阵，找到根结点，假设是in[4]，那么in[0-3]即为左子树，in[5-length]即为右子树</li><li>递归即可</li></ul><h3 id="Unique-Binary-Search-Tree"><a href="#Unique-Binary-Search-Tree" class="headerlink" title="Unique Binary Search Tree"></a>Unique Binary Search Tree</h3><blockquote><p>当给定 n 时，要求出有 n 个节点的不重复的二叉查找树</p></blockquote><p><strong>动态规划</strong></p><ul><li>卡特兰数</li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/catalan.png" alt="avatar"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从节点数2开始计算到节点数为n的BST</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//计算根是第一个数的BST数量，直到根是最后一个数的BST数量，这里j可以理解为根左边的节点数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="comment">//有n的节点的BST一共有 G(n)=F(1,n-1)+F(2,n-1)+...+F(n-1,n-1)个</span></span><br><span class="line">                <span class="comment">//以i为根总共n个节点的BST有 F(i,n)=G(i-1)*G(i+1-&gt;n)个</span></span><br><span class="line">                <span class="comment">//BST形态数量之和一共有多少个节点有关 G(i+1-&gt;n)=G(n-i)</span></span><br><span class="line">                <span class="comment">//所以G(n)= G(0)*G(n-1)+G(1)*G(n-2)+...</span></span><br><span class="line">                dp[i] += dp[j] * dp[i - j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数学方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) </span><br><span class="line">         c = <span class="number">2</span>*(<span class="number">2</span>*i-<span class="number">1</span>)*c/(i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归</strong></p><ul><li>求出以 i 为根节点的所有不重复二叉查找树的和，其中 i 从 1 到 n。</li><li>当 i 为根节点时，1~i-1 都在根节点的左子树上，i+1~n 都在根节点的右子树上。</li><li>左右子树也都是二叉查找树。根据排列组合可以知道，当i为根节点时，不重复二叉查找树的数量因该是左子树的数量乘以右子树的数量。<strong>即Root( i ) = numTrees( i - 1 ) * numTrees( n - i )。</strong></li><li>numTrees( n ) = Root( 1 ) + Root( 2 ) + Root( 3 ) + …… + Root( n ).</li></ul><h3 id="Unique-Binary-Search-Tree-II"><a href="#Unique-Binary-Search-Tree-II" class="headerlink" title="Unique Binary Search Tree II"></a>Unique Binary Search Tree II</h3><blockquote><p>和上一题不一样在于需要输出所有情况</p></blockquote><ul><li>边界条件的处理<ul><li>当start &lt; end时，正常处理</li><li>当start = end时，说明只剩下一个数字可用，也就只有一种子树了</li><li>当start &gt; end时，说明上一个递归里选了start或者end做root，那么左右子树就是null，返回null</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; result = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            result.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;TreeNode&gt; left =  generateTrees(start, i-<span class="number">1</span>);</span><br><span class="line">            List&lt;TreeNode&gt; right = generateTrees(i+<span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; left.size(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; right.size(); k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root.left = left.get(j);</span><br><span class="line">                    root.right = right.get(k);</span><br><span class="line">                    result.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Binary-Tree遍历&quot;&gt;&lt;a href=&quot;#Binary-Tree遍历&quot; class=&quot;headerlink&quot; title=&quot;Binary Tree遍历&quot;&gt;&lt;/a&gt;Binary Tree遍历&lt;/h2&gt;&lt;p&gt;前序、中序、后序遍历&lt;/p&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="DFS" scheme="blog.jiangdongyu.space/tags/DFS/"/>
    
      <category term="BFS" scheme="blog.jiangdongyu.space/tags/BFS/"/>
    
      <category term="BinaryTree" scheme="blog.jiangdongyu.space/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>Greedy</title>
    <link href="blog.jiangdongyu.space/2018/04/11/Greedy/"/>
    <id>blog.jiangdongyu.space/2018/04/11/Greedy/</id>
    <published>2018-04-11T11:52:00.000Z</published>
    <updated>2018-05-28T11:06:45.196Z</updated>
    
    <content type="html"><![CDATA[<p>贪心的奥义就是每一步都选择<strong>当前</strong>回合”可见范围“（即可得知的信息）内的<strong>最优</strong>，而在每一步都仅选择当前回合”可见范围“内的最优这一策略下能够导致<strong>全局最优</strong>的结果的情况使用贪心就会是正确的，否则不适用贪心（或不适用当前对贪心中的最优的定义）。</p><p>因此，贪心一个点是选择<strong>当前最优</strong>，另一个点是这个最优要怎么定义，比如是选使得A最小的还是选使得A-B或A/B最小的等等。</p><p>贪心的正确性其实都要通过<strong>归纳法或反证法</strong>等手段进行严格地证明，而这也是算法分析课程的一个重要讲授内容。</p><a id="more"></a><h2 id="Jump-Game"><a href="#Jump-Game" class="headerlink" title="Jump Game"></a>Jump Game</h2><blockquote><p>For example:</p><p>A = [2,3,1,1,4], return true.</p><p>A = [3,2,1,0,4], return false.</p></blockquote><p>数组里的每个元素表示从该位置可以跳出的最远距离，要求问从第一个元素（index=0）开始，能否达到数组的最后一个元素</p><ul><li>贪心<ul><li>设一个值max，遍历更新max = Math.max(max,i+nums[i])</li><li>最后判断max是否大于等于nums.length-1</li></ul></li><li>动态规划<ul><li>dp[i] i处可到的最远距离</li><li>dp[i] = Math.max(dp[i-1],i+nums[i]) i可达</li><li>dp[i] = dp[i-1] i不可达</li></ul></li></ul><h2 id="Jump-Game-II"><a href="#Jump-Game-II" class="headerlink" title="Jump Game II"></a>Jump Game II</h2><blockquote><p>给定一个非负整数数组，给定的初始化位置在数组的起始位置。数组中的每个元素代表着你能都在此位置跳跃的最大的距离。你的目标是用最少的跳跃数达到数组的末尾</p></blockquote><ul><li>贪心<ul><li>一次循环判断，当前所能到达的最远位置</li><li>如果到不了当前位置，则step加1</li></ul></li></ul><ul><li>动态规划<ul><li>dp[i] 到达i处的最少步数</li><li>两重循环，dp[i]&gt;dp[j]+1 ？dp[i]=dp[j]+1：dp[i] （i &gt; j ,i from 0 to n, j+nums[j] &gt;= i）</li></ul></li></ul><h2 id="Gas-Station"><a href="#Gas-Station" class="headerlink" title="Gas Station"></a>Gas Station</h2><blockquote><p>在一个圆形路径上有N个加油站，在位置 i 上的汽油的数目为gas[i].</p></blockquote><blockquote><p>你有一个汽车，这个汽车的油箱是无限容量的，它从加油站 i 到 加油站 （i+1）需要耗费的汽油数为cost[i]. 开始这段旅程的时候，你的起始状态是在加油站中的一个，油箱为空的.</p></blockquote><blockquote><p>若一次性完成整个的圆形路途，返回你的其实加油站的序号，若不能完成整个路途，返回-1.</p></blockquote><ol><li><p>如果total为<strong>负数</strong>，则无论如何都开不完一圈。</p></li><li><p><strong>如果从一个加油站i出发，开到加油站j所属路段的时候油耗尽，那么从i,j之间的任一个加油站出发都会在j路段或j之前路段耗尽油(相邻的加油站到达必须剩余油量&gt;=0)</strong></p></li></ol><ul><li>循环计算走一环的total和到某站点i的sum</li><li>如果sum&lt;0，则开始的站点变为i+1</li><li>最后判断total</li></ul><h2 id="Candy"><a href="#Candy" class="headerlink" title="Candy"></a>Candy</h2><blockquote><p>多个小朋友站成一排，根据他们的得分分发糖果，得分高的小朋友要比旁边得分低的小朋友得到的糖果多，每个小朋友至少得到一枚糖果，问最少要准备多少糖果？</p></blockquote><ul><li>每个人初始为1</li><li>先从左到右扫描一遍，使得右边比左边得分高的小朋友糖果数比左边多。</li><li>再从右到左扫描一遍，使得左边比右边得分高的小朋友糖果数比右边多。</li></ul><h2 id="Product-of-Array-Except-Self"><a href="#Product-of-Array-Except-Self" class="headerlink" title="Product of Array Except Self"></a>Product of Array Except Self</h2><blockquote><p>除本身之外的数组之积 O(n) 不能用除法</p></blockquote><ul><li>两次遍历</li><li>对result[i]来说，先保存从左到右计算0 ~ i-1的乘积x</li><li>再从右到左计算i+1 ~ n的乘积y,计算x与y的乘积即可</li></ul><h2 id="Meeting-Rooms-II"><a href="#Meeting-Rooms-II" class="headerlink" title="Meeting Rooms II"></a>Meeting Rooms II</h2><p>因为要知道之前有overlap的最小的end，所以可以用一个<strong>min heap</strong>。每次检查<strong>新的start是否比heap的top元素小，是的话就把保存原来的end，同时放进新的end；否则就放新的end同时poll出原来的</strong>，因为没有overlap且新的end较大。最后heap的大小就是需要的房间数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(Interval[] intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(intervals==<span class="keyword">null</span>||intervals.length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;Interval&gt;()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Interval i1, Interval i2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i1.start-i2.start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Arrays.sort可替换成：</span></span><br><span class="line">    <span class="comment">//Arrays.sort(intervals, (a, b) -&gt; a.start == b.start ? a.end - b.end : a.start - b.start);</span></span><br><span class="line"> </span><br><span class="line">    PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">    queue.offer(intervals[<span class="number">0</span>].end);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;intervals.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals[i].start &gt;= queue.peek())&#123;</span><br><span class="line">            queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        queue.offer(intervals[i].end);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> queue.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Task-Scheduler"><a href="#Task-Scheduler" class="headerlink" title="Task Scheduler"></a>Task Scheduler</h2><blockquote><p>安排CPU的任务，规定在两个相同任务之间至少隔n个时间点</p></blockquote><p>Input: tasks = [‘A’,’A’,’A’,’B’,’B’,’B’], n = 2</p><p>Output: 8</p><p>Explanation: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B.</p><p>我们首先考虑出现<strong>频率最高</strong>的task，我们仍假设为A，出现的频率为x，我们知道，要满足A的时间需求，我们至少应该有 x-1个n的间隔。对于频率小于x的任务，假设为B，我们按序插入任务B，可以发现，这样的插入也是满足要求的。</p><p>AB-AB-AB<br><strong>模块的次数为任务最大次数减1，模块的长度为n+1，最后加上的字母个数为出现次数最多的任务，可能有多个并列。</strong></p><p>如例题中模块AB-的次数为2，长度为3，结果即为2*3+2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> t : tasks)&#123;  </span><br><span class="line">            c[t - <span class="string">'A'</span>]++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        Arrays.sort(c);  </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">25</span>;  </span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; c[i] == c[<span class="number">25</span>]) i--;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> Math.max(tasks.length, (c[<span class="number">25</span>] - <span class="number">1</span>) * (n + <span class="number">1</span>) + <span class="number">25</span> - i);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;贪心的奥义就是每一步都选择&lt;strong&gt;当前&lt;/strong&gt;回合”可见范围“（即可得知的信息）内的&lt;strong&gt;最优&lt;/strong&gt;，而在每一步都仅选择当前回合”可见范围“内的最优这一策略下能够导致&lt;strong&gt;全局最优&lt;/strong&gt;的结果的情况使用贪心就会是正确的，否则不适用贪心（或不适用当前对贪心中的最优的定义）。&lt;/p&gt;
&lt;p&gt;因此，贪心一个点是选择&lt;strong&gt;当前最优&lt;/strong&gt;，另一个点是这个最优要怎么定义，比如是选使得A最小的还是选使得A-B或A/B最小的等等。&lt;/p&gt;
&lt;p&gt;贪心的正确性其实都要通过&lt;strong&gt;归纳法或反证法&lt;/strong&gt;等手段进行严格地证明，而这也是算法分析课程的一个重要讲授内容。&lt;/p&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Array" scheme="blog.jiangdongyu.space/tags/Array/"/>
    
      <category term="DynamicProgramming" scheme="blog.jiangdongyu.space/tags/DynamicProgramming/"/>
    
      <category term="Greedy" scheme="blog.jiangdongyu.space/tags/Greedy/"/>
    
      <category term="Sort" scheme="blog.jiangdongyu.space/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>腾讯云</title>
    <link href="blog.jiangdongyu.space/2018/04/10/%E8%85%BE%E8%AE%AF%E4%BA%91/"/>
    <id>blog.jiangdongyu.space/2018/04/10/腾讯云/</id>
    <published>2018-04-10T03:26:00.000Z</published>
    <updated>2018-05-28T10:55:17.542Z</updated>
    
    <content type="html"><![CDATA[<p>腾讯云后台开发实习生暑期实习面试<br><a id="more"></a></p><ul><li>介绍项目</li><li>多线程的实现方式，线程的状态<ul><li>new Thread / implements Runnable</li></ul></li><li>gc,什么时候gc，内存溢出<ul><li><a href="http://blog.jiangdongyu.space/2018/03/18/Java%20JVM/">Java GC</a></li></ul></li><li>Linux指令，怎么查看内存线程使用情况</li><li>Mysql索引，group by &amp; union</li><li>TCP的…四次挥手，为什么等待2MSL?</li><li>用过哪些大数据框架</li><li>怎么判断一棵二叉树是镜像的？<ul><li>层次遍历，每次取左子树左右结点，右子树右左结点，判断是否相同</li></ul></li><li><p>栈实现O(1)获得最小的数getMin()</p><ul><li>非常棒的一道题。原理很简单，但是需要思考清楚为什么可以。原理可以参考下图：<br><img src="http://p9fh1pach.bkt.clouddn.com/%E6%A0%88%E6%9C%80%E5%B0%8F.png" alt="avatar"></li><li>准备两个栈，一个正常栈，一个辅助栈，正常栈做pop和push。辅助栈push更新最小值，pop出正常栈的最小值。</li><li>过程很简单，当正常栈push的时候，查看辅助栈的栈顶元素，如果是比辅助栈栈顶还小或者等于，那么更新到栈顶。否则不加如辅助栈。<ul><li>当正常栈做pop，查看辅助栈栈顶是否相等，相等的话一起pop，否则不动。</li></ul></li><li><p>PS：注意当做push的时候，辅助栈栈顶元素和新元素相等，还是要入栈，因为再做pop把元素出栈后，正常栈其实后面还是有这个元素。</p></li><li><p>原理：其实就是类似动态规划的原理，辅助栈里的元素，全是到正常栈该元素位置的最小值是谁。所以除非正常栈做出栈弹出到这个值，否则辅助栈的栈顶就是当前的最小值。</p></li></ul></li><li>1000瓶水，1瓶有毒，一只小白鼠喝了有毒的一周死亡，现给10只小白鼠一周时间，怎么做？<ul><li>二进制 标记</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;腾讯云后台开发实习生暑期实习面试&lt;br&gt;
    
    </summary>
    
      <category term="实习面试经历" scheme="blog.jiangdongyu.space/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    
      <category term="2018" scheme="blog.jiangdongyu.space/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>今日头条</title>
    <link href="blog.jiangdongyu.space/2018/04/09/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1/"/>
    <id>blog.jiangdongyu.space/2018/04/09/今日头条/</id>
    <published>2018-04-09T03:26:00.000Z</published>
    <updated>2018-05-28T10:50:42.629Z</updated>
    
    <content type="html"><![CDATA[<p>今日头条后台开发面试<br><a id="more"></a></p><ul><li>自我介绍</li><li>给定一个结点，确定二叉树中序遍历的后继结点（结点有左指针，右指针，父亲指针）<ul><li>判断是否有右子树，有就找右子树最左的结点</li><li>没有，则不断找父亲结点，直到当前结点是父亲结点的左孩子</li></ul></li><li>介绍项目</li><li>hashmap的equals和hashcode方法，怎么判断key存在（底层）<ul><li>首先<strong>hash(key)得到key的hashcode()</strong>，hashmap根据获得的hashcode找到要插入的位置所在的链，在这个链里面放的都是hashcode相同的Entry键值对，在找到这个链之后，会通过<strong>equals()</strong>方法判断是否已经存在要插入的键值对，而这个equals比较的其实就是key。</li><li>判断key是否存在的时候是先比较key的hashCode，再比较相等或equals的</li></ul></li><li>Http的keep-alive长连接的特性，多个json怎么区分（content-length）</li><li>数据库事务的一致性<ul><li>事务执行前与执行后数据内在的逻辑始终是成立的。比如转账前与转账后两人存款的总和始终不变。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今日头条后台开发面试&lt;br&gt;
    
    </summary>
    
      <category term="实习面试经历" scheme="blog.jiangdongyu.space/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    
      <category term="2018" scheme="blog.jiangdongyu.space/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="blog.jiangdongyu.space/2018/04/07/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>blog.jiangdongyu.space/2018/04/07/位运算/</id>
    <published>2018-04-07T09:52:00.000Z</published>
    <updated>2018-05-28T11:08:01.315Z</updated>
    
    <content type="html"><![CDATA[<p><strong>例题</strong></p><h2 id="XOR相关"><a href="#XOR相关" class="headerlink" title="XOR相关"></a>XOR相关</h2><h3 id="Single-Number"><a href="#Single-Number" class="headerlink" title="Single Number"></a>Single Number</h3><blockquote><p>找到数组中只出现一次的元素，其它出现两次，不用额外内存<br>异或XOR ^ </p></blockquote><a id="more"></a><p><strong>Concept</strong></p><ul><li>If we take XOR of zero and some bit, it will return that bit<ul><li>a⊕0=a</li></ul></li><li>If we take XOR of two same bits, it will return 0<ul><li>a⊕a=0</li></ul></li><li>a⊕b⊕a=(a⊕a)⊕b=0⊕b=b</li></ul><h3 id="Single-Number-II"><a href="#Single-Number-II" class="headerlink" title="Single Number II"></a>Single Number II</h3><blockquote><p>找到数组中只出现一次的元素，其它出现三次，不用额外内存</p></blockquote><p>利用只出现3次的特性，模3的值只可能是0或1，则第一次出现存在ones中，第二次出现存在twos中，同时清掉ones的值，第三次出现，存在ones中，但twos中有了，同时清掉ones，twos的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++)&#123;</span><br><span class="line">        ones = (ones ^ A[i]) &amp; ~twos;</span><br><span class="line">        twos = (twos ^ A[i]) &amp; ~ones;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Single-Number-III"><a href="#Single-Number-III" class="headerlink" title="Single Number III"></a>Single Number III</h3><blockquote><p>2n+2的数组，每个元素出现两次，除了两个只出现一次的数，找到这两个数</p><p>time O(n) space O(1)</p></blockquote><ul><li>遍历数组异或，得到两个只出现一次的数异或之后的值x</li><li>将该值x与~(x-1)相与，获得最后几位不同的数值y</li><li>初始化返回数组，res[2]={0,0}</li><li>遍历数组，判断num[i]&amp;y == 0? res[0]^num[i]:res[1]^num[i]</li></ul><h3 id="Missing-Number"><a href="#Missing-Number" class="headerlink" title="Missing Number"></a>Missing Number</h3><blockquote><p>给定一个0-n每个元素都不同的数组，数组元素缺了一个，比如0，1，3，缺了2，找到缺少的那个数</p></blockquote><ul><li>对0-n做异或得x</li><li>对数组做异或得y</li><li>返回x^y</li></ul><h2 id="amp-相关"><a href="#amp-相关" class="headerlink" title="&amp;相关"></a>&amp;相关</h2><h3 id="Count-of-1-bits"><a href="#Count-of-1-bits" class="headerlink" title="Count of 1 bits"></a>Count of 1 bits</h3><blockquote><p>给定一个整数，求该整数二进制表示时1的个数</p></blockquote><h4 id="检查每一位是否是1，右移"><a href="#检查每一位是否是1，右移" class="headerlink" title="检查每一位是否是1，右移"></a>检查每一位是否是1，右移</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countSetBits</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         count += n &amp; <span class="number">1</span>;</span><br><span class="line">         n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="bitwise"><a href="#bitwise" class="headerlink" title="bitwise"></a>bitwise</h4><p>从integer减1时，从右往左所有0变1，将最右边1变为0</p><p>比如110100 减1 得110011，对这两个数做&amp;，变为110000</p><p>所以n &amp; (n-1)可以将n的最后一个1消掉，用while判断是否消掉所有的1</p><h3 id="Power-of-Two"><a href="#Power-of-Two" class="headerlink" title="Power of Two"></a>Power of Two</h3><blockquote><p>给定一个整数，判断是否是2的次方</p></blockquote><p>2的power只有一位是1，利用n &amp; (n-1)将1消掉，接着判断是否为0</p><h2 id="Shift相关"><a href="#Shift相关" class="headerlink" title="Shift相关"></a>Shift相关</h2><h3 id="Reverse-Bits"><a href="#Reverse-Bits" class="headerlink" title="Reverse Bits"></a>Reverse Bits</h3><blockquote><p>0100 -&gt; 0010</p></blockquote><p>32位整数，循环32次，将当前bit赋值给res,整数右移，res左移</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>;i++)&#123;</span><br><span class="line">            res = (res&lt;&lt;<span class="number">1</span>) | (n&amp;<span class="number">1</span>);</span><br><span class="line">            n = n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Math相关"><a href="#Math相关" class="headerlink" title="Math相关"></a>Math相关</h2><h3 id="Bitwise-AND-of-Numbers-Range"><a href="#Bitwise-AND-of-Numbers-Range" class="headerlink" title="Bitwise AND of Numbers Range"></a>Bitwise AND of Numbers Range</h3><blockquote><p>给定范围[m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回范围内所有整数的按位与，包括边界。</p></blockquote><p>例如，给定范围[5, 7], 你应该返回4。</p><ul><li>[m, n]范围的按位与的结果为m与n的公共“左边首部（left header）”</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m!=n)&#123;</span><br><span class="line">            m = m&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            n = n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m&lt;&lt;count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;例题&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;XOR相关&quot;&gt;&lt;a href=&quot;#XOR相关&quot; class=&quot;headerlink&quot; title=&quot;XOR相关&quot;&gt;&lt;/a&gt;XOR相关&lt;/h2&gt;&lt;h3 id=&quot;Single-Number&quot;&gt;&lt;a href=&quot;#Single-Number&quot; class=&quot;headerlink&quot; title=&quot;Single Number&quot;&gt;&lt;/a&gt;Single Number&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;找到数组中只出现一次的元素，其它出现两次，不用额外内存&lt;br&gt;异或XOR ^ &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Math" scheme="blog.jiangdongyu.space/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList</title>
    <link href="blog.jiangdongyu.space/2018/04/07/LinkedList/"/>
    <id>blog.jiangdongyu.space/2018/04/07/LinkedList/</id>
    <published>2018-04-07T09:52:00.000Z</published>
    <updated>2018-05-28T11:13:52.572Z</updated>
    
    <content type="html"><![CDATA[<ul><li>dummy node的运用</li><li>merge linked list一定要会</li></ul><p><strong>题目列表</strong><br>LinkedList题大体可分为三类：reverse类、Merge类、快慢针类<br><a id="more"></a></p><ul><li>Rotate List</li><li>Copy list with random pointers</li><li>Convert sorted list to Binary Search Tree </li><li>Remove Duplicates</li><li>Remove Duplicates II</li><li>Add Two Numbers</li><li>insertion sort list use a dummy node to add node to new list one at a time</li></ul><p><strong>reverse类</strong></p><ul><li>reverse linked list </li><li>reverse print list</li><li>reverse nodes in k group </li><li>swap nodes in pairs </li><li>palindrome list</li><li>reorder list</li></ul><p><strong>Merge类</strong></p><ul><li>merge linked list </li><li>merge K sorted List</li></ul><p><strong>快慢针类</strong></p><ul><li>list cycle I, II</li><li>get kth node ( get middle node)</li><li>intersection of two lists</li><li>remove nth node from end of list</li></ul><h2 id="Add-Two-Numbers"><a href="#Add-Two-Numbers" class="headerlink" title="Add Two Numbers"></a>Add Two Numbers</h2><blockquote><p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</p><p>Output: 7 -&gt; 0 -&gt; 8</p><p>Explanation: 342 + 465 = 807.</p></blockquote><p>dummy node的使用，sum &amp; carry</p><p>最后要对carry进行判断</p><h2 id="Remove-Duplicates"><a href="#Remove-Duplicates" class="headerlink" title="Remove Duplicates"></a>Remove Duplicates</h2><blockquote><p>For example,</p><p>Given 1-&gt;1-&gt;2, return 1-&gt;2.</p><p>Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.</p></blockquote><p>保留重复的值，可用cur = head,判断cur.val == cur.next.val ? </p><h2 id="Remove-Duplicates-II"><a href="#Remove-Duplicates-II" class="headerlink" title="Remove Duplicates II"></a>Remove Duplicates II</h2><blockquote><p>For example,</p><p>Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.</p><p>Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3.</p></blockquote><p>删除重复的值，需要dummy node，cur = dummy,需要记录cur.next.val进行循环删除</p><h2 id="Merge类"><a href="#Merge类" class="headerlink" title="Merge类"></a>Merge类</h2><h3 id="Merge-Two-Sorted-Lists"><a href="#Merge-Two-Sorted-Lists" class="headerlink" title="Merge Two Sorted Lists"></a>Merge Two Sorted Lists</h3><ul><li>递归</li><li>非递归</li></ul><h3 id="Merge-K-Sorted-Lists"><a href="#Merge-K-Sorted-Lists" class="headerlink" title="Merge K Sorted Lists"></a>Merge K Sorted Lists</h3><ul><li>二分+递归</li><li>使用堆（优先队列），将K个链表的头结点全部添加到队列，由于优先级队列采用了最小堆数据结构，堆顶为队列的最小元素，我们将其取出添加到结果链表中，取出元素对应的链表下移一个节点，并将这个节点添加到优先级队列中；然后我们继续取出堆顶元素，…，直到优先级队列为空，那么其中所有元素取尽，K个链表的元素已经全部排序到结果链表。</li></ul><h2 id="快慢针类"><a href="#快慢针类" class="headerlink" title="快慢针类"></a>快慢针类</h2><h3 id="List-Cycle"><a href="#List-Cycle" class="headerlink" title="List Cycle"></a>List Cycle</h3><ul><li>快慢指针，最后是否相遇 fast.next != null &amp;&amp; fast.next.next != null</li></ul><h3 id="List-Cycle-II"><a href="#List-Cycle-II" class="headerlink" title="List Cycle II"></a>List Cycle II</h3><blockquote><p>找到环开始的地方</p></blockquote><p><img src="http://p9fh1pach.bkt.clouddn.com/List%20Cycle%20II.png" alt="avatar"></p><p>假设从起点到环开始的地方长度为x,相遇点距离环起点为k，环长为L</p><p>d = x + m*L + k</p><p>2d = x + n*L +k</p><p>则 x + (2m -n)*L +k = 0</p><p>所以 x = (L-k) + (n-2m-1)*L</p><p>所以 一指针从开始出发，一指针从相遇点出发，最终会在环开始的地方相遇</p><h3 id="Remove-Nth-Node-From-End"><a href="#Remove-Nth-Node-From-End" class="headerlink" title="Remove Nth Node From End"></a>Remove Nth Node From End</h3><blockquote><p>删除从尾部开始数的第n个结点</p></blockquote><ul><li>快慢指针，快指针先走n步</li></ul><h3 id="Partition-List"><a href="#Partition-List" class="headerlink" title="Partition List"></a>Partition List</h3><blockquote><p>给定一个链表，一个整数x，将链表分开确定一边比x小，另一表不小于x，并保持原来的链表的相对顺序</p></blockquote><ul><li>需要dummy node</li><li>可以新建一个链表用来存小于x的node,并将原来对应的node删掉，最后将原来的list接在现在的之后</li></ul><h2 id="reverse类"><a href="#reverse类" class="headerlink" title="reverse类"></a>reverse类</h2><h3 id="Reverse-Linked-List"><a href="#Reverse-Linked-List" class="headerlink" title="Reverse Linked List"></a>Reverse Linked List</h3><ul><li>头插法</li><li>递归</li></ul><h3 id="Reverse-Linked-List-II"><a href="#Reverse-Linked-List-II" class="headerlink" title="Reverse Linked List II"></a>Reverse Linked List II</h3><blockquote><p>将链表m到n的位置的结点逆置</p></blockquote><ul><li>dummy node</li><li>找到开始反转的前一个node pre 维持不变，以及找到真正开始反转的结点start，下一个结点 then</li></ul><h3 id="Palindrome-List"><a href="#Palindrome-List" class="headerlink" title="Palindrome List"></a>Palindrome List</h3><ul><li>双指针，判断fast.next是否为null，不是则slow = slow.next</li><li>对slow进行逆置</li><li>一一比较两个链表的值</li></ul><h3 id="Swap-Nodes-in-Pairs"><a href="#Swap-Nodes-in-Pairs" class="headerlink" title="Swap Nodes in Pairs"></a>Swap Nodes in Pairs</h3><blockquote><p>For example,<br>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p></blockquote><ul><li>dummy node</li><li>三个node的使用，cur first second </li><li>cur = cur.next.next</li></ul><h3 id="Reorder-List"><a href="#Reorder-List" class="headerlink" title="Reorder List"></a>Reorder List</h3><blockquote><p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,</p><p>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p></blockquote><ul><li>找到中点，前半部分结尾设为null</li><li>将后半部分reverse</li><li>再merge</li></ul><h2 id="Rotate-List"><a href="#Rotate-List" class="headerlink" title="Rotate List"></a>Rotate List</h2><blockquote><p>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,</p></blockquote><blockquote><p>return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.</p></blockquote><ul><li>two pointer</li><li>找到length-k个，注意k可能大于length(%),并将next设为null</li><li>将原来链表的end的next设为head</li><li>返回原来的length-k+1个</li></ul><h2 id="Copy-List-with-Random-Pointer"><a href="#Copy-List-with-Random-Pointer" class="headerlink" title="Copy List with Random Pointer"></a>Copy List with Random Pointer</h2><blockquote><p>如果要copy一个带有random pointer的list，主要的问题就是有可能这个random指向的位置还没有被copy到，所以解决方法都是多次扫描list。</p></blockquote><p><strong>使用HashMap，HashMap的key存原始pointer，value存新的pointer。</strong></p><ul><li>hashmap，一次遍历put(node,new RandomListNode(node.label))</li><li>再次遍历，对next，random指针进行修改</li></ul><p><strong>3次遍历list，时间复杂度为O(3n)=O(n)。</strong></p><ul><li><p>对每个node进行复制，并插入其原始node的后面，新旧交替，变成重复链表。如：原始：1-&gt;2-&gt;3-&gt;null，复制后：1-&gt;1-&gt;2-&gt;2-&gt;3-&gt;3-&gt;null</p></li><li><p>遍历每个旧node，把旧node的random的复制给新node的random，因为链表已经是新旧交替的。所以复制方法为：</p><pre><code>node.next.random = node.random.next</code></pre><p>前面是说旧node的next的random，就是新node的random，后面是旧node的random的next，正好是新node，是从旧random复制来的。</p></li><li><p>把新旧两个表拆开，返回新的表即可。</p></li></ul><h2 id="Convert-Sorted-List-to-Binary-Search-Tree"><a href="#Convert-Sorted-List-to-Binary-Search-Tree" class="headerlink" title="Convert Sorted List to Binary Search Tree"></a>Convert Sorted List to Binary Search Tree</h2><p><strong>递归</strong></p><ul><li>找到中点</li><li>递归</li></ul><p><strong>中序遍历</strong></p><p>左子树-根-右子树</p><h2 id="Intersection-of-Two-Linked-List"><a href="#Intersection-of-Two-Linked-List" class="headerlink" title="Intersection of Two Linked List"></a>Intersection of Two Linked List</h2><p>For example, the following two linked lists:</p><blockquote><p>A:          a1 → a2 → c1 → c2 → c3  </p><p>B:      b1 → b2 → b3 → c1 → c2 → c3 </p></blockquote><p>begin to intersect at node c1.</p><p>获得两个链表的长度差x，较长的先往前x，再一起往前，直到相等</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;dummy node的运用&lt;/li&gt;
&lt;li&gt;merge linked list一定要会&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;题目列表&lt;/strong&gt;&lt;br&gt;LinkedList题大体可分为三类：reverse类、Merge类、快慢针类&lt;br&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LinkedList" scheme="blog.jiangdongyu.space/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>HashMap &amp; ConcurrentHashMap</title>
    <link href="blog.jiangdongyu.space/2018/04/03/HashMap&amp;ConcurrentHashMap/"/>
    <id>blog.jiangdongyu.space/2018/04/03/HashMap&amp;ConcurrentHashMap/</id>
    <published>2018-04-03T08:23:00.000Z</published>
    <updated>2018-05-28T10:56:58.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashMap实现原理"><a href="#HashMap实现原理" class="headerlink" title="HashMap实现原理"></a>HashMap实现原理</h2><p>HashMap即是采用了链地址法，也就是<strong>数组+链表</strong>的方式</p><p>HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。</p><a id="more"></a><p>所以，HashMap的整体结构如下</p><p><img src="http://p9fh1pach.bkt.clouddn.com/1024555-20161113235348670-746615111.png" alt="avatar"></p><p>简单来说，HashMap由数组+链表组成的，<strong>数组</strong>是HashMap的<strong>主体</strong>，<strong>链表</strong>则是主要为了解决<strong>哈希冲突</strong>而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度依然为O(1)，因为最新的Entry会插入链表头部，仅需简单改变引用链即可，而对于查找操作来讲，此时就需要遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的<strong>链表出现越少，性能才会越好</strong>。</p><p>其他几个重要字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际存储的key-value键值对的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//阈值，当table == &#123;&#125;时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//负载因子，代表了table的填充度有多少，默认是0.75</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationException</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><p>HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值</p><p><strong>initialCapacity默认为16，loadFactory默认为0.75</strong></p><p><strong>在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果table数组为空数组&#123;&#125;，进行数组填充（为table分配实际内存空间），入参为threshold，此时threshold为initialCapacity 默认是1&lt;&lt;4(24=16)</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果key为null，存储位置为table[0]或table[0]的冲突链上</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);<span class="comment">//对key的hashcode进一步计算，确保散列均匀</span></span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">//获取在table中的实际位置</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="comment">//如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value</span></span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    modCount++;<span class="comment">//保证并发访问时，若HashMap内部结构发生变化，快速响应失败</span></span><br><span class="line">    addEntry(hash, key, value, i);<span class="comment">//新增一个entry</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。</p><p><strong>HashMap的数组长度一定是2的次幂</strong></p><ul><li>如果数组进行扩容，数组长度发生变化，而存储位置 index = h&amp;(length-1),index也可能会发生变化，需要重新计算index</li><li>扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)</li><li>数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀</li></ul><p><strong>多线程下使用HashMap</strong></p><p>JDK1.7 存在死循环</p><h2 id="ConcurrentHashMap实现原理"><a href="#ConcurrentHashMap实现原理" class="headerlink" title="ConcurrentHashMap实现原理"></a>ConcurrentHashMap实现原理</h2><p><strong>分段锁</strong></p><p><img src="http://p9fh1pach.bkt.clouddn.com/1024555-20170514174100832-1891630860.png" alt="avatar"></p><p>ConcurrentHashMap采用了非常精妙的”分段锁”策略，ConcurrentHashMap的主干是个Segment数组。</p><p>在ConcurrentHashMap，一个Segment就是一个<strong>子哈希表</strong>，Segment里维护了一个HashEntry数组，并发环境下，对于不同Segment的数据进行操作是不用考虑锁竞争的。</p><p>所以，对于<strong>同一个Segment的操作才需考虑线程同步，不同的Segment则无需考虑</strong>。</p><p>Segment数组的大小ssize是由concurrentLevel来决定的，但是却不一定等于concurrentLevel，ssize一定是大于或等于concurrentLevel的最小的2的次幂。</p><p>put的主要逻辑也就两步：</p><p>1.定位segment并确保定位的Segment已初始化 </p><p>2.调用Segment的put方法。</p><p>Segment的get方法无需加锁，由于其中涉及到的共享变量都使用<strong>volatile</strong>修饰，volatile可以保证<strong>内存可见性</strong>，所以不会读取到过期数据。</p><p>Segment上的put方法，Segment中的put方法是要<strong>加锁</strong>的。只不过是<strong>锁粒度细</strong>了而已。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HashMap实现原理&quot;&gt;&lt;a href=&quot;#HashMap实现原理&quot; class=&quot;headerlink&quot; title=&quot;HashMap实现原理&quot;&gt;&lt;/a&gt;HashMap实现原理&lt;/h2&gt;&lt;p&gt;HashMap即是采用了链地址法，也就是&lt;strong&gt;数组+链表&lt;/strong&gt;的方式&lt;/p&gt;
&lt;p&gt;HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。&lt;/p&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="Map" scheme="blog.jiangdongyu.space/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>Math相关</title>
    <link href="blog.jiangdongyu.space/2018/04/02/%E6%95%B0%E5%AD%A6%E6%93%8D%E4%BD%9C/"/>
    <id>blog.jiangdongyu.space/2018/04/02/数学操作/</id>
    <published>2018-04-02T10:35:00.000Z</published>
    <updated>2018-05-28T11:07:42.688Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题型总结</strong></p><ul><li><p>第一种类型是最简单的， 就是对整数进行直接操作， 一般来说就是逐位操作， 比如反转， 比较等。 LeetCode中这类题目有Palindrome Number和Reverse Integer。</p></li><li><p>第二种题型是算术运算的题目， 比如乘除法， 阶乘， 开方等， LeetCode中这类题目有Sqrt(x)， Pow(x, n)和Divide Two Integers。 这种题目有时候看似复杂， 其实还是有几个比较通用的解法的， 下面主要介绍三种方法：</p><ul><li>二分法</li><li>牛顿法</li><li>位移法</li></ul></li><li>第三种题目是解析几何的题目， 一般来说解析几何题目的模型都比较复杂， 而且实现细节比较多， 在面试中并不常见， LeetCode中也只有Max Points on a Line是属于这种题型。</li></ul><h2 id="Math-without-Operator"><a href="#Math-without-Operator" class="headerlink" title="Math without Operator"></a>Math without Operator</h2><blockquote><p>不用operator进行数学运算</p></blockquote><a id="more"></a><h3 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h3><ul><li>对于乘除的题目，&lt;&lt;1是乘2，&gt;&gt;1是除以2</li><li>对于加减的题目，a ^ b得到sum，a &amp; b得到carry</li></ul><h3 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h3><ul><li>正负问题</li><li>是否会overflow,int的取值范围 -2147483648 ～ 2147473647</li></ul><hr><p><strong>例题</strong></p><h4 id="Divide-Two-Integers"><a href="#Divide-Two-Integers" class="headerlink" title="Divide Two Integers"></a>Divide Two Integers</h4><blockquote><p>不用乘法，除法，取余实现除法</p></blockquote><ul><li>不断减去被除数，直至小于除数，会超时</li><li>任何一个数，都可以表示成：(2^k)*除数 &lt;=  当前被除数 &lt;(2^(k+1))*除数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (divd &gt;= divs) &#123;</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// keep multiply by 2 until divs &gt; divd</span></span><br><span class="line">    <span class="keyword">while</span> (divd &gt;= (divs &lt;&lt; counter)) &#123; </span><br><span class="line">         counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// rollback counter so that (divs&lt;&lt;counter) &lt;= divd </span></span><br><span class="line">    counter--;  </span><br><span class="line">    <span class="comment">// quotient</span></span><br><span class="line">    ret += <span class="number">1</span> &lt;&lt; counter;  </span><br><span class="line">    divd -= divs &lt;&lt; counter;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="Ugly-Number"><a href="#Ugly-Number" class="headerlink" title="Ugly Number"></a>Ugly Number</h4><p>I：判断是否是丑数</p><ul><li>如果ugly number能被2,3或者5整除，那么就除以可以整除的</li><li>如果不能被2,3,􏰏5其中一个整除，则说明不是ugly number</li><li>ugly number应该可以一直被除到1，此时可以结束，说明这个数是ugly number</li></ul><p>II:找到n-th的ugly number丑陋数列可以拆分为下面3个子列表</p><blockquote><p>(1)1x2,2x2,3x2,4x2,5x2,…</p><p>(2)1x3,2x3,3x3,4x3,5x3,…</p><p>(3)1x5,2x5,3x5,4x5,5x5,…</p></blockquote><ul><li>我们􏰤􏰥发现每一个子列表都是ugly number本身(1, 2, 3, 4, 5, …) 乘以2, 3, 5</li><li>使用与归并相似的合并方法，从3个子列表中获得ugly number。每一步获得最小的，然后后移。</li><li>三个指针p2,p3,p5分别代表下一次乘以2,3,5的来比较ugly number的index，如果用过了就指向下一个ugly number</li></ul><h4 id="Add-Digits-Digit-root"><a href="#Add-Digits-Digit-root" class="headerlink" title="Add Digits (Digit root)"></a>Add Digits (Digit root)</h4><blockquote><p>如38，3+8 = 11，1+1=2</p></blockquote><p>num%9运算即可</p><h4 id="Add-Binary"><a href="#Add-Binary" class="headerlink" title="Add Binary"></a>Add Binary</h4><p>从后往前不断加，类似merge two list</p><h4 id="Trailing-Zeros"><a href="#Trailing-Zeros" class="headerlink" title="Trailing Zeros"></a>Trailing Zeros</h4><blockquote><p>n!中有几个0</p></blockquote><p>0的多少与2和5有关，而2比5多，因此只关心5即可</p><p><strong>解题方法</strong></p><ul><li>n / 5,得到所有5的一次方的数量，加到结果</li><li>n/ (5^2)，得到所有5的二次方的数量，加到结果</li><li>5的三次方…</li><li>直到n不大于下一个5的k次方则停止</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTrailingZeros</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">// Initialize result</span></span><br><span class="line">     <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Keep dividing n by powers of 5 and update count</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">5</span>; n/i&gt;=<span class="number">1</span>; i *= <span class="number">5</span>)</span><br><span class="line">          count += n/i;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Palindrome-Number"><a href="#Palindrome-Number" class="headerlink" title="Palindrome Number"></a>Palindrome Number</h4><blockquote><p>不用额外空间</p></blockquote><p>用数学方法不断获得最大位和最小位，比较之后去掉，同时除数大小也要调整</p><h4 id="Cont-Primes"><a href="#Cont-Primes" class="headerlink" title="Cont Primes"></a>Cont Primes</h4><p><a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Algorithm_complexity" target="_blank" rel="noopener">Sieve of Eratosthenes</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: an integer n &gt; 1.</span><br><span class="line"> </span><br><span class="line">Let A be an array of Boolean values, indexed by integers 2 to n,</span><br><span class="line"> initially all set to true.</span><br><span class="line"> </span><br><span class="line">for i = 2, 3, 4, ..., not exceeding √n:</span><br><span class="line">   if A[i] is true:</span><br><span class="line">     for j = i2, i2+i, i2+2i, i2+3i, ..., not exceeding n:</span><br><span class="line">       A[j] := false.</span><br><span class="line">       </span><br><span class="line">Output: all i such that A[i] is true.</span><br></pre></td></tr></table></figure><h4 id="Roman-to-Integer-amp-Integer-to-Roman"><a href="#Roman-to-Integer-amp-Integer-to-Roman" class="headerlink" title="Roman to Integer &amp; Integer to Roman"></a>Roman to Integer &amp; Integer to Roman</h4><h4 id="Multiply-Strings"><a href="#Multiply-Strings" class="headerlink" title="Multiply Strings"></a>Multiply Strings</h4><h4 id="Excel-Sheet-Column-Number"><a href="#Excel-Sheet-Column-Number" class="headerlink" title="Excel Sheet Column Number"></a>Excel Sheet Column Number</h4><p>26进制</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题型总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一种类型是最简单的， 就是对整数进行直接操作， 一般来说就是逐位操作， 比如反转， 比较等。 LeetCode中这类题目有Palindrome Number和Reverse Integer。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二种题型是算术运算的题目， 比如乘除法， 阶乘， 开方等， LeetCode中这类题目有Sqrt(x)， Pow(x, n)和Divide Two Integers。 这种题目有时候看似复杂， 其实还是有几个比较通用的解法的， 下面主要介绍三种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二分法&lt;/li&gt;
&lt;li&gt;牛顿法&lt;/li&gt;
&lt;li&gt;位移法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第三种题目是解析几何的题目， 一般来说解析几何题目的模型都比较复杂， 而且实现细节比较多， 在面试中并不常见， LeetCode中也只有Max Points on a Line是属于这种题型。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Math-without-Operator&quot;&gt;&lt;a href=&quot;#Math-without-Operator&quot; class=&quot;headerlink&quot; title=&quot;Math without Operator&quot;&gt;&lt;/a&gt;Math without Operator&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;不用operator进行数学运算&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Math" scheme="blog.jiangdongyu.space/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>求和问题</title>
    <link href="blog.jiangdongyu.space/2018/04/01/%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/"/>
    <id>blog.jiangdongyu.space/2018/04/01/求和问题/</id>
    <published>2018-04-01T06:55:00.000Z</published>
    <updated>2018-05-28T08:53:26.827Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题描述</strong> </p><p>一般是给一组n个数字，给1个target，求出k个数字的sum为target。有变化的就是求closet，求个数，求组合等。</p><a id="more"></a><p><strong>注意事项</strong></p><ul><li>可能有重复项，注意去重，除了2Sum都可以先排序</li></ul><h2 id="2-Sum-解法"><a href="#2-Sum-解法" class="headerlink" title="2 Sum 解法"></a>2 Sum 解法</h2><ul><li><p>方法一 brute force</p><p>枚举所有的k-subset，从N中选出k个，时间复杂度O(n^k)</p></li><li><p>先sort，再two pointer</p><p>两指针之和与target比较，大于则high–,小于则low++, O(nlogn)</p></li><li><p>利用hashmap</p><p>hashmap保存nums[i],i，循环判断map中是否存在target-nums[i],O(n)</p></li></ul><p><strong>后续题目</strong></p><p>对于2Sum的题目</p><ul><li>返回index，则优先使用hashmap做，排序会打乱顺序</li><li>如果是返回value，则用先sort，再two pointer</li></ul><p>对 3sum, 3sum closest, 4sum等题目，因为大部分都是根据two sum two pointer做法的延伸，所以都是要求return value。</p><p><strong>two pointer有利于跳过重复元素，用来计算closet，smaller等不等于target的题，优先使用</strong></p><h2 id="3-Sum-解法"><a href="#3-Sum-解法" class="headerlink" title="3 Sum 解法"></a>3 Sum 解法</h2><blockquote><p>可转换为2Sum问题，先取出一个数i，在剩下的数组中找sum为target-i的</p></blockquote><p>时间复杂度为O(nlogn+n^2) = O(n^2)</p><h2 id="3-Sum-Closet"><a href="#3-Sum-Closet" class="headerlink" title="3 Sum Closet"></a>3 Sum Closet</h2><p>sort + two pointer，不断更新最接近target的值</p><h2 id="4-Sum-解法"><a href="#4-Sum-解法" class="headerlink" title="4 Sum 解法"></a>4 Sum 解法</h2><blockquote><p>退化为3sum，两层loop，内部2 sum， O(n^3)</p></blockquote><h2 id="K-Sum-解法"><a href="#K-Sum-解法" class="headerlink" title="K Sum 解法"></a>K Sum 解法</h2><blockquote><p>一步步退化，最后变为2 Sum，O(n^(k-1))</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;问题描述&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;一般是给一组n个数字，给1个target，求出k个数字的sum为target。有变化的就是求closet，求个数，求组合等。&lt;/p&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="K Sum" scheme="blog.jiangdongyu.space/tags/K-Sum/"/>
    
  </entry>
  
  <entry>
    <title>编程面试的10大算法概念汇总</title>
    <link href="blog.jiangdongyu.space/2018/03/31/%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E7%9A%8410%E5%A4%A7%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%E6%B1%87%E6%80%BB/"/>
    <id>blog.jiangdongyu.space/2018/03/31/编程面试的10大算法概念汇总/</id>
    <published>2018-03-31T08:56:00.000Z</published>
    <updated>2018-05-28T08:53:40.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><blockquote><p>如果IDE没有代码自动补全功能，所以你应该记住下面的这些方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">toCharArray() <span class="comment">// 获得字符串对应的char数组</span></span><br><span class="line">Arrays.sort()  <span class="comment">// 数组排序</span></span><br><span class="line">Arrays.toString(<span class="keyword">char</span>[] a) <span class="comment">// 数组转成字符串</span></span><br><span class="line">charAt(<span class="keyword">int</span> x) <span class="comment">// 获得某个索引处的字符</span></span><br><span class="line">length() <span class="comment">// 字符串长度</span></span><br><span class="line">length <span class="comment">// 数组大小</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><blockquote><p>在Java中，链表的实现非常简单，每个节点Node都有一个值val和指向下个节点的链接next。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">Node next;</span><br><span class="line"> </span><br><span class="line">Node(<span class="keyword">int</span> x) &#123;</span><br><span class="line">val = x;</span><br><span class="line">next = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表两个著名的应用是栈Stack和队列Queue。</p><p>栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span>&#123;</span><br><span class="line">Node top; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(top != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(top == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Node temp = <span class="keyword">new</span> Node(top.val);</span><br><span class="line">top = top.next;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Node n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n != <span class="keyword">null</span>)&#123;</span><br><span class="line">n.next = top;</span><br><span class="line">top = n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span></span>&#123;</span><br><span class="line">    Node first, last;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first == <span class="keyword">null</span>)&#123;</span><br><span class="line">            first = n;</span><br><span class="line">            last = first;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            last.next = n;</span><br><span class="line">            last = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Node temp = <span class="keyword">new</span> Node(first.val);</span><br><span class="line">            first = first.next;</span><br><span class="line">            <span class="keyword">if</span>(last == temp) last = first;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><blockquote><p>这里的树通常是指二叉树，每个节点都包含一个左孩子节点和右孩子节点，像下面这样：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line">TreeNode left;</span><br><span class="line">TreeNode right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是与树相关的一些概念：</p><ul><li>平衡 vs. 非平衡：平衡二叉树中，每个节点的左右子树的<strong>深度相差至多为1（1或0）</strong>。</li><li>满二叉树（Full Binary Tree）：除叶子节点以外的每个节点都有<strong>两个孩子</strong>。</li><li>完美二叉树（Perfect Binary Tree）：是具有下列性质的满二叉树：所有的叶子节点都有相同的深度或处在同一层次，且每个父节点都必须有两个孩子。</li><li>完全二叉树（Complete Binary Tree）：二叉树中，可能除了最后一个，每一层都被完全填满，且所有节点都必须尽可能向左靠。</li></ul><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><blockquote><p>图相关的问题主要集中在深度优先搜索（depth first search）和广度优先搜索（breath first search）。</p></blockquote><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><table><thead><tr><th style="text-align:center">Algorithm</th><th style="text-align:center">Average Time</th><th style="text-align:center">Worst Time</th><th style="text-align:center">Space</th><th style="text-align:center">Stable</th></tr></thead><tbody><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">n^2</td><td style="text-align:center">n^2</td><td style="text-align:center">1</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">选择排序</td><td style="text-align:center">n^2</td><td style="text-align:center">n^2</td><td style="text-align:center">1</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">插入排序</td><td style="text-align:center">n^2</td><td style="text-align:center">n^2</td><td style="text-align:center"></td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center">nlog(n)</td><td style="text-align:center">n^2</td><td style="text-align:center"></td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center">nlog(n)</td><td style="text-align:center">nlog(n)</td><td style="text-align:center"></td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">nlog(n)</td><td style="text-align:center">nlog(n)</td><td style="text-align:center"></td><td style="text-align:center">N</td></tr></tbody></table><h2 id="递归-vs-迭代"><a href="#递归-vs-迭代" class="headerlink" title="递归 vs. 迭代"></a>递归 vs. 迭代</h2><blockquote><p>对程序员来说，递归应该是一个与生俱来的思想（a built-in thought），可以通过一个简单的例子来说明。</p></blockquote><p>问题： 有n步台阶，一次只能上1步或2步，共有多少种走法。</p><p>步骤1:找到走完前n步台阶和前n-1步台阶之间的关系。</p><blockquote><p>为了走完n步台阶，只有两种方法：从n-1步台阶爬1步走到或从n-2步台阶处爬2步走到。如果f(n)是爬到第n步台阶的方法数，那么f(n) = f(n-1) + f(n-2)。</p></blockquote><p>步骤2: 确保开始条件是正确的。</p><blockquote><p>f(0) = 0;<br>f(1) = 1;</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line"><span class="keyword">int</span> x = f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归方法的时间复杂度是n的指数级，因为有很多冗余的计算，如下：</p><p>f(5)</p><p>f(4) + f(3)</p><p>f(3) + f(2) + f(2) + f(1)</p><p>f(2) + f(1) + f(1) + f(0) + f(1) + f(0) + f(1)</p><p>f(1) + f(0) + f(1) + f(1) + f(0) + f(1) + f(0) + f(1)</p><p>直接的想法是将递归转换为迭代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> first = <span class="number">1</span>, second = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> third = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">third = first + second;</span><br><span class="line">first = second;</span><br><span class="line">second = third;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> third;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对这个例子而言，迭代花费的时间更少</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划是解决下面这些性质类问题的技术：</p><p>一个问题可以通过更小子问题的解决方法来解决（译者注：即问题的最优解包含了其子问题的最优解，也就是最优子结构性质）。<br>有些子问题的解可能需要计算多次（译者注：也就是子问题重叠性质）。<br>子问题的解存储在一张表格里，这样每个子问题只用计算一次。<br>需要额外的空间以节省时间。</p><h2 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h2><p>位操作符：</p><table><thead><tr><th style="text-align:center">OR ()</th><th style="text-align:center">AND (&amp;)</th><th style="text-align:center">XOR (^)</th><th style="text-align:center">Left Shift (&lt;&lt;)</th><th style="text-align:center">Right Shift (&gt;&gt;)</th><th style="text-align:center">Not (~)</th></tr></thead><tbody><tr><td style="text-align:center">1\</td><td style="text-align:center">0=1</td><td style="text-align:center">1&amp;0=0</td><td style="text-align:center">1^0=1</td><td style="text-align:center">0010&lt;&lt;2=1000</td><td style="text-align:center">1100&gt;&gt;2=0011</td><td>~1=0</td></tr></tbody></table><h2 id="概率问题"><a href="#概率问题" class="headerlink" title="概率问题"></a>概率问题</h2><blockquote><p>善于转换成对立的问题</p></blockquote><p>比如求50个人至少有两个人生日相同的概率（忽略闰年） ——-&gt; </p><p>计算所有人生日都互不相同的概率，也就是：365/365 <em> 364/365 </em> 363/365 <em> … </em> (365-49)/365，这样至少两个人生日相同的概率就是1 – 这个值。     </p><h2 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;如果IDE没有代码自动补全功能，所以你应该记住下面的这些方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;toCharArray() &lt;span class=&quot;comment&quot;&gt;// 获得字符串对应的char数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Arrays.sort()  &lt;span class=&quot;comment&quot;&gt;// 数组排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Arrays.toString(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;[] a) &lt;span class=&quot;comment&quot;&gt;// 数组转成字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;charAt(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x) &lt;span class=&quot;comment&quot;&gt;// 获得某个索引处的字符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;length() &lt;span class=&quot;comment&quot;&gt;// 字符串长度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;length &lt;span class=&quot;comment&quot;&gt;// 数组大小&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法概念" scheme="blog.jiangdongyu.space/tags/%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
</feed>
