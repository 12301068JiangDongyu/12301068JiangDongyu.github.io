<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>M&amp;Y</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="blog.jiangdongyu.space/"/>
  <updated>2018-07-15T15:01:58.477Z</updated>
  <id>blog.jiangdongyu.space/</id>
  
  <author>
    <name>Agnes</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>对Spring IOC和AOP的理解</title>
    <link href="blog.jiangdongyu.space/2018/07/15/Spring%20IOC%20AOP/"/>
    <id>blog.jiangdongyu.space/2018/07/15/Spring IOC AOP/</id>
    <published>2018-07-15T14:45:00.000Z</published>
    <updated>2018-07-15T15:01:58.477Z</updated>
    
    <content type="html"><![CDATA[<p>在面试中，经常会问，说说你对Spring IOC和AOP的理解，问题很宽泛，似乎不知道从何说起。</p><p><strong>回答思路</strong>：</p><ul><li>先用通俗易懂的话解释下何为IOC和AOP</li><li>各自的实现原理</li><li>自己的项目中如何使用</li></ul><p>以下是个人的一些总结，仅供参考。</p><a id="more"></a><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>许多应用都是通过彼此间的相互合作来实现业务逻辑的，如类A要调用类B的方法，以前我们都是在类A中，通过自身new一个类B，然后在调用类B的方法，现在我们把new类B的事情交给Spring来做，在我们调用的时候，容器会为我们实例化。</p><ul><li>IOC容器的初始化过程<ul><li>资源定位，即定义bean的xml</li><li>载入</li><li>IOC容器注册，注册beanDefinition</li></ul></li></ul><p>IOC容器的初始化过程，一般不包含bean的依赖注入的实现，在Spring IOC设计中，bean的<strong>注册</strong>和<strong>依赖注入</strong>是两个过程，依赖注入一般发生在应用<strong>第一次索取bean</strong>的时候，但是也可以在xm中配置，在容器初始化的时候，这个bean就完成了初始化。</p><p>三种<strong>注入方式</strong>：</p><ul><li>构造器</li><li>接口</li><li>set注入(常用)</li></ul><p>bean是如何创建——<strong>工厂模式</strong></p><p>数据是如何注入——<strong>反射</strong></p><p><a href="http://blog.jiangdongyu.space/2018/07/13/Spring%20IOC%E5%8E%9F%E7%90%86/">IOC的定义及实现原理</a></p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>面向切面编程，在我们的应用中，经常需要做一些事情，但是这些事情<strong>与核心业务无关</strong>，比如，要记录所有update*方法的执行时间时间，操作人等等信息，记录到日志，</p><p>通过Spring的AOP技术，就可以在不修改update*的代码的情况下完成该需求。</p><p>AOP的好处就是你只需要干你的正事，其它事情别人帮你干。</p><p>从Spring的角度看，AOP最大的用途就在于提供了<strong>事务管理</strong>的能力。事务管理就是一个关注点，你的正事就是去访问数据库，而你不想管事务（太烦），所以，Spring在你访问数据库之前，自动帮你开启事务，当你访问数据库结束之后，自动帮你提交/回滚事务！</p><p><a href="http://blog.jiangdongyu.space/2018/07/13/%E7%90%86%E8%A7%A3AOP/">AOP的实现原理——代理</a></p><p><a href="http://blog.jiangdongyu.space/2018/07/15/AOP%E7%9A%84%E5%BA%94%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/">AOP的应用的三种实现方式</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在面试中，经常会问，说说你对Spring IOC和AOP的理解，问题很宽泛，似乎不知道从何说起。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回答思路&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先用通俗易懂的话解释下何为IOC和AOP&lt;/li&gt;
&lt;li&gt;各自的实现原理&lt;/li&gt;
&lt;li&gt;自己的项目中如何使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是个人的一些总结，仅供参考。&lt;/p&gt;
    
    </summary>
    
      <category term="Java面试" scheme="blog.jiangdongyu.space/categories/Java%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Spring" scheme="blog.jiangdongyu.space/categories/Java%E9%9D%A2%E8%AF%95/Spring/"/>
    
    
      <category term="Spring" scheme="blog.jiangdongyu.space/tags/Spring/"/>
    
      <category term="AOP" scheme="blog.jiangdongyu.space/tags/AOP/"/>
    
      <category term="IOC" scheme="blog.jiangdongyu.space/tags/IOC/"/>
    
  </entry>
  
  <entry>
    <title>AOP的应用的三种实现方式</title>
    <link href="blog.jiangdongyu.space/2018/07/15/AOP%E7%9A%84%E5%BA%94%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>blog.jiangdongyu.space/2018/07/15/AOP的应用的三种实现方式/</id>
    <published>2018-07-15T08:22:00.000Z</published>
    <updated>2018-07-15T08:56:04.477Z</updated>
    
    <content type="html"><![CDATA[<p>Spring有两大核心，IOC和AOP。IOC在java web项目中无时无刻不在使用。然而AOP用的比较少，的确也是一般的项目用的场所不多。<strong>事务控制</strong>基本都用，但却是Spring封装的不需要我们再去实现，但Spring的AOP远不止这些。</p><a id="more"></a><h2 id="概念术语"><a href="#概念术语" class="headerlink" title="概念术语　　"></a>概念术语　　</h2><p>在开始之前，需要理解Spring AOP的一些基本的概念术语(总结的个人理解，并非Spring官方定义)：</p><ul><li><strong>切面</strong>(aspect)：用来切插业务方法的类。</li><li><strong>连接点</strong>(joinpoint)：是切面类和业务类的连接点，其实就是封装了业务方法的一些基本属性，作为通知的参数来解析。</li><li><strong>通知</strong>(advice)：在切面类中，声明对业务方法做额外处理的方法。</li><li><strong>切入点</strong>(pointcut)：业务类中指定的方法，作为切面切入的点。其实就是指定某个方法作为切面切的地方。</li><li><strong>目标对象</strong>(target object)：被代理对象。</li><li><strong>AOP代理</strong>(aop proxy)：代理对象。</li><li><strong>AOP通知类型</strong>：<ul><li>前置通知(before advice)：在切入点之前执行。</li><li>后置通知(after returning advice)：在切入点执行完成后，执行通知。</li><li>环绕通知(around advice)：包围切入点，调用方法前后完成自定义行为。</li><li>异常通知(after throwing advice)：在切入点抛出异常后，执行通知。</li></ul></li></ul><h2 id="Spring-AOP环境"><a href="#Spring-AOP环境" class="headerlink" title="Spring AOP环境"></a>Spring AOP环境</h2><p>要在项目中使用Spring AOP则需要在项目中导入除了spring jar包之外，还有aspectjweaver.jar，aopalliance.jar，asm.jar和cglib.jar 。</p><p>好了，前提工作准备完成，Spring提供了很多的实现AOP的方式，在学习过程中，循序渐进。进行<strong>Spring接口方式</strong>，<strong>Schema配置方式</strong>和<strong>注解</strong>的三种方式进行学习。好了废话不多说了，开始Spring AOP学习之旅：</p><h3 id="AOP接口"><a href="#AOP接口" class="headerlink" title="AOP接口"></a>AOP接口</h3><p>利用Spring AOP接口实现AOP，主要是为了指定自定义通知来供Spring AOP机制识别。主要接口：前置通知 MethodBeforeAdvice，后置通知：AfterReturningAdvice，环绕通知：MethodInterceptor，异常通知：ThrowsAdvice 。见例子代码：</p><h4 id="业务接口："><a href="#业务接口：" class="headerlink" title="业务接口："></a>业务接口：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理类接口，也是业务类接口</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 利用接口的方式，spring aop 将默认通过jdk 动态代理来实现代理类</span></span><br><span class="line"><span class="comment"> * 不利用接口，则spring aop 将通过cglib 来实现代理类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBaseBusiness</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用作代理的切入点方法</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">(String obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这方法不被切面切</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(String obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这方法切不切呢？可以设置</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modify</span><span class="params">(String obj)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务类："><a href="#业务类：" class="headerlink" title="业务类："></a>业务类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务类，也是目标对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBusiness</span> <span class="keyword">implements</span> <span class="title">IBaseBusiness</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切入点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========调用切入点："</span> + obj + <span class="string">"说：你敢删除我！===========\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄～"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"================这个方法不能被切。。。============== \n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄～ 嘿嘿！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modify</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=================这个也设置加入切吧====================\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄改瞄啊！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通知类："><a href="#通知类：" class="headerlink" title="通知类："></a>通知类：</h4><ul><li>前置通知：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前置通知。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBeforeAdvice</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * method : 切入的方法</span></span><br><span class="line"><span class="comment">     * args ：切入方法的参数</span></span><br><span class="line"><span class="comment">     * target ：目标对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========进入beforeAdvice()============ \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"准备在"</span> + target + <span class="string">"对象上用"</span>);</span><br><span class="line">        System.out.print(method + <span class="string">"方法进行对 '"</span>);</span><br><span class="line">        System.out.print(args[<span class="number">0</span>] + <span class="string">"'进行删除！\n\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"要进入切入点方法了 \n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>后置通知：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后置通知</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAfterReturnAdvice</span> <span class="keyword">implements</span> <span class="title">AfterReturningAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * returnValue ：切入点执行完方法的返回值，但不能修改</span></span><br><span class="line"><span class="comment">     * method ：切入点方法</span></span><br><span class="line"><span class="comment">     * args ：切入点方法的参数数组</span></span><br><span class="line"><span class="comment">     * target ：目标对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========进入afterReturning()=========== \n"</span>);</span><br><span class="line">        System.out.println(<span class="string">"切入点方法执行完了 \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(args[<span class="number">0</span>] + <span class="string">"在"</span>);</span><br><span class="line">        System.out.print(target + <span class="string">"对象上被"</span>);</span><br><span class="line">        System.out.print(method + <span class="string">"方法删除了"</span>);</span><br><span class="line">        System.out.print(<span class="string">"只留下："</span> + returnValue + <span class="string">"\n\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>环绕通知：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 环绕通知</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAroundAdvice</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * invocation ：连接点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========进入around环绕方法！=========== \n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用目标方法之前执行的动作</span></span><br><span class="line">        System.out.println(<span class="string">"调用方法之前: 执行！\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法的参数</span></span><br><span class="line">        Object[] args = invocation.getArguments();</span><br><span class="line">        <span class="comment">// 调用的方法</span></span><br><span class="line">        Method method = invocation.getMethod();</span><br><span class="line">        <span class="comment">// 获取目标对象</span></span><br><span class="line">        Object target = invocation.getThis();</span><br><span class="line">        <span class="comment">// 执行完方法的返回值：调用proceed()方法，就会触发切入点方法执行</span></span><br><span class="line">        Object returnValue = invocation.proceed();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"===========结束进入around环绕方法！=========== \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"输出："</span> + args[<span class="number">0</span>] + <span class="string">";"</span> + method + <span class="string">";"</span> + target + <span class="string">";"</span> + returnValue + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"调用方法结束：之后执行！\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>异常通知：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异常通知，接口没有包含任何方法。通知方法自定义</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAfterThrowsAdvice</span> <span class="keyword">implements</span> <span class="title">ThrowsAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知方法，需要按照这种格式书写</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">     *            可选：切入的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     *            可选：切入的方法的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     *            可选：目标对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> throwable</span></span><br><span class="line"><span class="comment">     *            必填 : 异常子类，出现这个异常类的子类，则会进入这个通知。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(Method method, Object[] args, Object target, Throwable throwable)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除出错啦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义指定切点："><a href="#定义指定切点：" class="headerlink" title="定义指定切点："></a>定义指定切点：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个切点，指定对应方法匹配。来供切面来针对方法进行处理&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 继承NameMatchMethodPointcut类，来用方法名匹配</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pointcut</span> <span class="keyword">extends</span> <span class="title">NameMatchMethodPointcut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3990456017285944475L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置单个方法匹配</span></span><br><span class="line">        <span class="keyword">this</span>.setMappedName(<span class="string">"delete"</span>);</span><br><span class="line">        <span class="comment">// 设置多个方法匹配</span></span><br><span class="line">        String[] methods = &#123; <span class="string">"delete"</span>, <span class="string">"modify"</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//也可以用“ * ” 来做匹配符号</span></span><br><span class="line">        <span class="comment">// this.setMappedName("get*");</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setMappedNames(methods);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.matches(method, targetClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context/spring-context-3.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/aop     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ==============================利用spring自己的aop配置================================ --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 声明一个业务类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baseBusiness"</span> <span class="attr">class</span>=<span class="string">"aop.base.BaseBusiness"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 声明通知类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baseBefore"</span> <span class="attr">class</span>=<span class="string">"aop.base.advice.BaseBeforeAdvice"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baseAfterReturn"</span> <span class="attr">class</span>=<span class="string">"aop.base.advice.BaseAfterReturnAdvice"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baseAfterThrows"</span> <span class="attr">class</span>=<span class="string">"aop.base.advice.BaseAfterThrowsAdvice"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baseAround"</span> <span class="attr">class</span>=<span class="string">"aop.base.advice.BaseAroundAdvice"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定切点匹配类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"pointcut"</span> <span class="attr">class</span>=<span class="string">"aop.base.pointcut.Pointcut"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 包装通知，指定切点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"matchBeforeAdvisor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.DefaultPointcutAdvisor"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pointcut"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"pointcut"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"advice"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"baseBefore"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用ProxyFactoryBean 产生代理对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"businessProxy"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 代理对象所实现的接口 ，如果有接口可以这样设置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"proxyInterfaces"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>aop.base.IBaseBusiness<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 设置目标对象 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"baseBusiness"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 代理对象所使用的拦截器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>matchBeforeAdvisor<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>baseAfterReturn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>baseAround<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="测试类："><a href="#测试类：" class="headerlink" title="测试类："></a>测试类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Debug</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"aop/schema_aop.xml"</span>);</span><br><span class="line">        IBaseBusiness business = (IBaseBusiness ) context.getBean(<span class="string">"businessProxy"</span>);</span><br><span class="line">        business.delete(<span class="string">"猫"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的代码实现可以从代码注释中很容易理解<strong>接口方式</strong>的实现。结果也可想而知，前置方法会在切入点方法之前执行，后置会在切入点方法执行之后执行，环绕则会在切入点方法执行前执行同时方法结束也会执行对应的部分。主要是调用proceed()方法来执行切入点方法。来作为环绕通知前后方法的分水岭。然后在实现的过程中，有几点却是可以细揣摩一下的。</p><p>可以看出在xml配置businessProxy这个bean的时候，ProxyFactoryBean类中指定了，proxyInterfaces参数。这里我把他配置了IBaseBusiness接口。因为在项目开发过程中，往往业务类都会有对应的接口，以方便利用IOC解耦。但Spring AOP却也能支持没有接口的代理。这就是为什么需要导入cglib.jar的包。看过spring的源码，知道在目标切入对象如果有实现接口，spring会默认走jdk动态代理来实现代理类。如果没有接口，则会通过cglib来实现代理类。</p><p>这个业务类现在有<strong>前置通知，后置通知，环绕</strong>三个通知同时作用，可能以及更多的通知进行作用。那么这些通知的执行顺序是怎么样的？就这个例子而言，同时实现了三个通知。在例子xml中，则显示执行before通知，然后执行around的前处理，执行切点方法，再执行return处理。最后执行around的后处理。经过测试，知道spring处理顺序是按照xml配置顺序依次处理通知，以队列的方式存放前通知，以压栈的方式存放后通知。所以是<strong>前通知依次执行，后通知到切入点执行完之后，从栈里在后进先出的形式把后通知执行</strong>。</p><p>在实现过程中发现通知执行对应目标对象的整个类中的方法，如何精确到某个方法，则需要定义一个切点匹配的方式：spring提供了方法名匹配或正则方式来匹配。然后通过DefaultPointcutAdvisor来包装通知，指定切点.</p><p>利用方式一的配置起来，可见代码还是非常的厚重的，<strong>定义一个切面就要定义一个切面类，然而切面类中，就一个通知方法</strong>，着实没有必要。所以Spring提供了，依赖aspectj的schema配置和基于aspectj 注解方式。这两种方式非常简介方便使用，也是项目中普遍的使用方式。梳理之：</p><h3 id="schema配置"><a href="#schema配置" class="headerlink" title="schema配置"></a>schema配置</h3><h4 id="业务类：-1"><a href="#业务类：-1" class="headerlink" title="业务类："></a>业务类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectBusiness</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切入点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========调用切入点："</span> + obj + <span class="string">"说：你敢删除我！===========\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄～"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"================这个方法不能被切。。。============== \n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄～ 嘿嘿！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modify</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=================这个也设置加入切吧====================\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄改瞄啊！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切面类："><a href="#切面类：" class="headerlink" title="切面类："></a>切面类：</h4><p>切面类中，包含了所有的通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个切面</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint jp)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========进入before advice============ \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"准备在"</span> + jp.getTarget().getClass() + <span class="string">"对象上用"</span>);</span><br><span class="line">        System.out.print(jp.getSignature().getName() + <span class="string">"方法进行对 '"</span>);</span><br><span class="line">        System.out.print(jp.getArgs()[<span class="number">0</span>] + <span class="string">"'进行删除！\n\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"要进入切入点方法了 \n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jp</span></span><br><span class="line"><span class="comment">     *            连接点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">     *            返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(JoinPoint jp, String result)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========进入after advice=========== \n"</span>);</span><br><span class="line">        System.out.println(<span class="string">"切入点方法执行完了 \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(jp.getArgs()[<span class="number">0</span>] + <span class="string">"在"</span>);</span><br><span class="line">        System.out.print(jp.getTarget().getClass() + <span class="string">"对象上被"</span>);</span><br><span class="line">        System.out.print(jp.getSignature().getName() + <span class="string">"方法删除了"</span>);</span><br><span class="line">        System.out.print(<span class="string">"只留下："</span> + result + <span class="string">"\n\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pjp</span></span><br><span class="line"><span class="comment">     *            连接点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAround</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========进入around环绕方法！=========== \n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用目标方法之前执行的动作</span></span><br><span class="line">        System.out.println(<span class="string">"调用方法之前: 执行！\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法的参数</span></span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        <span class="comment">// 调用的方法名</span></span><br><span class="line">        String method = pjp.getSignature().getName();</span><br><span class="line">        <span class="comment">// 获取目标对象</span></span><br><span class="line">        Object target = pjp.getTarget();</span><br><span class="line">        <span class="comment">// 执行完方法的返回值：调用proceed()方法，就会触发切入点方法执行</span></span><br><span class="line">        Object result = pjp.proceed();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"输出："</span> + args[<span class="number">0</span>] + <span class="string">";"</span> + method + <span class="string">";"</span> + target + <span class="string">";"</span> + result + <span class="string">"\n"</span>);</span><br><span class="line">        System.out.println(<span class="string">"调用方法结束：之后执行！\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doThrow</span><span class="params">(JoinPoint jp, Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除出错啦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context/spring-context-3.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/aop     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ==============================利用spring 利用aspectj来配置AOP================================ --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 声明一个业务类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aspectBusiness"</span> <span class="attr">class</span>=<span class="string">"aop.schema.AspectBusiness"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 声明通知类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aspectAdvice"</span> <span class="attr">class</span>=<span class="string">"aop.schema.advice.AspectAdvice"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"businessAspect"</span> <span class="attr">ref</span>=<span class="string">"aspectAdvice"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置指定切入的对象 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"point_cut"</span> <span class="attr">expression</span>=<span class="string">"execution(* aop.schema.*.*(..))"</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 只匹配add方法作为切入点</span></span><br><span class="line"><span class="comment">            &lt;aop:pointcut id="except_add" expression="execution(* aop.schema.*.add(..))" /&gt;</span></span><br><span class="line"><span class="comment">             --&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 前置通知 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"doBefore"</span> <span class="attr">pointcut-ref</span>=<span class="string">"point_cut"</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 后置通知 returning指定返回参数 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"doAfter"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">pointcut-ref</span>=<span class="string">"point_cut"</span> <span class="attr">returning</span>=<span class="string">"result"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"doAround"</span> <span class="attr">pointcut-ref</span>=<span class="string">"point_cut"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"doThrow"</span> <span class="attr">pointcut-ref</span>=<span class="string">"point_cut"</span> <span class="attr">throwing</span>=<span class="string">"e"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="测试类：-1"><a href="#测试类：-1" class="headerlink" title="测试类："></a>测试类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Debug</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"aop/schema_aop.xml"</span>);</span><br><span class="line">        AspectBusiness business = (AspectBusiness) context.getBean(<span class="string">"aspectBusiness"</span>);</span><br><span class="line">        business.delete(<span class="string">"猫"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="aspectj注解"><a href="#aspectj注解" class="headerlink" title="aspectj注解"></a>aspectj注解</h3><p>注解在项目中已经到处都是了，撇开一些优劣不提，开发的便利性和可读性是非常的方便的。用来配置Spring AOP也非常简单便利</p><h4 id="业务类：-2"><a href="#业务类：-2" class="headerlink" title="业务类："></a>业务类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Business</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切入点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========调用切入点："</span> + obj + <span class="string">"说：你敢删除我！===========\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄～"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"================这个方法不能被切。。。============== \n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄～ 嘿嘿！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modify</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=================这个也设置加入切吧====================\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄改瞄啊！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切面类：-1"><a href="#切面类：-1" class="headerlink" title="切面类："></a>切面类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义切面</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Aspect</span> : 标记为切面类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Pointcut</span> : 指定匹配切点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Before</span> : 指定前置通知，value中指定切入点匹配</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@AfterReturning</span> ：后置通知，具有可以指定返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@AfterThrowing</span> ：异常通知</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定切入点匹配表达式，注意它是以方法的形式进行声明的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* aop.annotation.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(value = <span class="string">"execution(* aop.annotation.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint jp)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========进入before advice============ \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"准备在"</span> + jp.getTarget().getClass() + <span class="string">"对象上用"</span>);</span><br><span class="line">        System.out.print(jp.getSignature().getName() + <span class="string">"方法进行对 '"</span>);</span><br><span class="line">        System.out.print(jp.getArgs()[<span class="number">0</span>] + <span class="string">"'进行删除！\n\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"要进入切入点方法了 \n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jp</span></span><br><span class="line"><span class="comment">     *            连接点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">     *            返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(value = <span class="string">"anyMethod()"</span>, returning = <span class="string">"result"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(JoinPoint jp, String result)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========进入after advice=========== \n"</span>);</span><br><span class="line">        System.out.println(<span class="string">"切入点方法执行完了 \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(jp.getArgs()[<span class="number">0</span>] + <span class="string">"在"</span>);</span><br><span class="line">        System.out.print(jp.getTarget().getClass() + <span class="string">"对象上被"</span>);</span><br><span class="line">        System.out.print(jp.getSignature().getName() + <span class="string">"方法删除了"</span>);</span><br><span class="line">        System.out.print(<span class="string">"只留下："</span> + result + <span class="string">"\n\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pjp</span></span><br><span class="line"><span class="comment">     *            连接点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around</span>(value = <span class="string">"execution(* aop.annotation.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAround</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========进入around环绕方法！=========== \n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用目标方法之前执行的动作</span></span><br><span class="line">        System.out.println(<span class="string">"调用方法之前: 执行！\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法的参数</span></span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        <span class="comment">// 调用的方法名</span></span><br><span class="line">        String method = pjp.getSignature().getName();</span><br><span class="line">        <span class="comment">// 获取目标对象</span></span><br><span class="line">        Object target = pjp.getTarget();</span><br><span class="line">        <span class="comment">// 执行完方法的返回值：调用proceed()方法，就会触发切入点方法执行</span></span><br><span class="line">        Object result = pjp.proceed();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"输出："</span> + args[<span class="number">0</span>] + <span class="string">";"</span> + method + <span class="string">";"</span> + target + <span class="string">";"</span> + result + <span class="string">"\n"</span>);</span><br><span class="line">        System.out.println(<span class="string">"调用方法结束：之后执行！\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(value = <span class="string">"execution(* aop.annotation.*.*(..))"</span>, throwing = <span class="string">"e"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doThrow</span><span class="params">(JoinPoint jp, Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除出错啦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置：-1"><a href="#配置：-1" class="headerlink" title="配置："></a>配置：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context/spring-context-3.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/aop     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"aop.annotation"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 打开aop 注解 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="测试类：-2"><a href="#测试类：-2" class="headerlink" title="测试类："></a>测试类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Debug</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"aop/annotation_aop.xml"</span>);</span><br><span class="line">        Business business = (Business) context.getBean(<span class="string">"business"</span>);</span><br><span class="line">        business.delete(<span class="string">"猫"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring有两大核心，IOC和AOP。IOC在java web项目中无时无刻不在使用。然而AOP用的比较少，的确也是一般的项目用的场所不多。&lt;strong&gt;事务控制&lt;/strong&gt;基本都用，但却是Spring封装的不需要我们再去实现，但Spring的AOP远不止这些。&lt;/p&gt;
    
    </summary>
    
      <category term="Java面试" scheme="blog.jiangdongyu.space/categories/Java%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Spring" scheme="blog.jiangdongyu.space/categories/Java%E9%9D%A2%E8%AF%95/Spring/"/>
    
    
      <category term="Spring" scheme="blog.jiangdongyu.space/tags/Spring/"/>
    
      <category term="AOP" scheme="blog.jiangdongyu.space/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>AOP的定义实现原理——代理</title>
    <link href="blog.jiangdongyu.space/2018/07/13/%E7%90%86%E8%A7%A3AOP/"/>
    <id>blog.jiangdongyu.space/2018/07/13/理解AOP/</id>
    <published>2018-07-13T12:05:00.000Z</published>
    <updated>2018-07-14T15:01:25.619Z</updated>
    
    <content type="html"><![CDATA[<p>Aspect Oriented Programming面向切面编程。解耦是程序员编码开发过程中一直追求的。AOP也是为了解耦所诞生。</p><p><strong>具体思想</strong>是：定义一个切面，在切面的纵向定义处理方法，处理完成之后，回到横向业务流。</p><p>AOP在Spring框架中被作为核心组成部分之一，的确Spring将AOP发挥到很强大的功能。最常见的就是<strong>事务控制</strong>。</p><p>AOP 主要是利用<strong>代理模式</strong>的技术来实现的。</p><a id="more"></a><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><blockquote><p>就是设计模式中的proxy模式</p></blockquote><ul><li>业务接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象主题角色：声明了真实主题和代理主题的共同接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITalk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String msg)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>业务实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真实主题角色：定义真实的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeopleTalk</span> <span class="keyword">implements</span> <span class="title">ITalk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String username;</span><br><span class="line">    <span class="keyword">public</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PeopleTalk</span><span class="params">(String username, String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(msg + <span class="string">"!你好,我是"</span> + username + <span class="string">"，我年龄是"</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代理对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理主题角色：内部包含对真实主题的引用，并且提供和真实主题角色相同的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkProxy</span> <span class="keyword">implements</span> <span class="title">ITalk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ITalk talker;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TalkProxy</span><span class="params">(ITalk talker)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// super();</span></span><br><span class="line">        <span class="keyword">this</span>.talker = talker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        talker.talk(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String msg, String singname)</span> </span>&#123;</span><br><span class="line">        talker.talk(msg);</span><br><span class="line">        sing(singname);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">(String singname)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"唱歌："</span> + singname);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理测试类，使用代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyPattern</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不需要执行额外方法的。</span></span><br><span class="line">        ITalk people = <span class="keyword">new</span> PeopleTalk(<span class="string">"AOP"</span>, <span class="string">"18"</span>);</span><br><span class="line">        people.talk(<span class="string">"No ProXY Test"</span>);</span><br><span class="line">        System.out.println(<span class="string">"-----------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要执行额外方法的（切面）</span></span><br><span class="line">        TalkProxy talker = <span class="keyword">new</span> TalkProxy(people);</span><br><span class="line">        talker.talk(<span class="string">"ProXY Test"</span>, <span class="string">"代理"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码可以看出来，代理模式其实就是AOP的雏形。上端代码中talk(String msg, String singname)是一个切面。在代理类中的sing(singname)方法是个后置处理方法。</p><p>这样就实现了，其他的辅助方法和业务方法的解耦。业务不需要专门去调用，而是走到talk方法，顺理成章的调用sing方法</p><p>再从这段代码看：</p><ul><li>要实现代理方式，必须要定义接口。</li><li>每个业务类，需要一个代理类。</li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><blockquote><p>jdk1.5中提供，利用反射。实现InvocationHandler接口。</p><p>业务接口还是必须得，业务接口，业务类同上。</p></blockquote><ul><li>代理类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 需要代理的目标类 */</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写法固定，aop专用:绑定委托对象并返回一个代理类</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delegate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Object</span></span><br><span class="line"><span class="comment">     *            target：指被代理的对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Method</span></span><br><span class="line"><span class="comment">     *            method：要调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Object</span></span><br><span class="line"><span class="comment">     *            [] args：方法调用时所需要的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 切面之前执行</span></span><br><span class="line">        System.out.println(<span class="string">"切面之前执行"</span>);</span><br><span class="line">        <span class="comment">// 执行业务</span></span><br><span class="line">        result = method.invoke(target, args);</span><br><span class="line">        <span class="comment">// 切面之后执行</span></span><br><span class="line">        System.out.println(<span class="string">"切面之后执行"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 绑定代理，这种方式会在所有的方法都加上切面方法</span></span><br><span class="line">        ITalk iTalk = (ITalk) <span class="keyword">new</span> DynamicProxy().bind(<span class="keyword">new</span> PeopleTalk());</span><br><span class="line">        iTalk.talk(<span class="string">"业务说明"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果会是：</p><pre><code>切面之前执行people talk业务说明切面之后执行</code></pre><p>说明只要在业务调用方法切面之前，是可以动态的加入需要处理的方法。</p><p>从代码来看，如果再建立一个业务模块，也只需要一个代理类。ITalk iTalk = (ITalk) new DynamicProxy().bind(new PeopleTalk()); 将业务接口和业务类绑定到动态代理类。</p><p>但是这种方式：还是需要定义接口。</p><h3 id="利用cglib"><a href="#利用cglib" class="headerlink" title="利用cglib"></a>利用cglib</h3><blockquote><p>CGLIB是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强。采用的是继承的方式。</p></blockquote><ul><li>业务类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeopleTalk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"people talk"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>cglib代理类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用cglib动态代理</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建代理对象</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());</span><br><span class="line">        <span class="comment">// 回调方法</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">"事物开始"</span>);</span><br><span class="line">        result = methodProxy.invokeSuper(proxy, args);</span><br><span class="line">        System.out.println(<span class="string">"事物结束"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PeopleTalk peopleTalk = (PeopleTalk) <span class="keyword">new</span> CglibProxy().getInstance(<span class="keyword">new</span> PeopleTalk());</span><br><span class="line">        peopleTalk.talk(<span class="string">"业务方法"</span>);</span><br><span class="line">        peopleTalk.spreak(<span class="string">"业务方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出结果：</p><pre><code>事物开始people talk业务方法事物结束事物开始spreak chinese业务方法事物结束</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Aspect Oriented Programming面向切面编程。解耦是程序员编码开发过程中一直追求的。AOP也是为了解耦所诞生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体思想&lt;/strong&gt;是：定义一个切面，在切面的纵向定义处理方法，处理完成之后，回到横向业务流。&lt;/p&gt;
&lt;p&gt;AOP在Spring框架中被作为核心组成部分之一，的确Spring将AOP发挥到很强大的功能。最常见的就是&lt;strong&gt;事务控制&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;AOP 主要是利用&lt;strong&gt;代理模式&lt;/strong&gt;的技术来实现的。&lt;/p&gt;
    
    </summary>
    
      <category term="Java面试" scheme="blog.jiangdongyu.space/categories/Java%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Spring" scheme="blog.jiangdongyu.space/categories/Java%E9%9D%A2%E8%AF%95/Spring/"/>
    
    
      <category term="Spring" scheme="blog.jiangdongyu.space/tags/Spring/"/>
    
      <category term="AOP" scheme="blog.jiangdongyu.space/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>IOC的定义及实现原理——反射</title>
    <link href="blog.jiangdongyu.space/2018/07/13/Spring%20IOC%E5%8E%9F%E7%90%86/"/>
    <id>blog.jiangdongyu.space/2018/07/13/Spring IOC原理/</id>
    <published>2018-07-13T11:22:00.000Z</published>
    <updated>2018-07-15T08:26:57.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IOC-DI"><a href="#IOC-DI" class="headerlink" title="IOC(DI)"></a>IOC(DI)</h2><p>Java程序员都知道：Java程序中的每个业务逻辑至少需要两个或以上的对象来协作完成，通常，每个对象在使用他的合作对象时，自己均要使用像new object()这样的语法来完成合作对象的申请工作。你会发现，对象间的耦合度高了。而IOC的<strong>思想</strong>是: <strong>Spring容器来实现这些相互依赖对象的创建、协调工作</strong>。对象只需要关系业务逻辑本身就可以了。从这方面来说，对象如何得到他的协作对象的责任被反转了(IOC、DI)。</p><a id="more"></a><p>DI其实就是IOC的另外一种说法。DI是由Martin Fowler 在2004年初的一篇论文中首次提出的。他总结：<strong>控制的什么被反转了？就是：获得依赖对象的方式反转了</strong>。</p><h3 id="IOC与DI"><a href="#IOC与DI" class="headerlink" title="IOC与DI"></a>IOC与DI</h3><p>首先想说说IOC(Inversion of Control，控制倒转)。这是Spring的<strong>核心</strong>，贯穿始终。所谓IOC，对于Spring框架来说，就是<strong>由Spring来负责控制对象的生命周期和对象间的关系</strong>。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，<strong>在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。</strong></p><p>那么IOC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，<strong>所有的类都会在Spring容器中登记</strong>，告诉Spring你是个什么东西，你需要什么东西，然后Spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。<strong>所有的类的创建、销毁都由Spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是Spring</strong>。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被Spring控制，所以这叫控制反转。</p><p>IOC的一个重点是在系统运行中，<strong>动态</strong>地向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了Spring我们就只需要告诉Spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，Spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖Connection才能正常运行，而这个Connection是由Spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢? Java 1.3之后一个重要特征是<strong>反射</strong>(reflection)，它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，<strong>Spring就是通过反射来实现注入的</strong>。</p><h3 id="Spring是怎么运行的"><a href="#Spring是怎么运行的" class="headerlink" title="Spring是怎么运行的"></a>Spring是怎么运行的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> ApplicationContext context = <span class="keyword">new</span> FileSystemXmlApplicationContext(</span><br><span class="line"><span class="string">"applicationContext.xml"</span>);</span><br><span class="line"> Animal animal = (Animal) context.getBean(<span class="string">"animal"</span>);</span><br><span class="line"> animal.say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>applicationContext.xml</strong>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"animal"</span> <span class="attr">class</span>=<span class="string">"phz.springframework.test.Cat"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"kitty"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>类phz.springframework.test.Cat:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"I am "</span> + name + <span class="string">"!"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = name;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了phz.springframework.test.Animal接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显上面的代码输出<strong>I am kitty!</strong></p><h3 id="实现Spring"><a href="#实现Spring" class="headerlink" title="实现Spring"></a>实现Spring</h3><p>那么到底Spring是如何做到的呢？</p><p>接下来就让我们自己写个Spring来看看Spring到底是怎么运行的吧！ </p><p>首先，我们定义一个Bean类，这个类用来存放一个Bean拥有的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/* Bean Id */</span></span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"><span class="comment">/* Bean Class */</span></span><br><span class="line"><span class="keyword">private</span> String type;</span><br><span class="line"><span class="comment">/* Bean Property */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; properties = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br></pre></td></tr></table></figure><p>一个Bean包括id,type,和Properties。 </p><p>接下来Spring就开始加载我们的配置文件了，将我们配置的信息保存在一个HashMap中，HashMap的key就是Bean的Id，HasMap的value是这个Bean，只有这样我们才能通过context.getBean(“animal”)这个方法获得Animal这个类。我们都知道Spirng可以注入基本类型，而且可以注入像List，Map这样的类型，接下来就让我们以Map为例看看Spring是怎么保存的。</p><p>Map配置可以像下面的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">class</span>=<span class="string">"Test"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testMap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"b"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring是怎样保存上面的配置呢？代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(beanProperty.element(<span class="string">"map"</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line"> Map&lt;String, Object&gt; propertiesMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"> Element propertiesListMap = (Element) beanProperty</span><br><span class="line">.elements().get(<span class="number">0</span>);</span><br><span class="line"> Iterator&lt;?&gt; propertiesIterator = propertiesListMap</span><br><span class="line">.elements().iterator();</span><br><span class="line"> <span class="keyword">while</span> (propertiesIterator.hasNext()) &#123;</span><br><span class="line">  Element vet = (Element) propertiesIterator.next();</span><br><span class="line">  <span class="keyword">if</span> (vet.getName().equals(<span class="string">"entry"</span>)) &#123;</span><br><span class="line">   String key = vet.attributeValue(<span class="string">"key"</span>);</span><br><span class="line">   Iterator&lt;?&gt; valuesIterator = vet.elements()</span><br><span class="line">.iterator();</span><br><span class="line">   <span class="keyword">while</span> (valuesIterator.hasNext()) &#123;</span><br><span class="line">Element value = (Element) valuesIterator.next();</span><br><span class="line"><span class="keyword">if</span> (value.getName().equals(<span class="string">"value"</span>)) &#123;</span><br><span class="line"> propertiesMap.put(key, value.getText());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (value.getName().equals(<span class="string">"ref"</span>)) &#123;</span><br><span class="line"> propertiesMap.put(key, <span class="keyword">new</span> String[] &#123; value.attributeValue(<span class="string">"bean"</span>) &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  bean.getProperties().put(name, propertiesMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就进入最核心部分了，让我们看看Spring到底是怎么<strong>依赖注入</strong>的吧，其实依赖注入的思想也很简单，它是通过<strong>反射</strong>机制实现的，在实例化一个类时，它通过<strong>反射调用类中set方法将事先保存在HashMap中的类属性注入到类中</strong>。让我们看看具体它是怎么做的吧。</p><p>首先<strong>实例化</strong>一个类，像这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line"> Class&lt;?&gt; cls = <span class="keyword">null</span>;</span><br><span class="line"> Object obj = <span class="keyword">null</span>;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  cls = Class.forName(className);</span><br><span class="line">  obj = cls.newInstance();</span><br><span class="line"> &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着它将这个<strong>类的依赖注入进去</strong>，像这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setProperty</span><span class="params">(Object obj, String name, String value)</span> </span>&#123;</span><br><span class="line"> Class&lt;? extends Object&gt; clazz = obj.getClass();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  String methodName = returnSetMthodName(name);</span><br><span class="line">  Method[] ms = clazz.getMethods();</span><br><span class="line">  <span class="keyword">for</span> (Method m : ms) &#123;</span><br><span class="line">   <span class="keyword">if</span> (m.getName().equals(methodName)) &#123;</span><br><span class="line"><span class="keyword">if</span> (m.getParameterTypes().length == <span class="number">1</span>) &#123;</span><br><span class="line"> Class&lt;?&gt; clazzParameterType = m.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line"> setFieldValue(clazzParameterType.getName(), value, m,obj);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后它将这个类的实例返回给我们，我们就可以用了。我们还是以Map为例看看它是怎么做的，我写的代码里面是创建一个HashMap并把该HashMap注入到需要注入的类中，像这样，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line"> Iterator&lt;?&gt; entryIterator = ((Map&lt;?, ?&gt;) value).entrySet().iterator();</span><br><span class="line"> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"> <span class="keyword">while</span> (entryIterator.hasNext()) &#123;</span><br><span class="line">  Entry&lt;?, ?&gt; entryMap = (Entry&lt;?, ?&gt;) entryIterator.next();</span><br><span class="line">  <span class="keyword">if</span> (entryMap.getValue() <span class="keyword">instanceof</span> String[]) &#123;</span><br><span class="line">map.put((String) entryMap.getKey(),</span><br><span class="line">getBean(((String[]) entryMap.getValue())[<span class="number">0</span>]));</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> BeanProcesser.setProperty(obj, property, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，这样我们就可以用Spring给我们创建的类了，是不是也不是很难啊？当然Spring能做到的远不止这些，这个示例程序仅仅提供了Spring最核心的依赖注入功能中的一部分。 </p><p>本文参考了大量文章无法一一感谢，在这一起感谢，如果侵犯了你的版权深表歉意，很希望对大家有帮助！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;IOC-DI&quot;&gt;&lt;a href=&quot;#IOC-DI&quot; class=&quot;headerlink&quot; title=&quot;IOC(DI)&quot;&gt;&lt;/a&gt;IOC(DI)&lt;/h2&gt;&lt;p&gt;Java程序员都知道：Java程序中的每个业务逻辑至少需要两个或以上的对象来协作完成，通常，每个对象在使用他的合作对象时，自己均要使用像new object()这样的语法来完成合作对象的申请工作。你会发现，对象间的耦合度高了。而IOC的&lt;strong&gt;思想&lt;/strong&gt;是: &lt;strong&gt;Spring容器来实现这些相互依赖对象的创建、协调工作&lt;/strong&gt;。对象只需要关系业务逻辑本身就可以了。从这方面来说，对象如何得到他的协作对象的责任被反转了(IOC、DI)。&lt;/p&gt;
    
    </summary>
    
      <category term="Java面试" scheme="blog.jiangdongyu.space/categories/Java%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Spring" scheme="blog.jiangdongyu.space/categories/Java%E9%9D%A2%E8%AF%95/Spring/"/>
    
    
      <category term="Spring" scheme="blog.jiangdongyu.space/tags/Spring/"/>
    
      <category term="IOC" scheme="blog.jiangdongyu.space/tags/IOC/"/>
    
  </entry>
  
  <entry>
    <title>String</title>
    <link href="blog.jiangdongyu.space/2018/07/11/String/"/>
    <id>blog.jiangdongyu.space/2018/07/11/String/</id>
    <published>2018-07-11T09:35:00.000Z</published>
    <updated>2018-07-13T07:07:42.835Z</updated>
    
    <content type="html"><![CDATA[<h3 id="38-Count-and-Say"><a href="#38-Count-and-Say" class="headerlink" title="38.Count and Say"></a>38.Count and Say</h3><p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p><a id="more"></a><pre><code>1.     12.     113.     214.     12115.     111221</code></pre><p>1 is read off as “one 1” or 11.</p><p>11 is read off as “two 1s” or 21.</p><p>21 is read off as “one 2, then one 1” or 1211.</p><p>Given an integer n, generate the nth term of the count-and-say sequence.</p><p><strong>Note</strong>: Each term of the sequence of integers will be represented as a string.</p><p><strong>Example 1</strong>:</p><pre><code>Input: 1Output: &quot;1&quot;</code></pre><p><strong>Example 2</strong>:</p><pre><code>Input: 4Output: &quot;1211&quot;</code></pre><blockquote><p>题目有些晦涩，就以上面的例子解释，“1”读出来是“一个1”，因此第二行就是“11”，“11”读出来是“两个1”,因此第三行就是“21”,“21”读出来是“一个2一个1”，因此第四行就是“1211”，以此类推</p></blockquote><p><strong>思路</strong></p><ul><li>如果我们要获得第n个字符串，那我们首先要获得第n-1个字符串的值。所以我们设置一个prev变量来保存每一次操作的到的字符串的值，从而进行下一次操作。</li><li>操作其实就是从前到后对每一个字符(say)连续出现的次数计数(count)，如果字符变了，那么就将刚才count和say的值加入curr字符串中。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder cur = <span class="keyword">new</span> StringBuilder(<span class="string">"1"</span>);</span><br><span class="line">        StringBuilder pre;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">char</span> say = pre.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; pre.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pre.charAt(j) != say)&#123;</span><br><span class="line">                    cur.append(count).append(say);</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                    say = pre.charAt(j);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    count++; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.append(count).append(say);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.toString();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-Zigzag-Conversion"><a href="#6-Zigzag-Conversion" class="headerlink" title="6.Zigzag Conversion"></a>6.Zigzag Conversion</h3><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p><pre><code>P   A   H   NA P L S I I GY   I   R</code></pre><p>And then read line by line: “PAHNAPLSIIGYIR”</p><p>Write the code that will take a string and make this conversion given a number of rows:</p><p>string convert(string s, int numRows);</p><p><strong>Example 1</strong>:</p><pre><code>Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3Output: &quot;PAHNAPLSIIGYIR&quot;</code></pre><p><strong>Example 2</strong>:</p><pre><code>Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4Output: &quot;PINALSIGYAHRPI&quot;Explanation:P     I    NA   L S  I GY A   H RP     I</code></pre><ul><li>重要是找准规律！</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> length = c.length;</span><br><span class="line">        StringBuilder[] sb = <span class="keyword">new</span> StringBuilder[numRows];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; numRows;i++) sb[i] = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; length)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; numRows &amp;&amp; i &lt; length;j++)&#123;</span><br><span class="line">                sb[j].append(c[i++]);<span class="comment">//垂直往下</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = numRows-<span class="number">2</span>;j &gt; <span class="number">0</span> &amp;&amp; i &lt; length;j--)&#123;</span><br><span class="line">                sb[j].append(c[i++]);<span class="comment">//斜着向上</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; numRows;j++)&#123;</span><br><span class="line">            sb[<span class="number">0</span>].append(sb[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb[<span class="number">0</span>].toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="58-Length-of-Last-word"><a href="#58-Length-of-Last-word" class="headerlink" title="58.Length of Last word"></a>58.Length of Last word</h3><p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.</p><p>If the last word does not exist, return 0.</p><p>Note: A word is defined as a character sequence consists of non-space characters only.</p><p><strong>Example:</strong></p><pre><code>Input: &quot;Hello World&quot;Output: 5</code></pre><ul><li>比较简单</li><li>记得trim(),再进行split操作</li></ul><h3 id="165-Compare-Version-Number"><a href="#165-Compare-Version-Number" class="headerlink" title="165.Compare Version Number"></a>165.Compare Version Number</h3><p>Compare two version numbers version1 and version2.<br>If <strong>version1 &gt; version2</strong> return <strong>1</strong>; if <strong>version1 &lt; version2</strong> return <strong>-1</strong>;otherwise return <strong>0</strong>.</p><p>You may assume that the version strings are non-empty and contain only digits and the . character.<br>The . character does not represent a decimal point and is used to separate number sequences.<br>For instance, 2.5 is not “two and a half” or “half way to version three”, it is the fifth second-level revision of the second first-level revision.</p><p><strong>Example 1:</strong></p><pre><code>Input: version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot;Output: -1</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: version1 = &quot;1.0.1&quot;, version2 = &quot;1&quot;Output: 1</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;Output: -1</code></pre><ul><li>还是挺简单的，但是要注意split的时候”.”的表示</li><li>在java中“\”代表转义字符，而“.”代表一个元字符，要表示一个“.”就需要用“.”，所以”\.” 在实际编译中就代表“.”</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(String version1, String version2)</span> </span>&#123;</span><br><span class="line">        String[] ver1 = version1.split(<span class="string">"\\."</span>);</span><br><span class="line">        String[] ver2 = version2.split(<span class="string">"\\."</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = Math.max(ver1.length,ver2.length);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = i &lt; ver1.length ? Integer.parseInt(ver1[i]):<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> num2 = i &lt; ver2.length ? Integer.parseInt(ver2[i]):<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(num1 &gt; num2)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num1 &lt; num2)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="151-Reverse-Words-in-a-String"><a href="#151-Reverse-Words-in-a-String" class="headerlink" title="151.Reverse Words in a String"></a>151.Reverse Words in a String</h3><p>Given an input string, reverse the string word by word.</p><p><strong>Example:</strong>  </p><pre><code>Input: &quot;the sky is blue&quot;,Output: &quot;blue is sky the&quot;.</code></pre><p><strong>Note:</strong></p><ul><li>A word is defined as a sequence of non-space characters.</li><li>Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces.</li><li>You need to reduce multiple spaces between two words to a single space in the reversed string.</li></ul><p><strong>注意两个单词之间可能有多个空格</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String[] arr = s.trim().split(<span class="string">" +"</span>);<span class="comment">//处理一个或多个空格</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            sb.append(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="186-Reverse-Words-in-a-String-II"><a href="#186-Reverse-Words-in-a-String-II" class="headerlink" title="186.Reverse Words in a String II"></a>186.Reverse Words in a String II</h3><p>Given an input string, reverse the string word by word. A word is defined as a sequence of non-space characters.</p><p>The input string <strong>does not contain</strong> leading or trailing spaces and the words are always separated by a single space.</p><p>For example, Given s = “the sky is blue”, return “blue is sky the”.</p><p>Could you do it in-place without allocating extra space?</p><ul><li>先反转整个数组，再对每个单词进行反转</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseWords</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        reverse(s, <span class="number">0</span>, s.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">                reverse(s, start, i - <span class="number">1</span>);</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(s, start, s.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = s[start];</span><br><span class="line">            s[start] = s[end];</span><br><span class="line">            s[end] = tmp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Palindrome"><a href="#Palindrome" class="headerlink" title="Palindrome"></a>Palindrome</h3><h4 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5.Longest Palindromic Substring"></a>5.Longest Palindromic Substring</h4><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer.</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: &quot;cbbd&quot;Output: &quot;bb&quot;</code></pre><p><strong>暴力枚举</strong></p><ul><li>穷举所有子字符串的可能，然后依次按位判断其是否是回文，并更新结果。虽然其时间复杂度很高，但它对空间的要求很低。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxStart = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; len - i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isPalindrome(s,i,j) &amp;&amp; (i+<span class="number">1</span>) &gt; maxLen)&#123;</span><br><span class="line">                    maxLen = i+<span class="number">1</span>;</span><br><span class="line">                    maxStart = j;</span><br><span class="line">                &#125;      </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxStart,maxStart+maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = j;</span><br><span class="line">        <span class="keyword">int</span> right = i+j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left) != s.charAt(right))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态规划</strong></p><ul><li>dp[i][j]代表字符串从i到j是否为回文串</li><li>当s.charAt(i)==s.charAt(j)并且dp[i+1][j-1]为true时，dp[i][j] = true</li><li>需要注意上述i,j相邻以及i,j中间有别的字符时，上式也成立</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxStart = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(j)==s.charAt(i) &amp;&amp; (j-<span class="number">2</span> &lt;= i || dp[i+<span class="number">1</span>][j-<span class="number">1</span>]))&#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(maxLength &lt; j-i+<span class="number">1</span>)&#123;</span><br><span class="line">                        maxLength = j -i + <span class="number">1</span>;</span><br><span class="line">                        maxStart = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxStart,maxStart + maxLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>中心扩散法</strong></p><ul><li>从小到大连续以某点为个中心的所有子字符串进行计算</li><li>外层循环遍历的是子字符串的中心点，内层循环则是从中心扩散</li><li>中心对称有两种情况，一是奇数个字母以某个字母对称，而是偶数个字母以两个字母中间为对称</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    String longest = <span class="string">""</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="comment">//计算奇数子字符串</span></span><br><span class="line">            helper(s, i, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//计算偶数子字符串</span></span><br><span class="line">            helper(s, i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(String s, <span class="keyword">int</span> idx, <span class="keyword">int</span> offset)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = idx;</span><br><span class="line">        <span class="keyword">int</span> right = idx + offset;</span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span> &amp;&amp; right&lt;s.length() &amp;&amp; s.charAt(left)==s.charAt(right))&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 截出当前最长的子串</span></span><br><span class="line">        String currLongest = s.substring(left + <span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">// 判断是否比全局最长还长</span></span><br><span class="line">        <span class="keyword">if</span>(currLongest.length() &gt; longest.length())&#123;</span><br><span class="line">            longest = currLongest;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="214-Shortest-Palindrome"><a href="#214-Shortest-Palindrome" class="headerlink" title="214.Shortest Palindrome"></a>214.Shortest Palindrome</h4><p>Given a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;aacecaaa&quot;Output: &quot;aaacecaaa&quot;</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: &quot;abcd&quot;Output: &quot;dcbabcd&quot;</code></pre><p><strong>暴力求解</strong></p><ul><li>补充之后的回文字符串的中心肯定在原字符串中</li><li>从原字符的第一个字符为起点至少存在一个回文串，找到原字符串中以第一个字符为起点最长的回文串，找到之后剩下的工作就是把剩余部分的翻转补充到原字符串头部</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || s.length() == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> len = s.length(), tail = len;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (tail &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(s.substring(<span class="number">0</span>, tail))) &#123;</span><br><span class="line">                builder = builder.append(s.substring(tail, len)).reverse();<span class="comment">//substring()从beginIndex开始取，到endIndex结束，从0开始数，其中不包括endIndex位置的字符</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tail--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.append(s).toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) != str.charAt(len - i - <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>KMP</strong>: O(n)</p><h3 id="242-Valid-Anagram"><a href="#242-Valid-Anagram" class="headerlink" title="242.Valid Anagram"></a>242.Valid Anagram</h3><p>Given two strings s and t , write a function to determine if t is an anagram of s.</p><p><strong>Example 1:</strong></p><pre><code>Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;Output: true</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: s = &quot;rat&quot;, t = &quot;car&quot;Output: false</code></pre><p><strong>Note:</strong></p><p>You may assume the string contains only lowercase alphabets.</p><p><strong>Follow up:</strong></p><p>What if the inputs contain unicode characters? How would you adapt your solution to such case?</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()!=t.length())&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">char</span>[] s1 = s.toCharArray();</span><br><span class="line">            <span class="keyword">char</span>[] s2 = t.toCharArray();</span><br><span class="line">            Arrays.sort(s1);</span><br><span class="line">            Arrays.sort(s2);</span><br><span class="line">            <span class="keyword">return</span> Arrays.equals(s1,s2);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="49-Group-Anagram"><a href="#49-Group-Anagram" class="headerlink" title="49.Group Anagram"></a>49.Group Anagram</h3><p>Given an array of strings, group anagrams together.</p><p><strong>Example:</strong></p><pre><code>Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],Output:[  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],  [&quot;nat&quot;,&quot;tan&quot;],  [&quot;bat&quot;]]</code></pre><p><strong>Note:</strong></p><ul><li>All inputs will be in lowercase.</li><li>The order of your output does not matter.</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        Map&lt;String,List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(String s:strs)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] c = s.toCharArray();<span class="comment">//String转char数组</span></span><br><span class="line">            Arrays.sort(c);</span><br><span class="line">            String key = String.valueOf(c);<span class="comment">//char数组转String</span></span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(key)) map.put(key,<span class="keyword">new</span> ArrayList());</span><br><span class="line">            map.get(key).add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(map.values());<span class="comment">//返回一个HashMap的值的Collection</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;38-Count-and-Say&quot;&gt;&lt;a href=&quot;#38-Count-and-Say&quot; class=&quot;headerlink&quot; title=&quot;38.Count and Say&quot;&gt;&lt;/a&gt;38.Count and Say&lt;/h3&gt;&lt;p&gt;The count-and-say sequence is the sequence of integers with the first five terms as following:&lt;/p&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode Category" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/LeetCode-Category/"/>
    
    
      <category term="String" scheme="blog.jiangdongyu.space/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>线程安全与锁优化</title>
    <link href="blog.jiangdongyu.space/2018/07/08/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/"/>
    <id>blog.jiangdongyu.space/2018/07/08/线程安全与锁优化/</id>
    <published>2018-07-08T06:20:00.000Z</published>
    <updated>2018-07-10T09:01:47.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>Brian Goetz对线程安全的定义：当多个线程访问一个对象时，如果不考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调度方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。</p><a id="more"></a><h3 id="Java语言中的线程安全"><a href="#Java语言中的线程安全" class="headerlink" title="Java语言中的线程安全"></a>Java语言中的线程安全</h3><p>按照线程安全的“安全程度”由强至弱来排序，java里面各种操作共享的数据分为以下5类：<strong>不可变，绝对线程安全，相对线程安全，线程兼容，线程对立</strong>。</p><ul><li><strong>不可变</strong>：可以是基本类型的<strong>final</strong>；可以是final对象，但对象的行为不会对其状态产生任何影响，比如<strong>String</strong>的subString就是new一个String对象，<strong>枚举类型</strong>，各种<strong>Number类型</strong>如BigInteger和BigDecimal等<strong>大数据类型</strong>都是不可变的，但是同为Number子类型的AtomicInteger和AtomicLong则并非不可变我觉得原因是它里面状态对象是unsafe对象，所做的操作都是CAS操作，可以保证原子性。</li><li><strong>绝对线程安全</strong>：他是完全满足Brian Goetz给出的线程安全的定义，一个类要达到这种程度，需要付出很大的，甚至不切实际的代价。</li><li><strong>相对线程安全</strong>：这就是我们通常意义上的线程安全。需要<strong>保证对象单独的操作时线程安全的</strong>。比如Vector，HashTable，synchronizedCollection包装集合等。</li><li><strong>线程兼容</strong>：<strong>对象本身不是线程安全的，但可以通过同步手段实现</strong>。一般我们说的不是线程安全的，绝大多数是指这个。比如ArrayList，HashMap等。</li><li><strong>线程对立</strong>：<strong>不管调用端是否采用了同步的措施，都无法在并发中使用的代码</strong>。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。</li></ul><h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><ul><li>互斥同步<ul><li>在多线程访问的时候，保证<strong>同一时间只有一条线程使用</strong>。而<strong>互斥是实现同步的一种手段</strong>，临界区(Critical Section)，互斥量(Mutex)，信号量(Semaphore)都是主要的互斥实现方式。java里最基本的互斥同步手段是<strong>synchronized</strong>，编译之后会形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象，还有个锁的计数器，来记录拥有锁的次数</li><li>其实在“Java与线程”里已经提到，java的线程是映射到操作系统的<strong>原生线程</strong>之上的，不管阻塞还是唤醒都需要操作系统的帮忙完成，都需要从用户态转换到核心态，这是很耗费时间的，是java语言中的一个<strong>重量级</strong>(Heavyweight)操作，虽然虚拟机本身会做一点优化的操作，比如通知操作系统阻塞之前会加一段自旋等待的过程，避免频繁切换到核心态。</li><li>还可以使用<strong>java.util.concurrent包中的重入锁（ReentrantLock）来实现同步</strong>，ReentrantLock比synchronized增加了一些高级功能：等待可中断、可实现公平锁以及锁可以绑定多个条件。</li></ul></li><li>非阻塞同步（Non-Blocking Synchronization）<ul><li><strong>互斥和同步最主要的问题就是阻塞和唤醒所带来的性能问题，所以这通常叫阻塞同步(悲观的并发策略)</strong>。随着硬件指令集的发展，我们有另外的选择：<strong>基于冲突检测的乐观并发策略</strong>，通俗讲就是先操作，如果没有其他线程争用共享的数据，操作就成功，如果有，则进行其他的补偿(最常见就是不断的重试)，这种乐观的并发策略许多实现都不需要把线程挂起，这种同步操作被称为<strong>非阻塞同步</strong>。</li></ul></li><li>无同步方案<ul><li>有一些代码天生就是线程安全的，不需要同步。其中有如下两类：</li><li><strong>可重入代码</strong>(Reentrant Code): 纯代码，具有不依赖存储在堆上的数据和公用的系统资源，用到的状态量都由参数中传入，不调用非可重入的方法等特征，它的返回结果是可以预测的。</li><li><strong>线程本地存储</strong>(Thread Local Storage): <strong>把共享数据的可见范围限制在同一个线程之内</strong>，这样就无须同步也能保证线程之间不出现数据争用问题。可以通过java.lang.ThreadLocal类来实现线程本地存储的功能。</li></ul></li></ul><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>为了在线程之间更高效的共享数据，以及解决竞争问题，从而提高程序的执行效率，创建了各种<strong>锁优化技术</strong>：适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、 锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）等。</p><ul><li><strong>自旋锁与自适应自旋</strong>：<ul><li>线程挂起和恢复的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力，在许多应用中，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得，可以让后请求锁的线程等待一会儿，但不放弃处理器的执行时间，让线程执行一个<strong>忙循环(自旋)</strong>。</li><li>自旋锁默认的自旋次数值是10次，可以使用参数-XX:PreBlockSpin更改。</li><li>自适应自旋意味着<strong>自旋的时间不再固定</strong>，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</li></ul></li><li><strong>锁消除</strong>：<ul><li>虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到<strong>不可能存在共享数据竞争的锁进行消除</strong>。锁消除的主要判定依据来源于<strong>逃逸分析</strong>的数据支持。</li></ul></li><li><strong>锁粗化</strong>：<ul><li>如果虚拟机探测到有一系列连续操作都<strong>对同一个对象反复加锁和解锁</strong>，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。</li></ul></li><li><strong>轻量级锁</strong>：<ul><li>使用对象头的Mark Word中锁标志位代替操作系统互斥量实现的锁。轻量级锁并不是用来代替重量级锁，它的本意是<strong>在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗</strong>。</li><li>轻量级锁是在无竞争的情况下使用CAS（Compare-and-Swap）操作去消除同步使用的互斥量。</li></ul></li><li><strong>偏向锁</strong>：<ul><li>和轻量级锁原理基本一致，但偏向锁在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程安全&quot;&gt;&lt;a href=&quot;#线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程安全&quot;&gt;&lt;/a&gt;线程安全&lt;/h2&gt;&lt;p&gt;Brian Goetz对线程安全的定义：当多个线程访问一个对象时，如果不考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调度方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="读书笔记" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深入理解Java虚拟机" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="高效并发" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
      <category term="Thread" scheme="blog.jiangdongyu.space/tags/Thread/"/>
    
      <category term="Lock" scheme="blog.jiangdongyu.space/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型与线程</title>
    <link href="blog.jiangdongyu.space/2018/07/06/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>blog.jiangdongyu.space/2018/07/06/Java内存模型与线程/</id>
    <published>2018-07-06T11:30:00.000Z</published>
    <updated>2018-07-10T09:02:05.462Z</updated>
    
    <content type="html"><![CDATA[<p>衡量一个服务性能的高低好坏，每秒事物处理数(TPS)是最重要的指标之一，它代表着一秒内服务端平均能响应的请求总数，而TPS的值与程序的<strong>并发</strong>能力又有密切的关系。对于计算量相同的任务，程序线程并发协调越有条不紊，效率自然就越高；反之，线程之间频繁阻塞甚至死锁，将会大大降低程序的并发能力。</p><a id="more"></a><h2 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h2><p>物理机并发问题与虚拟机的情况有不少相似之处。</p><p>计算机的存储设备与处理器的运算速度有几个数量级的差距，因而加入高速缓存来作为内存与处理器之间的缓冲，引入新的问题：<strong>缓存一致性</strong>。</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG299.jpeg" alt="avatar"></p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p>Java内存模型的主要目标是定义程序中各个变量的<strong>访问规则</strong>，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量，包括了<strong>实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数</strong>，因为后者是线程私有的，不会被共享，自然没有竞争问题。</p><p>Java内存模型规定了所有的变量都存储在<strong>主内存</strong>中。每条<strong>线程</strong>还有自己的<strong>工作内存</strong>，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，<strong>线程对变量的所有操作都必须在工作内存中进行</strong>，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG300.jpeg" alt="avatar"></p><h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的(对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外)：</p><ul><li>lock(锁定): 作用于<strong>主内存</strong>的变量，它把一个变量标识为一条线程独占的状态</li><li>unlock(解锁): 作用于<strong>主内存</strong>的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read(读取): 作用于<strong>主内存</strong>变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li>load(载入): 作用于<strong>工作内存</strong>的变量，它把read操作从主内存中得到的变量值放入到工作内存的变量副本中。</li><li>use(使用): 作用于<strong>工作内存</strong>的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个<strong>需要使用到变量</strong>的值的字节码指令的时候将会执行这个操作。</li><li>assign(赋值): 作用于<strong>工作内存</strong>的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个<strong>给变量赋值</strong>的字节码指令时将会执行这个操作。</li><li>store(存储): 作用于<strong>工作内存</strong>变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li><li>write(写入): 作用于<strong>主内存</strong>变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ul><p>Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：</p><ol><li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</li><li>不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步会主内存中。</li><li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use和store操作之前，必须先执行过assign和load操作。</li><li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock之后，只有执行相同次数的unlock操作，变量才会被解锁。</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定住的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store和write操作）。</li></ol><h3 id="对于volatile型变量的特殊规则"><a href="#对于volatile型变量的特殊规则" class="headerlink" title="对于volatile型变量的特殊规则"></a>对于volatile型变量的特殊规则</h3><p>关键字volatile可以说是Java虚拟机提供的<strong>最轻量级的同步机制</strong>。当一个变量被定义成volatile之后，它将具备两种特性，第一是<strong>保证此变量对所有线程的可见性</strong>，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以<strong>立即得知的</strong>。</p><p>由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性。</p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li><li>变量不需要与其他的状态变量共同参与不变约束。</li></ul><p>第二个特性是<strong>禁止指令重排序优化</strong>。普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这样就是Java内存模型中描述的所谓的“线程内表现为串行的语义”。</p><h3 id="对于long和double型变量的特殊规则"><a href="#对于long和double型变量的特殊规则" class="headerlink" title="对于long和double型变量的特殊规则"></a>对于long和double型变量的特殊规则</h3><p>Java内存模型要求lock、unlock、read、load、assign、use、store和write这8个操作都具有原子性，但是对于64位的数据类型long和double，在模型中特别定义了一条宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这四个操作的原子性，这点就是所谓的long和double的<strong>非原子性协定</strong>。</p><p>如果有多个线程共享一个未被声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读到一个既非原值，也非其他线程修改值的代表了“半个变量”的数值。</p><p>不过这种读取到“半个变量”的情况非常罕见，因为Java内存模型虽然允许虚拟机不把long和double变量的读写实现成原子操作，但<strong>允许虚拟机选择把这些操作实现为具有原子性的操作</strong>，而且还“强烈建议”虚拟机这样实现。目前各种平台下的商用虚拟机几乎都选择吧64位数据的读写操作作为原子操作来对待，因此在编码时，不需要将long和double变量专门声明为volatile。</p><h3 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h3><p>Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的：</p><ul><li>原子性(Atomicity):<ul><li>由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，我们大致可以认为基本数据类型的访问读写是具备原子性的。</li><li>在synchronized块之间的操作也具备原子性。</li></ul></li><li>可见性(Visibility): <ul><li>指当一个线程修改了共享变量的值，其他线程能够<strong>立即</strong>得知这个修改。</li><li>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介实现可见性的</li><li>普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能<strong>立即</strong>同步到主内存，以及每次使用前立即从主内存刷新。</li><li>除了volatile之外，synchronized和final也能实现可见性。同步块的可见性是由“<strong>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中</strong>”这条规则获得的，而final关键字的可见性是指：<strong>被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去，那在其他线程中就能看见final字段的值</strong></li></ul></li><li>有序性(Ordering): <ul><li>Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。</li><li>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了<strong>禁止指令重排序</strong>的语义，而synchronized则是由“<strong>一个变量在同一个时刻只允许一条线程对其进行lock操作</strong>”这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能<strong>串行</strong>地进入</li></ul></li></ul><h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p>先行发生是Java内存模型中定义的两项操作之间的<strong>偏序关系</strong>，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了小写、调用了方法等。</p><p>下面是Java内存模型下一些“天然的”先行发生关系，这些先行发送关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，他们就没有顺序性保障，虚拟机可以对它们进行随意重新排序。</p><ul><li>程序次序规则(Program Order Rule): 在一个线程内，按照程序<strong>代码顺序</strong>，书写在钱吗的操作先于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li><li>管程锁定规则(Monitor Lock Rule): 一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。</li><li>volatile变量规则(Volatile Variable Rule): 对一个volatile变量的写操作先行发生于后面对这个变量的读操作。“后面”是指时间上的先后顺序。</li><li>线程启动规则(Thread Start Rule): Thread对象的start()方法先行发生于此线程的每一个动作。</li><li>线程终止规则(Thread Termination Rule): 线程中所有操作都先行发生于此线程的终止检测。</li><li>线程中断规则(Thread Interruption Rule): 对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li><li>对象终结规则(Finalizer Rule): 一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</li><li>传递性(Transitivity): 如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得到操作A先行发生于操作C。</li></ul><h2 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h2><h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><ul><li>使用内核线程实现<ul><li>内核线程(Kernel Thread，KLT)就是直接由操作系统内核支持的线程，这种线程由<strong>内核</strong>来完成<strong>线程切换</strong>，内核通过操纵<strong>调度器</strong>对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程都可以看做是内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就叫<strong>多线程内核</strong>。</li><li>程序一般不会直接使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程(Light Weight Process，LWP)，轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。<br><img src="http://p9fh1pach.bkt.clouddn.com/20141214145942631.png" alt="avatar"></li><li>由于内核线程的支持，每个轻量级进程都成为一个<strong>独立</strong>的调度单元，即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作，但轻量级进程具有它的局限性：基于线程内核实现，各种线程操作都需要进行<strong>系统调用</strong>，系统调用代价高，需要在用户态和内核态中来回切换；轻量级进程都需要有一个内核线程的支持，<strong>消耗内核资源</strong></li></ul></li><li>使用用户线程实现<ul><li><strong>广义</strong>上，一个线程只要不是内核线程，那就可以认为是用户线程(User Thread，UT)。</li><li><strong>狭义</strong>上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到线程存在的实现。<br><img src="http://p9fh1pach.bkt.clouddn.com/20141214150247703.png" alt="avatar"></li><li>使用用户线程的<strong>优势劣势</strong>都在于没有系统内核的支援，所有线程操作都需要用户程序自己处理，困难，实现复杂，放弃使用  </li></ul></li><li>使用用户线程加轻量级进程混合实现<ul><li>线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式。在这种混合实现下，既存在用户线程，也存在轻量级进程。<br><img src="http://p9fh1pach.bkt.clouddn.com/20141214150313341.png" alt="avatar"></li></ul></li></ul><h3 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h3><p>线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是<strong>协同式线程调度</strong>(Cooperative Threads-Scheduling)和<strong>抢占式线程调度</strong>(Preemptive Threads-Scheduling)。</p><ul><li>如果使用<strong>协同式</strong>调度的多线程系统，线程的执行时间由<strong>线程</strong>本身来控制，线程把自己的工作执行完毕后，要主动通知系统切换到另一个线程上去。</li><li>如果使用<strong>抢占式</strong>调度的多线程系统，那么每个线程将由<strong>系统</strong>来分配执行时间，线程的切换不由线程本身来决定(在Java中，Thread.yield()可以让出执行时间，但要获取执行时间的话，线程本身是没有什么办法)。Java使用抢占式调度。线程优先级</li></ul><h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>Java语言定义了5种线程状态，在任意一个时间点，一个线程只能有且只有其中的一种状态，这5种状态分别是：</p><ul><li>新建(New): 创建后尚未启动</li><li>运行(Runable): Runable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待CPU为它分配执行时间</li><li>无期限等待(Waiting): 不会被分配CPU执行时间，需要等待被其他线程显式地唤醒</li><li>期限等待(Timed Waiting): 不会被分配CPU执行时间，无须等待被其他线程显式地唤醒，在一定时间之后会由系统自动唤醒</li><li>阻塞(Blocked): 线程被阻塞了，“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是等待一段时间，或者唤醒动作的发生</li><li>结束(Terminated): 已终止线程的线程状态，线程已经结束执行</li></ul><p>上述5种状态在遇到特定事件发生的时候会相互转换。<br><img src="http://p9fh1pach.bkt.clouddn.com/20141214150758572.png" alt="avatar"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;衡量一个服务性能的高低好坏，每秒事物处理数(TPS)是最重要的指标之一，它代表着一秒内服务端平均能响应的请求总数，而TPS的值与程序的&lt;strong&gt;并发&lt;/strong&gt;能力又有密切的关系。对于计算量相同的任务，程序线程并发协调越有条不紊，效率自然就越高；反之，线程之间频繁阻塞甚至死锁，将会大大降低程序的并发能力。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="读书笔记" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深入理解Java虚拟机" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="高效并发" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
      <category term="Thread" scheme="blog.jiangdongyu.space/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>晚期(运行期)优化</title>
    <link href="blog.jiangdongyu.space/2018/07/05/%E6%99%9A%E6%9C%9F(%E8%BF%90%E8%A1%8C%E6%9C%9F)%E4%BC%98%E5%8C%96/"/>
    <id>blog.jiangdongyu.space/2018/07/05/晚期(运行期)优化/</id>
    <published>2018-07-05T05:26:00.000Z</published>
    <updated>2018-07-10T09:01:34.904Z</updated>
    
    <content type="html"><![CDATA[<p>在部分商用虚拟机(HotSpot、IBM J9)中，Java程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“<strong>热点代码</strong>”。为了提高热点代码的执行效率，在运行时，虚拟机会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为<strong>即时编译器</strong>。</p><a id="more"></a><h2 id="HotSpot虚拟机内的即时编译器"><a href="#HotSpot虚拟机内的即时编译器" class="headerlink" title="HotSpot虚拟机内的即时编译器"></a>HotSpot虚拟机内的即时编译器</h2><h3 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h3><p>并不是所有的Java虚拟机都采用解释器与编译器并存的架构，但许多主流的商用虚拟机，如HotSpot、J9等，都同时包含解释器与编译器。解释器与编译器两者各有优势：</p><ul><li>当程序需要<strong>迅速启动和执行</strong>的时候，<strong>解释器</strong>可以首先发挥作用，省去编译的时间，立即执行</li><li>程序运行后，随着时间的推移，<strong>编译器</strong>逐渐发挥作用，把越来越多代码编译成本地代码之后，可以获取更高的执行效率</li><li>当程序运行环境中内存资源限制较大，可以使用<strong>解释执行节约内存</strong>，反之可以使用<strong>编译执行提升效率</strong></li><li>解释器还可以作为编译器<strong>激进优化</strong>时的一个“逃生门”，让编译器根据概率选择一些大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立时可以通过<strong>逆优化</strong>退回到解释状态继续执行。</li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG292.jpeg" alt="avatar"></p><p>无论采用的编译器是Client Compiler还是Server Compiler，解释器与编译器搭配使用的方式在虚拟机中称为“混合模式”，用户可以使用参数“-Xint”<strong>强制</strong>虚拟机运行于“解释模式”，这时<strong>编译器完全不介入工作</strong>，全部代码都使用解释方式执行。另外，也可以使用参数“-Xcomp”强制虚拟机运行于“编译模式”，这时<strong>优先</strong>采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程。</p><p>为了在程序启动相应速度与运行效率之间达到最佳平衡，HotSpot虚拟机还会逐渐启用<strong>分层编译</strong>的策略，分层编译根据<strong>编译器编译、优化的规模与耗时</strong>，划分出不同的编译层次：</p><ul><li>第0层，程序解释执行，解释器不开启性能监控功能，可触发第1层编译</li><li>第1层，也称为C1编译，将字节码编译为本地代码，进行简单、可靠的优化，如有必要加入性能监控的逻辑</li><li>第2层，也称为C2编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。</li></ul><p>实施分层编译后，Client Compiler和Server Compiler将会同时工作，许多代码可能会被多次编译，用<strong>Client Compiler</strong>获取<strong>更高的编译速度</strong>，用<strong>Server Compiler</strong>来获取<strong>更好的编译质量</strong>，在解释执行的时候也无须再承担收集性能监控信息的任务。</p><h3 id="编译对象与触发条件"><a href="#编译对象与触发条件" class="headerlink" title="编译对象与触发条件"></a>编译对象与触发条件</h3><p>“热点代码”有两类：</p><ul><li>被多次调用的方法</li><li>被多次执行的循环体</li></ul><p>“多次”的概念？</p><p>判断一段代码是不是热点代码，是不是需要触发即时编译，这样的行为称为<strong>热点探测</strong>，判定方式有两种：</p><ul><li>基于<strong>采样</strong>的热点探测<ul><li>周期性检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，那这个方法就是“热点方法”</li><li>实现简单、高效，容易获取方法调用关系</li><li>很难精确地确认一个方法的热度，容易因为收到线程阻塞或别的外界因素的影响而扰乱热点探测</li></ul></li><li>基于<strong>计数器</strong>的热点探测(HotSpot采用)<ul><li>为每个方法建立计数器，统计方法的执行次数，如果执行次数超过了一定的阈值就认为它是“热点方法”</li><li>实现麻烦，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系</li><li>更加精准和严谨</li></ul></li></ul><p>HotSpot为每个方法准备了两类计数器：方法调用计数器和回边计数器</p><ul><li>方法调用计数器<ul><li>统计方法被调用的次数，Client模式下默认阈值1500，Server默认10000</li><li>交互过程如下图：<br><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG293.jpeg" alt="avatar"></li><li>如果不做任何设置，方法调用计数器统计的是一个相对的<strong>执行频率</strong>，即一段时间内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的<strong>衰减</strong>，而这段时间称为此方法统计的<strong>半衰周期</strong>。进行热度衰减的动作在虚拟机进行<strong>垃圾收集</strong>时顺便进行。</li></ul></li><li>回边计数器<ul><li>统计一个方法中循环体代码执行的次数，为了触发OSR编译</li><li>虚拟机运行在Client模式下，回边计数器阈值计算公式为：<strong>方法调用计数器阈值 X OSR比率 /100</strong></li><li>虚拟机运行在Server模式下，回边计数器阈值计算公式为：<strong>方法调用计数器阈值 X (OSR比率 - 解释器监控比率) /100</strong></li><li>执行过程如下图：<br><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG294.jpeg" alt="avatar"> </li></ul></li></ul><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>默认设置下，无论是方法调用产生的即时编译请求，还是OSR编译请求，虚拟机在代码编译器还未完成之前，都仍然按照解释方式继续进行，而编译动作则在后台的编译线程中进行。</p><p>在后台编译的过程中，Client Compiler是一个简单快速的三段式编译器，主要的关注点在于局部性的优化，而放弃了许多耗时较长的全局优化手段。</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG295.jpeg" alt="avatar"></p><p>而Server Compiler则是专门面向服务端的典型应用并为服务端的性能配置特别调整过的编译器，也是一个充分优化过的高级编译器，它会执行所有经典的优化动作，如无用代码消除、循环展开、循环表达式外提、消除公共子表达式、常量传播、基本块重排序等，还会实施一些与Java语言特性密切相关的优化技术，如范围检查消除、空值检查消除等。</p><p>以<strong>即时编译</strong>的标准来看，Server Compiler比较缓慢，但它的编译速度依然远远超过传统的静态优化编译器，而且它相对于Client Compiler编译输出的<strong>代码质量</strong>有所提高，可以减少本地代码的执行时间，从而抵消了额外的编译时间开销，所以也有很多非服务端的应用选择使用Server模式的虚拟机运行。</p><h2 id="编译优化技术"><a href="#编译优化技术" class="headerlink" title="编译优化技术"></a>编译优化技术</h2><p>以编译方式执行本地代码比解释方式更快，除去虚拟机解释执行字节码需要额外消耗时间的原因外，还有一个很重要的原因就是虚拟机设计团队几乎把对代码的所有优化措施都集中在了即时编译器之中。</p><ul><li>公共子表达式消除</li><li>数组边界检查消除</li><li>方法内联<ul><li>非虚方法，直接内联</li><li>虚方法，会向“类型继承关系分析”(CHA)查询此方法在当前程序下是否有多个目标版本可选择，如果只有一个版本，也可以进行内联，不过这种内联属于<strong>激进优化</strong>，需要预留一个“逃生门”，称为<strong>守护内联</strong>。如果程序的后续执行过程中，虚拟机一直没有加载到会令这个方法的<strong>接受者继承关系</strong>发生变化的类，那这个内联优化的代码可以一直用下去。但如果加载了导致继承关系发生变化的新类，那就需要抛弃已经编译的代码，退回到解释状态执行，或者重新进行编译</li><li>如果向CHA查询出来的结果是有多个版本的目标方法可供选择，则编译器还将会尝试使用<strong>内联缓存</strong>来完成方法内联，这是一个建立在方法正常入口之前的缓存，它的工作原理大致是：在未发生方法调用之前，内联缓存为空，当第一次调用发生后，缓存记录下<strong>方法接收者的版本信息</strong>，并且每次进行方法调用时都比较接受者版本，如果以后进来的每次调用的方法接收者版本都是一样的，那这个内联还可以一直用下去。如果发生了方法接收者版本不一致的情况，就说明程序真正使用了虚方法的多态特性，这时才会取消内联，查找虚方法表进行方法分派。</li></ul></li><li>逃逸分析<ul><li>分析对象的作用域：当一个对象在方法中被定义后，它可能被<strong>外部</strong>方法所引用，称为<strong>方法逃逸</strong>。甚至还有可能被<strong>外部</strong>线程访问到，称为<strong>线程逃逸</strong></li><li>如果能证明一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问到这个对象，则可能为这个变量进行一些高效的优化</li><li>栈上分配</li><li>同步消除</li><li>标量替换(标量指一个数据已经无法再分解成更小的数据来表示了，与之对应的称为聚合量)</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在部分商用虚拟机(HotSpot、IBM J9)中，Java程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“&lt;strong&gt;热点代码&lt;/strong&gt;”。为了提高热点代码的执行效率，在运行时，虚拟机会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为&lt;strong&gt;即时编译器&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="读书笔记" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深入理解Java虚拟机" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="程序编译与代码优化" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
      <category term="Class" scheme="blog.jiangdongyu.space/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>早期(编译期)优化</title>
    <link href="blog.jiangdongyu.space/2018/07/04/%E6%97%A9%E6%9C%9F(%E7%BC%96%E8%AF%91%E6%9C%9F)%E4%BC%98%E5%8C%96/"/>
    <id>blog.jiangdongyu.space/2018/07/04/早期(编译期)优化/</id>
    <published>2018-07-04T07:00:00.000Z</published>
    <updated>2018-07-10T09:01:59.609Z</updated>
    
    <content type="html"><![CDATA[<p>Java语言的“编译期”是一段“不确定”的操作过程，因为它可能指：</p><ul><li>前端编译器（编译器的“前端”）把*.java文件转变成*.class文件的过程: Javac</li><li>后端运行期编译器(JIT)把字节码转变成机器码的过程:HotSpot VM的C1、C2</li><li>静态提前编译器(AOT)直接把*.java文件编译成本地机器码的过程</li></ul><p>本章讨论的“编译期”和“编译器”都仅限于第一类编译过程。</p><p>Javac对代码的运行效率几乎没有任何优化措施，但做了许多针对Java语言编码过程的优化措施来改善程序员的编码风格和提高编码效率。相当多新生的Java语法特性，都是靠编译器的“<strong>语法糖</strong>”来实现。</p><a id="more"></a><h2 id="Javac编译器"><a href="#Javac编译器" class="headerlink" title="Javac编译器"></a>Javac编译器</h2><p>Javac编译过程大致可以分为3个过程：</p><ul><li>解析和填充符号表过程</li><li>插入式注解处理器的注解处理过程</li><li>分析与字节码生成过程</li></ul><h3 id="Javac的源码与调试"><a href="#Javac的源码与调试" class="headerlink" title="Javac的源码与调试"></a>Javac的源码与调试</h3><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG290.jpeg" alt="avatar"></p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG291.jpeg" alt="avatar"></p><h3 id="解析和填充符号表"><a href="#解析和填充符号表" class="headerlink" title="解析和填充符号表"></a>解析和填充符号表</h3><ul><li>词法、语法分析<ul><li>词法分析将源代码的字符流转变为标记(Token)集合</li><li>语法分析根据Token序列构造抽象语法树</li></ul></li><li>填充符号表<ul><li>符号表是由一组符号地址和符号信息构成的表格</li></ul></li></ul><h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h3><p>注解在<strong>运行期</strong>间发生作用。</p><p>如果注解处理器在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round(上图10-4的循环过程)。</p><h3 id="语义分析与字节码生成"><a href="#语义分析与字节码生成" class="headerlink" title="语义分析与字节码生成"></a>语义分析与字节码生成</h3><p>语法分析后，编译器获得了程序代码的抽象语法树表示，<strong>语法树</strong>能表示一个<strong>结构正确</strong>的源程序的抽象，但无法保证源程序是符合逻辑的。而<strong>语义分析</strong>的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。</p><ul><li>标注检查<ul><li>检查变量使用前是否已被声明、变量与赋值之间的数据类型能否匹配等</li></ul></li><li>数据及控制流分析<ul><li>能检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被处理了等问题</li><li>将<strong>局部变量</strong>声明为final，对<strong>运行期</strong>没有影响，<strong>变量的不变性仅仅由编译器在编译期间保障</strong>。</li></ul></li><li>解语法糖<ul><li>使用语法糖能增加程序的可读性，从而减少程序代码出错的机会</li></ul></li><li>字节码生成<ul><li>把前面各个步骤所生成的信息转化成字节码写到磁盘中，进行少量的代码添加和转换工作</li></ul></li></ul><h2 id="Java语法糖的味道"><a href="#Java语法糖的味道" class="headerlink" title="Java语法糖的味道"></a>Java语法糖的味道</h2><h3 id="泛型与类型擦除"><a href="#泛型与类型擦除" class="headerlink" title="泛型与类型擦除"></a>泛型与类型擦除</h3><p>Java中的泛型只在程序源码中存在，在编译后的字节码文件中，会替换成原来的原生类型，并在相应的地方插入强制转型代码。ArrayList<int>和ArrayList<string>对Java来说就是同一个类。Java中泛型实现方法称为<strong>类型擦除</strong>，基于这种方法实现的泛型称为<strong>伪泛型</strong>。</string></int></p><p>引入Signature、LocalVariableTypeTable等属性用于解决伴随泛型而来的参数类型的识别问题。擦除法所谓的擦除，只是对方法的Code属性中的字节码进行擦除，元数据中还是保留了泛型信息。</p><h3 id="自动装箱、拆箱与遍历循环"><a href="#自动装箱、拆箱与遍历循环" class="headerlink" title="自动装箱、拆箱与遍历循环"></a>自动装箱、拆箱与遍历循环</h3><p>遍历循环会把代码还原成迭代器的实现，这就是遍历的类需要实现Iterable接口的原因。</p><p>这是关于Java中<strong>自动装箱与拆箱</strong>的一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoxingTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Integer c = <span class="number">3</span>;</span><br><span class="line">        Integer d = <span class="number">3</span>;</span><br><span class="line">        Integer e = <span class="number">321</span>;</span><br><span class="line">        Integer f = <span class="number">321</span>;</span><br><span class="line">        Long g = <span class="number">3L</span>;</span><br><span class="line">        System.out.println(c == d); <span class="comment">//true</span></span><br><span class="line">        System.out.println(e == f); <span class="comment">//false</span></span><br><span class="line">        System.out.println(c == (a + b)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(c.equals(a + b)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(g == (a + b)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(g.equals(a + b)); <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>装箱代码，注意IntegerCache的存在：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拆箱代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译完的class文件，再重新反编译后的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoxingTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Integer a = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">        Integer b = Integer.valueOf(<span class="number">2</span>);</span><br><span class="line">        Integer c = Integer.valueOf(<span class="number">3</span>);</span><br><span class="line">        Integer d = Integer.valueOf(<span class="number">3</span>);</span><br><span class="line">        Integer e = Integer.valueOf(<span class="number">321</span>);</span><br><span class="line">        Integer f = Integer.valueOf(<span class="number">321</span>);</span><br><span class="line">        Long g = Long.valueOf(<span class="number">3L</span>);</span><br><span class="line">        System.out.println(c == d); </span><br><span class="line">        System.out.println(e == f); </span><br><span class="line">        System.out.println(c.intValue() == a.intValue() + b.intValue());</span><br><span class="line">        System.out.println(c.equals(Integer.valueOf(a.intValue() + b.intValue())));</span><br><span class="line">        System.out.println(g.longValue() == a.intValue() + b.intValue());</span><br><span class="line">        System.out.println(g.equals(Integer.valueOf(a.intValue() + b.intValue())));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>System.out.println(c == d) =&gt; <em>System.out.println(c == d)</em>：类型一致，不涉及装箱与拆箱，变量c、d保存于线程私有栈中，c和d是保存的是一个地址引用，指向内存堆中的某个地址，对于值在【-128，127】Integer类型，由于IntegerCache.cache[]的存在，所以c、d指向的是堆中同一个地址，故执行结果为true</li><li>System.out.println(e == f) =&gt; <em>System.out.println(e == f)</em>:  类型一致，不涉及装箱与拆箱操作，判定规则参照上面的分析，因为321不在【-128，127】内，故e和f指向的是内存堆中两个不同的地址，故执行结果为false</li><li>System.out.println(c == (a + b)) =&gt; <em>System.out.println(c.intValue() == a.intValue() + b.intValue())</em>：通过反编译字节码我们可以看到，这里涉及了包装类型的拆箱操作，只有基础类型才可以进行加法操作，实际比较的是存于Java私有线程栈中两个int类型的数值比较，执行结果为true</li><li>System.out.println(c.equals(a + b)) =&gt; <em>System.out.println(c.equals(Integer.valueOf(a.intValue() + b.intValue())))</em>：这里涉及了先拆箱，然后再装箱的操作，a+b先执行拆箱操作，然后再对结果执行装箱操作，最后执行equals方法，我们看下Integer类中equals方法的定义如下，很明显，执行结果为true</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">        <span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>System.out.println(g == (a + b)) =&gt; <em>System.out.println(g.longValue() == a.intValue() + b.intValue())</em>：类型不一致，拆箱操作，g和a、b分别执行了拆箱操作，然后比较结果，执行结果为true</li><li>System.out.println(g.equals(a + b)) =&gt; <em>System.out.println(g.equals(Integer.valueOf(a.intValue() + b.intValue())))</em>：与第四条规则一致，先拆箱执行加法操作，然后加法结果执行装箱操作，最后执行Long类型的equals方法，Long中equals方法定义如下，故执行结果为false</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Long) &#123;</span><br><span class="line">        <span class="keyword">return</span> value == ((Long)obj).longValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集合中只能包含对象，不能包含基础数据类型，如果将基础数据类型的数据添加到集合操作，JVM（JDK1.5之后）会自动进行装箱操作，将基础数据类型封装为对应的封装类</p><p><img src="http://p9fh1pach.bkt.clouddn.com/OOP_WrapperClass.png" alt="avatar"></p><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><p>使用条件为常量的if语句</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java语言的“编译期”是一段“不确定”的操作过程，因为它可能指：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前端编译器（编译器的“前端”）把*.java文件转变成*.class文件的过程: Javac&lt;/li&gt;
&lt;li&gt;后端运行期编译器(JIT)把字节码转变成机器码的过程:HotSpot VM的C1、C2&lt;/li&gt;
&lt;li&gt;静态提前编译器(AOT)直接把*.java文件编译成本地机器码的过程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本章讨论的“编译期”和“编译器”都仅限于第一类编译过程。&lt;/p&gt;
&lt;p&gt;Javac对代码的运行效率几乎没有任何优化措施，但做了许多针对Java语言编码过程的优化措施来改善程序员的编码风格和提高编码效率。相当多新生的Java语法特性，都是靠编译器的“&lt;strong&gt;语法糖&lt;/strong&gt;”来实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="读书笔记" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深入理解Java虚拟机" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="程序编译与代码优化" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
      <category term="Class" scheme="blog.jiangdongyu.space/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机字节码执行引擎</title>
    <link href="blog.jiangdongyu.space/2018/07/02/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <id>blog.jiangdongyu.space/2018/07/02/虚拟机字节码执行引擎/</id>
    <published>2018-07-02T05:00:00.000Z</published>
    <updated>2018-07-10T09:01:53.806Z</updated>
    
    <content type="html"><![CDATA[<p>从<strong>概念模型</strong>的角度讲解虚拟机的方法调用和字节码执行。</p><h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>栈帧是用于支持虚拟机进行<strong>方法调用和方法执行</strong>的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的<strong>局部变量表、操作数栈、动态连接和方法返回地址</strong>等信息。每一个方法从调用开始至执行完成的过程，都对应着一个<strong>栈帧</strong>在虚拟机栈里面从<strong>入栈到出栈</strong>的过程。</p><a id="more"></a><p><strong>编译</strong>时，栈帧需要多大的局部变量表，多深的操作数栈都已经完全确定，并且写入到方法表的Code属性中，因此一个<strong>栈帧需要分配多少内存</strong>，仅仅取决于<strong>具体的虚拟机实现</strong>。</p><p>对执行引擎来说，在活动线程中，只有位于<strong>栈顶的栈帧</strong>才是有效的，称为<strong>当前栈帧</strong>，与这个栈帧相关联的方法称为当前方法。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如下图所示：</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG281.jpeg" alt="avatar"></p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表是一组<strong>变量值存储空间</strong>，用于存放<strong>方法参数和方法内部定义的局部变量</strong>。在Java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。</p><p>局部变量表的容量以变量槽(Slot)为最小单位，一个Slot可以存放一个32位以内的数据类型(boolean、byte、char、short、int、float、reference和returnAddress)。而对于64位的数据类型，虚拟机会以<strong>高位对齐</strong>的方式为其分配<strong>两个连续</strong>的Slot空间。</p><p>虚拟机通过索引定位的方式使用局部变量表。</p><p>如果一个局部变量定义了但没有赋初始值是不能被使用的。</p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈也常称为操作栈，它是一个后入先出栈。同局部变量表一样，操作数栈的最大深度也在<strong>编译</strong>的时候写入到Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意的Java数据类型。</p><p>在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的。但在大多数虚拟机的实现都会做一些优化处理，令两个栈帧出现一部分重叠。让下面栈帧的部分<strong>操作数栈</strong>与上面栈帧的部分<strong>局部变量表</strong>重叠在一起，这样在进行方法调用时就可以共用一部分数据，无须进行额外的参数复制传递。</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG282.jpeg" alt="avatar"></p><p>Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。</p><h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的<strong>动态连接</strong>。</p><p>Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在<strong>类加载阶段或者第一次使用</strong>的时候就转化为直接引用，这种转化称为<strong>静态解析</strong>。另外一部分将在每一次<strong>运行期间</strong>转化为直接引用，这部分称为<strong>动态连接</strong>。</p><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>方法开始执行后，有两种方式可以退出这个方法</p><ul><li>执行引擎遇到任意一个方法返回的字节码指令，可能会有返回值传递给上层方法调用者(<strong>正常完成出口</strong>)</li><li>执行过程遇到异常，并且该异常在方法体内没有被处理(<strong>异常完成出口</strong>)</li></ul><p>方法退出后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。</p><p>方法<strong>正常退出</strong>时，<strong>调用者的PC计数器</strong>的值可以作为<strong>返回地址</strong>，栈帧中很可能会保存这个计数器的值。方法<strong>异常</strong>退出时，返回地址是要通过<strong>异常处理器表</strong>来确定的。</p><h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为<strong>栈帧信息</strong>。</p><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>确定被调用方法的版本</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个<strong>可确定的调用版本</strong>，并且这个方法的调用版本<strong>在运行期是不可改变的</strong>。换句话说，<strong>调用目标在程序代码写好、编译器进行编译时就必须确定下来</strong>。这类方法的调用称为<strong>解析</strong>。</p><p>在Java中符合“编译期可知，运行期不可变”的，包括静态方法和私有方法两大类，适合在类加载阶段进行解析。</p><p>与之对应的是，在Java虚拟机里提供了5条方法调用字节码指令：</p><ul><li>invokestatic：静态方法</li><li>invokespecial：调用实例构造器\<init>方法、私有方法和父类方法</init></li><li>invokevirtual：虚方法</li><li>invokeinterface：接口方法，会在运行时再确定一个实现该接口的对象</li><li>invokedynamic：现在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法</li></ul><p>只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、实例构造器、私有方法和父类方法4类(非虚方法，非虚方法还包含被final修饰的方法)。其他都称为虚方法。</p><p>解析调用是静态的过程。</p><h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><p>揭示多态性特征的一些最基本的体现。</p><ul><li>静态分派<ul><li>重载(同名函数，不同参数个数/类型)相关，虚拟机重载时通过参数的静态类型作为判断依据</li></ul></li><li>动态分派<ul><li>重写(子类父类之间)有关，根据实际类型确定方法执行版本</li></ul></li><li>单分派与多分派<ul><li>方法的接收者与方法的参数统称为方法的宗量</li><li>单分派根据一个宗量对目标方法进行选择</li><li>多分派根据多于一个宗量对目标方法进行选择</li><li><strong>Java的静态分派属于多分派类型，动态分派属于单分派类型</strong></li></ul></li><li>虚拟动态分派的实现<ul><li>虚方法表</li><li>内联缓存</li><li>基于“类型继承关系分析”技术的守护内联</li></ul></li></ul><h3 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h3><ul><li>动态类型语言<ul><li>动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期</li><li>“变量无类型而变量值才有类型”</li></ul></li><li>JDK1.7与动态类型</li><li>java.lang.invoke包 <ul><li>MethodHandle</li></ul></li><li>invokedynamic指令</li><li>掌控方法分派规则<ul><li>Son类中调用祖父类thinking()方法：<br><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG283.jpeg" alt="avatar"></li></ul></li></ul><h2 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h2><h3 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h3><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG284.jpeg" alt="avatar"></p><p>上图中下面那条分支，是传统编译原理中程序代码到目标机器代码的生成过程，而中间那条分支，就是解释执行的过程。</p><p>Java程序编译半独立。Javac编译器完成程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机内部。</p><h3 id="基于栈的指令集与基于寄存器的指令集"><a href="#基于栈的指令集与基于寄存器的指令集" class="headerlink" title="基于栈的指令集与基于寄存器的指令集"></a>基于栈的指令集与基于寄存器的指令集</h3><p>基于栈的指令集的优点：</p><ul><li>可移植</li><li>代码相对更加紧凑</li><li>编译器实现更简单</li></ul><p>基于栈的指令集的缺点：执行速度相对较慢</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从&lt;strong&gt;概念模型&lt;/strong&gt;的角度讲解虚拟机的方法调用和字节码执行。&lt;/p&gt;
&lt;h2 id=&quot;运行时栈帧结构&quot;&gt;&lt;a href=&quot;#运行时栈帧结构&quot; class=&quot;headerlink&quot; title=&quot;运行时栈帧结构&quot;&gt;&lt;/a&gt;运行时栈帧结构&lt;/h2&gt;&lt;p&gt;栈帧是用于支持虚拟机进行&lt;strong&gt;方法调用和方法执行&lt;/strong&gt;的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的&lt;strong&gt;局部变量表、操作数栈、动态连接和方法返回地址&lt;/strong&gt;等信息。每一个方法从调用开始至执行完成的过程，都对应着一个&lt;strong&gt;栈帧&lt;/strong&gt;在虚拟机栈里面从&lt;strong&gt;入栈到出栈&lt;/strong&gt;的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="读书笔记" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深入理解Java虚拟机" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="虚拟机执行子系统" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
      <category term="Class" scheme="blog.jiangdongyu.space/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机类加载机制</title>
    <link href="blog.jiangdongyu.space/2018/06/29/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>blog.jiangdongyu.space/2018/06/29/虚拟机类加载机制/</id>
    <published>2018-06-29T06:00:00.000Z</published>
    <updated>2018-07-10T09:02:33.638Z</updated>
    
    <content type="html"><![CDATA[<p><strong>虚拟机的类加载机制:</strong></p><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。</p><p>Java语言<strong>运行期</strong>类加载的特性</p><a id="more"></a><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>类的生命周期：加载，验证，准备，解析，初始化，使用和卸载。其中验证，准备，解析3个部分统称为连接，发生顺序如下：</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG279.jpeg" alt="avatar"></p><p>其中，加载、验证、准备、初始化和卸载顺序是确定的，类的加载过程必须按照这个顺序按部就班地开始，但是解析阶段则不一定(动态绑定，多态)</p><p><strong>那什么时候开始类加载的第一个过程“加载”呢？</strong></p><p>虚拟机规范严格规定了有且只有5种情况必须立即对类进行“初始化”（加载、验证、准备自然在这之前），以下五种情况称为<strong>对一个类的主动引用</strong>：</p><ul><li>遇到<strong>new、getstatic、putstatic或invokestati</strong>这4条字节码指令时，如果类没有进行初始化，则需要先初始化<ul><li>生成这4条指令最常见的场景是：new 实例化对象时，读取、设置一个类的静态字段(被final修饰，常量除外)，调用一个类的静态方法</li></ul></li><li>使用<strong>java.lang.reflect包</strong>的方法对类进行<strong>反射</strong>调用时，如果类没有进行初始化，则需要先初始化</li><li>初始化类时，如果<strong>父类</strong>还没有初始化，则需要先初始化父类</li><li>虚拟机启动时，用户需要指定一个<strong>主类</strong>（包含main()方法的类），虚拟机会先初始化主类</li><li>使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REE_getStatic、REE_putStatic、REE_invokeStatic的方法句柄，并且该句柄所对应的类没有进行初始化，则需要先初始化</li></ul><p>除此之外，所有引用类的方式不会触发初始化，称为<strong>被动引用</strong></p><p><strong>接口</strong>的加载过程与<strong>类</strong>加载过程稍有不同，只是第3条，一个接口在初始化时，<strong>不</strong>要求其父类接口全部完成了初始化，只有在<strong>真正用到父接口</strong>的时候才会初始化。</p><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>在加载阶段，虚拟机需要完成以下3件事情：</p><ul><li>通过一个类的全限定名来获取此类的二进制流</li><li>将该字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ul><p>“通过一个类的全限定名来获取此类的二进制流”，没有指明从哪里获取，怎么获取：</p><ul><li>从ZIP包获取，JAR、WAR、EAR</li><li>网络获取，Applet</li><li>运算时生成，动态代理技术</li><li>其他文件生成，JSP</li><li>数据库读取</li><li>……</li></ul><p>相对于类加载过程中的其他阶段，一个<strong>非数组类</strong>的加载阶段（加载过程中获取类的二进制字节流的动作）可控性最强，既可以用系统提供的引导类加载器，也可以由用户自定义的类加载器来完成（重写类加载器的loadClass()）</p><p>而<strong>数组</strong>类，是由<strong>Java虚拟机直接创建</strong>的，但是数组类的元素类型，最终还是需要类加载器来创建，一个数组类的创建过程遵循以下<strong>规则</strong>：</p><ul><li>如果数组的组件类型是引用类型，递归非数组类加载过程加载，数组将在加载该组件类型的类加载器的类名称空间上被标识</li><li>不是引用类型，将数组标记为与引导类加载器关联</li><li>数组类的可见性与它的组件类型的可见性一致，如果不是引用类型，默认为public</li></ul><p>加载阶段与连接阶段的部分内容交叉进行，加载阶段尚未完成，连接阶段可能已经开始。但这两个阶段开始的时间仍然保持先后顺序。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>确保Class文件的字节流包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</p><p>验证阶段大致会完成以下4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证</p><ul><li>文件格式验证<ul><li>保证输入的<strong>字节流</strong>能正确地解析并存储于<strong>方法区</strong>之内，格式上符合描述一个Java类型信息的要求</li><li>验证魔数、主次版本号、常量池中的常量类型…</li><li>基于<strong>字节流</strong>进行验证，后面3个验证都是基于<strong>方法区的存储结构</strong>进行的</li></ul></li><li>元数据验证<ul><li>对类的元数据信息进行<strong>语义校验</strong>，保证不存在不符合Java语言规范的元数据信息</li><li>是否有父类、父类是否继承不允许被继承的类，类中的字段、方法是否与父类矛盾…</li></ul></li><li>字节码验证<ul><li>通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的</li><li>在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对<strong>类的方法体</strong>进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件</li><li>保证方法体中的类型转换有效、跳转指令不会跳转到方法体以外的字节码指令上…</li><li>为了优化，Code属性中<strong>“StackMapTable“</strong>，描述方法体中所有基本块开始时本地变量表和操作栈该有的状态，在字节码验证期间，就不用推导合法性，直接查该属性中的记录即可。将字节码验证的<strong>类型推导</strong>转变为<strong>类型检查</strong>。</li></ul></li><li>符号引用验证<ul><li>发生在虚拟机将符号引用转化为直接引用时，在<strong>解析阶段</strong>发生，确保解析动作能正常执行</li><li>对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验</li><li>符号引用中通过字符串描述的全限定名能否找到对应的类，符号引用中的类、方法、字段的访问行是否可被当前类所访问…</li></ul></li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>正式为<strong>类变量</strong>分配<strong>内存</strong>并设置类变量<strong>初始值</strong>，内存都在<strong>方法区</strong>中分配。</p><ul><li>进行内存分配的只是<strong>类变量</strong>(被static修饰)，不包含实例变量</li><li>初始化，一般指赋0值，但如果是常量(static final)，则是常量具体的值</li></ul><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用在Class文件中以CONSTANT_Class_info等类型的常量出现。</p><p><strong>解析阶段符号引用和直接引用的关联:</strong></p><ul><li>符号引用：以一组符号来描述所引用的目标，符号形式不限，只要在使用时能无歧义地定位到目标即可。与虚拟机实现的<strong>内存布局无关</strong>，引用的目标<strong>不一定已经加载到内存中</strong>。虚拟机实现的内存布局可以各不相同，但它们能接受的<strong>符号引用都是一致的</strong>。</li><li>直接引用：可以是直接指向目标的指针、相对偏移量或者能间接定位到目标的句柄。和与虚拟机实现的<strong>内存布局相关</strong>，<strong>同一个符号引用</strong>在不同虚拟机翻译出来的<strong>直接引用一般不会相同</strong>。如果有了直接引用，那引用的目标<strong>必定已经在内存中</strong>。</li></ul><p><strong>解析阶段发生的具体时间不确定</strong>，只要求了在16个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。</p><p>因此，虚拟机实现可以按需判断是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用时才去解析它。</p><p>对一个符号引用的<strong>多次解析</strong>很常见，除了invokedynamic指令外，虚拟机实现可以对第一次解析进行<strong>缓存</strong>。需要保证的是在同一个实体中，如果一个符号引用之前被<strong>成功解析过</strong>，那么后续的解析也应该<strong>一直成功</strong>；同样的，如果<strong>第一次失败</strong>，那么之后也应该收到<strong>相同的异常</strong>。</p><p>而对于invokedynamic指令用于<strong>动态语言支持</strong>，必须等到程序实际运行到这条指令的时候，解析动作才能进行。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用店限定符7类符号引用进行，以下是前4种：</p><h4 id="类或接口的解析"><a href="#类或接口的解析" class="headerlink" title="类或接口的解析"></a>类或接口的解析</h4><p>假设当前代码所处的类为D，要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，虚拟机完成整个解析需要3个步骤：</p><ul><li>如果C不是数组类型，虚拟机会把代表N的全限定名传递给D的类加载器去加载类C，加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作。一旦加载过程出现异常则宣告失败</li><li>如果C是数组类型，并且数组的元素类型为对象，那将会按照第1点的规则加载数组元素类型，接着由虚拟机生成一个代表词数组维度和元素的数组对象</li><li>如果上述步骤没有出现异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还需要进行<strong>符号引用验证</strong>，确认D是否具备对C的访问<strong>权限</strong>，如果没有，则抛出java.lang.IllegalAccessError异常。</li></ul><h4 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h4><p>要解析一个未被解析过的字段符号引用，首先会对<strong>字段所属的类或接口的符号引用进行解析</strong>。如果在解析的过程中出现异常，则解析失败。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索：</p><ul><li>如果C本身包含了简单名称和字段描述符都与目标相匹配的字段，则直接返回该字段的直接引用，查找结束</li><li>否则，如果C实现了接口，则<strong>按照继承关系从下往上递归搜索</strong>各个接口以及父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回该字段的直接引用，查找结束</li><li>否则，如果C不是java.lang.Object的话，<strong>按照继承关系从下往上递归搜索</strong>其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回该字段的直接引用，查找结束</li><li>否则，查找失败，抛出java.lang.NoSuchFieldError异常</li></ul><p>如果查找过程成功返回了引用，将会对这个字段进行<strong>权限验证</strong>，如果没有访问权限，则抛出java.lang.IllegalAccessError异常。</p><p>如果有一个<strong>同名字段同时出现在C的接口和父类中，或者同时在自己或父类的多个接口中出现，那编译器可能拒绝编译</strong>。</p><h4 id="类方法解析"><a href="#类方法解析" class="headerlink" title="类方法解析"></a>类方法解析</h4><p>第一个步骤和字段解析一样，也需要先解析出<strong>类方法表</strong>的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C表示这个类，接下来虚拟机会按照如下步骤进行后续的类方法搜索：</p><ul><li>类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是<strong>接口</strong>，直接抛出java.lang.IncompatibleClassChangeError异常</li><li>如果通过第1步，在类C中查找是否有简单名称和字段描述符都与目标相匹配的方法，如果有则直接返回这个方法的直接引用，查找结束</li><li>否则，在C的<strong>父类</strong>中递归查找是否有简单名称和字段描述符都与目标相匹配的方法，如果有则直接返回这个方法的直接引用，查找结束</li><li>否则，在C实现的<strong>接口列表及它们的父接口</strong>之中递归查找是否有简单名称和字段描述符都与目标相匹配的方法，如果有，说明C是个<strong>抽象类</strong>，这时查找结束，抛出java.lang.AbstractMethodError异常</li><li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError</li></ul><p>最后，如果查找过程成功返回了直接引用，将会对这个方法进行<strong>权限验证</strong>，如果发现不具备权限，将抛出java.lang.IllegalAccessError异常。</p><h4 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h4><p>接口方法也需要先解析出<strong>接口方法表</strong>的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C表示这个接口，接下来虚拟机会按照如下步骤进行后续的接口方法搜索：</p><ul><li>与类方法解析不同，如果在接口方法表中发现class_index中索引的C是<strong>类</strong>，直接抛出java.lang.IncompatibleClassChangeError异常</li><li>否则，在接口C中查找是否有简单名称和字段描述符都与目标相匹配的方法，如果有则直接返回这个方法的直接引用，查找结束</li><li>否则，在的<strong>父接口</strong>之中递归查找，直到java.lang.Object类，看是否有简单名称和字段描述符都与目标相匹配的方法，如果有则直接返回这个方法的直接引用，查找结束</li><li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常</li></ul><p>接口中所有方法默认都是public的，因此不需要进行权限验证。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>真正开始执行类中定义的Java代码，初始化阶段是执行类构造器clinit()方法的过程。</p><ul><li>clinit()方法是由编译器自动收集类中的所有<strong>类变量的赋值动作</strong>和<strong>静态语句块中的语句</strong>合并产生的，静态语句块中只能<strong>访问</strong>到定义在静态语句块<strong>之前的变量</strong>，定义在它之<strong>后</strong>的变量，只能<strong>赋值</strong>不能访问。</li><li>虚拟机保证子类的clinit()方法执行前，父类的clinit()方法已经执行完毕</li><li>父类中定义的静态语句块要优先于子类的变量赋值操作</li><li>接口中不能使用静态语句块，但仍有变量初始化赋值操作，因此也会生成clinit()方法。但接口的clinit()方法，<strong>不需要先执行父类的clinit()方法</strong>。只有当<strong>父接口中定义的变量使用时，父接口才会初始化</strong>。另外，<strong>接口的实现类</strong>在初始化时也一样<strong>不会</strong>执行接口的clinit()方法</li><li>虚拟机会保证一个类的clinit()方法在多线程环境中被正确地加锁、同步</li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>虚拟机设计团队把类<strong>加载</strong>阶段中的“通过一个类的全限定名来获取此类的二进制流”这个动作放到Java虚拟机的外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“<strong>类加载器</strong>”。</p><h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>类加载器用于实现类的加载动作。对于任意一个类，都需要由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。也就是说，比较两个类是否“相等”，只有这两个类是由同一个类加载器加载的前提下才有意义。</p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>从Java虚拟机的角度来讲，只存在两种不同类型的类加载器：</p><ul><li>启动类加载器，C++语言实现，虚拟机自身的一部分</li><li>其他所有的类加载器，Java语言实现，独立于虚拟机外部，全都继承自抽象类java.lang.ClassLoader</li></ul><p>从Java开发人员的角度来看，绝大部分Java程序都会使用到以下3种系统提供的类加载器：</p><ul><li>启动类加载器：负责将存放在<strong>\&lt;JAVA_HOME&gt;\lib</strong>目录中的，或者被<strong>-Xbootclasspath参数所指定的路径</strong>中的，并且是<strong>虚拟机识别的类库</strong>加载到虚拟机内存中。启动类加载器<strong>无法被Java程序直接引用</strong></li><li>扩展类加载器：负责加载<strong>\&lt;JAVA_HOME&gt;\lib\ext</strong>目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器</li><li>应用程序类加载器：负责加载用户类路径(Classpath)上所指定的类库，开发者可以直接使用这个类加载器。程序的<strong>默认</strong>类加载器。</li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG280.jpeg" alt="avatar"></p><p>双亲委派模型要求顶层是启动类加载器，其余的类加载器应该有自己的父类加载器。类加载器之间的父子关系是使用组合关系来复用父加载器的代码。</p><p>双亲委派模型的<strong>工作过程</strong>：</p><p>如果一个类加载器收到了类加载请求，它<strong>不会自己去尝试加载这个类</strong>，而是将这个请求<strong>委派给父类加载器</strong>去完成，每一个层次的类加载器都这样，因此所有的加载请求最终都应该传送到顶层的启动类中，只有当<strong>父类</strong>加载器反馈自己<strong>无法完成</strong>这个加载请求时，子加载器才会尝试自己加载。</p><h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h3><ul><li>向前兼容</li><li>模型自身缺陷<ul><li>双亲委派模型很好地解决了各个类加载器的基础类的统一问题(越基础的类由越上层的类加载器进行加载)</li><li>基础类又要调回用户的代码，比如JNDI，可以使用线程上下文类加载器</li></ul></li><li>用户对程序动态性的追求，热部署等</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;虚拟机的类加载机制:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。&lt;/p&gt;
&lt;p&gt;Java语言&lt;strong&gt;运行期&lt;/strong&gt;类加载的特性&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="读书笔记" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深入理解Java虚拟机" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="虚拟机执行子系统" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
      <category term="Class" scheme="blog.jiangdongyu.space/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>Stack</title>
    <link href="blog.jiangdongyu.space/2018/06/26/Stack/"/>
    <id>blog.jiangdongyu.space/2018/06/26/Stack/</id>
    <published>2018-06-26T12:35:00.000Z</published>
    <updated>2018-06-27T11:32:44.228Z</updated>
    
    <content type="html"><![CDATA[<p>Stack实际上也是通过<strong>数组</strong>去实现的。</p><p>执行push时(即，将元素推入栈中)，是通过将元素追加的数组的末尾中。</p><p>执行peek时(即，取出栈顶元素，不执行删除)，是返回数组末尾的元素。</p><p>执行pop时(即，取出栈顶元素，并将该元素从栈中删除)，是取出数组末尾的元素，然后将该元素从数组中删除。</p><p>Stack继承于Vector，意味着Vector拥有的属性和功能，Stack都拥有。</p><a id="more"></a><h3 id="225-Implement-Stack-with-Queue"><a href="#225-Implement-Stack-with-Queue" class="headerlink" title="225.Implement Stack with Queue"></a>225.Implement Stack with Queue</h3><p>Implement the following operations of a stack using queues.</p><ul><li>push(x) – Push element x onto stack.</li><li>pop() – Removes the element on top of the stack.</li><li>top() – Get the top element.</li><li>empty() – Return whether the stack is empty.</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyStack stack = new MyStack();</span><br><span class="line">stack.push(1);</span><br><span class="line">stack.push(2);  </span><br><span class="line">stack.top();   // returns 2</span><br><span class="line">stack.pop();   // returns 2</span><br><span class="line">stack.empty(); // returns false</span><br></pre></td></tr></table></figure><p><strong>Notes:</strong></p><ul><li>You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty operations are valid.</li><li>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.</li><li>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</li></ul><p><strong>维护两个队列</strong></p><ul><li>Push O(n),Pop O(1)<ul><li>Push: q2存放新元素，q1元素逐个添加到q2队尾，q1，q2互换</li><li>Pop: q1.poll()</li><li>Top: q1.peek()</li><li>Empty: q1.isEmpty()</li></ul></li><li>Push O(1),Pop O(n)<ul><li>Push: q1直接存,并更新top值</li><li>Pop: q1的大小大于1时，更新top值，并移到q2;删除q1的值，交换q1,q2</li><li>Top: 直接返回top</li><li>Empty: q1.isEmpty()</li></ul></li></ul><p><strong>维护一个队列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> LinkedList&lt;Integer&gt; q1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push element x onto stack.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    q1.add(x);</span><br><span class="line">    <span class="keyword">int</span> sz = q1.size();</span><br><span class="line">    <span class="keyword">while</span> (sz &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        q1.add(q1.remove());</span><br><span class="line">        sz--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="232-Implement-Queue-with-stacks"><a href="#232-Implement-Queue-with-stacks" class="headerlink" title="232.Implement Queue with stacks"></a>232.Implement Queue with stacks</h3><p>Implement the following operations of a queue using stacks.</p><ul><li>push(x) – Push element x to the back of queue.</li><li>pop() – Removes the element from in front of queue.</li><li>peek() – Get the front element.</li><li>empty() – Return whether the queue is empty.</li></ul><p><strong>Example:</strong></p><pre><code>MyQueue queue = new MyQueue();queue.push(1);queue.push(2);  queue.peek();  // returns 1queue.pop();   // returns 1queue.empty(); // returns false</code></pre><p><strong>Notes:</strong></p><ul><li>You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid.</li><li>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.</li><li>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</li></ul><p><strong>(Two Stacks) Push - O(1) per operation, Pop - Amortized O(1) per operation.</strong></p><ul><li>Push: s1直接存,记录下最开始s1为空时的peek值</li><li>Pop: s2为空时，把s1中的值pop到s2,再返回s2.pop()</li><li>Peek: s2为空直接返回peek,否则返回s2.peek()</li><li>Empty: s1.isEmpty()&amp;&amp;s2.isEmpty()</li></ul><h3 id="155-Min-Stack"><a href="#155-Min-Stack" class="headerlink" title="155.Min Stack"></a>155.Min Stack</h3><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><ul><li>push(x) – Push element x onto stack.</li><li>pop() – Removes the element on top of the stack.</li><li>top() – Get the top element.</li><li>getMin() – Retrieve the minimum element in the stack.</li></ul><p><strong>Example:</strong></p><pre><code>MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --&gt; Returns -3.minStack.pop();minStack.top();      --&gt; Returns 0.minStack.getMin();   --&gt; Returns -2.</code></pre><p><strong>使用两个栈(借助辅助栈，存储min)</strong></p><ul><li>Push: s1直接push，当s2为空或者新入栈的元素小于等于栈顶元素时，s2也入栈</li><li>Pop: s1直接pop，如果s1中pop的元素和s2栈顶元素相同，s2也pop</li><li>Top: s1.peek()</li><li>GetMin: s2.peek()</li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20.Valid Parentheses"></a>20.Valid Parentheses</h4><p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p>Note that an empty string is also considered valid.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;()&quot;Output: true</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: &quot;()[]{}&quot;Output: true</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: &quot;(]&quot;Output: false</code></pre><p><strong>Example 4:</strong></p><pre><code>Input: &quot;([)]&quot;Output: false</code></pre><p><strong>Example 5:</strong></p><pre><code>Input: &quot;{[]}&quot;Output: true</code></pre><ul><li>典型Stack的题，符号匹配<ul><li>是左括号，则入栈</li><li>判断是否是对应的右括号，同时栈不为空</li><li>都不满足，则返回false</li><li>最后判断栈是否为空</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'('</span> || c == <span class="string">'['</span> || c == <span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">')'</span> &amp;&amp; !stack.empty() &amp;&amp; stack.peek() == <span class="string">'('</span>)&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">']'</span> &amp;&amp; !stack.empty() &amp;&amp; stack.peek() == <span class="string">'['</span>)&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'&#125;'</span> &amp;&amp; !stack.empty() &amp;&amp; stack.peek() == <span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>更简洁的解法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'('</span>)</span><br><span class="line">stack.push(<span class="string">')'</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'&#123;'</span>)</span><br><span class="line">stack.push(<span class="string">'&#125;'</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'['</span>)</span><br><span class="line">stack.push(<span class="string">']'</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || stack.pop() != c)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="150-Evaluate-Reverse-Polish-Notation"><a href="#150-Evaluate-Reverse-Polish-Notation" class="headerlink" title="150.Evaluate Reverse Polish Notation"></a>150.Evaluate Reverse Polish Notation</h4><p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p><p>Valid operators are +, -, *, /. Each operand may be an integer or another expression.</p><p><strong>Note:</strong></p><ul><li>Division between two integers should truncate toward zero.</li><li>The given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation.</li></ul><p><strong>Example 1:</strong></p><pre><code>Input: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]Output: 9Explanation: ((2 + 1) * 3) = 9</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]Output: 6Explanation: (4 + (13 / 5)) = 6</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]Output: 22Explanation:  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22</code></pre><p><strong>解题思路</strong></p><ul><li>用栈解决</li><li>遇到数字直接入栈</li><li>遇到操作符，则pop出两个数字，进行计算，计算后的值接着入栈</li><li>需要注意的是除法的时候，是后pop出来的除以先pop出来的</li></ul><h4 id="84-Largest-Rectangel-in-Histrogram"><a href="#84-Largest-Rectangel-in-Histrogram" class="headerlink" title="84.Largest Rectangel in Histrogram"></a>84.Largest Rectangel in Histrogram</h4><blockquote><p>在DP专题总结过</p></blockquote><p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. </p><p><img src="http://p9fh1pach.bkt.clouddn.com/1418713310-55de4fd532244.png" alt="avatar"></p><p>Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].</p><p><img src="http://p9fh1pach.bkt.clouddn.com/765770818-55de4fe7f3337.png" alt="avatar"></p><p>The largest rectangle is shown in the shaded area, which has area = 10 unit.</p><ul><li>栈，存放数组的index</li><li>栈为空或者数组是递增状态，则直接push</li><li>小于则pop，并计算当前的最大面积</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = height.length;</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> h = (i == len ? <span class="number">0</span> : height[i]);</span><br><span class="line">            <span class="keyword">if</span>(s.isEmpty() || h &gt;= height[s.peek()])&#123;</span><br><span class="line">                s.push(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> tp = s.pop();</span><br><span class="line">                maxArea = Math.max(maxArea, height[tp] * (s.isEmpty() ? i : i - <span class="number">1</span> - s.peek()));</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>, largestArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; height.length || (index == height.length &amp;&amp; !stack.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index != height.length &amp;&amp; (stack.isEmpty() || height[stack.peek()] &lt; height[index])) &#123;</span><br><span class="line">                stack.push(index++);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = height[stack.pop()];</span><br><span class="line">                <span class="keyword">int</span> w = stack.isEmpty() ? index : index - stack.peek() - <span class="number">1</span>;</span><br><span class="line">                largestArea = Math.max(largestArea, h * w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> largestArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="85-Maximal-Rectangle"><a href="#85-Maximal-Rectangle" class="headerlink" title="85.Maximal Rectangle"></a>85.Maximal Rectangle</h4><blockquote><p>在DP专题总结过</p></blockquote><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing all 1’s and return its area.</p><ul><li>要求最大的矩形，实际上可以将矩阵的每一行，转化为上一题的直方图，</li><li>而直方图的每个竖条的数字，就是该行对应坐标正上方，向上方向有多少个连续的1。</li><li>要转化为直方图，方法是每一行的数值都累加上一行计算出来的数值，而第一行的数值就是本身。如果原始矩阵中遇到0，则累加中断，重新置0。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 0 1 1 0 -&gt; 0 0 1 1 0</span><br><span class="line">0 0 1 1 0 -&gt; 0 0 2 2 0</span><br><span class="line">1 1 0 0 0 -&gt; 1 1 0 0 0</span><br><span class="line">1 1 1 0 0 -&gt; 2 2 1 0 0</span><br></pre></td></tr></table></figure><ul><li>dp[i][j]化为直方图的值</li><li>接着对dp[i][j]进行Largest Rectangle in Histogram计算即可</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i == 0 --&gt; dp[i][j] = matrix[i][j] - &apos;0&apos;</span><br><span class="line">i != 0 --&gt; </span><br><span class="line">matrix[i][j] == 1 --&gt; dp[i][j] = dp[i-1][j] + matrix[i][j] - &apos;0&apos;</span><br><span class="line">matrix[i][j] != 1 --&gt; dp[i][j] = 0</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="comment">// 如果是第一行就是自身，如果遇到0则停止累加</span></span><br><span class="line">                dp[i][j] =  i == <span class="number">0</span> ? matrix[i][j] - <span class="string">'0'</span> : matrix[i][j] == <span class="string">'1'</span> ? dp[i-<span class="number">1</span>][j] + matrix[i][j] - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++)&#123;</span><br><span class="line">            <span class="comment">//找每行的最大矩形</span></span><br><span class="line">            <span class="keyword">int</span> tmp = findRowMax(i, dp);</span><br><span class="line">            max = Math.max(max, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findRowMax</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span>[][] matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[row].length== <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stk = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, max = matrix[row][<span class="number">0</span>];</span><br><span class="line">        stk.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(i &lt; matrix[row].length || (i == matrix[row].length &amp;&amp; !stk.isEmpty()))&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != matrix[row].length &amp;&amp; ( stk.isEmpty() || matrix[row][i] &gt;= matrix[row][stk.peek()] ))&#123;</span><br><span class="line">                stk.push(i);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> top = matrix[row][stk.pop()];</span><br><span class="line">                <span class="keyword">int</span> currMax = !stk.isEmpty() ? top * (i - stk.peek() - <span class="number">1</span>) : top * i;</span><br><span class="line">                max = Math.max(currMax, max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="71-Simplify-Path"><a href="#71-Simplify-Path" class="headerlink" title="71.Simplify Path"></a>71.Simplify Path</h4><p>Given an absolute path for a file (Unix-style), simplify it.</p><p>For example,</p><p><strong>path</strong> = “/home/“, =&gt; “/home”</p><p><strong>path</strong> = “/a/./b/../../c/“, =&gt; “/c”</p><p><strong>Corner Cases:</strong></p><ul><li>Did you consider the case where path = “/../“?<br>In this case, you should return “/“.</li><li>Another corner case is the path might contain multiple slashes ‘/‘ together, such as “/home//foo/“.In this case, you should ignore redundant slashes and return “/home/foo”.</li></ul><p><strong>题目意思</strong></p><ul><li>.可忽略，..需要pop掉上一个，比如/b/../c/ -&gt; /c</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">for</span>(String cur: path.split(<span class="string">"/"</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.equals(<span class="string">".."</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!stack.empty()) stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.length()&gt;<span class="number">0</span> &amp;&amp; !cur.equals(<span class="string">"."</span>)) stack.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/"</span>+String.join(<span class="string">"/"</span>,stack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Stack实际上也是通过&lt;strong&gt;数组&lt;/strong&gt;去实现的。&lt;/p&gt;
&lt;p&gt;执行push时(即，将元素推入栈中)，是通过将元素追加的数组的末尾中。&lt;/p&gt;
&lt;p&gt;执行peek时(即，取出栈顶元素，不执行删除)，是返回数组末尾的元素。&lt;/p&gt;
&lt;p&gt;执行pop时(即，取出栈顶元素，并将该元素从栈中删除)，是取出数组末尾的元素，然后将该元素从数组中删除。&lt;/p&gt;
&lt;p&gt;Stack继承于Vector，意味着Vector拥有的属性和功能，Stack都拥有。&lt;/p&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode Category" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/LeetCode-Category/"/>
    
    
      <category term="String" scheme="blog.jiangdongyu.space/tags/String/"/>
    
      <category term="Stack" scheme="blog.jiangdongyu.space/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>类文件结构</title>
    <link href="blog.jiangdongyu.space/2018/06/25/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>blog.jiangdongyu.space/2018/06/25/类文件结构/</id>
    <published>2018-06-25T06:00:00.000Z</published>
    <updated>2018-07-10T09:02:22.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h2><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG272.jpeg" alt="avatar"></p><p>Class文件的头4个字节称为魔数(magic),用于确定文件是否是能被虚拟机接收的Class文件。0xCAFEBABE 代表Java</p><p>紧接着的是Class文件的版本号：第5和第6字节是次版本号(minor_version),第7和第8字节是主版本号(major_version)</p><a id="more"></a><p>紧接着主次版本号之后的是常量池入口，由于常量数量不固定，需要放置常量池容量计数值(constant_pool_count), <strong>计数从1开始</strong>, (0用来表示“不引用任何一个常量池项目”)</p><p>常量池中存放两大类常量：字面量和符号引用。字面量接近Java中常量的概念，而符号引用则属于编译原理方面的概念，包含三大类：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p><strong>JDK的bin目录中，javap工具-verbose可用于输出常量表</strong></p><p>常量池结束之后，是访问标志(access_flags), 用于识别一些类或者接口的访问信息。包括是否public、final、abstract等</p><p>类索引(this_class)、父类索引(super_class)分别确定类、父类的全限定名。接口索引集合(interfaces), 由这三项数据确定类的继承关系。</p><p>字段表(field_info)用于描述接口或者类中声明的变量，字段包括类级变量以及实例级变量。</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG273.jpeg" alt="avatar"></p><p>方法表和字段表相似，结构也包含上述的4个部分，仅在访问标志和属性表集合的可选项中有些区别，方法里面的代码存放在属性表集合中“Code”属性中。</p><p>属性表集合，不需要严格顺序，几个常用属性讲解：</p><ul><li>Code属性<ul><li>使用位置：方法表，Java代码编译成的字节码指令</li></ul></li><li>Exceptions属性<ul><li>列出方法中可能抛出的异常，即throws关键字后列举的异常</li></ul></li><li>LineNumberTable属性<ul><li>描述Java源码行号和字节码行号之间的对应关系，选择不生成，则抛出异常时没有出错行号</li></ul></li><li>LocalVariableTable属性<ul><li>描述栈帧中局部变量表中的变量和Java源代码中定义的变量之间的关系，如果不生成，当别人引用该方法时，参数名称会丢失，IDE使用args1等占位符替代，带来不便</li></ul></li><li>SourceFile属性<ul><li>记录生成这个Class文件的源码文件名称，选择不生成，则抛出异常时，不显示出错代码的文件名</li></ul></li><li>ConstantValue属性<ul><li>通知虚拟机为静态变量赋值</li><li>非static变量，在实例构造器init中进行</li><li>类变量，类构造器clinit中/使用ConstantValue</li><li>Sun Javac中，如果同时使用static和final修饰，并且是基本数据类型或者String时，生成ConstantValue来进行初始化，如果没有被final修饰或者类型不符，则在clinit中初始化</li></ul></li><li>InnerClasses属性<ul><li>记录内部类和宿主类之间的关联。如果一个类中定义了内部类，编译器会为它以及它所包含的内部类生成该属性</li></ul></li><li>Deprecated及Synthetic属性<ul><li>标志类型的布尔类型</li><li>Deprecated表示类、字段或方法，已经被程序作者定为不再推荐使用，可以使用@ deprecated注解设置</li><li>Synthetic表示字段或者方法不是由Java源码直接产生的，而是由编译器添加的。所有由非用户生成的类、方法及字段都应该至少设置Synthetic属性或者ACC_SYNTHETIC标志位，但是实例构造器init和类构造器clinit除外</li></ul></li><li>StackMapTable属性<ul><li>位于Code属性的属性表中，在虚拟机类加载的字节码验证阶段被新类型检查验证器使用，用于代替之前比较消耗性能的基于数据流分析的类型推导验证器</li><li>一个方法的Code属性醉倒只能有一个StackMapTable</li></ul></li><li>Signature属性<ul><li>记录泛型类型，Java采用的是擦除法实现的伪泛型，泛型信息编译之后会被擦除，比如运行前做反射时无法得到泛型类型</li></ul></li></ul><h2 id="字节码指令简介"><a href="#字节码指令简介" class="headerlink" title="字节码指令简介"></a>字节码指令简介</h2><p>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字(操作码)以及紧随其后的零至多个代表此操作所需参数(操作数)而构成。Java虚拟机采用操作数栈，大多数质量都不包含操作数。</p><ul><li>加载和存储指令<ul><li>将数据在栈帧中的局部变量表和操作数栈之间来回传输</li></ul></li><li>运算指令<ul><li>用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入操作栈顶</li></ul></li><li>类型转换指令<ul><li>将两种不同的数值类型进行转换，<strong>显式类型转换</strong></li></ul></li><li>对象创建与访问指令<ul><li>针对类实例和数组</li></ul></li><li>操作数栈管理指令<ul><li>直接操作操作数栈，类似操作数据结构中的堆栈</li></ul></li><li>控制转移指令<ul><li>让Java虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的下一条指令继续执行程序。(条件分支ifeq、复合条件分支、无条件分支goto)</li></ul></li><li>方法调用和返回指令<ul><li>方法调用(分派、执行过程)指令与数据类型无关，方法返回指令根据返回值的类型区分</li></ul></li><li>异常处理指令<ul><li>Java中显式抛出异常的操作(throw)都由athrow来实现，很多运行时异常会在检测到时自动抛出</li><li>Java虚拟机中，处理异常(catch)，采用异常表来完成</li></ul></li><li>同步指令<ul><li>支持方法级的同步和方法内部一段指令序列的同步，都使用管程(Monitor)来支持</li><li>方法级同步时隐式的，实现在方法调用和返回操作之中。虚拟机得知是否为同步方法，方法调用时，检查ACC_SYNCHRONIZED访问标志是否被设置，设置则要求成功持有管程，然后才能执行方法，方法完成(成功/失败)时释放管程。方法执行期间，其他线程无法获得该管程。如果同步期间抛出异常，并在内部无法处理，则管程会在异常抛出到同步方法之外时释放</li><li>同步一段指令序列通过synchronized语句块来表示，Java指令集中monitorenter和monitorexit来支持synchronized语义</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Class类文件的结构&quot;&gt;&lt;a href=&quot;#Class类文件的结构&quot; class=&quot;headerlink&quot; title=&quot;Class类文件的结构&quot;&gt;&lt;/a&gt;Class类文件的结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://p9fh1pach.bkt.clouddn.com/WechatIMG272.jpeg&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
&lt;p&gt;Class文件的头4个字节称为魔数(magic),用于确定文件是否是能被虚拟机接收的Class文件。0xCAFEBABE 代表Java&lt;/p&gt;
&lt;p&gt;紧接着的是Class文件的版本号：第5和第6字节是次版本号(minor_version),第7和第8字节是主版本号(major_version)&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="读书笔记" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深入理解Java虚拟机" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="虚拟机执行子系统" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
      <category term="Class" scheme="blog.jiangdongyu.space/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>HTTP中GET与POST的区别</title>
    <link href="blog.jiangdongyu.space/2018/06/20/HTTP/"/>
    <id>blog.jiangdongyu.space/2018/06/20/HTTP/</id>
    <published>2018-06-20T10:50:00.000Z</published>
    <updated>2018-06-20T11:01:23.628Z</updated>
    
    <content type="html"><![CDATA[<p>GET和POST是HTTP请求的两种基本方法，最直观的区别就是GET把<strong>参数</strong>包含在URL中，POST通过request body传递参数。</p><p>你轻轻松松的给出了一个<strong>“标准答案”</strong>：</p><a id="more"></a><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求。 </li><li>GET产生的URL地址可以被Bookmark，而POST不可以。 </li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。 </li><li>GET请求只能进行url编码，而POST支持多种编码方式。 </li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 </li><li>GET请求在URL中传送的参数是有长度限制的，而POST没有。 </li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 </li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 </li><li>GET参数通过URL传递，POST放在Request body中。</li></ul><p><strong>GET和POST是什么?</strong></p><p>HTTP协议中的两种发送请求的方法。</p><p><strong>HTTP是什么?</strong></p><p>HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。</p><p>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。</p><p>那么，“标准答案”里的那些区别是怎么回事?</p><p>在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签(设置method为GET)，而且要求把传送的数据放在车顶上(url中)以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩;也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。<br>但是，我们只看到HTTP对GET和POST参数的传送渠道(url还是requrest body)提出了要求。“标准答案”里关于参数大小的限制又是从哪来的呢?</p><p>在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器(发起http请求)和服务器(接受http请求)就是不同的运输公司。虽然理论上，你可以在车顶上无限的堆货物(url中无限加参数)。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，<strong>(大多数)浏览器通常都会限制url长度在2K个字节，而(大多数)服务器最多处理64K大小的url。</strong>超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。<br>好了，现在你知道，<strong>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同</strong>。</p><p>GET和POST还有一个<strong>重大区别</strong>，简单的说：</p><ul><li>GET产生一个TCP数据包;POST产生两个TCP数据包。</li></ul><p>长的说：</p><ul><li>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);</li><li>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。</li></ul><p>也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。</p><p>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑!跳入需谨慎。为什么?</p><ol><li>GET与POST都有自己的语义，不能随便混用。</li><li>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</li><li>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</li></ol><p><a href="http://www.techweb.com.cn/network/system/2016-10-11/2407736.shtml" target="_blank" rel="noopener">本文参考地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GET和POST是HTTP请求的两种基本方法，最直观的区别就是GET把&lt;strong&gt;参数&lt;/strong&gt;包含在URL中，POST通过request body传递参数。&lt;/p&gt;
&lt;p&gt;你轻轻松松的给出了一个&lt;strong&gt;“标准答案”&lt;/strong&gt;：&lt;/p&gt;
    
    </summary>
    
      <category term="Java面试" scheme="blog.jiangdongyu.space/categories/Java%E9%9D%A2%E8%AF%95/"/>
    
      <category term="HTTP" scheme="blog.jiangdongyu.space/categories/Java%E9%9D%A2%E8%AF%95/HTTP/"/>
    
    
      <category term="计算机网络" scheme="blog.jiangdongyu.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP" scheme="blog.jiangdongyu.space/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 -- 传输层</title>
    <link href="blog.jiangdongyu.space/2018/06/19/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <id>blog.jiangdongyu.space/2018/06/19/传输层/</id>
    <published>2018-06-19T03:00:00.000Z</published>
    <updated>2018-07-10T09:02:11.914Z</updated>
    
    <content type="html"><![CDATA[<p><strong>知识架构图如下:</strong></p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG268.jpeg" alt="avatar"></p><a id="more"></a><h2 id="传输层提供的服务"><a href="#传输层提供的服务" class="headerlink" title="传输层提供的服务"></a>传输层提供的服务</h2><h3 id="传输层的功能"><a href="#传输层的功能" class="headerlink" title="传输层的功能"></a>传输层的功能</h3><p>面向通信部分的最高层，用户功能中的最低层。传输层提供<strong>可靠</strong>服务（尽管网络层不可靠）</p><p><strong>传输层的功能：</strong></p><ul><li>传输层为运行在不同主机上的<strong>进程</strong>提供逻辑通信（端到端通信），而网络层提供<strong>主机</strong>之间的逻辑通信。</li><li>复用和分用<ul><li>传输层：（复用）不同进程可用同一传输协议，（分用）可剥离给不同进程</li><li>网络层：（复用）不同协议数据可封装成IP数据报发送出去，（分用）可剥离给不同协议</li></ul></li><li>传输层对收到的报文进行差错检测（首部和数据部分），网络层只检测IP数据报的首部，不检验数据部分是否出错</li><li>提供两种不同的传输协议，面向连接的TCP和无连接的UDP，网络层无法同时实现两种</li></ul><h3 id="传输层的寻址与端口"><a href="#传输层的寻址与端口" class="headerlink" title="传输层的寻址与端口"></a>传输层的寻址与端口</h3><ul><li>端口的作用<ul><li>让应用进程将数据通过端口交付给传输层</li><li>让传输层知道讲数据交付给应用层对于进程</li></ul></li><li>端口号：只有本地意义<ul><li>服务端使用的端口号</li><li>客户端使用的端口号，短暂端口号</li></ul></li><li>套接字：组合识别端点<ul><li><strong>IP地址</strong>标识和区别不同主机，<strong>端口号</strong>标识和区别主机众不同应用进程，<strong>套接字</strong>组合识别端点</li><li><strong>套接字 = （主机IP地址，端口号）</strong></li></ul></li></ul><h3 id="无连接服务与面向连接服务"><a href="#无连接服务与面向连接服务" class="headerlink" title="无连接服务与面向连接服务"></a>无连接服务与面向连接服务</h3><ul><li>面向连接服务就是在通信之前，必须建立连接，通信过程中，实时监控和管理连接情况。通信结束后，应该释放连接。<ul><li>TCP不提供广播或组播服务，适合可靠性更重要的场合，如FTP，HTTP，TELNET（远程登录）</li></ul></li><li>无连接的服务，通信不需要先建立连接，需要通信时，直接将信息发送到“网络”中，让信息的传递尽力往目的地传送<ul><li>UDP在IP之上提供多路复用和对数据的错误检查，执行速度快，实时性好，TFTP（小文件传送协议），DNS，SNMP（简单网络管理协议）和RTP（实时协议）</li></ul></li></ul><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><h3 id="UDP数据报"><a href="#UDP数据报" class="headerlink" title="UDP数据报"></a>UDP数据报</h3><p>UDP = IP + 复用/分用 + 差错检测</p><p><strong>UDP优点：</strong></p><ul><li>UDP无需建立连接，没有建立连接的时延</li><li>无连接状态，能支持更多的活动客户机</li><li>首部开销小，8字节开销</li><li>应用层能更好地控制要发送的数据和发送时间，无拥塞控制，发送发自由</li></ul><p>UDP用于一次性传输少量数据的网络应用，也用于多媒体应用，不保证可靠性交付但要求低延迟，应用层可灵活设计可靠性机制保证可靠性。</p><p>UDP面向报文，发送方UDP对应用层交下来的报文，添加首部后直接给IP层，不合并，不拆分；接收方UDP对IP层交上来的数据报，去除首部后直接给应用进程，一次交付一个完整的报文。（以报文为操作单位）</p><p>UDP数据报 = UDP首部（8B） + 用户数据</p><ul><li>源端口：需要对方回信时用，不用则为0</li><li>目的端口</li><li>长度：最小值为8（仅首部）</li><li>校验和：检验UDP数据报在传输中是否出错，有错则丢弃。源主机不想计算校验和，则为0</li></ul><h3 id="UDP校验"><a href="#UDP校验" class="headerlink" title="UDP校验"></a>UDP校验</h3><p>采用首部、伪首部、数据进行二进制反码运算求和再取反</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG269.jpeg" alt="avatar"></p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="TCP协议的特点"><a href="#TCP协议的特点" class="headerlink" title="TCP协议的特点"></a>TCP协议的特点</h3><ul><li>面向连接</li><li>点对点（一对一）</li><li>可靠的交付，无差错、不丢失、不重复且有序</li><li>全双工通信，通信双方都可发送数据</li><li>面向字节流</li></ul><h3 id="TCP报文段-TCP传送的数据单元"><a href="#TCP报文段-TCP传送的数据单元" class="headerlink" title="TCP报文段(TCP传送的数据单元)"></a>TCP报文段(TCP传送的数据单元)</h3><p>TCP报文段分为首部和数据两部分，整个TCP段作为IP数据报的数据部分封装在IP数据报中。首部前20字节是固定的，后面有4N字节是根据需要而增加的选项。</p><p><img src="http://p9fh1pach.bkt.clouddn.com/201806191848.png" alt="avatar"></p><p>TCP报文段既可以用来运载数据，也可以用来建立/释放连接，应答。</p><ul><li>序号字段：4字节，指的是本报文段所发送的数据的第一个字节的序号</li><li>确认号字段：4字节，期望收到对方的下一个报文段的数据的第一个字节的序号。若确认号为N，则表示到序号N-1为止的数据都已正确收到</li><li>数据偏移：首部长度，4位</li><li>保留字段：6位，目前置0</li><li>紧急位URG：URG = 1时，表示<strong>紧急指针</strong>有效，表明有紧急数据，需要尽快送达。URG需要和紧急指针配套使用，数据从第一个字节到紧急指针所指字节就是<strong>紧急数据</strong></li><li>确认位ACK：ACK = 1时<strong>确认号字段</strong>才有效。连接建立后所有传送的报文段都必须把ACK置1</li><li>推送位PSH：（PSH = 1）尽快交付接收应用进程，不用等到缓冲区满了再交付</li><li>复位位RST：（RST = 1）连接出现严重差错，必须释放连接，然后再重新建立运输连接</li><li>同步位SYN：SYN = 1表示这是一个连接请求或连接接收报文<ul><li>SYN = 1，ACK = 0，连接请求报文</li><li>SYN = 1，ACK = 1，连接接收报文</li></ul></li><li>终止位FIN：（FIN = 1）发送方数据发送完毕，要求释放连接</li><li>窗口字段：2字节，指出允许对方发送的数据量</li><li>检验和：2字节，检验首部和数据，计算时和UDP相似，也要加12字节的伪首部，将UDP中的17 -&gt; 6</li><li>紧急指针字段：16位，指出本报文段中紧急数据的字节总数（紧急数据放在报文段数据的最前面）</li><li>选项字段：最大报文段长度（MSS），MSS是TCP报文段中的数据字段的最大长度</li><li>填充字段：为了使整个首部长度是4字节的整数倍</li></ul><h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><p>TCP连接的端口叫套接字，每一条TCP连接唯一地被通信两端的两个端点所确定。</p><h4 id="TCP连接的建立（三次握手）"><a href="#TCP连接的建立（三次握手）" class="headerlink" title="TCP连接的建立（三次握手）"></a>TCP连接的建立（三次握手）</h4><p><img src="http://p9fh1pach.bkt.clouddn.com/20170607205709367.gif" alt="avatar"></p><blockquote><p>最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。</p></blockquote><ul><li>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</li><li>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。<strong>TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</strong></li><li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。<strong>这个报文也不能携带数据，但是同样要消耗一个序号。</strong></li><li>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。<strong>TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</strong></li><li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。 </li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/20170605110405666.png" alt="avatar"></p><p>TCP是全双工通信，通信双方的应用进程在任何时候都能发送数据。</p><p>服务器的资源是在完成第二次握手时分配的，客户端资源是在完成第三次握手时分配的。这使服务器易于受到SYN洪泛攻击。</p><pre><code>Q:为什么TCP客户端最后还要发送一次确认呢？A:防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</code></pre><h4 id="TCP连接的释放（四次挥手）"><a href="#TCP连接的释放（四次挥手）" class="headerlink" title="TCP连接的释放（四次挥手）"></a>TCP连接的释放（四次挥手）</h4><p><img src="http://p9fh1pach.bkt.clouddn.com/20170607205756255.gif" alt="avatar"></p><blockquote><p>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。</p></blockquote><ul><li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。<strong>TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</strong></li><li>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。<strong>TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。*</strong>这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。*</li><li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文<strong>（在这之前还需要接受服务器发送的最后的数据）</strong>。</li><li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li><li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。<strong>注意此时TCP连接还没有释放，必须经过2[Math Processing Error]MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</strong></li><li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。<strong>可以看到，服务器结束TCP连接的时间要比客户端早一些。</strong></li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/20170606084851272.png" alt="avatar"></p><p><strong>为什么客户端最后还要等待2MSL？</strong></p><ul><li>保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，<strong>站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次</strong>，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</li><li>防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</li></ul><p><strong>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</strong></p><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 </p><p>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p><h3 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h3><p>保证接收方进程从缓冲区读出的字节流与发送方发出的字节流是完全一样的</p><p>使用了校验、序号、确认和重传等机制来达到目的</p><ul><li>序号：TCP 数据段以字节为单位对数据段中的“数据”部分进行一一编号，确保每个字节的数据都可以有序传送和接受</li><li>确认：TCP 要求每接受一个数据段都必须由接收端向发送端返回一个确认数据段，其中的“确认号”表明接收端已正确接受的数据段序号（“确认号”前面的所有数据段，确认号表示将要接收的下一个数据段编号）。</li><li>重传<ul><li>超时：超出计时器的重传时间还未收到确认则重传，RTT</li><li>冗余：TCP规定每当比期望序号大的失序报文段到达时，发送一个冗余ACK，指明下一个期待字节的序列号。TCP规定当发送方收到对同一个报文段的3个冗余ACK时，可以认为跟在这个被确认的报文段之后的报文段已经丢失（<strong>快重传</strong>）。</li></ul></li></ul><h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><p>在确认报文中设置窗口字段rwnd来限制发送速率，发送方可也根据当前网络拥塞程度设置拥塞窗口cwnd。<strong>发送窗口的实际大小取rwnd和cwnd的最小值</strong></p><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>根据自己估算的网络拥塞程度设置cwnd来限制发送速率</p><ul><li>慢开始算法：刚连接的TCP，令cwnd = 1（一个最大报文段长度），每收到一个确认后加1。每经过一个RTT，cwnd加倍，直到慢开始门限（ssthresh），改用拥塞避免算法</li><li>拥塞避免算法：cwnd每经过一个RTT就加1（<strong>加法增大</strong>），当出现一次超时，令慢开始门限等于当前cwnd的一半（<strong>乘法减小</strong>）</li></ul><p>根据cwnd的大小执行不同算法：</p><ul><li>cwnd &lt; ssthresh,慢开始算法</li><li>cwnd &gt; ssthresh,停止慢开始，使用拥塞避免算法</li><li>cwnd = ssthresh,都可以（通常使用拥塞避免算法）</li></ul><p>一旦网络出现拥塞时，都要把ssthresh设为cwnd的一半（但不能小于2），然后把cwnd设为1，执行慢开始算法。</p><p>快重传、快恢复是对慢开始算法和拥塞避免算法的改进。</p><ul><li>快重传：发送方连续收到三个重复的ACK时，直接重传对方尚未收到的报文段</li><li>快恢复：发送方连续收到三个重复的ACK时，就执行“乘法减小”，将ssthresh设置为cwnd的一半。<strong>把cwnd设为ssthresh改变后的值</strong>，然后开始执行拥塞避免算法（“加法增大”）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;知识架构图如下:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p9fh1pach.bkt.clouddn.com/WechatIMG268.jpeg&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="读书笔记" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机网络" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="传输层" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
    
      <category term="计算机网络" scheme="blog.jiangdongyu.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 -- 网络层</title>
    <link href="blog.jiangdongyu.space/2018/06/13/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>blog.jiangdongyu.space/2018/06/13/网络层/</id>
    <published>2018-06-13T09:00:00.000Z</published>
    <updated>2018-07-10T09:02:27.898Z</updated>
    
    <content type="html"><![CDATA[<p><strong>知识架构图如下:</strong></p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG265.jpeg" alt="avatar"></p><a id="more"></a><h2 id="网络层的功能"><a href="#网络层的功能" class="headerlink" title="网络层的功能"></a>网络层的功能</h2><h3 id="异构网络互联"><a href="#异构网络互联" class="headerlink" title="异构网络互联"></a>异构网络互联</h3><p>网络的互联，指的是将两个以上的计算机网络，通过一定的方法，用一种或多种通信处理设备(即中间设备/中间系统/中继系统)相互连接起来，以构成更大的网络系统。</p><p>四种不同的中继系统：</p><ul><li>物理层中继系统: 中继器，集线器(Hub)</li><li>数据链路层中继系统: 网桥或交换机</li><li>网络层中继系统: 路由器</li><li>网络层以上的中继系统: 网关</li></ul><p>物理层、数据链路层中继系统，只是扩大网络，但仍然是同一个网络，称不上互联。</p><p>网络互联通常是指用路由器进行网络互联和路由选择，路由器就是一台专用计算机，用于在互联网中进行路由选择。</p><p>虚拟(逻辑)互联网络，互联起来的各种物理网络的异构行本来是客观存在的，但使用IP协议可以看起来是一个统一的网络。</p><p>使用虚拟(逻辑)互联网络的好处：当互联网的主机进行通信时，就好像在一个网络上通信一样，而看不见互联的具体的网络异构细节。</p><h3 id="路由与转发"><a href="#路由与转发" class="headerlink" title="路由与转发"></a>路由与转发</h3><p>路由器主要完成两个功能：</p><ul><li><strong>路由选择</strong>(确定哪一条路径): 按照分布式算法，根据从相邻路由器所得到的关于整个网络拓扑的变化情况，动态改变所选路由</li><li><strong>分组转发</strong>(当一个分组到达时所采取的动作): 根据转发表将用户的IP数据报从合适的端口转发出去</li></ul><p>路由表是根据路由选择算法得出的，转发表从路由表得出。转发表的结构应该使查找过程最优化，路由表则需要对网络拓扑变化的计算最优化。</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>在通信子网中，由于出现过量的分组而引起网络性能下降的现象称为<strong>拥塞</strong>。</p><p>判断网络是否进入拥塞状态的方法是观察网络的吞吐量和网络负载的关系：</p><p>网络负载增加:</p><ul><li>吞吐量小于正常:  <ul><li>“轻度拥塞”</li></ul></li><li>吞吐量下降:     <ul><li>拥塞</li></ul></li><li>吞吐量将为0:    <ul><li>死锁</li></ul></li></ul><p><strong>流量控制与拥塞控制的区别</strong>: 流量控制指在发送端和接收端之间的点对点通信量的控制。流量控制所要做的就是抑制发送端发送端发送数据的速率，以便接收端来得及接收。而拥塞控制必须确保通信子网能够传送待传送的数据，是一个全局性的问题，设计网络中所有主机、路由器以及导致网络传输能力下降的所有因素。</p><p>拥塞控制的方法：</p><ul><li>开环控制: 静态预防，视线尽可能考虑好，启动后不修改，不考虑当前网络状态</li><li>闭环控制: 事先不管，动态监控，启动后监视检测，及时解决，基于反馈环路概念</li></ul><h2 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h2><h3 id="静态路由与动态路由"><a href="#静态路由与动态路由" class="headerlink" title="静态路由与动态路由"></a>静态路由与动态路由</h3><p>从能否随网络的通信量货拓扑自适应地进行调整变化来划分，可分为两大类：</p><ul><li>静态路由算法(非自适应): 网络管理员手工配置的路由信息。网络拓扑或链路状态变化时，需要手工修改路由表中相关的静态路由信息。<ul><li>简便、可靠，适合负荷稳定、拓扑变化不大的网络</li><li>不适合大型、复杂网络环境</li></ul></li><li>动态路由算法(自适应): 路由器上的路由表项是通过相互连接的路由器之间彼此交换信息，然后按照一定的算法优化出来的，这些信息是在一定时间间隙里不断更新，以适应不断变化的网络，以随时获得最优的寻路效果<ul><li>改善网络性能并有助于流量控制</li><li>算法复杂，增加网络负担，有时因对动态变化的反应太快而引起振荡，或反应太慢而影响网络路由的一致性</li></ul></li></ul><h3 id="距离-向量路由算法（最常见RIP算法）"><a href="#距离-向量路由算法（最常见RIP算法）" class="headerlink" title="距离-向量路由算法（最常见RIP算法）"></a>距离-向量路由算法（最常见RIP算法）</h3><p>所有结点都定期将它们的整个路由选择表传送给所有与之直接相邻的结点。这种路由选择表包括：</p><ul><li>每条路径的目的地（另一结点）</li><li>路径的代价（也称距离）</li></ul><p>当被通告有新的路由或者到达某一个目的地的距离更小时，会发生更新</p><h3 id="链路状态路由算法（典型OSPF算法）"><a href="#链路状态路由算法（典型OSPF算法）" class="headerlink" title="链路状态路由算法（典型OSPF算法）"></a>链路状态路由算法（典型OSPF算法）</h3><p>链路状态路由算法要求每个参与该算法的结点都有完全的网络拓扑信息。执行两项任务：</p><ul><li>主动测试所有邻接结点的状态</li><li>定期将链路状态传播给所有其他的结点</li></ul><p>在一个链路状态路由选择中，一个结点检查所有直接链路的状态，并将所得的状态信息发送给网上所有其他结点。</p><p>当链路报文到达时，路由结点根据信息去更新网络拓扑和状态“视野图”，一旦链路状态变化，结点对更新了的网络图利用Dijsktra最短路径算法重新计算路由。</p><p><strong>三点特征：</strong></p><ul><li>泛洪法，路由器通过所有端口向所有相邻的路由器发送信息。而每一个相邻路由器又将此信息发往其所有相邻路由器（不包含刚发来信息的路由器）</li><li>发送的信息就是与路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息</li><li>只有当链路状态变化时，才向所有路由器发送此消息</li></ul><p><strong>优点：</strong></p><ul><li>结点使用同样的原始状态数据独立计算路径，不依赖中间结点</li><li>链路状态报文不加改变地传播，易于查找故障</li><li>链路状态报文只包含单个结点关于直接链路的信息，与网络中路由结点的数量无关</li></ul><p>适用于<strong>大型的或路由信息变化聚敛</strong>的互联网环境</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">特点</th><th style="text-align:center">优缺点</th></tr></thead><tbody><tr><td style="text-align:center">距离-向量路由算法</td><td style="text-align:center">仅与直接邻居交谈，为邻居提供从自己到所有其他结点的费用</td><td style="text-align:center">路由环路</td></tr><tr><td style="text-align:center">链路状态路由算法</td><td style="text-align:center">广播方式与所有其他结点交谈，仅告诉与之直接相连链路的费用</td><td style="text-align:center">更好的规模可伸展性</td></tr></tbody></table><h3 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h3><p>将互联网划分为许多自治系统，每个自治系统自主决定内部使用何种路由选择协议。</p><p>路由选择协议：</p><ul><li>内部网关协议(域内路由选择)：自治系统内部使用，RIP和OSFP</li><li>外部网关协议(域间路由选择)：自治系统之间使用，BGP</li></ul><p>采用层次划分区域虽然使交换信息种类增多，使OSPF协议更复杂，但能使每个区域内交换路由信息的通信量大大减小，因而使OSPF能够用于规模更大的自治系统中。</p><h2 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h2><h3 id="IPV4分组"><a href="#IPV4分组" class="headerlink" title="IPV4分组"></a>IPV4分组</h3><p><img src="http://p9fh1pach.bkt.clouddn.com/20131220194104812.jpeg" alt="avatar"></p><p>总长度：首部+数据，以太网帧最大传送单元MTU为1500字节，数据报总长度不能超过</p><p>标识：每产生一个数据报就加1，并赋值给标识字段。当数据报长度超过MTU时必须分片，数据报片都复制一次标识号以便能正确组装原来的数据报</p><p>标志：是否有片，最低位MF，MF=1表示后面还有分片；MF=0表示最后一个分片。标志字段中间的一位是DF，DF=0才允许分片，片在<strong>目的地的网络层</strong>被重新组装</p><p>片偏移：较长的分组在分片后，某片在原分组中的相对位置</p><p>首部检验和：只校验分组首部，不校验数据部分</p><p><strong>生存时间TTL</strong>：数据报在网络中可通过的路由器数的最大值，标识分组在网络中的寿命，确保分组不会永远在网络中循环</p><p>协议：分组携带的数据使用何种协议</p><p>固定部分20B，<strong>首部长度、总长度、片偏移的基本单位分别为4B、1B、8B</strong></p><h3 id="IPV4地址与NAT"><a href="#IPV4地址与NAT" class="headerlink" title="IPV4地址与NAT"></a>IPV4地址与NAT</h3><h4 id="IPV4地址"><a href="#IPV4地址" class="headerlink" title="IPV4地址"></a>IPV4地址</h4><p>IP地址由网络号和主机号两部分组成</p><h4 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h4><p>将专用网络地址转换为公用地址，从而对外隐藏内部管理的IP地址</p><h3 id="子网划分与子网掩码、CIDR"><a href="#子网划分与子网掩码、CIDR" class="headerlink" title="子网划分与子网掩码、CIDR"></a>子网划分与子网掩码、CIDR</h3><h4 id="子网划分-amp-子网掩码"><a href="#子网划分-amp-子网掩码" class="headerlink" title="子网划分&amp;子网掩码"></a>子网划分&amp;子网掩码</h4><p>采用子网掩码对物理子网再一次进行子网划分。</p><p>计算机只需将IP地址和其对应子网掩码逐位相“与”，就可得出相应子网的网络地址</p><h4 id="无分类编址CIDR"><a href="#无分类编址CIDR" class="headerlink" title="无分类编址CIDR"></a>无分类编址CIDR</h4><p>无分类域间路由选择(CIDR)是在变长子网掩码的基础上提出的一种消除传统A、B、C类网络划分，并且可以在软件的支持下实现超网构造的一种IP地址的划分方法。</p><p><strong>主要特点：</strong></p><ul><li>消除传统A、B、C类地址以及划分子网的概念，IP地址的无分类两级编址为：IP::{&lt;网络前缀&gt;,&lt;主机号&gt;}<ul><li>斜线记法，IP地址/网络前缀所占比特数</li><li>例如128.14.32.5/20，掩码是20个连续的1和后续12个连续的0，逐位相“与”可以得到该地址的网络前缀（或直接截取前20位）</li></ul></li><li>将网络前缀都相同的连续IP地址组成“CIDR”地址块，这种地址的聚合称为<strong>路由聚合</strong>或称为构成超网，<strong>使得</strong>路由表中的一个项目可以表示很多个原来传统分类地址的路由，减少路由器之间路由选择信息的交换。二进制表示的IP地址取最长公共前缀作为网络号。</li></ul><h3 id="ARP协议、DHCP协议与ICMP协议"><a href="#ARP协议、DHCP协议与ICMP协议" class="headerlink" title="ARP协议、DHCP协议与ICMP协议"></a>ARP协议、DHCP协议与ICMP协议</h3><h4 id="IP地址与硬件地址"><a href="#IP地址与硬件地址" class="headerlink" title="IP地址与硬件地址"></a>IP地址与硬件地址</h4><h4 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h4><p>IP地址到MAC地址的映射，每个主机设有一个ARP高速缓存，存放本局域网上各主机和路由器的IP地址到MAC地址的映射表(ARP表)</p><p><strong>ARP工作在网络层</strong>，4中典型情况：</p><ul><li>发送方是主机，把数据报发送到本网络另一个主机。用ARP找到目的主机的硬件地址</li><li>发送方是主机，把数据报发送到另一个网络的一个主机。用ARP找到本网络的一个路由器的硬件地址，剩下的工作由路由器完成</li><li>发送方是路由器，把数据报发送到本网络的一个主机。用ARP找到目的主机的硬件地址</li><li>发送方是路由器，把数据报发送到另一个网络的一个主机。用ARP找到本网络的一个路由器的硬件地址，剩下的工作由路由器完成</li></ul><h4 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h4><p>动态主机配置协议常用于给主机动态分配IP地址，提供了即插即用的联网机制。<strong>应用层协议，基于UDP</strong></p><p>DHCP服务器和DHCP客户端的交换过程如下：</p><ul><li>DHCP客户机广播“DHCP发现”消息，试图找到网络中的DHCP服务器，以便从DHCP服务器获得一个IP地址。由于DHCP客户机还未配置IP地址，它只能使用广播方式发送消息，并且源IP地址设置为0.0.0.0。 </li><li>DHCP服务器收到“DHCP发现”消息后，就向网络中广播“DHCP供给”消息，其中包括提供给DHCP客户机的IP地址和相关配置信息。 </li><li>DHCP客户机收到“DHCP供给”消息，如果接受DHCP服务器所提供的相关参数，就通过广播“DHCP请求”向DHCP服务器请求提供IP地址。 </li><li>DHCP服务器广播“DHCP确认”消息，将IP地址分配给DHCP客户机。</li></ul><h4 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h4><p>用来给主机或路由器报告差错和异常情况。</p><p>ICMP报文作为IP层数据报的数据，加上数据报首部，组成IP数据包发送出去。<strong>ICMP协议是IP层协议</strong></p><p>ICMP的报文种类有ICMP差错报告报文和ICMP询问报文：</p><p>差错报告报文有5种：</p><ul><li>终点不可以到达：当路由器和主机不能交付的时候</li><li>源点抑制：当路由器由于网络拥塞而丢弃的时候，源点把数据报发送速率减慢</li><li>时间超过：当路由器收到生存时间为0的数据报的时候</li><li>参数问题：当目的主机发现收到的数据报首部有问题的时候</li><li>改变路由：路由器把改变你的路由交付主机，告诉下一次的主机</li></ul><p>不应发送ICMP差错报告报文：</p><ul><li>对ICMP差错报告报文不再发送ICMP差错报告报文</li><li>若数据报进行了分片,只有第一个分片能发送ICMP报文</li><li>组播地址的数据报,不发送ICMP报文</li><li>特殊地址(如127.0.0.0或0.0.0.0)不发送ICMP报文</li></ul><p>ICMP询问报文：</p><p>回送请求和回答报文(PING,应用层，直接使用ICMP)、时间戳请求和回答报文(Traceroute/tracert)、掩码地址请求和回答报文、路由器询问和通告报文，最常用的是前两类</p><h2 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h2><h3 id="IPV6的主要特点"><a href="#IPV6的主要特点" class="headerlink" title="IPV6的主要特点"></a>IPV6的主要特点</h3><ul><li>IPv6具有更大的地址空间。32-&gt;128</li><li>扩展的地址层次结构</li><li>灵活的首部格式</li><li>改进的选项。</li><li>允许协议继续扩充。如果新的技术或应用需要时，IPV6允许协议进行扩充</li><li>支持即插即用，IPv6加入了对自动配置（Auto Configuration）的支持。</li><li>支持资源预分配</li><li>不允许分片，只有在包的源结点才能分片</li><li>首部长度必须是8B的整数倍</li><li>IPv6具有更高的安全性。身份验证和保密功能</li></ul><p>与IPV4不兼容，兼容TCP、UDP、ICMP、IGMP、BGP和DNS</p><h3 id="IPV6地址"><a href="#IPV6地址" class="headerlink" title="IPV6地址"></a>IPV6地址</h3><p>IPv6协议主要定义了三种地址类型：单播地址（Unicast Address）、组播地址（Multicast Address）和任播地址（Anycast Address）。与原来在IPv4地址相比，新增了“任播地址”类型，取消了原来IPv4地址中的广播地址，因为在IPv6中的广播功能是通过组播来完成的。</p><ul><li>单播地址：用来唯一标识一个接口，类似于IPv4中的单播地址。发送到单播地址的数据报文将被传送给此地址所标识的一个接口。<strong>点对点</strong></li><li>组播地址：用来标识一组接口（通常这组接口属于不同的节点），类似于IPv4中的组播地址。发送到组播地址的数据报文被传送给此地址所标识的所有接口。<strong>一点对多点</strong></li><li>任播地址：用来标识一组接口（通常这组接口属于不同的节点）。发送到任播地址的数据报文被传送给此地址所标识的一组接口中距离源节点<strong>最近</strong>（根据使用的路由协议进行度量）的一个接口。</li></ul><h2 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h2><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG267.jpeg" alt="avatar"></p><h3 id="自治系统"><a href="#自治系统" class="headerlink" title="自治系统"></a>自治系统</h3><p>一个自治系统内的所有网络属于一个行政单位来管辖，一个自治系统的所有路由器在本自治系统内都必须是连通的。</p><h3 id="域内路由与域间路由"><a href="#域内路由与域间路由" class="headerlink" title="域内路由与域间路由"></a>域内路由与域间路由</h3><p>路由选择协议：</p><ul><li>内部网关协议(IGP)：自治系统内部使用，RIP和OSFP</li><li>外部网关协议(EGP)：自治系统之间使用，BGP-4</li></ul><h3 id="RIP路由协议-距离-向量"><a href="#RIP路由协议-距离-向量" class="headerlink" title="RIP路由协议(距离-向量)"></a>RIP路由协议(距离-向量)</h3><p>路由信息协议，分布式的机遇距离向量的路由选择协议</p><p><strong>RIP的特点</strong></p><ul><li>仅和相邻的路由器交换信息。如果两个路由器之间的通信不经过另外一个路由器，那么这两个路由器是相邻的。RIP协议规定，不相邻的路由器之间不交换信息。</li><li>路由器交换的信息是当前本路由器所知道的全部信息。即自己的路由表。</li><li>按固定时间交换路由信息，如，每隔30秒，然后路由器根据收到的路由信息更新路由表。（也可进行相应配置使其触发更新）</li></ul><p><strong>最大优点</strong>就是实现简单，开销较小，收敛过程快</p><p><strong>缺点：</strong></p><ul><li>限制了网络的规模，能使用的最大距离为15（16表示不可达）</li><li>路由器交换的信息是路由器的完整路由表，因而随着网络规模的扩大，开销也就增加。</li><li>“坏消息传播得慢”，使更新过程的收敛时间过长。</li></ul><p>RIP是<strong>应用层</strong>协议，使用<strong>UDP</strong>传送数据，RIP选择的一定是具有最少路径路由器的路径。</p><h3 id="OSPF路由协议"><a href="#OSPF路由协议" class="headerlink" title="OSPF路由协议"></a>OSPF路由协议</h3><h4 id="OSPF协议的基本特点"><a href="#OSPF协议的基本特点" class="headerlink" title="OSPF协议的基本特点"></a>OSPF协议的基本特点</h4><p>开放最短路径优先协议使用分布式链路状态路由算法。</p><p>OSPF与RIP相比有4点主要区别：</p><ul><li>OSPF使用泛洪法向本自治系统中所有路由器发信息，而RIP只向和自己相邻的路由器发送信息</li><li>发送的信息是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。“链路状态”就是说明本路由器和哪些路由器相邻，以及该链路的“度量”（或代价）。而在RIP中发送的信息是本路由器所知道的全部信息，即整个路由表</li><li>只有当链路状态发生变化时，才用泛洪法向所有路由器发送此信息，并且更新过程收敛得快，不会出现RIP“消息传播得慢”的问题。RIP中，不管网络拓扑是否变化，都会定期交换路由表信息</li><li>OSPF是网络层协议，直接使用IP数据报传送。RIP是应用层协议，在传输层使用UDP协议</li></ul><p>除以上区别外，OSPF还有如下<strong>特点</strong>：</p><ul><li>OSPF对不同链路可根据IP分组的不同服务类型而设置成不同的代价，对不同类型业务计算出不同路由</li><li>如果到同一目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫多路径间的<strong>负载平衡</strong></li><li>所有在OSPF路由器之间交换的分组都具有鉴别功能，保证仅在可信赖路由之间交换链路状态信息</li><li>支持可变长度的子网划分和CIDR</li><li>每一个链路状态都带上一个32位的序号，序号越大状态越新</li></ul><h4 id="OSPF的基本工作原理"><a href="#OSPF的基本工作原理" class="headerlink" title="OSPF的基本工作原理"></a>OSPF的基本工作原理</h4><p>全网的拓扑结构图</p><p>利用“区域”减少整个网络负荷</p><h4 id="OSPF的五种分组类型"><a href="#OSPF的五种分组类型" class="headerlink" title="OSPF的五种分组类型"></a>OSPF的五种分组类型</h4><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG266.jpeg" alt="avatar"></p><h3 id="BGP路由协议"><a href="#BGP路由协议" class="headerlink" title="BGP路由协议"></a>BGP路由协议</h3><p>边界网关协议是不同自治系统的路由器之间交换路由信息的协议。</p><p>路径向量路由选择协议，BGP协议是应用层协议，基于TCP，寻找的并非最佳路由</p><h2 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a>IP组播</h2><p>在发送者和每一接受者之间实现点对多点网络连接，仅应用于UDP，使用D类地址格式</p><p>构造组播转发树以避免路由环路</p><h2 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h2><p>移动结点以固定的网络IP地址，实现跨越不同网段的漫游功能，并保证了基于网络IP的网络权限在漫游过程中不发生改变。</p><p>基于IPv4的移动IP定义三种功能实体：移动节点（mobile node）、归属代理（home agent）和外部代理（foreign agent）。归属代理和外部代理又统称为移动代理。</p><h2 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a>网络层设备</h2><h3 id="路由器的组成和功能"><a href="#路由器的组成和功能" class="headerlink" title="路由器的组成和功能"></a>路由器的组成和功能</h3><p>特点：连接异构网络，完成路由转发，隔离冲突和广播域</p><p>组成：</p><ul><li>控制部分（路由选择部分）：路由选择处理机，根据路由协议构造和维护路由表</li><li>分组转发部分：交换结构、一组输入端口、一组输出端口</li></ul><h3 id="路由表与路由转发"><a href="#路由表与路由转发" class="headerlink" title="路由表与路由转发"></a>路由表与路由转发</h3><p>路由表根据路由选择算法得出，主要用于路由选择，标准的路由表具有四个项目：目的网络IP地址、子网掩码、下一跳IP地址、接口</p><p>“转发”根据转发表把IP数据报从合适的端口转发出去，只涉及一个路由器。“路由选择”涉及很多路由器，路由表是很多路由器协同工作的结果</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;知识架构图如下:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p9fh1pach.bkt.clouddn.com/WechatIMG265.jpeg&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="读书笔记" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机网络" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="网络层" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
    
      <category term="计算机网络" scheme="blog.jiangdongyu.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Heap</title>
    <link href="blog.jiangdongyu.space/2018/06/12/Heap/"/>
    <id>blog.jiangdongyu.space/2018/06/12/Heap/</id>
    <published>2018-06-12T04:09:00.000Z</published>
    <updated>2018-06-12T08:08:29.690Z</updated>
    
    <content type="html"><![CDATA[<h3 id="272-Closest-Binary-Search-Tree-Value-II"><a href="#272-Closest-Binary-Search-Tree-Value-II" class="headerlink" title="272.Closest Binary Search Tree Value II"></a>272.Closest Binary Search Tree Value II</h3><p>Given a non-empty binary search tree and a target value, find <strong>k</strong> values in the BST that are closest to the target.</p><p><strong>Note:</strong></p><p>Given target value is a floating point. You may assume k is always valid, that is: k ≤ total nodes. You are guaranteed to have only one unique set of k values in the BST that are closest to the target. </p><a id="more"></a><p><strong>Follow up:</strong></p><p>Assume that the BST is balanced, could you solve it in less than O(n) runtime (where n = total nodes)?</p><p><strong>Hint:</strong></p><p>Consider implement these two helper functions: getPredecessor(N), which returns the next smaller node to N. getSuccessor(N), which returns the next larger node to N.</p><ul><li>中序遍历法<ul><li>二叉搜索树的中序遍历就是顺序输出二叉搜索树</li><li>中序遍历二叉搜索树，同时维护一个大小为K的队列</li><li>前K个数直接加入队列</li><li>之后每来一个新的数（较大的数），如果该数和目标的差，相比于队头的数离目标的差来说，更小，则将队头拿出来，将新数加入队列</li><li>更大，则直接退出并返回这个队列</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">closestKValues</span><span class="params">(TreeNode root, <span class="keyword">double</span> target, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; klist = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stk = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="comment">// 迭代中序遍历二叉搜索树的代码</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stk.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stk.isEmpty())&#123;</span><br><span class="line">            TreeNode curr = stk.pop();</span><br><span class="line">            <span class="comment">// 维护一个大小为k的队列</span></span><br><span class="line">            <span class="comment">// 队列不到k时直接加入</span></span><br><span class="line">            <span class="keyword">if</span>(klist.size() &lt; k)&#123;</span><br><span class="line">                klist.offer(curr.val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 队列到k时，判断下新的数是否更近，更近就加入队列并去掉队头</span></span><br><span class="line">                <span class="keyword">int</span> first = klist.peek();</span><br><span class="line">                <span class="keyword">if</span>(Math.abs(first - target) &gt; Math.abs(curr.val - target))&#123;</span><br><span class="line">                    klist.poll();</span><br><span class="line">                    klist.offer(curr.val);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果不是更近则直接退出，后面的数只会更大</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 中序遍历的代码</span></span><br><span class="line">            <span class="keyword">if</span>(curr.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                curr = curr.right;</span><br><span class="line">                <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    stk.push(curr);</span><br><span class="line">                    curr = curr.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 强制转换成List，是用LinkedList实现的所以可以转换</span></span><br><span class="line">        <span class="keyword">return</span> (List&lt;Integer&gt;)klist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>相似的题：<br>270.Closest Binary Search Tree Value</strong></p><p>Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target.</p><p><strong>Note:</strong></p><p>Given target value is a floating point. You are guaranteed to have only one unique value in the BST that is closest to the target.</p><ul><li>递归<ul><li>当遍历到某个根节点时，最近的那个节点要么是在子树里面，要么就是根节点本身</li><li>根据这个递归，返回子树中最近的节点，和根节点中更近的那个</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">closestValue</span><span class="params">(TreeNode root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 选出子树的根节点</span></span><br><span class="line">        TreeNode kid = target &lt; root.val ? root.left : root.right;</span><br><span class="line">        <span class="comment">// 如果没有子树，也就是递归到底时，直接返回当前节点值</span></span><br><span class="line">        <span class="keyword">if</span>(kid == <span class="keyword">null</span>) <span class="keyword">return</span> root.val;</span><br><span class="line">        <span class="comment">// 找出子树中最近的那个节点</span></span><br><span class="line">        <span class="keyword">int</span> closest = closestValue(kid, target);</span><br><span class="line">        <span class="comment">// 返回根节点和子树最近节点中，更近的那个节点</span></span><br><span class="line">        <span class="keyword">return</span> Math.abs(root.val - target) &lt; Math.abs(closest - target) ? root.val : closest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>迭代<ul><li>记录一个最近的值，然后沿着二叉搜索的路径一路比较下去，并更新这个最近值</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">closestValue</span><span class="params">(TreeNode root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> closest = root.val;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果该节点的离目标更近，则更新到目前为止的最近值</span></span><br><span class="line">            closest = Math.abs(closest - target) &lt; Math.abs(root.val - target) ? closest : root.val;</span><br><span class="line">            <span class="comment">// 二叉搜索</span></span><br><span class="line">            root = target &lt; root.val ? root.left : root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> closest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="239-Sliding-Window-Maximum"><a href="#239-Sliding-Window-Maximum" class="headerlink" title="239.Sliding Window Maximum"></a>239.Sliding Window Maximum</h3><p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.</p><p><strong>Example:</strong></p><pre><code>Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3Output: [3,3,5,5,6,7] Explanation: Window position                Max---------------               -----[1  3  -1] -3  5  3  6  7       3 1 [3  -1  -3] 5  3  6  7       3 1  3 [-1  -3  5] 3  6  7       5 1  3  -1 [-3  5  3] 6  7       5 1  3  -1  -3 [5  3  6] 7       6 1  3  -1  -3  5 [3  6  7]      7</code></pre><p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ input array’s size for non-empty array.</p><p><strong>Follow up:</strong><br>Could you solve it in linear time?</p><p><strong>思路与代码</strong></p><p>就看题目中的例子，[1 3 -1] -3 5 3 6 7，我们知道这个窗口中的最大值为3。我们同时也可以确定，3之前的数字无需加入后面大小的比较，因为它们一定比3小。</p><p>按照这种规则，我们可以维护一个存储了可比较数字的链表。这个链表中的数字可以和当前准备加入链表的值进行比较。那么我们看一下将一个值加入该链表有什么场景：</p><ul><li>链表为空，直接加入</li><li>链表的数量大于窗口，则删除最左侧的值</li><li>链表中有值，且有些值小于即将加入的值，则这些小于的值都被抛弃</li><li>链表中的值均大于即将加入的值，则不进行任何操作</li></ul><p><strong>代码</strong>： 可以用deque</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;nums.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(list.size() != <span class="number">0</span> &amp;&amp; list.getFirst() &lt; i-k+<span class="number">1</span>)&#123;</span><br><span class="line">            list.remove(<span class="number">0</span>);<span class="comment">//deq.poll()</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(list.size()!=<span class="number">0</span> &amp;&amp; nums[list.getLast()] &lt; nums[i])&#123;</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);<span class="comment">//deq.pollLast()</span></span><br><span class="line">        &#125;</span><br><span class="line">        list.addLast(i);</span><br><span class="line">        <span class="keyword">if</span>(i - k + <span class="number">1</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            result[i-k+<span class="number">1</span>] = nums[list.getFirst()];<span class="comment">//deq.peek()</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="480-Sliding-Window-Median"><a href="#480-Sliding-Window-Median" class="headerlink" title="480.Sliding Window Median"></a>480.Sliding Window Median</h3><blockquote><p>与上一题不同的是这次找的是中位数</p></blockquote><p>For example,<br>Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.</p><pre><code>Window position                Median---------------               -----[1  3  -1] -3  5  3  6  7       1 1 [3  -1  -3] 5  3  6  7       -1 1  3 [-1  -3  5] 3  6  7       -1 1  3  -1 [-3  5  3] 6  7       3 1  3  -1  -3 [5  3  6] 7       5 1  3  -1  -3  5 [3  6  7]      6</code></pre><p>Therefore, return the median sliding window as [1,-1,-1,3,5,6].</p><ul><li>minHeap和maxHeap，maxHeap在保存较小的一半元素，minHeap保存较大的一半元素</li><li>然后调整最大堆和最小堆的大小。根据k值可以分两种情况讨论：<ul><li>若k为偶数，则需要最大堆中元素和最小堆中元素数量相等</li><li>若k为奇数，此时最小堆的堆顶元素即为此时窗口元素的median</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;Integer&gt; minHeap;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; maxHeap;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] medianSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">double</span>[] result = <span class="keyword">new</span> <span class="keyword">double</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k/<span class="number">2</span> + <span class="number">1</span>, (a, b) -&gt; b.compareTo(a));</span><br><span class="line">        minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k/<span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// delete the element beyond the window</span></span><br><span class="line">            <span class="keyword">if</span>(maxHeap.size() + minHeap.size() == k) slide(nums[i - k]);</span><br><span class="line">            <span class="comment">// add new element to the window</span></span><br><span class="line">            add(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                result[i - k + <span class="number">1</span>] = getMedian();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">slide</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(minHeap.contains(target)) minHeap.remove(target);</span><br><span class="line">        <span class="keyword">else</span> maxHeap.remove(target);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        maxHeap.add(num);</span><br><span class="line">        minHeap.add(maxHeap.poll());</span><br><span class="line">        <span class="keyword">if</span>(maxHeap.size() + <span class="number">1</span> &lt; minHeap.size()) maxHeap.add(minHeap.poll());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// window size is even</span></span><br><span class="line">        <span class="keyword">if</span>(minHeap.size() == maxHeap.size()) <span class="keyword">return</span> minHeap.peek()/<span class="number">2.0</span> + maxHeap.peek()/<span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;272-Closest-Binary-Search-Tree-Value-II&quot;&gt;&lt;a href=&quot;#272-Closest-Binary-Search-Tree-Value-II&quot; class=&quot;headerlink&quot; title=&quot;272.Closest Binary Search Tree Value II&quot;&gt;&lt;/a&gt;272.Closest Binary Search Tree Value II&lt;/h3&gt;&lt;p&gt;Given a non-empty binary search tree and a target value, find &lt;strong&gt;k&lt;/strong&gt; values in the BST that are closest to the target.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given target value is a floating point. You may assume k is always valid, that is: k ≤ total nodes. You are guaranteed to have only one unique set of k values in the BST that are closest to the target. &lt;/p&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode Category" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/LeetCode-Category/"/>
    
    
      <category term="Heap" scheme="blog.jiangdongyu.space/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>HashTable</title>
    <link href="blog.jiangdongyu.space/2018/06/09/HashTable/"/>
    <id>blog.jiangdongyu.space/2018/06/09/HashTable/</id>
    <published>2018-06-09T02:38:00.000Z</published>
    <updated>2018-06-12T08:11:45.424Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><h3 id="217-Contains-Duplicate"><a href="#217-Contains-Duplicate" class="headerlink" title="217.Contains Duplicate"></a>217.Contains Duplicate</h3><p>Given an array of integers, find if the array contains any duplicates.</p><p>Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p><a id="more"></a><p><strong>Example 1:</strong></p><pre><code>Input: [1,2,3,1]Output: true</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: [1,2,3,4]Output: false</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: [1,1,1,3,3,4,3,2,4,2]Output: true</code></pre><ul><li>直接使用hashset</li><li>排序，对相邻的做比较</li></ul><h3 id="219-Contains-Duplicate-II"><a href="#219-Contains-Duplicate-II" class="headerlink" title="219.Contains Duplicate II"></a>219.Contains Duplicate II</h3><blockquote><p>判断数组是否存在i,j位置相同的数，同时j-i &lt;= k</p></blockquote><ul><li>hashmap<ul><li>key: nums[i], value: i</li><li>判断是否存在key,，存在则接着比较index</li><li>无论存在与否，都需要put，相同key被覆盖</li></ul></li><li>hashset<ul><li>i&gt;k则删除nums[i-k-1]</li><li>判断!set.add(nums[i])</li></ul></li></ul><h3 id="220-Contains-Duplicate-III"><a href="#220-Contains-Duplicate-III" class="headerlink" title="220.Contains Duplicate III"></a>220.Contains Duplicate III</h3><blockquote><p>判断数组是否存在i,j位置，num[j]-nums[i] &lt;= t，同时j-i &lt;= k</p></blockquote><p>类似sliding window,移动的时候增加和减少element，但对每一个value,需要考察[value-t,value+t]，时间复杂度太高…</p><ul><li>利用Bucket Sort<ul><li>构建一个大小为t+1的bucket, 比如[0, 1, 2, 3, … , t], 最大绝对值差的两个数就是t和0. </li><li>如果两个数字出现在同一个Bucket内，说明我们已经找到了。 如果不是，则在相邻的两个bucket内再找。</li><li>如果相邻的bucket内元素绝对值只差在t以内，说明我们知道到了，返回true.</li><li>为了保证j - i &lt;= k，我们在i&gt;=k时，删除 nums[i-k]对应的Bucket.</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( k &lt; <span class="number">1</span> || t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map&lt;Long, Long&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">// [-t, 0] [0, t] 的元素都会落在bucket[0]里。</span></span><br><span class="line">            <span class="comment">// 为了解决这个问题，所有元素横移Integer.MIN_VALUE。</span></span><br><span class="line">            <span class="keyword">long</span> remappedNum = (<span class="keyword">long</span>) nums[i] - Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">long</span> bucket = remappedNum / ((<span class="keyword">long</span>)t + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(bucket) </span><br><span class="line">                ||(map.containsKey(bucket-<span class="number">1</span>) &amp;&amp; remappedNum - map.get(bucket-<span class="number">1</span>) &lt;= t)</span><br><span class="line">                    || (map.containsKey(bucket+<span class="number">1</span>) &amp;&amp; map.get(bucket+<span class="number">1</span>) - remappedNum &lt;= t) )</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastBucket = ((<span class="keyword">long</span>) nums[i-k] - Integer.MIN_VALUE) / ((<span class="keyword">long</span>)t + <span class="number">1</span>);</span><br><span class="line">                map.remove(lastBucket);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(bucket,remappedNum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用treeset</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( k &lt; <span class="number">1</span> || t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        TreeSet&lt;Long&gt; tree = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//floor() 小于等于</span></span><br><span class="line">            Long floor = tree.floor((<span class="keyword">long</span>)nums[i] + t);</span><br><span class="line">            <span class="comment">//ceiling() 大于等于</span></span><br><span class="line">            Long ceil = tree.ceiling((<span class="keyword">long</span>)nums[i] - t);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>((floor != <span class="keyword">null</span> &amp;&amp; floor &gt;= nums[i])</span><br><span class="line">                || (ceil != <span class="keyword">null</span> &amp;&amp; ceil &lt;= nums[i]) )</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">            tree.add((<span class="keyword">long</span>)nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k)&#123;</span><br><span class="line">                tree.remove((<span class="keyword">long</span>)nums[i-k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="243-Shortest-Word-Distance"><a href="#243-Shortest-Word-Distance" class="headerlink" title="243.Shortest Word Distance"></a>243.Shortest Word Distance</h3><p>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p><p>For example, Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”].</p><p>Given word1 = “coding”, word2 = “practice”, return 3. Given word1 = “makes”, word2 = “coding”, return 1.</p><p>Note: You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.</p><ul><li>双指针法 <ul><li>分别记录word1和word2的位置</li><li>更新distance</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(String[] words, String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ind1 = -<span class="number">1</span>, ind2 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> distance = Integer.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; words.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(words[i].equals(word1))&#123;</span><br><span class="line">                ind1 = i;</span><br><span class="line">                <span class="keyword">if</span>(ind2 != -<span class="number">1</span>) distance = Math.min(distance, ind1 - ind2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(words[i].equals(word2))&#123;</span><br><span class="line">                ind2 = i;</span><br><span class="line">                <span class="keyword">if</span>(ind1 != -<span class="number">1</span>) distance = Math.min(distance, ind2 - ind1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="244-Shortest-Word-Distance-II"><a href="#244-Shortest-Word-Distance-II" class="headerlink" title="244.Shortest Word Distance II"></a>244.Shortest Word Distance II</h3><p>This is a follow up of Shortest Word Distance. The only difference is now you are given the list of words and your method <strong>will be called repeatedly many times</strong> with different parameters. How would you optimize it?</p><p>Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list.</p><ul><li>多次call, 那就需要记录下所有的word的下标</li><li>同时，一个word可能出现多次，应该是个list</li><li>比较的时候，类似merge two sorted list的做法, 先比较最小的，然后把较小的去掉，接着比较</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordDistance</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    HashMap&lt;String, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String, List&lt;Integer&gt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordDistance</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 统计每个单词出现的下标存入哈希表中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">            List&lt;Integer&gt; cnt = map.get(words[i]);</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="keyword">null</span>)&#123;</span><br><span class="line">                cnt = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            cnt.add(i);</span><br><span class="line">            map.put(words[i], cnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortest</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; idx1 = map.get(word1);</span><br><span class="line">        List&lt;Integer&gt; idx2 = map.get(word2);</span><br><span class="line">        <span class="keyword">int</span> distance = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 每次比较两个下标列表最小的下标，然后把跳过较小的那个</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; idx1.size() &amp;&amp; j &lt; idx2.size())&#123;</span><br><span class="line">            distance = Math.min(Math.abs(idx1.get(i) - idx2.get(j)), distance);</span><br><span class="line">            <span class="keyword">if</span>(idx1.get(i) &lt; idx2.get(j))&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="245-Shortest-Word-Distance-III"><a href="#245-Shortest-Word-Distance-III" class="headerlink" title="245.Shortest Word Distance III"></a>245.Shortest Word Distance III</h3><p>This is a follow up of Shortest Word Distance. The only difference is now word1 <strong>could be the same</strong> as word2.</p><p>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p><p>word1 and word2 may be the same and they represent <strong>two individual words</strong> in the list.</p><p>For example, Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”].</p><p>Given word1 = “makes”, word2 = “coding”, return 1. Given word1 = “makes”, word2 = “makes”, return 3.</p><p>Note: You may assume word1 and word2 are both in the list.</p><ul><li>和I相似，区别就在于两个词可能相同</li><li>需要区分第一次遇到和第二次遇到这个词。加入一个turns，如果是相同单词的话，每次遇到一个单词turn加1，这样可以根据turn来判断是否要switch</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(String[] words, String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ind1 = -<span class="number">1</span>, ind2 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> distance = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> turns = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> inc = word1.equals(word2) ? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; words.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(words[i].equals(word1) &amp;&amp; turns % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                ind1 = i;</span><br><span class="line">                <span class="keyword">if</span>(ind2 != -<span class="number">1</span>) distance = Math.min(distance, ind1 - ind2);</span><br><span class="line">                turns += inc;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(words[i].equals(word2))&#123;</span><br><span class="line">                ind2 = i;</span><br><span class="line">                <span class="keyword">if</span>(ind1 != -<span class="number">1</span>) distance = Math.min(distance, ind2 - ind1);</span><br><span class="line">                turns += inc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><h3 id="202-Happy-Number"><a href="#202-Happy-Number" class="headerlink" title="202.Happy Number"></a>202.Happy Number</h3><p>Write an algorithm to determine if a number is “happy”.</p><p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p><p><strong>Example:</strong></p><pre><code>Input: 19Output: trueExplanation: 1^2 + 9^2 = 828^2 + 2^2 = 686^2 + 8^2 = 1001^2 + 0^2 + 0^2 = 1</code></pre><ul><li>用set记录在计算过程中出现的值</li><li>如果再次出现，说明不行</li><li>否则一直计算直到结果为1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(set.add(n))&#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> digit = n%<span class="number">10</span>;</span><br><span class="line">                res += digit * digit;</span><br><span class="line">                n /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(res == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                n = res;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="3-Longest-Substring-without-repeat-characters"><a href="#3-Longest-Substring-without-repeat-characters" class="headerlink" title="3.Longest Substring without repeat characters"></a>3.Longest Substring without repeat characters</h3><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><p><strong>Examples:</strong></p><p>Given “abcabcbb”, the answer is “abc”, which the length is 3.</p><p>Given “bbbbb”, the answer is “b”, with the length of 1.</p><p>Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p><ul><li>sliding window + set解法<ul><li>两个指针p1,p2，p1是window的左边界，p2是右边界</li><li>左边界不动时，右边界尽可能往右扩展，直到不能满足条件</li><li>左边界移动，删除set中左边的元素</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt; length)&#123;</span><br><span class="line">            <span class="keyword">while</span>(p2 &lt; length &amp;&amp; set.add(s.substring(p2, p2+<span class="number">1</span>)))&#123;</span><br><span class="line">                max = Math.max(max, p2-p1+<span class="number">1</span>);</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">            set.remove(s.substring(p1, p1+<span class="number">1</span>));</span><br><span class="line">            p1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="159-Longest-Substring-with-at-most-Two-Distinct-Characters"><a href="#159-Longest-Substring-with-at-most-Two-Distinct-Characters" class="headerlink" title="159.Longest Substring with at most Two Distinct Characters"></a>159.Longest Substring with at most Two Distinct Characters</h3><p>Given a string, find the length of the longest substring T that contains at most 2 distinct characters.</p><p>For example, Given s = “eceba”,</p><p>T is “ece” which its length is 3.</p><ul><li>两个指针，一个map来记录字符及其出现次数。</li><li>一个右指针先移动，不断更新map, </li><li>当发现map里的字符个数大于规定个数的时候，开始移动左指针，同时更新map,</li><li>直到map里的字符个数等于规定个数，</li><li>中间不断更新包含规定字符个数的最大长度。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length()) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 根据右指针指的当前字符更新map</span></span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(c)) &#123;</span><br><span class="line">                map.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(c, map.get(c) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 移动左指针，直到map中字符数量降至规定数量</span></span><br><span class="line">            <span class="keyword">while</span> (map.size() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">char</span> leftChar = s.charAt(left);</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(leftChar)) &#123;</span><br><span class="line">                </span><br><span class="line">                    <span class="comment">// 注意会有重复元素，所以先减小次数，只有次数降至0，才删除元素</span></span><br><span class="line">                    map.put(leftChar, map.get(leftChar) - <span class="number">1</span>);                     </span><br><span class="line">                    <span class="keyword">if</span> (map.get(leftChar) == <span class="number">0</span>) &#123; </span><br><span class="line">                        map.remove(leftChar);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;               </span><br><span class="line">            maxLen = Math.max(maxLen, i - left + <span class="number">1</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Follow up</strong>: 340.Longest Substring with at most k Distinct Characters</p><blockquote><p>最多允许k个字符</p></blockquote><p>上面的代码直接把2改成k即可。</p><h3 id="76-Minimum-Window-Substring"><a href="#76-Minimum-Window-Substring" class="headerlink" title="76.Minimum Window Substring"></a>76.Minimum Window Substring</h3><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p><p><strong>Example:</strong></p><pre><code>Input: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;Output: &quot;BANC&quot;</code></pre><p><strong>Note:</strong></p><ul><li>If there is no such window in S that covers all characters in T, return the empty string “”.</li><li><p>If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</p></li><li><p>类似于Longest Substring with At Most Two Distinct Characters。</p></li><li>此类window题型，我们都需要用<strong>两个指针</strong>，用<strong>一个map</strong>记录字符及其出现次数，</li><li>不同的是由于这里题目要求是覆盖字符串T中所有字符，所以我们需要用一个变量如<strong>count</strong>来记录window中覆盖字符串T中有效字符的个数。</li><li>只要count == T.length(), 便可更新window的最短长度。</li><li>同时，我们必须移动左指针，直到window中包含的字符个数小于规定的数量，我们才开始移动右指针。另外要注意何时更新count的值。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 建map, 记录被包含字符串中字符及其个数</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = t.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(c)) &#123;</span><br><span class="line">                map.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(c, map.get(c) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minStart = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minLen = s.length() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.get(c) &gt; <span class="number">0</span>)  </span><br><span class="line">                    count++; <span class="comment">// 注意count++的条件</span></span><br><span class="line">                map.put(c, map.get(c) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (count == t.length()) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 不断更新最值</span></span><br><span class="line">                <span class="keyword">if</span> (i - l + <span class="number">1</span> &lt; minLen) &#123;</span><br><span class="line">                    minLen = i - l + <span class="number">1</span>;</span><br><span class="line">                    minStart = l;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 移动左指针</span></span><br><span class="line">                <span class="keyword">char</span> leftChar = s.charAt(l);</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(leftChar)) &#123;</span><br><span class="line">                    map.put(leftChar, map.get(leftChar) + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (map.get(leftChar) &gt; <span class="number">0</span>) &#123; </span><br><span class="line">                        count--; <span class="comment">// 注意count--条件</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (minLen == s.length() + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(minStart, minLen + minStart);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="30-Substring-with-Concatenation-of-All-Words"><a href="#30-Substring-with-Concatenation-of-All-Words" class="headerlink" title="30.Substring with Concatenation of All Words"></a>30.Substring with Concatenation of All Words</h3><p>You are given a string, <strong>s</strong>, and a list of words, <strong>words</strong>, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.</p><p><strong>Example 1:</strong></p><pre><code>Input:  s = &quot;barfoothefoobarman&quot;,  words = [&quot;foo&quot;,&quot;bar&quot;]Output: [0,9]Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively.The output order does not matter, returning [9,0] is fine too.</code></pre><p><strong>Example 2:</strong></p><pre><code>Input:  s = &quot;wordgoodstudentgoodword&quot;,  words = [&quot;word&quot;,&quot;student&quot;]Output: []</code></pre><blockquote><p>输入一个字符串s和一个字符串数组words，其中words中的每个word的长度都相等。在字符串中找到所有子字符串的起始下标，只要该子字符串满足words中所有单词的连接结果（顺序无关）</p></blockquote><ul><li>把每个词当作一个字母来看待，但是要遍历K次，K是单词的长度，因为我们要分别统计从下标0开头，从下标1开头。。。直到下标K-1开头的字符串。</li><li>通过哈希表维护一个窗口，比如foo|bar|foo中，我们先拿出foo。如果foo都不在数组中，那说明根本不能拼进去，则哈希表全部清零，从下一个词开始重新匹配。</li><li>但是foo是在数组中的，所以给当前搜索的哈希表计数器加上1，如果发现当前搜索中foo出现的次数已经比给定数组中foo出现的次数多了，我们就要把上一次出现foo之前的所有词都从窗口中去掉</li><li>如果没有更多，则看下一个词bar，不过在这之前，我们还要看看窗口中有多少个词了，如果词的个数等于数组中词的个数，说明我们找到了一个结果。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(words == <span class="keyword">null</span> || words.length == <span class="number">0</span> || s == <span class="keyword">null</span> || s.equals(<span class="string">""</span>)) <span class="keyword">return</span> res;</span><br><span class="line">        HashMap&lt;String, Integer&gt; freq = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">        <span class="comment">// 统计数组中每个词出现的次数，放入哈希表中待用</span></span><br><span class="line">        <span class="keyword">for</span>(String word : words)&#123;</span><br><span class="line">            freq.put(word, freq.containsKey(word) ? freq.get(word) + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到每个词的长度</span></span><br><span class="line">        <span class="keyword">int</span> len = words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="comment">// 错开位来统计</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="comment">// 建一个新的哈希表，记录本轮搜索中窗口内单词出现次数</span></span><br><span class="line">            HashMap&lt;String, Integer&gt; currFreq = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">            <span class="comment">// start是窗口的开始，count表明窗口内有多少词</span></span><br><span class="line">            <span class="keyword">int</span> start = i, count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= s.length() - len; j += len)&#123;</span><br><span class="line">                String sub = s.substring(j, j + len);</span><br><span class="line">                <span class="comment">// 看下一个词是否是给定数组中的</span></span><br><span class="line">                <span class="keyword">if</span>(freq.containsKey(sub))&#123;</span><br><span class="line">                    <span class="comment">// 窗口中单词出现次数加1</span></span><br><span class="line">                    currFreq.put(sub, currFreq.containsKey(sub) ? currFreq.get(sub) + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="comment">// 如果该单词出现次数已经超过给定数组中的次数了，说明多来了一个该单词，所以要把窗口中该单词上次出现的位置及之前所有单词给去掉</span></span><br><span class="line">                    <span class="keyword">while</span>(currFreq.get(sub) &gt; freq.get(sub))&#123;</span><br><span class="line">                        String leftMost = s.substring(start, start + len);</span><br><span class="line">                        currFreq.put(leftMost, currFreq.get(leftMost) - <span class="number">1</span>);</span><br><span class="line">                        start = start + len;</span><br><span class="line">                        count--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果窗口内单词数和总单词数一样，则找到结果</span></span><br><span class="line">                    <span class="keyword">if</span>(count == words.length)&#123;</span><br><span class="line">                        String leftMost = s.substring(start, start + len);</span><br><span class="line">                        currFreq.put(leftMost, currFreq.get(leftMost) - <span class="number">1</span>);</span><br><span class="line">                        res.add(start);</span><br><span class="line">                        start = start + len;</span><br><span class="line">                        count--;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="comment">// 如果截出来的单词都不在数组中，前功尽弃，重新开始</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    currFreq.clear();</span><br><span class="line">                    start = j + len;</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="249-Group-Shift-Strings"><a href="#249-Group-Shift-Strings" class="headerlink" title="249.Group Shift Strings"></a>249.Group Shift Strings</h3><p>Given a string, we can “shift” each of its letter to its successive letter, for example: “abc” -&gt; “bcd”. We can keep “shifting” which forms the sequence:</p><pre><code>&quot;abc&quot; -&gt; &quot;bcd&quot; -&gt; ... -&gt; &quot;xyz&quot;</code></pre><p>Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence.</p><p>For example, given: [“abc”, “bcd”, “acef”, “xyz”, “az”, “ba”, “a”, “z”], </p><p>A solution is:</p><pre><code>[[&quot;abc&quot;,&quot;bcd&quot;,&quot;xyz&quot;],[&quot;az&quot;,&quot;ba&quot;],[&quot;acef&quot;],[&quot;a&quot;,&quot;z&quot;]]</code></pre><ul><li>同一组string, 他们的间隔是一样的</li><li>判断间隔，以间隔为key</li><li>value为相同间隔的string的list</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; groupStrings(String[] strings) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String str : strings) &#123;</span><br><span class="line">            String key = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> offset = str.charAt(i) - str.charAt(i - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//在为负数的时候，当经过z, a的时候，数值大小会很大得反转</span></span><br><span class="line">                key += offset &lt; <span class="number">0</span> ? offset + <span class="number">26</span> : offset;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(key)) map.put(key, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">            map.get(key).add(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; list : map.values()) &#123;</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="288-Unique-Word-Abbreviation"><a href="#288-Unique-Word-Abbreviation" class="headerlink" title="288.Unique Word Abbreviation"></a>288.Unique Word Abbreviation</h3><p>An abbreviation of a word follows the form <first letter=""><number><last letter="">. Below are some examples of word abbreviations:</last></number></first></p><pre><code>a) it                      --&gt; it    (no abbreviation)     1b) d|o|g                   --&gt; d1g              1    1  1     1---5----0----5--8c) i|nternationalizatio|n  --&gt; i18n              1     1---5----0d) l|ocalizatio|n          --&gt; l10n</code></pre><p>Assume you have a dictionary and given a word, find whether its abbreviation is unique in the dictionary.<br>A word abbreviation is unique if no other word from the dictionary has the same abbreviation.</p><p><strong>Example:</strong></p><pre><code>Given dictionary = [ &quot;deer&quot;, &quot;door&quot;, &quot;cake&quot;, &quot;card&quot; ]isUnique(&quot;dear&quot;) -&gt; falseisUnique(&quot;cart&quot;) -&gt; trueisUnique(&quot;cane&quot;) -&gt; falseisUnique(&quot;make&quot;) -&gt; true</code></pre><ul><li>首字母+中间str长度+尾字母</li><li>判断是否唯一</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidWordAbbr</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Set&lt;String&gt; &gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ValidWordAbbr</span><span class="params">(String[] dictionary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dictionary.length; i++) &#123;</span><br><span class="line">            String s = dictionary[i];</span><br><span class="line">            <span class="keyword">if</span>(s.length() &gt; <span class="number">2</span> ) &#123;</span><br><span class="line">                s = s.charAt(<span class="number">0</span>) + Integer.toString(s.length()-<span class="number">2</span>) + s.charAt(s.length()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s) ) &#123;</span><br><span class="line">                map.get(s).add(dictionary[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">                set.add(dictionary[i]);</span><br><span class="line">                map.put(s, set);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//input check</span></span><br><span class="line">        String s = word;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &gt; <span class="number">2</span> ) &#123;</span><br><span class="line">            s = s.charAt(<span class="number">0</span>) + Integer.toString(s.length()-<span class="number">2</span>) + s.charAt(s.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(s)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> map.get(s).contains(word) &amp;&amp; map.get(s).size()&lt;=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Array&quot;&gt;&lt;a href=&quot;#Array&quot; class=&quot;headerlink&quot; title=&quot;Array&quot;&gt;&lt;/a&gt;Array&lt;/h2&gt;&lt;h3 id=&quot;217-Contains-Duplicate&quot;&gt;&lt;a href=&quot;#217-Contains-Duplicate&quot; class=&quot;headerlink&quot; title=&quot;217.Contains Duplicate&quot;&gt;&lt;/a&gt;217.Contains Duplicate&lt;/h3&gt;&lt;p&gt;Given an array of integers, find if the array contains any duplicates.&lt;/p&gt;
&lt;p&gt;Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.&lt;/p&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode Category" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/LeetCode-Category/"/>
    
    
      <category term="Array" scheme="blog.jiangdongyu.space/tags/Array/"/>
    
      <category term="String" scheme="blog.jiangdongyu.space/tags/String/"/>
    
      <category term="HashTable" scheme="blog.jiangdongyu.space/tags/HashTable/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集器与内存分配策略</title>
    <link href="blog.jiangdongyu.space/2018/06/06/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <id>blog.jiangdongyu.space/2018/06/06/垃圾收集器与内存分配策略/</id>
    <published>2018-06-06T10:54:00.000Z</published>
    <updated>2018-07-10T09:02:16.938Z</updated>
    
    <content type="html"><![CDATA[<p><strong>垃圾回收主要是对Java堆、方法区内存的回收</strong></p><h2 id="对象已死吗"><a href="#对象已死吗" class="headerlink" title="对象已死吗"></a>对象已死吗</h2><p>堆中存放着几乎所有的对象实例，回收前，需要对对象是否存活进行确定，判断是否能进行回收</p><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><ul><li>给对象添加一个引用计数器</li><li>引用则加1</li><li>引用失效，则减1</li><li>计数器为0的对象就可以被回收</li></ul><p><strong>优点：</strong><br>实现简单，效率高<br><a id="more"></a></p><p><strong>缺点：</strong><br>Java中不用，<strong>很难解决循环引用问题</strong></p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><ul><li>“GC Roots”对象为起点，开始向下搜索</li><li>搜索走过的路径称为<strong>引用链</strong></li><li>当一个对象到“GC Roots”没有引用链相连时，该对象不可用</li></ul><p><strong>Java和C#中都是采用该算法来判定对象是否存活的。</strong></p><p>Java中，可作为GC Roots的对象如下:</p><ol><li>虚拟机栈（栈桢中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI引用的对象</li></ol><h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>强引用、软引用、弱引用、虚引用，强度依次减弱</p><ul><li>强引用，类似Object obj = new Object(), 只要强引用还在，系统不会回收</li><li>软引用，还有用但非必需的对象，会在内存不足的时候释放</li><li>弱引用，非必需对象，被弱引用关联的对象只能生存到下一次垃圾回收之前</li><li>虚应用，不能用虚引用获得一个实例对象，存在是为了在对象被回收后获得系统反馈</li></ul><h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><ul><li>可达性分析算法中不可达，也不一定是“非死不可”</li><li>真正被回收，至少要经历两次标记过程：<ul><li>进行可达性分析后没有与GC Roots相连接的引用链，第一次标记并筛选，筛选的条件是对象是否有必要执行<strong>finalize()</strong>方法（对象未覆盖finalize()方法或者该方法已经被调用过，视为“没有必要执行”）</li><li>如果判定为有必要，则该对象会被放置在F-Queue队列中，会有低优先级的线程去触发</li><li>稍后GC对F-Queue中对象进行二次标记，如果对象在finalize()方法中重新产生引用链，则被移出“即将回收”集合</li></ul></li></ul><p><strong>一个对象的finalize()方法最多只会被系统自动调用一次</strong></p><h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>方法区（HotSpot中的永久代）垃圾回收率很低。</p><p>永久代垃圾回收收集废弃常量和无用的类。</p><ul><li>回收常量：没有引用即可</li><li>回收类，无用的类的判定：<ul><li>类的所有实例被回收，Java堆中不存在该类的任何实例</li><li>加载该类的ClassLoader被回收</li><li>该类对应的java.lang.Class对象没有被引用，无法通过反射访问该类的方法</li></ul></li><li>虚拟机<strong>可以</strong>对符合上述条件的类回收</li><li>是否对类回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息</li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>标记需要回收对象，统一回收，不作处理</p><p><strong>优点：</strong><br>不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效。</p><p><strong>缺点：</strong></p><ul><li>标记和清除过程的效率都不高（这种方法需要使用一个空闲列表来记录所有的空闲区域以及大小。对空闲列表的管理会增加分配对象时的工作量）</li><li>标记清除后会产生大量不连续的内存碎片。虽然空闲区域的大小是足够的，但是可能没有足够大的连续空间。</li></ul><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><ul><li>内存等量分为两块，每次只使用一块</li><li>当一块用完时，将存活对象复制到另一块上</li><li>把再把已使用过的内存空间一次清理掉</li></ul><p><strong>复制算法比较适合于新生代（短生存期的对象），在老年代（长生存期的对象）中，对象存活率比较高，如果执行较多的复制操作，效率将会变低，所以老年代一般会选用其他算法，如标记—整理算法。</strong></p><p><strong>优点：</strong></p><ul><li>标记阶段和复制阶段可以同时进行。</li><li>每次只对一块内存进行回收，运行高效。</li><li>只需移动栈顶指针，按顺序分配内存即可，实现简单。</li><li>内存回收时不用考虑内存碎片的出现（得活动对象所占的内存空间之间没有空闲间隔）。</li></ul><p><strong>缺点：</strong><br>需要一块能容纳下所有存活对象的额外的内存空间。因此，可一次性分配的最大内存缩小了一半。</p><p>HotSpot虚拟机默认Eden和Survivor的大小比例是8:1, 当Survivor内存不够时，需要依赖其他内存（老年代）进行分配担保。</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>将所有对象内存向一端移动，清除端外的。</p><p><strong>优点：</strong></p><ul><li>经过整理之后，新对象的分配只需要通过指针碰撞便能完成（Pointer Bumping），相当简单。</li><li>使用这种方法空闲区域的位置是始终可知的，也不会再有碎片的问题了。</li></ul><p><strong>缺点：</strong><br>GC暂停的时间会增长，因为你需要将所有的对象都拷贝到一个新的地方，还得更新它们的引用地址。</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>新生代：复制<br>老年代：标记-清除、标记-整理算法</p><h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><p>GC Roots找引用链，需要消耗很多时间</p><p>GC停顿需要在保持<strong>一致性</strong>的快照中进行（分析期间，对象引用关系不变），GC停顿指GC进行时停顿所有Java执行线程。</p><p>使用准确式GC，直接得知哪些地方存放着对象引用。HotSpot使用OopMap来达到这一目的，在类加载完成时，HotSpot把对象内什么偏移量时什么类型数据计算出来，在JIT编译过程中，在<strong>安全点</strong>记录下栈和寄存器中哪些位置是引用。</p><p>程序执行时在安全点才会停下来GC，安全点的选定是以程序“是否具有让程序长时间执行的特征”为标准进行选定的，“长时间执行”最明显的特征是<strong>指令序列复用</strong>，例如方法调用、循环跳转、异常跳转等。</p><p>GC发生时有两种方案让所有线程都“跑”到最近的安全点才停顿下来：</p><ul><li>抢先式中断(几乎不用)：GC发生时，把线程全部中断，如果线程不在安全点，就恢复，让它“跑”在安全点上</li><li>主动式中断：设置标志，线程去轮询，标志为真时就中断挂起。轮询标志和安全点是重合的，另外再加上创建对象需要分配内存的地方。</li></ul><p>安全点保证了<strong>程序运行时</strong>，能在不太长时间内遇到可进入GC的安全点。但程序“不执行”、<strong>没有分配CPU时</strong>，比如线程处于sleep或blocked时，就需要<strong>安全区域</strong>。</p><p>执行到Safe Region中的代码时，首先标识进入了Safe Region，线程要离开Safe Region时，检查系统是否已经完成根节点枚举（or整个GC过程）,如果完成，线程继续执行，否则必须等待知道收到可以离开的信号。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>讨论的收集器基于JDK    1.7 Update 14之后的HotSpot虚拟机，虚拟机包含的所有收集器如下图：</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG253.jpeg" alt="avatar"></p><p>如果两个收集器之前存在连线，则说明可以搭配使用。虚拟机所处的区域，表示它属于新生代还是老年代。</p><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>单线程收集器，只使用一个CPU或一条收集线程去完成垃圾收集工作，收集时，<strong>暂停其他所有工作线程</strong>，直至收集结束。</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG254.jpeg" alt="avatar"></p><p><strong>优点：</strong><br>简单而高效（与其他收集器的单线程比）</p><p><strong>缺点：</strong><br>Stop The World，其它工作线程在用户不可见时全部停掉</p><p><strong>使用场景：</strong><br>运行在Client模式下的虚拟机</p><h3 id="ParNew收集器（并行）"><a href="#ParNew收集器（并行）" class="headerlink" title="ParNew收集器（并行）"></a>ParNew收集器（并行）</h3><p>Serial收集器的多线程版本，进行垃圾收集时也会停止工作线程</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG255.jpeg" alt="avatar"></p><p>是许多运行在Server模式下的虚拟机中首选的新生代收集器，很大原因在于，只有Serial收集器和ParNew收集器能与CMS收集器配合工作</p><p><strong>注意</strong></p><ul><li><p>并行（parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；</p></li><li><p>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。</p></li></ul><h3 id="Parallel-Scavenge收集器（并行）"><a href="#Parallel-Scavenge收集器（并行）" class="headerlink" title="Parallel Scavenge收集器（并行）"></a>Parallel Scavenge收集器（并行）</h3><p>新生代收集器、使用复制算法、并行的多线程收集器</p><p>不能与CMS收集器配合使用，目标达到一个<strong>可控制的吞吐量</strong>（Throughput）。吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间)</p><p>停顿时间越短越适合需要与用户交互的程序，良好的响应时间速度能提升用户体验，而高吞吐量可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>控制最大垃圾收集停顿时间：-XX:MaxGCPauseMillis，直接设置吞吐量大小参数：-XX: GCTimeRatio（0-100）。</p><p>-XX：+UseAdaptiveSizePlicvy，开关参数，当参数打开之后，就不需要手工指定新生代大小-Xmn、Eden与Survivor区的比例-XX:SurviviorRatio、晋升到老年代对象年龄-XX:PretenureSizeThreshold等细节参数了，虚拟机会根据当前系统运行情况收集性能监控信息，动态调整这些参数以提供合适的停顿时间或者最大吞吐量，这种调节方式称为<strong>GC自适应的调节策略</strong>（GC Ergonomics）。</p><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial收集器老年代版本，也是用于给Client模式下的虚拟机使用</p><p>在Server模式下，两大用途：</p><ul><li>在JDK1.5及以上，与Parallel Scavenge收集器搭配使用（Parallel Scavenge收集器架构中本身有PS MarkSweep收集器进行老年代的收集，并非直接使用Serial Old，但Serial Old与PS MarkSweep实现非常接近）</li><li>作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用</li></ul><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Scavenge老年代版本，使用多线程和“标记-整理”算法</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG259.jpeg" alt="avatar"></p><p><strong>使用场景：</strong><br>注重高吞吐量以及CPU资源敏感的场合，可以考虑Parallel Scavenge加Parallel Old</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上。基于“标记-清除”算法实现。</p><ul><li>初始标记：Stop the World，只是标记一下GC Roots能直接关联到的对象，用户进程停顿</li><li>并发标记：进行GC Roots Tracing（追踪）的过程，并发用户进程</li><li>重新标记：Stop the World，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，用户进程停顿</li><li>并发删除：并发用户进程</li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG260.jpeg" alt="avatar"></p><p><strong>优点：</strong><br>并发收集、低停顿</p><p><strong>缺点：</strong></p><ul><li>对CPU资源敏感，并发阶段，占用线程（CPU资源）导致应用程序变慢，总吞吐量降低</li><li>无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。“浮动垃圾”指在并发清理过程中用户进程仍在运行，自然会产生垃圾，这部分垃圾出现在标记过程之后，CMS无法当次集中处理，只好留到下一次GC.</li><li>基于“标记-清除”算法，空间碎片过多，但无法找到足够大的连续空间用以分配，触发Full GC</li></ul><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>面向服务端的垃圾收集器</p><p><strong>特点：</strong></p><ul><li>并行与并发：缩短Stop the World停顿时间</li><li>分代收集：采用不同方式处理新对象和存活一段时间的对象</li><li>空间整合：与CMS的标记-清理算法不同，整体基于标记-整理算法，从局部（两个Region之间）基于复制算法。不会产生空间碎片。</li><li>可预测的停顿，之所以能做到，是因为能有计划避免在整个堆中进行全区域的垃圾收集</li></ul><p>将堆划分为等大小的独立区域（Region），跟踪各个Region里垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p><p>使用Remembered Set避免全堆扫描，处于不同的Region，则记录到被引用对象的Region中，在GC根节点枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</p><p>不计算维护Remembered Set操作，大致分为以下步骤：</p><ul><li>初始标记：标记一下GC Roots能直接关联到的对象，并修改TAMS(Next Top at Mark Start)的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，<strong>停顿</strong>线程</li><li>并发标记：进行GC Roots Tracing（追踪）的过程，<strong>并发</strong>用户进程</li><li>最终标记：修正在并发标记期间因用户程序继续运作而导致标记表动的那一部分标记记录，虚拟机将并发标记期间的对象变化记录在Remembered Set Logs中，在这阶段将这部分数据合并到Remembered Set中，<strong>停顿线程，但可并行执行</strong></li><li>筛选回收：对各Region的回收价值和成本排序，根据用户所期望的GC停顿来制定回收计划，可以做到并发，但意义不大</li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG261.jpeg" alt="avatar"></p><h3 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h3><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG262.jpeg" alt="avatar"></p><ul><li>“33.125”和“100.667”代表GC发生的<strong>时间</strong>，是从Java虚拟机启动以来经过的秒数</li><li>“[GC”和”[Full GC”说明<strong>垃圾收集的停顿类型</strong>，如果有”Full”说明是发生了Stop-The-World，如果是调用System.gc()触发的收集，则显示”[Full GC(System)”</li><li>“[DefNew”(Default New Generation)、”[ParNew”(Parallel New Generation)、”[PSYoungGen”(Parallel Scavenge)表示GC发生的<strong>区域</strong></li><li>方括号内部的”3324K-&gt;152(3712K)”指“GC前该内存区域已使用容量-&gt;GC后该内存区域已使用容量(该内存区域总容量)”;方括号之外的“3324K-&gt;152(11904K)”表示“GC前Java堆已使用容量-&gt;GC后Java堆已使用容量(Java堆总容量)”</li><li>“0.0025925secs”表示该内存区域GC所占用的时间</li></ul><h3 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h3><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG264.jpeg" alt="avatar"><br><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG263.jpeg" alt="avatar"></p><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><ul><li>对象优先在Eden分配，当Eden区没有足够空间进行分配时，虚拟机发起Minor GC，分配担保机制提前将原占用Eden的资源转移到老年代中<ul><li>新生代GC(Minor GC): 发生在新生代的垃圾收集行为，频繁，回收速度快</li><li>老年代GC(Major GC/Full GC): 发生在老年代的GC,经常伴随至少一次的Minor GC(非绝对),比Minor GC慢10倍以上</li></ul></li><li>大对象(需要大量连续内存空间的对象)直接进入老年代</li><li>长期存活的对象将进入老年代</li></ul><p>虚拟机采用<strong>分代收集</strong>思想管理内存，那么内存回收时就必须能识别对象放在哪。虚拟机给每个对象定义了一个<strong>对象年龄(Age)</strong>计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Surviror容纳得话，将被移到Surviror空间中，并且对象年龄设为1。对象在Surviror区每熬过一次Minor GC, 年龄就增加1岁，当年龄增加到一定程度(默认15岁)，就会被晋升到老年代中。</p><p>虚拟机并不是永远要求对象年龄必须达到了MaxTenuringThreshold才能晋升到老年代，如果在Surviror空间中<strong>相同年龄的所有对象大小总和大于Surviror空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代</strong>，无须等到MaxTenuringThreshold要求的年龄。</p><p>发生Minor GC前，先检查老年代最大可用连续空间是否能够存放新生代所有对象，能则确保Minor GC安全。否则，则看HandlePromotionFailure是否允许担保失败。如果允许，则继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，大于则进行Minor GC；如果小于，或者HandlePromotionFailure设置不允许冒险，则进行Full GC。</p><p>在JDK 6 Update 24后，<strong>只要老年代的联系空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则Full GC</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;垃圾回收主要是对Java堆、方法区内存的回收&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;对象已死吗&quot;&gt;&lt;a href=&quot;#对象已死吗&quot; class=&quot;headerlink&quot; title=&quot;对象已死吗&quot;&gt;&lt;/a&gt;对象已死吗&lt;/h2&gt;&lt;p&gt;堆中存放着几乎所有的对象实例，回收前，需要对对象是否存活进行确定，判断是否能进行回收&lt;/p&gt;
&lt;h3 id=&quot;引用计数算法&quot;&gt;&lt;a href=&quot;#引用计数算法&quot; class=&quot;headerlink&quot; title=&quot;引用计数算法&quot;&gt;&lt;/a&gt;引用计数算法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;给对象添加一个引用计数器&lt;/li&gt;
&lt;li&gt;引用则加1&lt;/li&gt;
&lt;li&gt;引用失效，则减1&lt;/li&gt;
&lt;li&gt;计数器为0的对象就可以被回收&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;br&gt;实现简单，效率高&lt;br&gt;
    
    </summary>
    
      <category term="Java基础" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="读书笔记" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深入理解Java虚拟机" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="自动内存管理机制" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
    
      <category term="JVM" scheme="blog.jiangdongyu.space/tags/JVM/"/>
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java内存区域与内存溢出异常</title>
    <link href="blog.jiangdongyu.space/2018/06/05/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
    <id>blog.jiangdongyu.space/2018/06/05/Java内存区域与内存溢出异常/</id>
    <published>2018-06-05T06:00:00.000Z</published>
    <updated>2018-07-10T09:02:44.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java技术体系"><a href="#Java技术体系" class="headerlink" title="Java技术体系"></a>Java技术体系</h2><p>Java程序设计语言、Java虚拟机、Java API类库三部分统称为<strong>JDK</strong>，JDK是用于支持Java程序开发的最小环境。Java API类库中的Java SE API子集和Java虚拟机这两个部分统称为<strong>JRE</strong>，JRE是支持Java程序运行的标准环境。</p><a id="more"></a><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="http://p9fh1pach.bkt.clouddn.com/Java2.png" alt="avatar"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>线程独立，唯一没有规定OutOfMemoryError的区域</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><ul><li>线程私有，生命周期和线程相同</li><li>平时所谓的堆、栈、方法区，栈就是指<strong>虚拟机栈</strong>，或者说是其中的<strong>局部变量表</strong>部分</li><li>两种异常状况<ul><li>StackOverflowError: 线程请求栈深度大于所允许</li><li>OutOfMemoryError: 扩展无法申请足够内存</li></ul></li></ul><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>和虚拟机栈发挥作用相似</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><ul><li>线程共享，虚拟机启动时创建，<strong>存放对象实例</strong></li><li>GC管理的主要区域</li><li>内存空间不连续</li><li>OutOfMemoryError: 堆中没有内存完成实例分配并且无法扩展时</li></ul><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul><li>线程共享</li><li>存放类信息、常量、静态变量、即时编译器编译后的代码</li><li>OutOfMemoryError: 无法满足内存分配需求时</li></ul><h3 id="JVM实例"><a href="#JVM实例" class="headerlink" title="JVM实例"></a>JVM实例</h3><p><img src="http://p9fh1pach.bkt.clouddn.com/%E5%A0%86%E6%A0%88%E6%96%B9%E6%B3%95%E5%8C%BA.jpg" alt="avatar"></p><h2 id="HotSpot虚拟机对象揭秘"><a href="#HotSpot虚拟机对象揭秘" class="headerlink" title="HotSpot虚拟机对象揭秘"></a>HotSpot虚拟机对象揭秘</h2><p>HotSpot虚拟机在Java堆中对象分配、布局、访问的全过程</p><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><ul><li>虚拟机遇到new指令，检查指令的参数能否在常量池中定位到一个类的符号引用</li><li>检查所代表的类是否已被加载、解析和初始化过</li><li>没有，则先执行类加载过程</li><li>虚拟机为新生对象分配内存，对象所需内存大小在类加载完成后便可确定<ul><li>指针碰撞: 假设Java堆内存绝对规整，用过的内存和没用过的严格分开，有一个指针作为分界点的指示器，移动指针即可</li><li>空闲列表: 内存不规整，维护列表，记录是否可用，需要在列表中找一块足够大的区域</li></ul></li><li>对象创建频繁，可能会导致在并发情况下线程不安全<ul><li>对分配内存动作加上同步处理: CAS+失败重试</li><li>按线程划分在不同空间，每个线程预先分配<strong>本地线程分配缓冲(TLAB)</strong>，哪个线程需要分配内存，就在哪个线程的TLAB分配，只有在用完并分配新的TLAB时才同步锁定</li></ul></li><li>将分配到的内存空间初始化为零值</li><li>根据<strong>对象头</strong>对对象进行必要的设置</li><li>执行<init>方法</init></li></ul><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>HotSpot中分3块区域: 对象头、实例数据、对齐填充</p><ul><li>对象头<ol><li>存储对象自身运行时数据: 哈希码、GC分代年龄…</li><li>类型指针，对象指向其类原数据的指针，<strong>确定对象是哪个类的实例</strong>（不是所有虚拟机实现都必须保留该指针）</li></ol></li><li>实例数据: 在代码中定义的各种类型的字段内容<ul><li>HotSpot默认相同宽度字段被分配到一起，比如shorts/chars，父类的变量在子类之前</li></ul></li><li>对齐填充(不一定存在，占位作用)</li></ul><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>使用对象需要通过<strong>栈</strong>上的reference来操作<strong>堆</strong>上的具体对象，引用如何去定位，主流有两种：</p><ul><li>句柄（稳定）<ul><li>reference存储对象的句柄地址，句柄中包含对象实例数据和类型数据的具体信息<br><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG239.jpeg" alt="avatar"></li></ul></li><li>直接指针（速度快，HotSpot）<ul><li>reference存储对象的地址<br><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG240.jpeg" alt="avatar"></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java技术体系&quot;&gt;&lt;a href=&quot;#Java技术体系&quot; class=&quot;headerlink&quot; title=&quot;Java技术体系&quot;&gt;&lt;/a&gt;Java技术体系&lt;/h2&gt;&lt;p&gt;Java程序设计语言、Java虚拟机、Java API类库三部分统称为&lt;strong&gt;JDK&lt;/strong&gt;，JDK是用于支持Java程序开发的最小环境。Java API类库中的Java SE API子集和Java虚拟机这两个部分统称为&lt;strong&gt;JRE&lt;/strong&gt;，JRE是支持Java程序运行的标准环境。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="读书笔记" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深入理解Java虚拟机" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="自动内存管理机制" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
    
      <category term="JVM" scheme="blog.jiangdongyu.space/tags/JVM/"/>
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
  </entry>
  
</feed>
