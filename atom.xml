<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>M&amp;Y</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="blog.jiangdongyu.space/"/>
  <updated>2018-05-27T16:41:57.089Z</updated>
  <id>blog.jiangdongyu.space/</id>
  
  <author>
    <name>Agnes</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试经验</title>
    <link href="blog.jiangdongyu.space/2018/03/23/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    <id>blog.jiangdongyu.space/2018/03/23/面试经验/</id>
    <published>2018-03-23T06:26:00.000Z</published>
    <updated>2018-05-27T16:41:57.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="搜狐汽车"><a href="#搜狐汽车" class="headerlink" title="搜狐汽车"></a>搜狐汽车</h2><ul><li>介绍简历</li><li>问了String为什么是final的,Enum,数据库连接（左外，右外，内连接）</li><li>用栈实现队列(时间复杂度),数组找出只出现一次的元素(时间复杂度),手写快排</li><li>Java运行时的编译情况，大的项目是怎么编译的</li><li>Spring的文档什么的有没有看过</li><li>确定自己喜欢的是什么，有没有兴趣，自驱动能力</li></ul><a id="more"></a><ol><li>String为什么是final的？<blockquote><p>不可变final指不在原内存地址上修改数据，而是重新指向一个新对象，新地址</p></blockquote></li></ol><ul><li><p>JDK源码，java.lang.String前三行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">    <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,<span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;,<span class="title">CharSequence</span></span>&#123;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** String本质是个char数组，而且用final修饰*/</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Array可变，只是在后面的String的所有方法里没有动数组的元素，没有暴露内部成员。<strong>String不可变的关键都在底层实现，而不是一个final</strong></p><ul><li>不可变是为了安全</li></ul><ol start="2"><li><p>SQL四种连接</p><ul><li><p>内联接（典型的联接运算，使用像 =  或 &lt;&gt; 之类的比较运算符）。包括相等联接和自然联接。<br>内联接使用比较运算符根据每个表共有的列的值匹配两个表中的行。例如，检索 students和courses表中学生标识号相同的所有行。   </p></li><li><p>外联接。外联接可以是左向外联接、右向外联接或完整外部联接。<br>在 FROM子句中指定外联接时，可以由下列几组关键字中的一组指定：     </p><ul><li><p>1）LEFT  JOIN或LEFT OUTER JOIN<br>左向外联接的结果集包括  LEFT OUTER子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值。       </p></li><li><p>2）RIGHT  JOIN 或 RIGHT  OUTER  JOIN<br>右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。       </p></li><li>3）FULL  JOIN 或 FULL OUTER JOIN<br>完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。   </li></ul></li><li>交叉联接<br>交叉联接返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉联接也称作笛卡尔积。</li></ul></li></ol><h2 id="搜狐智能媒体研发中心"><a href="#搜狐智能媒体研发中心" class="headerlink" title="搜狐智能媒体研发中心"></a>搜狐智能媒体研发中心</h2><ul><li>并发编程，能并发的数据结构</li><li>Springboot为什么能做到不配置一些xml？</li><li>1.0版本的智慧教室会遇到哪些问题？并发？底层的哪些不够用了，才会出现这些问题？</li><li>JVM参数调优，怎么做？参数的意义？</li><li>HTTP要了解得更深入一些</li><li>服务器怎么判断是某个用户，用户登录的时候怎么返回该用户的信息，session怎么做安全？</li><li>MySQL建表的时候需要注意什么？long类型在mysql中怎么存？</li><li>Redis适合存一些什么样的数据？在什么场合使用？</li><li>Spring的IOC、AOP需要知道流程，Java基础，NIO等…</li><li>单链表反转，递归，非递归</li></ul><h2 id="蚂蚁金服"><a href="#蚂蚁金服" class="headerlink" title="蚂蚁金服"></a>蚂蚁金服</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ul><li>介绍项目，主要介绍在微软的实习，要注意项目讲得对方能理解</li><li>10亿条文件排序，外部归并，merge时堆内部排序</li><li>一堆运动员的成绩排序，如a:10,b:20,c:5，排序并保证新来的一个运动员也是有序的 用treemap, map底层怎么实现的，哈希表或红黑树</li><li>白板写代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设用一组字符串表示一个目录下的层级结构:</span></span><br><span class="line"><span class="comment">//如"dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"</span></span><br><span class="line"><span class="comment">//表示的结构为</span></span><br><span class="line"><span class="comment">// dir</span></span><br><span class="line"><span class="comment">//    subdir1</span></span><br><span class="line"><span class="comment">//        file1.ext</span></span><br><span class="line"><span class="comment">//        subsubdir1</span></span><br><span class="line"><span class="comment">//    subdir2</span></span><br><span class="line"><span class="comment">//        subsubdir2</span></span><br><span class="line"><span class="comment">//            file2.ext   </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Value</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">15</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getLargestLength(<span class="string">"dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLargestLength</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String arr []  = str.split(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">0</span>].contains(<span class="string">"\t"</span>))</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; dirLength = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dirLength.add(arr[<span class="number">0</span>].length());</span><br><span class="line">        max = arr[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> length = arr[i].replaceAll(<span class="string">"\t"</span>, <span class="string">""</span>).length();</span><br><span class="line">            <span class="keyword">int</span> count = arr[i].length() - length;</span><br><span class="line">            <span class="keyword">if</span> (dirLength.size() &lt; count) &#123;</span><br><span class="line">                <span class="comment">//输入欠缺中间目录</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//新的根目录</span></span><br><span class="line">                dirLength = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dirLength = dirLength.subList(<span class="number">0</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">            dirLength.add(length + dirLength.get(count - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (dirLength.get(count) &gt; max)&#123;</span><br><span class="line">                max = dirLength.get(count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ul><li>介绍项目</li><li>给一个二维数组代表会议室的预定时间区间，比如[1,2],[2,3],[1,3]，则最少需要的会议室的数量为2<ul><li>贪心 转换为一个会议室利用率最高的问题，对开始时间排序，选择下一个开始时间离结束时间最近的</li></ul></li><li>数学题，给1-5五个数字，全排列，[12345,12354,…,54312,54321],求中间两个数的差值</li><li>hiveql和sql是一样的么？不一样，举例说明，并说明理由</li><li>hiveql数据表的join,map reduce的过程？<br><img src="./hive map reduce.png" alt="本地图片链接"></li><li>给一个整数数组[x1,x2…xi,…xn]，求X+Y+Z&lt;N的所有可能性，不能重复<ul><li>3sum 的变体，先排序，外层循环，内层两个指针判断，如果和&gt; N-Z，则尾指针前移</li></ul></li><li><p>HTTP怎么做到有状态？</p><ul><li>我们要实现的是一种web应用，实现这种应用的协议我们选择了http这种本质上是无状态的通信协议。但是事实上，我们需要我们的web应用是有状态的。所以我们加入了<strong>cookies、session</strong>等机制去实现由状态的web应用</li><li><strong>Web应用=http协议+session、cookies等状态机制+其他辅助的机制</strong></li></ul></li><li><p>MySQL数据库引擎，innoDB的特点？别的引擎？</p><ul><li>InnoDB：该存储引擎为MySQL表提供了<strong>ACID事务支持</strong>、系统崩溃修复能力和多版本并发控制（即MVCC Multi-Version Concurrency Control）的<strong>行级锁</strong>;该引擎支持<strong>自增长列（auto_increment）</strong>,自增长列的值不能为空，如果在使用的时候为空则自动从现有值开始增值，如果有但是比现在的还大，则直接保存这个值; 该引擎存储引擎支持<strong>外键（foreign key）</strong>,外键所在的表称为子表而所依赖的表称为父表。该引擎在5.5后的MySQL数据库中为<strong>默认</strong>存储引擎。</li><li>ISAM：该引擎在<strong>读取数据</strong>方面速度很快，而且不占用大量的内存和存储资源；但是ISAM<strong>不支持事务处理、不支持外来键、不能够容错、也不支持索引</strong>。该引擎在包括MySQL 5.1及其以上版本的数据库中不再支持。</li><li>MyISAM：该引擎基于ISAM数据库引擎，除了提供ISAM里所没有的<strong>索引和字段管理</strong>等大量功能，MyISAM还使用一种<strong>表格锁定的机制</strong>来优化多个并发的读写操作，但是需要经常运行<strong>OPTIMIZE TABLE</strong>命令，来恢复被更新机制所浪费的空间，否则碎片也会随之增加，最终影响数据访问性能。MyISAM还有一些有用的扩展，例如用来修复数据库文件的MyISAMChk工具和用来恢复浪费空间的 MyISAMPack工具。MyISAM强调了快速读取操作，主要用于高负载的select，这可能也是MySQL深受Web开发的主要原因：在Web开发中进行的大量数据操作都是读取操作，所以大多数虚拟主机提供商和Internet平台提供商（Internet Presence Provider，IPP）只允许使用MyISAM格式。</li><li>HEAP（也称为MEMORY）：该存储引擎通过在<strong>内存中创建临时表</strong>来存储数据。每个基于该存储引擎的表实际对应一个磁盘文件，该文件的文件名和表名是相同的，类型为.frm。该磁盘文件只存储表的结构，而其数据存储在内存中，所以使用该种引擎的表拥有极高的插入、更新和查询效率。这种存储引擎默认使用<strong>哈希（HASH）索引</strong>，其速度比使用B-+Tree型要快，但也可以使用B树型索引。由于这种存储引擎所存储的数据保存在内存中，所以其保存的数据具有不稳定性，比如如果mysqld进程发生异常、重启或计算机关机等等都会造成这些数据的消失，所以这种存储引擎中的表的<strong>生命周期很短，一般只使用一次</strong>。</li><li>CSV（Comma-Separated Values逗号分隔值）：使用该引擎的MySQL数据库表会在MySQL安装目录data文件夹中的和该表所在数据库名相同的目录中生成一个.CSV文件（所以，它可以将CSV类型的文件当做表进行处理），这种文件是一种普通文本文件，每个数据行占用一个文本行。该种类型的存储引擎<strong>不支持索引，即使用该种类型的表没有主键列；另外也不允许表中的字段为null</strong>。</li></ul></li><li>小英的用户数据一台机器放不下的时候，怎么办？</li></ul><h2 id="腾讯云一面"><a href="#腾讯云一面" class="headerlink" title="腾讯云一面"></a>腾讯云一面</h2><ul><li>介绍项目</li><li>多线程的实现方式，线程的状态<ul><li>new Thread / implements Runnable</li></ul></li><li>gc,什么时候gc，内存溢出<ul><li><a href="./Java JVM.md">Java GC</a></li></ul></li><li>Linux指令，怎么查看内存线程使用情况</li><li>Mysql索引，group by &amp; union</li><li>TCP的…四次挥手，为什么等待2MSL?</li><li>用过哪些大数据框架</li><li>怎么判断一棵二叉树是镜像的？<ul><li>层次遍历，每次取左子树左右结点，右子树右左结点，判断是否相同</li></ul></li><li><p>栈实现O(1)获得最小的数getMin()</p><ul><li>非常棒的一道题。原理很简单，但是需要思考清楚为什么可以。原理可以参考下图：<br><img src="./栈最小.png" alt="avatar"></li><li>准备两个栈，一个正常栈，一个辅助栈，正常栈做pop和push。辅助栈push更新最小值，pop出正常栈的最小值。</li><li>过程很简单，当正常栈push的时候，查看辅助栈的栈顶元素，如果是比辅助栈栈顶还小或者等于，那么更新到栈顶。否则不加如辅助栈。<ul><li>当正常栈做pop，查看辅助栈栈顶是否相等，相等的话一起pop，否则不动。</li></ul></li><li><p>PS：注意当做push的时候，辅助栈栈顶元素和新元素相等，还是要入栈，因为再做pop把元素出栈后，正常栈其实后面还是有这个元素。</p></li><li><p>原理：其实就是类似动态规划的原理，辅助栈里的元素，全是到正常栈该元素位置的最小值是谁。所以除非正常栈做出栈弹出到这个值，否则辅助栈的栈顶就是当前的最小值。</p></li></ul></li><li>1000瓶水，1瓶有毒，一只小白鼠喝了有毒的一周死亡，现给10只小白鼠一周时间，怎么做？<ul><li>二进制 标记</li></ul></li></ul><h2 id="今日头条一面"><a href="#今日头条一面" class="headerlink" title="今日头条一面"></a>今日头条一面</h2><ul><li>自我介绍</li><li>给定一个结点，确定二叉树中序遍历的后继结点（结点有左指针，右指针，父亲指针）<ul><li>判断是否有右子树，有就找右子树最左的结点</li><li>没有，则不断找父亲结点，直到当前结点是父亲结点的左孩子</li></ul></li><li>介绍项目</li><li>hashmap的equals和hashcode方法，怎么判断key存在（底层）<ul><li>首先<strong>hash(key)得到key的hashcode()</strong>，hashmap根据获得的hashcode找到要插入的位置所在的链，在这个链里面放的都是hashcode相同的Entry键值对，在找到这个链之后，会通过<strong>equals()</strong>方法判断是否已经存在要插入的键值对，而这个equals比较的其实就是key。</li><li>判断key是否存在的时候是先比较key的hashCode，再比较相等或equals的</li></ul></li><li>Http的keep-alive长连接的特性，多个json怎么区分（content-length）</li><li>数据库事务的一致性<ul><li>事务执行前与执行后数据内在的逻辑始终是成立的。比如转账前与转账后两人存款的总和始终不变。</li></ul></li></ul><h2 id="腾讯一面"><a href="#腾讯一面" class="headerlink" title="腾讯一面"></a>腾讯一面</h2><ul><li>自我介绍</li><li>写hql <ul><li>给定腾讯新闻数据，三个表</li><li>第一个表：腾讯新闻版面id，文章id</li><li>第二个表，浏览行为数据：时间戳，版面id，文章id</li><li>第三个表，评论行为数据：时间戳，版面id，文章id</li><li>求每天文章/版面的曝光</li><li>曝光 = 评论/浏览</li></ul></li><li>求两个数组的交集<ul><li>hashset</li><li>排序，再比较</li></ul></li></ul><h2 id="微软Summer-Intern"><a href="#微软Summer-Intern" class="headerlink" title="微软Summer Intern"></a>微软Summer Intern</h2><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><ul><li>介绍azure table为什么能做到一个用户的数据在一台机器上</li><li>介绍datafactory入hive的过程，如果将copy和hive分开，怎么做？用socket？为什么websocket能做到双方发消息？</li><li>多态是在编译时知道？还是<em>运行时</em>？ B extends A;<ul><li>A a = new A() <strong>编译时</strong></li><li>A a = new B() <strong>运行时</strong></li></ul></li><li><p>给定一个正整数，求阶乘？ 越界？ 非递归？</p><ul><li>n较小时</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static long getNFactorial(int n)&#123;</span><br><span class="line">  if(n==0)&#123;</span><br><span class="line">      return 1l;</span><br><span class="line">  &#125;</span><br><span class="line">  return n*getNFactorial1(n-1);</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>public static long getNFactorial1(int n){</p><pre><code>if(n==0){    return 1l;}long sum=1l;for(int i=1;i&lt;=n;i++){    sum=sum*i;}return sum;</code></pre><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- n较大时</span><br></pre></td></tr></table></figure><p>public static void getNFactorial(int n) {</p><pre><code>int num[] = new int[1000];int i, j;if (n == 1 || n == 0) {    System.out.println(1);} else {    int p, h;// p 存放当前结果的位数，h为进位；    p = 1;    h = 0;    num[1] = 1;    for (i = 2; i &lt;= n; i++) {        // 使得a[]的每位与i相乘        for (j = 1; j &lt;= p; j++) {            num[j] = num[j] * i + h;            h = num[j] / 10;            num[j] = num[j] % 10;        }        // 表示向新的位置进位        while (h &gt; 0) {            num[j] = h % 10;            h = h / 10;            j++;        }        p = j - 1;    }    for (i = p; i &gt;= 1; i--) {        System.out.print(num[i]);    }}</code></pre><p>  }<br><code>`</code> </p></li></ul><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><ul><li>2 Sum &amp; 3 Sum</li><li>int parse(String str)的测试用例</li><li>为什么用azure？</li></ul><h2 id="商汤Java实习生"><a href="#商汤Java实习生" class="headerlink" title="商汤Java实习生"></a>商汤Java实习生</h2><ul><li>Collections框架体系<br><img src="https://img-blog.csdn.net/20170309094509415?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VuaWFuXzkzMDEyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="avatar"></li><li>HashSet的特性<ul><li>基于HashMap实现</li><li>无序不重复</li></ul></li><li>HashMap结构<ul><li>哈希表，数组+链表</li></ul></li><li>HashMap和ConcurrentHashMap区别</li><li>锁的了解</li><li>线程池有哪些？</li><li>怎么实现线程？</li><li>并发包…</li><li>SpringBoot中@ReseController注解对应哪两个<ul><li>@ResponseBody和@Controller的组合注解。</li></ul></li><li>Redis支持哪些类型？<ul><li>Strings</li><li>Lists</li><li>Sets 求交集、并集</li><li>Sorted Set</li><li>hashes</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;搜狐汽车&quot;&gt;&lt;a href=&quot;#搜狐汽车&quot; class=&quot;headerlink&quot; title=&quot;搜狐汽车&quot;&gt;&lt;/a&gt;搜狐汽车&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;介绍简历&lt;/li&gt;
&lt;li&gt;问了String为什么是final的,Enum,数据库连接（左外，右外，内连接）&lt;/li&gt;
&lt;li&gt;用栈实现队列(时间复杂度),数组找出只出现一次的元素(时间复杂度),手写快排&lt;/li&gt;
&lt;li&gt;Java运行时的编译情况，大的项目是怎么编译的&lt;/li&gt;
&lt;li&gt;Spring的文档什么的有没有看过&lt;/li&gt;
&lt;li&gt;确定自己喜欢的是什么，有没有兴趣，自驱动能力&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Interview" scheme="blog.jiangdongyu.space/categories/Interview/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList</title>
    <link href="blog.jiangdongyu.space/2017/09/30/LinkedList%E9%A2%98/"/>
    <id>blog.jiangdongyu.space/2017/09/30/LinkedList题/</id>
    <published>2017-09-30T09:52:00.000Z</published>
    <updated>2018-05-27T14:54:15.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h2><h3 id="83-Remove-Duplicates-from-Sorted-List"><a href="#83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="83.Remove Duplicates from Sorted List"></a>83.Remove Duplicates from Sorted List</h3><p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p><blockquote><p>For example,<br>Given 1-&gt;1-&gt;2, return 1-&gt;2.<br>Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.val == cur.next.val)&#123;</span><br><span class="line">           cur.next = cur.next.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="82-Remove-Duplicates-from-Sorted-List-II"><a href="#82-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="82.Remove Duplicates from Sorted List II"></a>82.Remove Duplicates from Sorted List II</h3><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p><blockquote><p>For example,<br>Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.<br>Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);  </span><br><span class="line">    dummy.next = head; </span><br><span class="line">    ListNode cur = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span>(cur.next.val == cur.next.next.val)&#123;</span><br><span class="line">           <span class="keyword">int</span> temp = cur.next.val;</span><br><span class="line">           <span class="keyword">while</span>(cur.next ！= <span class="keyword">null</span> &amp;&amp; cur.next.val == temp)&#123;</span><br><span class="line">              cur.next = cur.next.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          cur = cur.next;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="147-Insertion-Sort-List"><a href="#147-Insertion-Sort-List" class="headerlink" title="147.Insertion Sort List"></a>147.Insertion Sort List</h3><p>Sort a linked list using insertion sort.</p><blockquote><p>插入排序：两层循环，将数插入到已经排序的数组中合适的位置去</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Function to sort array using insertion sort*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> key = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j = i-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Move elements of arr[0..i-1], that are</span></span><br><span class="line"><span class="comment">               greater than key, to one position ahead</span></span><br><span class="line"><span class="comment">               of their current position */</span></span><br><span class="line">            <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; arr[j] &gt; key)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                j = j-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j+<span class="number">1</span>] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>链表的插入排序，同样两层循环，考虑到头指针也需要被排序，需要新增一个fakeHead。</p><p>链表的插入需要维护三个指针，pre，cur，next，<br>pre始终指向有序链表的fakeHead，cur指向当前需要排序的节点，next指向下一个待排序的节点。</p><p>当有序链表为空或者pre.next所指向的元素的值比当前节点的值大时，需要将cur插入到pre.next之前的位置，<br>否则，则将pre指针后移，最后返回fakeHead.next即可。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);  </span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode next= cur.next;</span><br><span class="line">        <span class="keyword">while</span>(pre.next != <span class="keyword">null</span> &amp;&amp; pre.next.val &lt; cur.val)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = pre.next;</span><br><span class="line">        pre.next = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> dummy.next; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="92-Reverse-Linked-List-II"><a href="#92-Reverse-Linked-List-II" class="headerlink" title="92.Reverse Linked List II"></a>92.Reverse Linked List II</h3><p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p><blockquote><p>For example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,<br>return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL.</p></blockquote><p>Note:<br>Given m, n satisfy the following condition:<br>1 ≤ m ≤ n ≤ length of list.</p><blockquote><p>指定位置的链表部分逆转，考虑到头指针也可能被逆转，新建fakeHead。</p><p>维护三个指针，pre永远指向m-1个位置的节点，start指向m位置的节点，then指向start.next</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">        </span><br><span class="line">   ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">   dummy.next = head;</span><br><span class="line">   ListNode pre = dummy;</span><br><span class="line">        </span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m-<span class="number">1</span>;i++)&#123;</span><br><span class="line">       pre = pre.next;</span><br><span class="line">   &#125;</span><br><span class="line">        </span><br><span class="line">   ListNode start = pre.next;</span><br><span class="line">   ListNode then = start.next;</span><br><span class="line">        </span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n-m ;i++)&#123;</span><br><span class="line">       start.next = then.next;</span><br><span class="line">       then.next = pre.next;</span><br><span class="line">       pre.next = then;</span><br><span class="line">       then = start.next;</span><br><span class="line">   &#125;</span><br><span class="line">        </span><br><span class="line">   <span class="keyword">return</span> dummy.next;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="148-Sort-List"><a href="#148-Sort-List" class="headerlink" title="148.Sort List"></a>148.Sort List</h3><p>Sort a linked list in O(n log n) time using constant space complexity.</p><blockquote><p>归并排序</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode pre = head;</span><br><span class="line">    ListNode slower = head;</span><br><span class="line">    ListNode faster = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(faster !=<span class="keyword">null</span> &amp;&amp; faster.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        pre = slower;</span><br><span class="line">        slower = slower.next;</span><br><span class="line">        faster = faster.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pre.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ListNode h1 = sortList(head);</span><br><span class="line">    ListNode h2 = sortList(slower);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge(h1,h2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode head1,ListNode head2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> head2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(head2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> head1;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode mergeHead  = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(head1.val &lt; head2.val)&#123;</span><br><span class="line">       mergeHead = head1;</span><br><span class="line">       mergeHead.next = merge(head1.next,head2);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       mergeHead = head2;</span><br><span class="line">       mergeHead.next = merge(head1,head2.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mergeHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="23.Merge k Sorted Lists"></a>23.Merge k Sorted Lists</h3><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p><blockquote><p>递归转化为已知问题，合并两个有序链表</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> partition(lists,<span class="number">0</span>,lists.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode[] lists,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">       <span class="keyword">return</span> lists[start];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(start &lt; end)&#123;</span><br><span class="line">       <span class="keyword">int</span> middle = (start+end)/<span class="number">2</span>;</span><br><span class="line">       ListNode l1 = partition(lists,start,middle);</span><br><span class="line">       ListNode l2 = partition(lists,middle+<span class="number">1</span>,end);</span><br><span class="line">       <span class="keyword">return</span> merge(l1,l2);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode head1,ListNode head2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> head2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(head2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> head1;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode mergeHead = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(head1.val &lt; head2.val)&#123;</span><br><span class="line">       mergeHead = head1;</span><br><span class="line">       mergeHead.next = merge(head1.next,head2);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       mergeHead = head2;</span><br><span class="line">       mergeHead.next = merge(head1,head2.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mergeHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="143-Reorder-List"><a href="#143-Reorder-List" class="headerlink" title="143.Reorder List"></a>143.Reorder List</h3><p>Given a singly linked list L: L0?L1?…?Ln-1?Ln,<br>reorder it to: L0?Ln?L1?Ln-1?L2?Ln-2?…</p><blockquote><p>For example,<br>Given {1,2,3,4}, reorder it to {1,4,2,3}.</p></blockquote><p>You must do this in-place without altering the nodes’ values.</p><blockquote><p>找到中心节点，将后半段链表反转变成一个新链表，再合并即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    ListNode slower = head;</span><br><span class="line">    ListNode faster = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(faster != <span class="keyword">null</span> &amp;&amp; faster.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        pre = slower;</span><br><span class="line">        slower = slower.next;</span><br><span class="line">        faster = faster.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    ListNode head2 = reverse(slower);</span><br><span class="line"></span><br><span class="line">    merge(head,head2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode temp = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(ListNode h1,ListNode h2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(h1 != <span class="keyword">null</span> &amp;&amp; h1.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">       ListNode n1 = h1.next;</span><br><span class="line">       ListNode n2 = h2.next;</span><br><span class="line">     </span><br><span class="line">       h1.next = h2;</span><br><span class="line">       <span class="keyword">if</span>(n1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       h2.next = n1;</span><br><span class="line">       h1 = n1;</span><br><span class="line">       h2 = n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2.Add Two Numbers"></a>2.Add Two Numbers</h3><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><blockquote><p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">   ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">   ListNode cur = dummy;</span><br><span class="line">   ListNode p1 = l1;</span><br><span class="line">   ListNode p2 = l2;</span><br><span class="line">   <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(p1 != <span class="keyword">null</span> || p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">int</span> x = p1 == <span class="keyword">null</span> ? <span class="number">0</span>:p1.val;</span><br><span class="line">       <span class="keyword">int</span> y = p2 == <span class="keyword">null</span> ? <span class="number">0</span>:p2.val;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line">       carry = sum/<span class="number">10</span>;</span><br><span class="line">       cur.next = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line">       cur = cur.next;</span><br><span class="line">       <span class="keyword">if</span>(p1 != <span class="keyword">null</span>) p1 = p1.next;</span><br><span class="line">       <span class="keyword">if</span>(p2 != <span class="keyword">null</span>) p2 = p2.next;</span><br><span class="line">   &#125;</span><br><span class="line">        </span><br><span class="line">   <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      cur.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">   &#125;     </span><br><span class="line">   <span class="keyword">return</span> dummy.next;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="86-Partition-List"><a href="#86-Partition-List" class="headerlink" title="86.Partition List"></a>86.Partition List</h3><p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.<br>给定一个单链表和数值x，划分链表使得所有小于x的节点排在大于等于x的节点之前。</p><p>You should preserve the original relative order of the nodes in each of the two partitions.<br>你应该保留两部分内链表节点原有的相对顺序。</p><blockquote><p>For example,<br>Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,<br>return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br><span class="line">   ListNode leftDummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">   ListNode rightDummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">   ListNode left = leftDummy;</span><br><span class="line">   ListNode right = rightDummy;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span>(head.val &lt; x)&#123;</span><br><span class="line">          left.next = head;</span><br><span class="line">          left = head;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          right.next = head;</span><br><span class="line">          right = head;</span><br><span class="line">       &#125;</span><br><span class="line">       head = head.next;</span><br><span class="line">   &#125;</span><br><span class="line">   right.next = <span class="keyword">null</span>;     </span><br><span class="line">   left.next = rightDummy.next;    </span><br><span class="line">   <span class="keyword">return</span> leftDummy.next;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="138-Copy-List-with-Random-Pointer"><a href="#138-Copy-List-with-Random-Pointer" class="headerlink" title="138.Copy List with Random Pointer"></a>138.Copy List with Random Pointer</h3><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.<br>Return a deep copy of the list.</p><blockquote><p>浅拷贝是指源对象与拷贝对象共用一份实体，仅仅是引用的变量不同（名称不同）。对其中任何一个对象的改动都会影响另外一个对象。举个例子，一个人一开始叫张三，后来改名叫李四了，可是还是同一个人，不管是张三缺胳膊少腿还是李四缺胳膊少腿，都是这个人倒霉。</p></blockquote><p>深拷贝是指源对象与拷贝对象<strong>互相独立</strong>，其中任何一个对象的改动都不会对另外一个对象造成影响。举个例子，一个人名叫张三，后来用他克隆（假设法律允许）了另外一个人，叫李四，不管是张三缺胳膊少腿还是李四缺胳膊少腿都不会影响另外一个人。</p><p><strong>因此，本题转换为拷贝原链表为一个新链表，next，random都得符合</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * class RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     RandomListNode next, random;</span></span><br><span class="line"><span class="comment"> *     RandomListNode(int x) &#123; this.label = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;RandomListNode,RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;RandomListNode,RandomListNode&gt;(); </span><br><span class="line">    RandomListNode node = head;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        map.put(node,<span class="keyword">new</span> RandomListNode(node.label));</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;  </span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">       map.get(node).next = map.get(node.next);</span><br><span class="line">       map.get(node).random = map.get(node.random);</span><br><span class="line">       node = node.next;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="445-Add-Two-Numbers-II"><a href="#445-Add-Two-Numbers-II" class="headerlink" title="445.Add Two Numbers II"></a>445.Add Two Numbers II</h3><p>假定用一个链表表示两个数，其中每个节点仅包含一个数字。假设这两个数的数字顺序排列，请设计一种方法将两个数相加，并将其结果表现为链表的形式。</p><blockquote><p>样例<br>给出 6-&gt;1-&gt;7 + 2-&gt;9-&gt;5。即，617 + 295。<br>返回 9-&gt;1-&gt;2。即，912 。</p></blockquote><p><strong>将链表放入栈操作，利用栈的特性，进行加法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;      </span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @param l1: The first list.</span></span><br><span class="line"><span class="comment">     * @param l2: The second list.</span></span><br><span class="line"><span class="comment">     * @return: the sum list of l1 and l2.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addLists2</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        Stack&lt;Integer&gt; s1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; s2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            s1.push(l1.val);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            s2.push(l2.val);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        ListNode cur = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!s1.isEmpty()||!s2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!s1.isEmpty())&#123;</span><br><span class="line">                sum += s1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!s2.isEmpty())&#123;</span><br><span class="line">                sum += s2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            cur.val = sum%<span class="number">10</span>;</span><br><span class="line">            ListNode head = <span class="keyword">new</span> ListNode(sum/<span class="number">10</span>);</span><br><span class="line">            head.next = cur;</span><br><span class="line">            cur = head;</span><br><span class="line">            sum = sum/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val == <span class="number">0</span>?cur.next:cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LintCode"><a href="#LintCode" class="headerlink" title="LintCode"></a>LintCode</h2><h3 id="交换链表当中两个节点"><a href="#交换链表当中两个节点" class="headerlink" title="交换链表当中两个节点"></a>交换链表当中两个节点</h3><p>给你一个链表以及两个权值v1和v2，交换链表中权值为v1和v2的这两个节点。保证链表中节点权值各不相同，如果没有找到对应节点，那么什么也不用做。</p><blockquote><p>样例<br>给出链表 1-&gt;2-&gt;3-&gt;4-&gt;null ，以及 v1 = 2 ， v2 = 4<br>返回结果 1-&gt;4-&gt;3-&gt;2-&gt;null。</p></blockquote><p><strong>头节点，相邻情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @param head: a ListNode</span></span><br><span class="line"><span class="comment">     * @param v1: An integer</span></span><br><span class="line"><span class="comment">     * @param v2: An integer</span></span><br><span class="line"><span class="comment">     * @return: a new head of singly-linked list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapNodes</span><span class="params">(ListNode head, <span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        ListNode p1 = <span class="keyword">null</span>;</span><br><span class="line">        ListNode p2 = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == v1)&#123;</span><br><span class="line">                p1 = cur;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.next.val == v2)&#123;</span><br><span class="line">                p2 = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p1 == <span class="keyword">null</span> || p2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dummy.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode n1 = p1.next;</span><br><span class="line">        ListNode n2 = p2.next;</span><br><span class="line">        ListNode x1 = n1.next;</span><br><span class="line">        ListNode x2 = n2.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p1.next == p2)&#123;</span><br><span class="line">            p1.next = n2;</span><br><span class="line">            n2.next = n1;</span><br><span class="line">            n1.next = x2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p2.next == p1)&#123;</span><br><span class="line">            p2.next = n1;</span><br><span class="line">            n1.next = n2;</span><br><span class="line">            n2.next = x1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p1.next = n2;</span><br><span class="line">            n2.next = x1;</span><br><span class="line">            p2.next = n1;</span><br><span class="line">            n1.next = x2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h3><p>设计一种方式检查一个链表是否为回文链表。</p><blockquote><p>样例<br>1-&gt;2-&gt;1 就是一个回文链表。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @param head: A ListNode.</span></span><br><span class="line"><span class="comment">     * @return: A boolean.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slower = head;</span><br><span class="line">        ListNode faster = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(faster.next != <span class="keyword">null</span> &amp;&amp; faster.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slower = slower.next;</span><br><span class="line">            faster = faster.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode mid = slower;</span><br><span class="line">        ListNode first = mid.next;</span><br><span class="line">        ListNode cur = first.next;</span><br><span class="line">        first.next = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">           ListNode tem =  cur.next;</span><br><span class="line">           cur.next = mid.next;</span><br><span class="line">           mid.next = cur;</span><br><span class="line">           cur = tem;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        slower = mid.next;</span><br><span class="line">        faster = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(slower != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(faster.val != slower.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            faster = faster.next;</span><br><span class="line">            slower = slower.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h3><p>给定一个单链表L: L0→L1→…→Ln-1→Ln,</p><p>重新排列后为：L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>必须在不改变节点值的情况下进行原地操作。</p><blockquote><p>样例<br>给出链表 1-&gt;2-&gt;3-&gt;4-&gt;null，重新排列后为1-&gt;4-&gt;2-&gt;3-&gt;null。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for ListNode.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @param head: The head of linked list.</span></span><br><span class="line"><span class="comment">     * @return: nothing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode p1 = head;</span><br><span class="line">        ListNode p2 = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(p2.next != <span class="keyword">null</span> &amp;&amp; p2.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode preM = p1;</span><br><span class="line">        ListNode pre = p1.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pre.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode cur = pre.next;</span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">            cur.next = preM.next;</span><br><span class="line">            preM.next = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        p1 = head;</span><br><span class="line">        p2 = preM.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(p1 != preM)&#123;</span><br><span class="line">            preM.next = p2.next;</span><br><span class="line">            p2.next = p1.next;</span><br><span class="line">            p1.next = p2;</span><br><span class="line">            p1 = p2.next;</span><br><span class="line">            p2 = preM.next;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode&quot;&gt;&lt;a href=&quot;#Leetcode&quot; class=&quot;headerlink&quot; title=&quot;Leetcode&quot;&gt;&lt;/a&gt;Leetcode&lt;/h2&gt;&lt;h3 id=&quot;83-Remove-Duplicates-from-Sorted-List&quot;&gt;&lt;a href=&quot;#83-Remove-Duplicates-from-Sorted-List&quot; class=&quot;headerlink&quot; title=&quot;83.Remove Duplicates from Sorted List&quot;&gt;&lt;/a&gt;83.Remove Duplicates from Sorted List&lt;/h3&gt;&lt;p&gt;Given a sorted linked list, delete all duplicates such that each element appear only once.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For example,&lt;br&gt;Given 1-&amp;gt;1-&amp;gt;2, return 1-&amp;gt;2.&lt;br&gt;Given 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3, return 1-&amp;gt;2-&amp;gt;3.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Algorithm and Data Structure" scheme="blog.jiangdongyu.space/categories/Algorithm-and-Data-Structure/"/>
    
    
      <category term="LinkedList" scheme="blog.jiangdongyu.space/tags/LinkedList/"/>
    
  </entry>
  
</feed>
