<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>J&amp;DY</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="blog.jiangdongyu.space/"/>
  <updated>2018-09-05T16:23:05.758Z</updated>
  <id>blog.jiangdongyu.space/</id>
  
  <author>
    <name>Agnes</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第一个不重复的字符串</title>
    <link href="blog.jiangdongyu.space/2018/09/05/%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>blog.jiangdongyu.space/2018/09/05/第一个不重复的字符串/</id>
    <published>2018-09-05T03:44:00.000Z</published>
    <updated>2018-09-05T16:23:05.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一个不重复的字符串"><a href="#第一个不重复的字符串" class="headerlink" title="第一个不重复的字符串"></a>第一个不重复的字符串</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给一个很长的字符串，但是都由26个字母组成，返回一个长度为10的第一个与后面不重复的字符串</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>逐个遍历，利用String自带的contains方法判断</li><li>利用hashmap，空间换时间<ul><li>key: 长度为10的字符串，value: 保存字符串起始位置的list</li><li>两个指针去做</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getFirstSubString</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(str.length() &lt; <span class="number">10</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Map&lt;String,List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= str.length() - <span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(str.substring(low+i,low+<span class="number">10</span>+i)))&#123;</span><br><span class="line">                map.put(str.substring(low+i,low+<span class="number">10</span>+i),<span class="keyword">new</span> ArrayList&lt;&gt;(low+i));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.get(str.substring(low+i,low+<span class="number">10</span>+i)).add(low+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String s: map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(s).size() == <span class="number">1</span>)&#123;</span><br><span class="line">                min = Math.min(min,map.get(s).get(<span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.substring(min,min+<span class="number">10</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一个不重复的字符串&quot;&gt;&lt;a href=&quot;#第一个不重复的字符串&quot; class=&quot;headerlink&quot; title=&quot;第一个不重复的字符串&quot;&gt;&lt;/a&gt;第一个不重复的字符串&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
      <category term="每日一题" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="算法" scheme="blog.jiangdongyu.space/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树转换成双向链表</title>
    <link href="blog.jiangdongyu.space/2018/09/04/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E6%88%90%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>blog.jiangdongyu.space/2018/09/04/二叉搜索树转换成双向链表/</id>
    <published>2018-09-04T03:04:00.000Z</published>
    <updated>2018-09-05T16:22:58.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉搜索树转换成双向链表"><a href="#二叉搜索树转换成双向链表" class="headerlink" title="二叉搜索树转换成双向链表"></a>二叉搜索树转换成双向链表</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul><li>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。</li><li>要求不能创建任何新的结点，只能调整树中结点指针的指向。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>中续遍历</li><li>根节点的左指针指向左子树形成链表的最后一个节点</li><li>根节点的右指针指向右子树形成链表的第一个节点</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">         TreeNode left = Convert(root.left);</span><br><span class="line">         TreeNode p = left;</span><br><span class="line">         <span class="keyword">while</span>(p != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">             p = p.right;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(left != <span class="keyword">null</span>)&#123;</span><br><span class="line">             p.right = root;</span><br><span class="line">             root.left = p;</span><br><span class="line">         &#125;</span><br><span class="line">         TreeNode right = Convert(root.right);</span><br><span class="line">         <span class="keyword">if</span>(right != <span class="keyword">null</span>)&#123;</span><br><span class="line">             root.right = right;</span><br><span class="line">             right.left = root;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> left == <span class="keyword">null</span> ? root:left;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二叉搜索树转换成双向链表&quot;&gt;&lt;a href=&quot;#二叉搜索树转换成双向链表&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树转换成双向链表&quot;&gt;&lt;/a&gt;二叉搜索树转换成双向链表&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
      <category term="每日一题" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="算法" scheme="blog.jiangdongyu.space/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java锁机制</title>
    <link href="blog.jiangdongyu.space/2018/07/31/Java%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>blog.jiangdongyu.space/2018/07/31/Java锁机制/</id>
    <published>2018-07-31T12:25:00.000Z</published>
    <updated>2018-07-31T13:07:24.756Z</updated>
    
    <content type="html"><![CDATA[<p>在开发Java多线程应用程序中，各个线程之间由于要共享资源，必须用到锁机制。Java提供了多种多线程锁机制的实现方式，常见的有synchronized、ReentrantLock、Semaphore、AtomicInteger等。每种机制都有优缺点与各自的适用场景，必须熟练掌握他们的特点才能在Java多线程应用开发时得心应手。——<a href="http://blog.jiangdongyu.space/2018/07/30/%E5%B8%B8%E7%94%A8%E9%94%81%E6%9C%BA%E5%88%B6%E7%AE%80%E4%BB%8B/">Java锁机制详解</a></p><a id="more"></a><p>线程同步有关的类图关系可用以下的图总结：</p><p><img src="http://p9fh1pach.bkt.clouddn.com/1042141-20180119085622974-1501528059.jpg" alt="avatar"></p><ol><li>Java Concurrency API 中的 Lock 接口是什么？对比同步它有什么优势？</li></ol><p>Lock接口比同步方法和同步块（这里的同步就是考察Synchronized关键字）提供了更具扩展性的锁操作。Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性，Lock是一个类，通过这个类可以实现同步访问；他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。它的优势有：可以使锁更<strong>公平</strong>；可以使线程在等待锁的时候<strong>响应中断</strong>；可以让线程<strong>尝试获取锁</strong>，并在无法获取锁的时候立即返回或者等待一段时间；可以在不同的范围，以不同的顺序获取和释放锁。</p><p>关于API及代码的例子请移步：《<a href="https://www.cnblogs.com/dolphin0520/p/3923167.html" target="_blank" rel="noopener">java并发编程Lock</a>》。常用接口方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先<strong>lock()</strong>方法是平常使用得最多的一个方法，就是用来<strong>获取锁</strong>。如果锁已被其他线程获取，则进行等待。由于在前面讲到如果采用Lock，必须<strong>主动</strong>去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用Lock来进行同步的话，是以下面这种形式去使用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//处理任务</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">     </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();   <span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>tryLock()</strong>方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line"><span class="keyword">if</span>(lock.tryLock()) &#123;</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="comment">//处理任务</span></span><br><span class="line">     &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">         </span><br><span class="line">     &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">         lock.unlock();   <span class="comment">//释放锁</span></span><br><span class="line">     &#125; </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果不能获取锁，则直接做其他事情</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>lockInterruptibly()</strong>方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。由于lockInterruptibly()的声明中抛出了异常，所以lock.lockInterruptibly()必须放在try块中或者在调用lockInterruptibly()的方法外声明抛出InterruptedException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">     <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock，意思是“可重入锁”，ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。以下给出一个ReentrantLock的运行实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();    <span class="comment">//注意这个地方，声明为类的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         <span class="comment">//可以用Java箭头函数特性改写上述冗余代码：</span></span><br><span class="line">         <span class="comment">// new Thread()&#123;()-&gt;Thread.currentThread&#125;.start();</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"得到了锁"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                arrayList.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"释放了锁"</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文中提到了Lock接口以及对象，使用它，很优雅的控制了竞争资源的安全访问，但是这种锁不区分读写，称这种锁为普通锁。为了提高性能，Java提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。Java中读写锁有个接口java.util.concurrent.locks. ReadWriteLock，也有具体的实现ReentrantReadWriteLock，因而会有下面的提问：</p><ol start="2"><li>ReadWriteLock是什么？</li></ol><p>读写锁：分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm自己控制的，我们只要上好相应的锁即可。如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁；如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！读写锁接口：<strong>ReadWriteLock</strong>，它的具体实现类为：<strong>ReentrantReadWriteLock</strong>。</p><p>《<a href="https://www.cnblogs.com/liang1101/p/6475555.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">ReadWriteLock场景应用</a>》：在多线程的环境下，对同一份数据进行读写，会涉及到线程安全的问题。比如在一个线程读取数据的时候，另外一个线程在写数据，而导致前后数据的不一致性；一个线程在写数据的时候，另一个线程也在写，同样也会导致线程前后看到的数据的不一致性。这时候可以在读写方法中加入互斥锁，任何时候只能允许一个线程的一个读或写操作，而不允许其他线程的读或写操作，这样是可以解决这样以上的问题，但是效率却大打折扣了。因为在真实的业务场景中，一份数据，读取数据的操作次数通常高于写入数据的操作，而线程与线程间的读读操作是不涉及到线程安全的问题，没有必要加入互斥锁，只要在读-写，写-写期间上锁就行了。</p><ol start="3"><li>锁机制有什么用</li></ol><p>有些业务逻辑在执行过程中要求对数据进行<strong>排他性</strong>的访问，于是需要通过一些机制保证在此过程中数据被锁住不会被外界修改，这就是所谓的锁机制。</p><ol start="4"><li>什么是乐观锁（Optimistic Locking）？如何实现乐观锁？如何避免ABA问题</li></ol><p>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于<strong>多读</strong>的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。</p><ol start="5"><li>解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁</li></ol><p><strong>重入锁（ReentrantLock）</strong>是一种递归无阻塞的同步机制。重入锁，也叫做递归锁，指的是同一线程外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，但不受影响。在JAVA环境下 ReentrantLock 和synchronized 都是可重入锁。</p><p><strong>自旋锁</strong>，由于自旋锁使用者一般保持锁时间非常短，因此选择自旋而不是睡眠是非常必要的，自旋锁的效率远高于互斥锁。如何旋转呢？何为自旋锁，就是如果发现锁定了，不是睡眠等待，而是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时 才能进入临界区。</p><p><strong>偏向锁</strong>(Biased Locking)是Java6引入的一项多线程优化，它会偏向于<strong>第一个访问锁的线程</strong>，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。</p><p><strong>轻量级锁</strong>是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁。</p><p><strong>公平锁</strong>，就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己</p><p><strong>非公平锁</strong>比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。</p><ol start="6"><li>什么时候应该使用可重入锁？</li></ol><p>场景1：如果已加锁，则不再重复加锁。a、忽略重复加锁。b、用在界面交互时点击执行较长时间请求操作时，防止多次点击导致后台重复执行（忽略重复触发）。以上两种情况多用于进行非重要任务防止重复执行，（如：清除无用临时文件，检查某些资源的可用性，数据备份操作等）</p><p>场景2：如果发现该操作已经在执行，则尝试等待一段时间，等待超时则不执行（尝试等待执行）这种其实属于场景2的改进，等待获得锁的操作有一个时间的限制，如果超时则放弃执行。用来防止由于资源处理不当长时间占用导致死锁情况（大家都在等待资源，导致线程队列溢出）。</p><p>场景3：如果发现该操作已经加锁，则等待一个一个加锁（同步执行，类似synchronized）这种比较常见大家也都在用，主要是防止资源使用冲突，保证同一时间内只有一个操作可以使用该资源。但与synchronized的明显区别是性能优势（伴随jvm的优化这个差距在减小）。同时Lock有更灵活的锁定方式，公平锁与不公平锁，而synchronized永远是公平的。这种情况主要用于对资源的争抢（如：文件操作，同步消息发送，有状态的操作等）</p><p>场景4：可中断锁。synchronized与Lock在默认情况下是不会响应中断(interrupt)操作，会继续执行完。lockInterruptibly()提供了可中断锁来解决此问题。（场景3的另一种改进，没有超时，只能等待中断或执行完毕）这种情况主要用于取消某些操作对资源的占用。如：（取消正在同步运行的操作，来防止不正常操作长时间占用造成的阻塞）</p><ol start="7"><li>简述锁的等级方法锁、对象锁、类锁</li></ol><p><strong>方法锁</strong>（synchronized修饰方法时）通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。synchronized 方法控制对类成员变量的访问： 每个类实例对应一把锁，每个 synchronized 方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态，从而有效避免了类成员变量的访问冲突。</p><p><strong>对象锁</strong>（synchronized修饰方法或代码块）当一个对象中有synchronized method或synchronized block的时候调用此对象的同步方法或进入其同步区域时，就必须先获得对象锁。如果此对象的对象锁已被其他调用者占用，则需要等待此锁被释放。（方法锁也是对象锁）。java的所有对象都含有1个互斥锁，这个锁由JVM自动获取和释放。线程进入synchronized方法的时候获取该对象的锁，当然如果已经有线程获取了这个对象的锁，那么当前线程会等待；synchronized方法正常返回或者抛异常而终止，JVM会自动释放对象锁。这里也体现了用synchronized来加锁的1个好处，方法抛异常的时候，锁仍然可以由JVM来自动释放。　</p><p><strong>类锁</strong>(synchronized修饰<strong>静态</strong>的方法或代码块)，由于一个class不论被实例化多少次，其中的静态方法和静态变量在内存中都只有一份。所以，一旦一个静态的方法被申明为synchronized。此类所有的实例化对象在调用此方法，共用同一把锁，我们称之为类锁。对象锁是用来控制实例方法之间的同步，类锁是用来控制静态方法（或静态变量互斥体）之间的同步。类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别的。java类可能会有很多个对象，但是只有1个Class对象，也就是说类的不同实例之间共享该类的Class对象。Class对象其实也仅仅是1个java对象，只不过有点特殊而已。由于每个java对象都有1个互斥锁，而类的静态方法是需要Class对象。所以所谓的类锁，不过是Class对象的锁而已。获取类的Class对象有好几种，最简单的就是［类名.class］的方式。</p><ol start="8"><li>Java中活锁和死锁有什么区别？</li></ol><p>死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。死锁发生的<strong>四个条件</strong></p><ul><li>互斥条件：线程对资源的访问是<strong>排他性</strong>的，如果一个线程对占用了某资源，那么其他线程必须处于等待状态，直到资源被释放。</li><li>请求和保持条件：线程T1至少已经保持了一个资源R1占用,但又提出对另一个资源R2请求，而此时，资源R2被其他线程T2占用，于是该线程T1也必须等待，但又对自己保持的资源R1不释放。</li><li>不剥夺条件：线程已获得的资源，在未使用完之前，不能被其他线程剥夺，只能在使用完以后由自己释放。</li><li>环路等待条件：在死锁发生时，必然存在一个“进程-资源环形链”，即：{p0,p1,p2,…pn},进程p0（或线程）等待p1占用的资源，p1等待p2占用的资源，pn等待p0占用的资源。（最直观的理解是，p0等待p1占用的资源，而p1而在等待p0占用的资源，于是两个进程就相互等待）</li></ul><p><strong>活锁</strong>：是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。</p><ol start="9"><li>如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？</li></ol><p>预防死锁，预先破坏产生死锁的四个条件。互斥不可能破坏，所以有如下3种方法：</p><ul><li>破坏，请求和保持条件<ul><li>进程等所有要请求的资源都空闲时才能申请资源，这种方法会使资源严重浪费（有些资源可能仅在运行初期或结束时才使用，甚至根本不使用）</li><li>允许进程获取初期所需资源后，便开始运行，运行过程中再逐步释放自己占有的资源。比如有一个进程的任务是把数据复制到磁盘中再打印，前期只需要获得磁盘资源而不需要获得打印机资源，待复制完毕后再释放掉磁盘资源。这种方法比上一种好，会使资源利用率上升。</li></ul></li><li>破坏，不可抢占条件。这种方法代价大，实现复杂</li><li>破坏，循坏等待条件。对各进程请求资源的顺序做一个规定，避免相互等待。这种方法对资源的利用率比前两种都高，但是前期要为设备指定序号，新设备加入会有一个问题，其次对用户编程也有限制</li></ul><ol start="10"><li>死锁与饥饿的区别？</li></ol><p><strong>相同点</strong>：二者都是由于竞争资源而引起的。</p><p><strong>不同点</strong>：</p><ul><li>从进程状态考虑，死锁进程都处于等待状态，忙等待(处于运行或就绪状态)的进程并非处于等待状态，但却可能被饿死；</li><li>死锁进程等待永远不会被释放的资源，饿死进程等待会被释放但却不会分配给自己的资源，表现为等待时限没有上界(排队等待或忙式等待)；</li><li>死锁一定发生了循环等待，而饿死则不然。这也表明通过资源分配图可以检测死锁存在与否，但却不能检测是否有进程饿死；</li><li>死锁一定涉及多个进程，而饥饿或被饿死的进程可能只有一个。</li><li>在饥饿的情形下，系统中有至少一个进程能正常运行，只是饥饿进程得不到执行机会。而死锁则可能会最终使整个系统陷入死锁并崩溃</li></ul><ol start="11"><li>怎么检测一个线程是否拥有锁？</li></ol><p>java.lang.Thread中有一个方法叫<strong>holdsLock()</strong>，它返回true如果当且仅当当前线程拥有某个具体对象的锁</p><ol start="12"><li>如何实现分布式锁？</li></ol><ul><li>基于数据库实现分布式锁</li><li>基于缓存（redis，memcached，tair）实现分布式锁</li><li>基于Zookeeper实现分布式锁</li></ul><p>可以参考详情《<a href="http://www.hollischuang.com/archives/1716" target="_blank" rel="noopener">分布式锁的几种实现方式</a>》、《<a href="https://www.cnblogs.com/rwxwsblog/p/6046034.html" target="_blank" rel="noopener">分布式锁的3种方式</a>》</p><ol start="13"><li>Executors类是什么？ Executor和Executors的区别</li></ol><p>正如上面所说，这三者均是 Executor 框架中的一部分。Java 开发者很有必要学习和理解他们，以便更高效的使用 Java 提供的不同类型的线程池。总结一下这三者间的区别，以便大家更好的理解：</p><ul><li>Executor 和 ExecutorService 这两个接口主要的区别是：ExecutorService 接口继承了 Executor 接口，是 Executor 的子接口</li><li>Executor 和 ExecutorService 第二个区别是：Executor 接口定义了 execute()方法用来接收一个Runnable接口的对象，而 ExecutorService 接口中的 submit()方法可以接受Runnable和Callable接口的对象。</li><li>Executor 和 ExecutorService 接口第三个区别是 Executor 中的 execute() 方法不返回任何结果，而 ExecutorService 中的 submit()方法可以通过一个 Future 对象返回运算结果。</li><li>Executor 和 ExecutorService 接口第四个区别是除了允许客户端提交一个任务，ExecutorService 还提供用来控制线程池的方法。比如：调用 shutDown() 方法终止线程池。可以通过 《Java Concurrency in Practice》 一书了解更多关于关闭线程池和如何处理 pending 的任务的知识。</li><li>Executors 类提供工厂方法用来创建不同类型的线程池。比如: newSingleThreadExecutor() 创建一个只有一个线程的线程池，newFixedThreadPool(int numOfThreads)来创建固定线程数的线程池，newCachedThreadPool()可以根据需要创建新的线程，但如果已有线程是空闲的会重用已有线程。</li></ul><table><thead><tr><th style="text-align:left">Executor</th><th style="text-align:left">ExecutorService</th></tr></thead><tbody><tr><td style="text-align:left">Executor 是 Java 线程池的核心接口，用来并发执行提交的任务</td><td style="text-align:left">ExecutorService 是 Executor 接口的扩展，提供了异步执行和关闭线程池的方法</td></tr><tr><td style="text-align:left">提供execute()方法用来提交任务</td><td style="text-align:left">提供submit()方法用来提交任务</td></tr><tr><td style="text-align:left">execute()方法无返回值</td><td style="text-align:left">submit()方法返回Future对象，可用来获取任务执行结果</td></tr><tr><td style="text-align:left">不能取消任务</td><td style="text-align:left">可以通过Future.cancel()取消pending中的任务</td></tr><tr><td style="text-align:left">没有提供和关闭线程池有关的方法</td><td style="text-align:left">提供了关闭线程池的方法</td></tr></tbody></table><ol start="14"><li>什么是Java线程转储(Thread Dump)，如何得到它？</li></ol><p>线程转储是一个JVM活动线程的列表，它对于分析系统瓶颈和死锁非常有用。</p><p>有很多方法可以获取线程转储——使用Profiler，Kill -3命令，jstack工具等等。我更喜欢jstack工具，因为它容易使用并且是JDK自带的。由于它是一个基于终端的工具，所以我们可以编写一些脚本去定时的产生线程转储以待分析。</p><ol start="15"><li>如何在Java中获取线程堆栈？</li></ol><p>Java虚拟机提供了线程转储（thread dump）的后门，通过这个后门可以把线程堆栈打印出来。通常我们将堆栈信息重定向到一个文件中，便于我们分析，由于信息量太大，很可能超出控制台缓冲区的最大行数限制造成信息丢失。这里介绍一个jdk自带的打印线程堆栈的工具，jstack用于打印出给定的Java进程ID或core file或远程调试服务的Java堆栈信息。（<a href="https://blog.csdn.net/weiweicao0429/article/details/53185999" target="_blank" rel="noopener">Java问题定位之Java线程堆栈分析</a>）</p><pre><code>示例：$jstack –l 23561 &gt;&gt; xxx.dump命令 : $jstack [option] pid &gt;&gt; 文件 </code></pre><p>>&gt;表示输出到文件尾部，实际运行中，往往一次dump的信息，还不足以确认问题，建议产生三次dump信息，如果每次dump都指向同一个问题，我们才确定问题的典型性。</p><ol start="16"><li>说出 3 条在 Java 中使用线程的最佳实践</li></ol><ul><li>给你的线程起个有意义的名字。这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor这种名字比Thread-1. Thread-2 and Thread-3好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。</li><li>避免锁定和缩小同步的范围锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。</li><li>多用同步类少用wait和notify，首先，CountDownLatch, Semaphore, CyclicBarrier和Exchanger这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。</li><li>多用并发集合少用同步集合，这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发Java多线程应用程序中，各个线程之间由于要共享资源，必须用到锁机制。Java提供了多种多线程锁机制的实现方式，常见的有synchronized、ReentrantLock、Semaphore、AtomicInteger等。每种机制都有优缺点与各自的适用场景，必须熟练掌握他们的特点才能在Java多线程应用开发时得心应手。——&lt;a href=&quot;http://blog.jiangdongyu.space/2018/07/30/%E5%B8%B8%E7%94%A8%E9%94%81%E6%9C%BA%E5%88%B6%E7%AE%80%E4%BB%8B/&quot;&gt;Java锁机制详解&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="锁" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E9%94%81/"/>
    
    
      <category term="锁" scheme="blog.jiangdongyu.space/tags/%E9%94%81/"/>
    
      <category term="多线程" scheme="blog.jiangdongyu.space/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程基础</title>
    <link href="blog.jiangdongyu.space/2018/07/30/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>blog.jiangdongyu.space/2018/07/30/Java多线程基础/</id>
    <published>2018-07-30T10:53:00.000Z</published>
    <updated>2018-07-30T11:44:24.838Z</updated>
    
    <content type="html"><![CDATA[<p>在一个程序中，能够独立运行的程序片段叫做“线程”，利用它进行编写的程序叫做多线程处理程序。通常情况下，多线程程序能够更好低利用计算机资源，提高程序执行的效率。多线程编程具有重要的意义，每个程序猿都应该掌握。</p><a id="more"></a><p><a href="http://www.cnblogs.com/hanganglin/articles/3517178.html" target="_blank" rel="noopener">本文原文链接</a></p><h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><ul><li>新建状态：用Thread的new语句创建了线程对象，此时对象只在堆内存中分配了内存。</li><li>就绪状态：当新建状态下的线程对象调用了start()方法后，该线程就进入了就绪状态，处于这个状态的线程位于可运行池中，等待获得CPU使用权。</li><li>运行状态：正在被CPU执行的线程状态。</li><li>阻塞状态：当线程因为某种原因处于阻塞状态时，JVM不会给线程分配CPU，直到线程重新进入就绪状态，才有机会被CPU运行。<ul><li>位于对象<strong>等待池</strong>中的阻塞状态：当线程运行获取对象锁后，执行了Object.wait()方法，JVM就会把该线程加入对象的等待池中，这种状态必须等待其他线程调用同个对象的notify()或notifyAll()方法时才有可能激活为就绪状态；</li><li>位于<strong>对象锁</strong>中的阻塞状态：当线程运行时，试图获取某个对象的同步锁时，如果该对象的同步锁已被其他线程占用，则JVM就会把当前线程放入对象的锁池中，当对象的同步锁被释放后，JVM就会根据一定的调度算法，将处于对象锁中阻塞状态的某个线程激活为就绪状态；</li><li>其他阻塞状态：当线程执行了sleep()方法，或者调用了其他线程的join()方法，或发出了I/O请求时，线程就会进入这个状态。</li></ul></li></ul><h2 id="Java创建多线程的几种方式"><a href="#Java创建多线程的几种方式" class="headerlink" title="Java创建多线程的几种方式"></a>Java创建多线程的几种方式</h2><p>Java通过线程类Thread来创建多线程，每个线程是Thread类或其子类的实例对象，每个对象描述了一个单独的线程。Java中创建一个线程，有两种实现方法，详细介绍如下。</p><h3 id="通过继承Thread类创建线程（了解即可，不常用）"><a href="#通过继承Thread类创建线程（了解即可，不常用）" class="headerlink" title="通过继承Thread类创建线程（了解即可，不常用）"></a>通过继承Thread类创建线程（了解即可，不常用）</h3><ul><li>通过这种方式创建的线程之间是彼此相互独立的，各自有用自己的资源，互不干扰。</li><li><strong>缺点</strong>：<ul><li>Java是单继承的，继承Thead类后不能继承其他类，可能不满足开发需求；</li><li>多线程之间无法共享资源。</li></ul></li></ul><h3 id="通过实现Runnable接口创建线程（推荐使用）"><a href="#通过实现Runnable接口创建线程（推荐使用）" class="headerlink" title="通过实现Runnable接口创建线程（推荐使用）"></a>通过实现Runnable接口创建线程（推荐使用）</h3><p>通过继承Thread类创建的多线程可以满足非协同工作的多线程需求，但当要求各个线程之间需要处理共享资源时，只能通过实现Runnable接口的方式。</p><p><strong>优点</strong>：</p><ul><li>避免了Java但继承带来的局限性；</li><li>多线程之间可以共享资源，相互协作。</li></ul><h3 id="通过FutureTask类创建带返回值的线程（需要获得线程返回值时使用）"><a href="#通过FutureTask类创建带返回值的线程（需要获得线程返回值时使用）" class="headerlink" title="通过FutureTask类创建带返回值的线程（需要获得线程返回值时使用）"></a>通过FutureTask类创建带返回值的线程（需要获得线程返回值时使用）</h3><p>FutureTask是一种可以取消的异步的计算任务。它的计算是通过Callable实现的，它等价于<strong>可以携带返回值的Runnable</strong>。</p><p>FutureTask是为了弥补Thread的不足而设计的，它可以让程序员准确地知道线程什么时候执行完成并获得到线程执行完成后返回的结果（如果有需要）。</p><p><strong>FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果</strong></p><h3 id="通过TimerTask类创建计划任务类线程"><a href="#通过TimerTask类创建计划任务类线程" class="headerlink" title="通过TimerTask类创建计划任务类线程"></a>通过TimerTask类创建计划任务类线程</h3><p>Timer和TimerTask是用来创建定时任务，定时任务实质就是一个线程。TimerTask继承了Runnable接口，通过Timer启动计划任务入口有schedule和scheduleAtFixedRate两种方法。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>Java语言的关键字，用它来修饰一个方法或一个代码块的时候，能够保证在同一个时刻最多只有一个线程执行该段代码，可保证修饰的代码在执行过程中不会被其他线程干扰，即<strong>原子性</strong>。</p><h3 id="synchronized可修饰的对象"><a href="#synchronized可修饰的对象" class="headerlink" title="synchronized可修饰的对象"></a>synchronized可修饰的对象</h3><ul><li>synchronized {普通方法}<ul><li>同一时间只能有一个线程访问<strong>同一个对象</strong>的该方法。</li><li>缺点：同步整个方法<strong>效率不高</strong>。 </li><li>synchronized void method() { … }相当于void method( synchronized(this) { … } )</li></ul></li><li>synchronized {代码块}<ul><li>对代码块执行线程同步，效率要高于对整个函数执行同步，<strong>推荐</strong>使用这种方法。</li></ul></li><li>synchronized {static方法}<ul><li>加锁的对象是<strong>类</strong>，同一时间，该类的所有对象中的synchronized static方法只能有一个线程访问。 </li><li>class Foo { public synchronized static fun(){…}}等价于在class Foo { public static fun(){ synchronized(Foo.class){ … } }}</li></ul></li><li>synchronized {run方法}：此时为同步普通方法的特殊情况，由于在线程的整个生命期内run方法一直在运行，因此<strong>同一个Runnable对象的多个线程只能串行运行</strong>。 </li></ul><h3 id="使用synchronized应重点理解以下细节："><a href="#使用synchronized应重点理解以下细节：" class="headerlink" title="使用synchronized应重点理解以下细节："></a>使用synchronized应重点理解以下细节：</h3><ul><li>当多个并发线程访问同一个对象的同步代码块时，一段时间内只能有一个线程得到执行，其他线程必须等待当前线程执行完代码块后再执行代码；</li><li>当一个线程访问一个对象的同步代码块时，其他线程可以访问该对象的中的非同步代码块；</li><li><strong>当一个线程访问一个对象的同步代码块时，其他线程对该对象中的所有同步代码块均不能访问</strong></li></ul><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal主要用来更方便地访问线程内部变量，提供了保持对象的方法和避免参数传递的方便的对象访问方式。查阅了网上很多资料，大都观点说ThreadLocal是用来解决多线程共享对象的访问问题的，对此，本人完全不赞同，这压根就是两码事。当线程调用ThreadLocal.set()方法时，具体的值是保存在线程内部的ThreadLocal.ThreadLocalMap对象中，也就是说，每个线程设值的变量都只限于本线程访问，对于其他线程是隔离的，这与线程同步完全是两码事。</p><p>假设三个打印机进程共享一台打印机资源，通常我们使用同步方法（如synchronized、Lock等）来对打印机进行同步操作，这是为了解决多线程下的安全问题。使用ThreadLocal，相当于增加了两台打印机资源，给每个打印进程分配了一台打印机。</p><p>因此，<strong>ThreadLocal不是用来解决对象共享访问问题的，也不是为线程提供共享变量的副本，而仅仅是为线程隔离对象</strong>。</p><p>此外，线程的数据是保存在线程内部的变量中的，而非保存在ThreadLocal对象中，ThreadLocal的get与set方法可以直接操作线程Thread内部ThreadLocal.ThreadLocalMap对象。在ThreadLocal.ThreadLocalMap中保存了一个Entry数组，通过ThreadLocal对象作为数组下标操作数据。</p><p>在ThreadLocal.ThreadLocalMap中，使用了弱引用WeakReference，避免了内存泄露。</p><p>多线程共享一个数据库连接等适用，为每个线程单独建立一个连接资源。</p><h2 id="线程其他常用操作方法"><a href="#线程其他常用操作方法" class="headerlink" title="线程其他常用操作方法"></a>线程其他常用操作方法</h2><p>1、Object.wait()、Object.notify()和Object.notifyAll()</p><p>Object.wait是指线程在获取对象锁后，由于某些条件的不成立，主动<strong>释放对象锁</strong>，同时本线程进入对象等待池中处于阻塞状态。在synchronized同步块中，一旦线程捕获某个对象的同步锁，系统就很难控制线程，必须等待线程主动释放对象锁，这时候，在同步块内，使用Object.wait()可以使线程在进入synchronized同步块后主动释放对象锁。因此Object.wait()、Object.notify()和Object.notifyAll()方法<strong>必须在synchronized同步块内使用</strong>，否则会抛出IllegalMonitorStateException异常。</p><ul><li>Object.wait() ：线程调用此方法后，只有当其他线程调用同个对象的notify()或notifyAll()方法后，才可能激活为就绪状态；</li><li>Object.wait(long timeout) ：线程调用此方法后，当其他线程调用同个对象的notify()或notifyAll()方法，<strong>或者超过时间timeout</strong>，线程都可能激活为就绪状态。</li></ul><p>当其他线程调用Object.notify()后，JVM会根据调度策略调取一个对象等待池中的线程，将其从阻塞状态激活为就绪状态，当此线程<strong>再次获得对象锁和CPU后</strong>，就可以进入执行状态。</p><p>方法Object.notify()和方法Object.notifyAll()用于将处于wait等待状态的线程激活为就绪状态，notify()是根据调度策略激活某一个线程，notifyAll()是将所有处于等待线程池中的线程全部激活为就绪状态，但是激活后就绪状态的线程要想重新执行，必须再次获得对象锁。 </p><p>2、Thread.sleep(long millis)和Thread.yield()</p><p>这两个方法都会让当前正在执行的线程处于<strong>暂时停止执行</strong>的状态，交出CPU的使用权一段时间。与Object.wait()方法不同的是，Thread.sleep(long millis)和Thread.yield()在暂停线程的同时<strong>不会释放已获得的对象锁</strong>，而Object.wait()会暂停线程并且释放对象锁。</p><p>两者的<strong>区别</strong>如下：</p><ul><li>Thread.sleep方法必须带一个时间参数，单位毫秒，当线程执行sleep后，在指定时间内，将转为<strong>阻塞</strong>状态；Thread.yield方法不带参数，当线程执行yield后，线程将进入<strong>就绪</strong>状态。</li><li>Thread.sleep会抛出InterruptedException异常，而Thread.yield方法不会抛出异常。</li><li>sleep()方法比yield()方法具有更好的移植性。</li><li>sleep()方法会给其他线程运行的机会，而不考虑其他线程的优先级，因此会给较低线程一个运行的机会；yield()方法只会给相同优先级或者更高优先级的线程一个运行的机会。</li></ul><p>实际上，yield()方法对应了如下操作： </p><p>先检测当前是否有<strong>相同优先级</strong>的线程处于同可运行状态，如有，则把 CPU 的占有权交给此线程，否则继续运行原来的线程。所以yield()方法称为“<strong>退让</strong>”，它把运行机会让给了同等优先级的其他线程。yield()只是提前结束当前线程占用CPU的时间，线程转为就绪状态，等待下一个时间片再继续获得CPU并执行。</p><p>3、Thread.join()</p><p>Thread.join()可以将多线程的异步变为同步，在父线程调用子线程的join方法后，必须等待子线程执行结束，父线程才会继续执行下去。Thread.join()方法会抛出InterruptedException异常。</p><p>4、volatile关键字</p><p>volatile是synchronized的一种弱实现，它可以保证变量的<strong>可见性</strong>，而不能保证程序执行的原子性。JVM运行多线程时，在主内存中保存着共享变量，每个线程运行时有一个自己的栈，用来保存从本线程运行需要的变量。当线程访问一个变量值的时候，首先通过对象的引用找到在主内存的地址，然后把变量的值拷贝到本线程的栈中，建立一个变量的副本。在线程对该变量计算的过程中，该变量副本和主内存的原始变量就没有任何关系了，当线程结算结束时，再将变量副本写回到主内存中对象变量的地址中，更新内存中的共享变量，详细的交互过程如下图所示。</p><p><img src="http://p9fh1pach.bkt.clouddn.com/191326344702.jpg" alt="avatar"></p><p>使用volatile修饰的变量，JVM只能保证从主内存加载到线程工作栈中的值是最新的，但使用过程不能完全保证线程对该变量同步的情况，因此，建议少使用volatile，对需要同步的地方使用synchronized。</p><p>5、Thread.start()和Thread.run() </p><p><strong>启动线程应该使用Thread.start()，Thread.run()只是调用Runnable中的run方法，并没有启动线程，此时整个程序还是只有一个线程，顺序执行。</strong></p><p>6、Thread.setDaemon()设置守护线程</p><p>Java中有两类线程，分别是用户线程(User Thread)和守护线程(Daemon Thread)。守护线程是指在程序运行时后台提供一种通用服务的线程，如垃圾回收线程就是一个守护线程，当所有的非守护线程结束时，程序也就终止了，同时会结束所有的守护进程。用户线程和守护线程唯一的区别就是，当程序中只剩守护线程时，程序就会结束，而只要程序中还存在一个非守护线程，程序就不会终止。</p><ul><li>普通线程转换为守护线程。Thread.SetDaemon(true)可以将普通线程转换为守护线程，但是设置必须在Thread.start()之前，否则会报IllegalThreadStateException异常。</li><li>Daemon线程产生的子线程也是Daemon的。</li><li>守护线程应该永远不去访问固有资源，如文件和数据库等，因为他可能随时会中断。</li></ul><p>7、<a href="http://jiangzhengjun.iteye.com/blog/652269" target="_blank" rel="noopener">Thread.interrput()中断线程</a></p><p>调用线程的Thread.interrupt方法中断线程时，JVM将会将对应线程内的中断状态位设置为true，可以在线程执行的方法中调用Thread.interrupted()或Thread.currentThread().isInterrupted()来检测中断位是否为true，至于线程下一步是死亡还是继续执行完全取决于程序本身，这一点与强制结束线程的已废弃的方法stop不同。</p><p>当其他线程通过Thread.interrupt请求中断当前线程时，当前线程可能正处于非阻塞状态、阻塞状态或请求锁临时状态，下面来分析各种状态下如何来中断当前线程。</p><ul><li>被请求中断时，当前线程处于非阻塞状态。<ul><li>此时可以在程序中调用方法获取线程内中断状态位的值，并根据该值自由决定是否结束当前线程。获取中断位值建议有两种方法:</li><li>Thread.currentThread().isInterrupted()方法，返回状态值</li><li>Thread.interrupted()静态方法，返回状态值，<strong>并将中断位状态值重置为false</strong>。也就是说，此时若调用两次Thread.interrupted()方法，第二次方法返回值为false。因此<strong>建议使用方法Thread.currentThread().isInterrupted()来获取中断位状态值</strong>，常见线程循环时的中断方式如下所示：</li><li>另一种实现方式-使用中断信号量(共享变量)中断非阻塞状态线程也是一种很受欢迎的方式，其实笔者认为，这种方式与使用Thread.interrupt来实现中断的内部机理是一样的。</li></ul></li></ul><pre><code>while(!Thread.currentThread().isInterrupted() &amp;&amp; more work to do){      do more work  } </code></pre><ul><li>被请求中断时，当前线程处于阻塞状态。 <ul><li>对于由于调用Object.wait()、Thread.sleep()或Thread.join()等方式而处于阻塞状态的线程，被请求中断时会<strong>抛出异常InterruptException</strong>，使当前线程从阻塞状态激活进入异常代码块，便于结束。注意，在抛出异常InterruptException后，中断状态位会被重置为false，因此<strong>在使用Thread.currentThread().isInterrupted()检测循环是否中断的代码块内，若捕捉到此异常，必须将状态位重新设置为true，否则线程循环将永不停止。</strong><ul><li>对由于请求I/O操作而处于阻塞状态的线程，被请求中断时，I/O通道会立即被关闭，并抛出异常ClosedByInterruptException，处理方式与上述一致。</li><li>被请求中断时，当前线程正处于获取锁的过程中，这时候线程是无法响应中断的，也就是说，<strong>当线程采用synchronized争夺锁资源而发生死锁时，使用Thread.interrupt是无法使线程中断的。补充一点，当使用Lock锁并且通过方法lockInterruptibly()设置响应中断锁时，线程可以被中断</strong>。</li></ul></li></ul></li></ul><p>8、TimeUnit枚举工具</p><p>TimeUnit是一个枚举，可以使用它来简化某些操作，如让线程休眠5分钟，可以写成：TimeUnit.MINUTES.sleep(5)，相当于Thread.sleep(5*60*1000)，时间会在TimeUnit内部自动转化。</p><p>9、Condition.await()、Condition.signal()和Condition.signalAll()</p><p>同Object.wait()、Object.notify()和Object.notifyAll()对应功能一致，Object的方法用于synchronized同步块中，而Condition的方法用于ReentrantLock的lock()与unlock()之间。</p><p>可用Reentrant.newCondition()来产生一个新的Condition。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一个程序中，能够独立运行的程序片段叫做“线程”，利用它进行编写的程序叫做多线程处理程序。通常情况下，多线程程序能够更好低利用计算机资源，提高程序执行的效率。多线程编程具有重要的意义，每个程序猿都应该掌握。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="blog.jiangdongyu.space/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java锁机制简介</title>
    <link href="blog.jiangdongyu.space/2018/07/30/%E5%B8%B8%E7%94%A8%E9%94%81%E6%9C%BA%E5%88%B6%E7%AE%80%E4%BB%8B/"/>
    <id>blog.jiangdongyu.space/2018/07/30/常用锁机制简介/</id>
    <published>2018-07-30T10:53:00.000Z</published>
    <updated>2018-07-31T10:33:22.267Z</updated>
    
    <content type="html"><![CDATA[<p>在开发Java多线程应用程序中，各个线程之间由于要共享资源，必须用到锁机制。Java提供了多种多线程锁机制的实现方式，常见的有<strong>synchronized、ReentrantLock、Semaphore、AtomicInteger</strong>等。每种机制都有优缺点与各自的适用场景，必须熟练掌握他们的特点才能在Java多线程应用开发时得心应手。</p><a id="more"></a><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>几乎每一个Java开发人员都认识synchronized，使用它来实现多线程的同步操作是非常简单的，只要在需要同步的对方的方法、类或代码块中加入该关键字，它能够保证在同一个时刻最多只有一个线程执行同一个对象的同步代码，可保证修饰的代码在执行过程中不会被其他线程干扰。使用synchronized修饰的代码具有<strong>原子性和可见性</strong>，在需要进程同步的程序中使用的频率非常高，可以满足一般的进程同步要求（详见《<a href="http://blog.jiangdongyu.space/2018/07/30/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">Java多线程基础</a>》）。</p><p><strong>synchronized实现的机理依赖于软件层面上的JVM</strong>，因此其性能会随着Java版本的不断升级而提高。事实上，在Java1.5中，synchronized是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。到了Java1.6，synchronized进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的Java1.7与1.8中，均对该关键字的实现机理做了优化。</p><p>需要说明的是，<strong>当线程通过synchronized等待锁时是不能被Thread.interrupt()中断的</strong>，因此程序设计时必须检查确保合理，否则可能会造成线程死锁的尴尬境地。</p><p>最后，尽管Java实现的锁机制有很多种，并且有些锁机制性能也比synchronized高，但还是强烈推荐在多线程应用程序中使用该关键字，因为实现方便，后续工作由JVM来完成，可靠性高。只有在确定锁机制是当前多线程程序的性能瓶颈时，才考虑使用其他机制，如ReentrantLock等。</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>可重入锁，顾名思义，这个锁可以被线程多次重复进入进行获取操作。ReentantLock继承接口Lock并实现了接口中定义的方法，除了能完成synchronized所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。</p><p><strong>Lock实现的机理依赖于特殊的CPU指定</strong>，可以认为不受JVM的约束，并可以通过其他语言平台来完成底层的实现。在并发量较小的多线程应用程序中，ReentrantLock与synchronized性能相差无几，但在高并发量的条件下，synchronized性能会迅速下降几十倍，而ReentrantLock的性能却能依然维持一个水准，因此我们建议在<strong>高并发量</strong>情况下使用ReentrantLock。</p><p>ReentrantLock引入两个概念：<strong>公平锁与非公平锁</strong>。<strong>公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁。反之，JVM按随机、就近原则分配锁的机制则称为不公平锁</strong>。ReentrantLock在构造函数中提供了是否公平锁的初始化方式，默认为非公平锁。这是因为，非公平锁实际执行的效率要远远超出公平锁，除非程序有特殊需要，否则最常用非公平锁的分配机制。</p><p>ReentrantLock通过方法lock()与unlock()来进行加锁与解锁操作，与synchronized会被JVM自动解锁机制不同，ReentrantLock加锁后需要手动进行解锁。为了避免程序出现异常而无法正常解锁的情况，使用ReentrantLock必须在finally控制块中进行解锁操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">try &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    //...进行任务操作</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们详细介绍有关ReentrantLock提供的<strong>可响应中断锁、可轮询锁请求、定时锁</strong>等机制与操作方式。</p><p>1、线程在等待资源过程中需要中断</p><p>ReentrantLock的在<strong>获取锁的过程</strong>中有2种锁机制，<strong>忽略中断锁</strong>和<strong>响应中断锁</strong>。当等待线程A或其他线程尝试中断线程A时，忽略中断锁机制则不会接收中断，而是继续处于等待状态；响应中断锁则会处理这个中断请求，并将线程A由阻塞状态唤醒为就绪状态，不再请求和等待资源。</p><p><strong>lock.lock()</strong>可设置锁机制为忽略中断锁，<strong>lock.lockInterruptibly()</strong>可设置锁机制为响应中断锁。</p><p>ReentrantLock.lockInterruptibly()方法可设置线程在<strong>获取锁的时候</strong>响应其他线程对当前线程发出的中断请求。但必须注意，<strong>此处响应中断锁是指正在获取锁的过程中，如果线程此时并非处于获取锁的状态，通过此方法设置是无法中断线程的</strong>，非阻塞状态可根据中断标记位Thread.currentThread().isInterrupted()在程序中手动设置中断，阻塞状态可通过抛出异常InterruptedException来中断线程，详细可参考博文《<a href="http://blog.jiangdongyu.space/2018/07/30/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">Java多线程基础</a>》。</p><p>2、实现可轮询的锁请求</p><p>在synchronized中，一旦发生死锁，唯一能够恢复的办法只能重新启动程序，唯一的预防方法是在设计程序时考虑完善不要出错。而有了Lock以后，死锁问题就有了新的预防办法，它提供了<strong>tryLock()</strong>轮询方法来获得锁，如果锁可用则获取锁，如果锁不可用，则此方法返回false，并不会为了等待锁而阻塞线程，这极大地降低了死锁情况的发生。典型使用语句如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line"><span class="keyword">if</span>(lock.tryLock())&#123;</span><br><span class="line">    <span class="comment">//锁可用，则成功获取锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取锁后进行处理</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//锁不可用，其他处理方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、定时锁请求</p><p>在synchronized中，一旦发起锁请求，该请求就不能停止了，如果不能获得锁，则当前线程会阻塞并等待获得锁。在某些情况下，你可能需要让线程在一定时间内去获得锁，如果在指定时间内无法获取锁，则让线程放弃锁请求，转而执行其他的操作。Lock就提供了定时锁的机制，使用<strong>Lock.tryLock(long timeout, TimeUnit unit)</strong>来指定让线程在timeout单位时间内去争取锁资源，如果超过这个时间仍然不能获得锁，则放弃锁请求，定时锁可以避免线程陷入死锁的境地。</p><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>上述两种锁机制类型都是“互斥锁”，学过操作系统的都知道，互斥是进程同步关系的一种特殊情况，相当于只存在一个临界资源，因此同时最多只能给一个线程提供服务。但是，在实际复杂的多线程应用程序中，可能存在多个临界资源，这时候我们可以借助Semaphore信号量来完成多个临界资源的访问。</p><p>Semaphore基本能完成ReentrantLock的所有工作，使用方法也与之类似，通过acquire()与release()方法来获得和释放临界资源。经实测，<strong>Semaphone.acquire()方法默认为可响应中断锁</strong>，与ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被Thread.interrupt()方法中断。</p><p>此外，Semaphore也实现了可轮询的锁请求与定时锁的功能，除了方法名tryAcquire与tryLock不同，其使用方法与ReentrantLock几乎一致。Semaphore也提供了公平与非公平锁的机制，也可在构造函数中进行设定。</p><p>Semaphore的锁释放操作也由手动进行，因此与ReentrantLock一样，为避免线程因抛出异常而无法正常释放锁的情况发生，<strong>释放锁的操作也必须在finally代码块中完成</strong>。</p><p>Semaphore支持多个临界资源，而ReentrantLock只支持一个临界资源，笔者认为ReentrantLock是Semaphore的一种特殊情况。</p><h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><p>首先说明，此处AtomicInteger是一系列相同类的代表之一，常见的还有AtomicLong、AtomicLong等，他们的实现原理相同，区别在与运算对象类型的不同。令人兴奋地，还可以通过<strong>AtomicReference<v></v></strong>将一个对象的所有操作转化成原子操作。</p><p>我们知道，在多线程程序中，诸如++i 或 i++等运算不具有原子性，是不安全的线程操作之一。通常我们会使用synchronized将该操作变成一个原子操作，但JVM为此类操作特意提供了一些同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger的性能是ReentantLock的好几倍。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发Java多线程应用程序中，各个线程之间由于要共享资源，必须用到锁机制。Java提供了多种多线程锁机制的实现方式，常见的有&lt;strong&gt;synchronized、ReentrantLock、Semaphore、AtomicInteger&lt;/strong&gt;等。每种机制都有优缺点与各自的适用场景，必须熟练掌握他们的特点才能在Java多线程应用开发时得心应手。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="锁" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E9%94%81/"/>
    
    
      <category term="锁" scheme="blog.jiangdongyu.space/tags/%E9%94%81/"/>
    
      <category term="多线程" scheme="blog.jiangdongyu.space/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>揭秘Spring AOP</title>
    <link href="blog.jiangdongyu.space/2018/07/26/%E6%8F%AD%E7%A7%98Spring%20AOP/"/>
    <id>blog.jiangdongyu.space/2018/07/26/揭秘Spring AOP/</id>
    <published>2018-07-26T11:33:00.000Z</published>
    <updated>2018-07-30T08:48:02.143Z</updated>
    
    <content type="html"><![CDATA[<p>AOP要解决的问题：分离功能性需求和非功能性需求</p><p><strong>使用场景</strong></p><ul><li>权限控制</li><li>缓存控制</li><li>事务控制</li><li>审计日志</li><li>性能监控</li></ul><h3 id="切面表达式"><a href="#切面表达式" class="headerlink" title="切面表达式"></a>切面表达式</h3><ul><li>designators指示器，描述通过什么方式去匹配类的哪些方法</li><li>Wildcards通配符</li><li>operators运算符</li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/aop1.png" alt="avatar"></p><p><img src="http://p9fh1pach.bkt.clouddn.com/aop2.png" alt="avatar"></p><ul><li>within表达式</li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/aop3.png" alt="avatar"></p><p><img src="http://p9fh1pach.bkt.clouddn.com/aop4.png" alt="avatar"></p><p><img src="http://p9fh1pach.bkt.clouddn.com/aop5.png" alt="avatar"></p><p><img src="http://p9fh1pach.bkt.clouddn.com/aop6.png" alt="avatar"></p><ul><li>execution表达式</li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/aop7.png" alt="avatar"></p><p>?表示可以省略</p><ul><li>advice注解<br><img src="http://p9fh1pach.bkt.clouddn.com/aop8.png" alt="avatar"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AOP要解决的问题：分离功能性需求和非功能性需求&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用场景&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;权限控制&lt;/li&gt;
&lt;li&gt;缓存控制&lt;/li&gt;
&lt;li&gt;事务控制&lt;/li&gt;
&lt;li&gt;审计日志&lt;/li&gt;
&lt;li&gt;性能监控&lt;/li&gt;
&lt;/ul
      
    
    </summary>
    
      <category term="JavaWeb" scheme="blog.jiangdongyu.space/categories/JavaWeb/"/>
    
      <category term="Spring" scheme="blog.jiangdongyu.space/categories/JavaWeb/Spring/"/>
    
      <category term="AOP" scheme="blog.jiangdongyu.space/categories/JavaWeb/Spring/AOP/"/>
    
    
      <category term="Spring" scheme="blog.jiangdongyu.space/tags/Spring/"/>
    
      <category term="AOP" scheme="blog.jiangdongyu.space/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="blog.jiangdongyu.space/2018/07/26/Redis/"/>
    <id>blog.jiangdongyu.space/2018/07/26/Redis/</id>
    <published>2018-07-26T07:39:00.000Z</published>
    <updated>2018-07-26T10:20:30.162Z</updated>
    
    <content type="html"><![CDATA[<h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><p>为什么需要NoSQL？</p><ul><li>高并发读写</li><li>海量数据的高效率存储与访问</li><li>高可扩展性和高可用性</li></ul><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul><li>应用场景<ul><li>缓存</li><li>任务队列</li><li>应用排行榜</li><li>网站访问统计</li><li>数据过期处理</li><li>分布式集群架构中的session分离</li></ul></li><li>数据类型<ul><li>String</li><li>List：rpoplpush</li><li>Set</li><li>Hash</li><li>Sorted Set </li></ul></li><li>持久化<ul><li>RDB：定时内存快照，在指定的时间间隔写入硬盘</li><li>AOF：将以日志，记录每一个操作，服务器启动后就构建数据库，修改同步</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;NoSQL&quot;&gt;&lt;a href=&quot;#NoSQL&quot; class=&quot;headerlink&quot; title=&quot;NoSQL&quot;&gt;&lt;/a&gt;NoSQL&lt;/h3&gt;&lt;p&gt;为什么需要NoSQL？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高并发读写&lt;/li&gt;
&lt;li&gt;海量数据的高效率存储与访问&lt;/li&gt;
      
    
    </summary>
    
      <category term="数据库基础" scheme="blog.jiangdongyu.space/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Redis" scheme="blog.jiangdongyu.space/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Redis/"/>
    
    
      <category term="Redis" scheme="blog.jiangdongyu.space/tags/Redis/"/>
    
      <category term="NoSQL" scheme="blog.jiangdongyu.space/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>菜鸟二面</title>
    <link href="blog.jiangdongyu.space/2018/07/24/%E8%8F%9C%E9%B8%9F%E4%BA%8C%E9%9D%A2/"/>
    <id>blog.jiangdongyu.space/2018/07/24/菜鸟二面/</id>
    <published>2018-07-24T13:41:00.000Z</published>
    <updated>2018-07-25T11:53:50.427Z</updated>
    
    <content type="html"><![CDATA[<p>还是聊了半个小时- -</p><a id="more"></a><ul><li>介绍学习、实习、项目情况</li><li>介绍影响最深、提升能力最快的项目</li><li>问一些相对比较难的题</li><li>SpringBoot和Spring的区别<ul><li>SpringBoot是在Spring上的快速开发包</li><li>SpringBoot内嵌了一些容器，比如tomcat</li><li>问内嵌的tomcat和不内嵌的有什么区别？内嵌的无需部署war文件</li></ul></li><li>MyBatis和Hibernate有什么区别？<ul><li>MyBatis半自动，Hibernate全自动</li><li>Hibernate为什么能实现全自动？</li><li>通过对象关系模型来实现对数据库的操作，并且拥有完整的JavaBean对象来自动拼装SQL语句。</li></ul></li><li>问觉得阿里和微软的区别</li><li>给了些建议- -</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;还是聊了半个小时- -&lt;/p&gt;
    
    </summary>
    
      <category term="面试经历" scheme="blog.jiangdongyu.space/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    
      <category term="2018" scheme="blog.jiangdongyu.space/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018/"/>
    
      <category term="秋招" scheme="blog.jiangdongyu.space/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018/%E7%A7%8B%E6%8B%9B/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>79. Word Search</title>
    <link href="blog.jiangdongyu.space/2018/07/24/79.%20Word%20Search/"/>
    <id>blog.jiangdongyu.space/2018/07/24/79. Word Search/</id>
    <published>2018-07-24T10:00:00.000Z</published>
    <updated>2018-07-24T10:12:00.908Z</updated>
    
    <content type="html"><![CDATA[<p>Given a 2D board and a word, find if the word exists in the grid.</p><p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><a id="more"></a><p><strong>Example:</strong></p><pre><code>board =[  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]Given word = &quot;ABCCED&quot;, return true.Given word = &quot;SEE&quot;, return true.Given word = &quot;ABCB&quot;, return false.</code></pre><p><strong>思路：</strong><br>还算是比较明显的dfs的题。</p><ul><li>首先需要找到word首字母的位置，才能接着判断</li><li>接下来就是递归的过程，上下左右都有可能</li><li>同时为了避免当前再被递归到，需要将当前值先修改再恢复</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word == <span class="keyword">null</span> || word.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="keyword">null</span> || board.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; board.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; board[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == word.charAt(<span class="number">0</span>) &amp;&amp; exists(board, word, i, j, <span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(<span class="keyword">char</span>[][] board, String word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word.length() == start) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; board.length &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; board[<span class="number">0</span>].length &amp;&amp; board[i][j] == word.charAt(start))&#123;</span><br><span class="line">            board[i][j] = <span class="string">'$'</span>;</span><br><span class="line">            <span class="keyword">boolean</span> res = exists(board, word, i-<span class="number">1</span>, j, start+<span class="number">1</span>) || exists(board, word, i+<span class="number">1</span>, j, start+<span class="number">1</span>) || exists(board, word, i, j-<span class="number">1</span>, start+<span class="number">1</span>) || exists(board, word, i, j+<span class="number">1</span>, start+<span class="number">1</span>);</span><br><span class="line">            board[i][j] = word.charAt(start);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a 2D board and a word, find if the word exists in the grid.&lt;/p&gt;
&lt;p&gt;The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.&lt;/p&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
      <category term="刷题打卡" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/"/>
    
    
      <category term="Array" scheme="blog.jiangdongyu.space/tags/Array/"/>
    
      <category term="BackTracking" scheme="blog.jiangdongyu.space/tags/BackTracking/"/>
    
  </entry>
  
  <entry>
    <title>第四范式</title>
    <link href="blog.jiangdongyu.space/2018/07/19/%E7%AC%AC%E5%9B%9B%E8%8C%83%E5%BC%8F/"/>
    <id>blog.jiangdongyu.space/2018/07/19/第四范式/</id>
    <published>2018-07-19T06:30:00.000Z</published>
    <updated>2018-07-20T12:10:50.513Z</updated>
    
    <content type="html"><![CDATA[<p>第四范式 Java 开发实习生 面试</p><a id="more"></a><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ul><li>自我介绍</li><li>介绍一下项目</li><li>Exception &amp;&amp; Error      </li><li>synchronized关键字static修饰和没有static修饰<ul><li>比如synchronized修饰方法，让循环输出1-10，new两个类，调用该线程</li><li>作用域不同，static修饰指同步类，输出两次1-10</li><li>非static修饰，是同步局部变量，不能确定结果</li></ul></li><li>final修饰字段，方法，类<ul><li>字段不可变</li><li>方法不可override</li><li>类不能被继承</li></ul></li><li>String,StringBuilder,StringBuffer <ul><li>String不可变，源码是用final修饰的private数组，同时方法等没改变数组的值</li><li>StringBuilder，StringBuffer都可变，StringBuffer线程安全</li></ul></li><li>ArrayList和LinkedList<ul><li>同：实现List接口</li><li>异：ArrayList查 O(1),增删 O(n)</li><li>LinkedList查 O(n),增删 O(1)</li></ul></li><li>知不知道Dequeue?</li><li>实现最小栈GetMin()<ul><li>leetcode原题155.Min Stack</li></ul></li></ul><p><strong>Q: Exception &amp;&amp; Error</strong></p><p><img src="http://p9fh1pach.bkt.clouddn.com/20160603151809323.jpeg" alt="avatar"></p><p>A: Error和Exception都继承自<strong>Throwable</strong>；</p><p><strong>Exception：</strong></p><blockquote><p>RuntimeException 类及其子类表示“JVM 常用操作”引发的错误</p></blockquote><ul><li>可以是可被控制（checked）或者不可控制（unchecked）；<ul><li>unchecked exception（非检查异常）: 运行时异常,比如常见的NullPointerException、IndexOutOfBoundsException。对于运行时异常，java编译器<strong>不要求</strong>必须进行异常捕获处理或者抛出声明，由程序员自行决定。</li><li>checked exception（检查异常，编译异常）: 非运行时异常,java编译器<strong>强制</strong>程序员必须进行捕获处理，比如常见的IOExeption和SQLException。对于非运行时异常如果不进行捕获或者抛出声明处理，编译都不会通过。</li></ul></li><li>表示一个由<strong>程序员</strong>导致的错误；</li><li>应该在应用程序级被处理；</li></ul><p><strong>Error：</strong></p><blockquote><p>大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。</p></blockquote><ul><li>总是不可控制的（unchecked）；</li><li>经常用来表示<strong>系统错误或者底层资源</strong>错误；</li><li>如果可能的话，应该在系统级被捕捉；</li></ul><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ul><li>自我介绍</li><li>项目介绍比较详细</li><li>问了下熟悉的技术</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第四范式 Java 开发实习生 面试&lt;/p&gt;
    
    </summary>
    
      <category term="面试经历" scheme="blog.jiangdongyu.space/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    
      <category term="2018" scheme="blog.jiangdongyu.space/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018/"/>
    
      <category term="实习" scheme="blog.jiangdongyu.space/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018/%E5%AE%9E%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS通信过程</title>
    <link href="blog.jiangdongyu.space/2018/07/19/HTTPS%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B/"/>
    <id>blog.jiangdongyu.space/2018/07/19/HTTPS通信过程/</id>
    <published>2018-07-19T05:04:00.000Z</published>
    <updated>2018-07-26T11:23:29.901Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取。所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。</p><a id="more"></a><h3 id="HTTPS简介"><a href="#HTTPS简介" class="headerlink" title="HTTPS简介"></a>HTTPS简介</h3><p>HTTPS其实是有两部分组成：<strong>HTTP + SSL / TLS</strong>，也就是在HTTP上又加了一层<strong>处理加密信息的模块</strong>。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。具体是如何进行加密，解密，验证的，且看下图。</p><p><img src="http://p9fh1pach.bkt.clouddn.com/20121130144420002.png" alt="avatar"></p><ul><li>客户端发起HTTPS请求<ul><li>这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。</li></ul></li><li>服务端的配置<ul><li>采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对<strong>公钥和私钥</strong>。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</li></ul></li><li>传送证书<ul><li>这个证书其实就是<strong>公钥</strong>，只是包含了很多信息，如证书的颁发机构，过期时间等等。</li></ul></li><li>客户端解析证书<ul><li>这部分工作是有客户端的TLS来完成的，首先会<strong>验证公钥是否有效</strong>，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就<strong>生成一个随机值</strong>。然后用*8证书对该随机值进行加密**。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</li></ul></li><li>传送加密信息<ul><li>这部分<strong>传送的是用证书加密后的随机值</strong>，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</li></ul></li><li>服务段解密信息<ul><li>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行<strong>对称加密</strong>。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</li></ul></li><li>传输加密后的信息<ul><li>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原</li></ul></li><li>客户端解密信息<ul><li>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取。所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="blog.jiangdongyu.space/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTPS" scheme="blog.jiangdongyu.space/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/"/>
    
    
      <category term="计算机网络" scheme="blog.jiangdongyu.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTPS" scheme="blog.jiangdongyu.space/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>菜鸟一面</title>
    <link href="blog.jiangdongyu.space/2018/07/19/%E8%8F%9C%E9%B8%9F%E4%B8%80%E9%9D%A2/"/>
    <id>blog.jiangdongyu.space/2018/07/19/菜鸟一面/</id>
    <published>2018-07-19T03:24:00.000Z</published>
    <updated>2018-07-25T11:42:14.729Z</updated>
    
    <content type="html"><![CDATA[<p>说了下午有事，就简单聊了半个小时</p><a id="more"></a><ul><li>为什么要用多线程</li><li>线程是不是越多效率越快？</li><li>怎么控制线程，尽可能减少上下文切换？或者说有没有一种方式达到了多线程的效果，但是避免了上下文切换？<ul><li>提示concurrent包里有</li></ul></li><li>讲一下Spring IOC，为什么要控制反转？目的是啥？IOC的过程？</li><li>两个int型的set求交集？</li><li>求交集的同时，还要给出相同的数字的个数？</li><li>如果set特别大，大到无法在内存处理，怎么办？</li><li>Linux的了解？</li><li>问微软的pipeline导入为什么能提高效率？</li><li>问了下职业规划</li></ul><p><strong>如何减少上下文切换？</strong></p><p>减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。</p><ul><li>无锁并发并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。</li><li>CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要加锁。<ul><li>CAS:Compare and Swap,是比较并交换的意思。</li><li>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</li></ul></li><li>使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。</li><li>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说了下午有事，就简单聊了半个小时&lt;/p&gt;
    
    </summary>
    
      <category term="面试经历" scheme="blog.jiangdongyu.space/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    
      <category term="2018" scheme="blog.jiangdongyu.space/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018/"/>
    
      <category term="秋招" scheme="blog.jiangdongyu.space/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018/%E7%A7%8B%E6%8B%9B/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Keep</title>
    <link href="blog.jiangdongyu.space/2018/07/17/Keep/"/>
    <id>blog.jiangdongyu.space/2018/07/17/Keep/</id>
    <published>2018-07-17T06:00:00.000Z</published>
    <updated>2018-07-20T12:10:58.976Z</updated>
    
    <content type="html"><![CDATA[<p>Keep Java 开发实习生 面试</p><a id="more"></a><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ul><li>自我介绍</li><li>问项目</li><li>int[]数组长度为n，问数组中连续m个数的最大值</li><li>链表反转</li><li>20w条ip地址的数据，给一个ip地址，怎么找到？</li><li>设计用户发微博的数据库，以及查看首页功能<ul><li>首页时间线表，但对于大V发微博，告知关注者的时间线处理有问题</li></ul></li><li>微博用户群组问题，怎么做到分群组？<ul><li>图的BFS</li></ul></li><li>对设计的微博的表，怎么建索引？建索引为什么会快？</li><li>http和https的区别？https的加密过程？</li></ul><p>Q：哪些情况需要加索引？</p><ul><li>在经常需要<strong>搜索的列</strong>上，可以加快搜索的速度；</li><li>在作为<strong>主键</strong>的列上，强制该列的唯一性和组织表中数据的排列结构；</li><li>在经常用在<strong>连接的列</strong>上，这些列主要是一些外键，可以加快连接的速度；</li><li>在经常需要<strong>根据范围进行搜索的列</strong>上创建索引，因为索引已经排序，其指定的范围是连续的；</li><li>在经常需要<strong>排序的列</strong>上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li><li>在经常使用在<strong>WHERE子句中的列</strong>上面创建索引，加快条件的判断速度。</li></ul><p>Q：哪些情况不需要加索引？</p><ul><li>第一，对于那些在查询中<strong>很少使用或者参考</strong>的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li><li>第二，对于那些只有<strong>很少数据值</strong>的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</li><li>第三，对于那些定义为<strong>text, image和bit</strong>数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 </li><li>第四，当<strong>修改性能远远大于检索性能时</strong>，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li></ul><p>Q：数据库建立索引为什么会加快查询速度？</p><p>首先明白为什么索引会增加速度，DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行<strong>全表扫描</strong>，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段<strong>增加索引</strong>，查询时就会<strong>先去索引列表中一次定位到特定值的行数</strong>，大大减少遍历匹配的行数，所以能明显增加查询的速度。</p><p><a href="http://blog.jiangdongyu.space/2018/07/19/HTTPS%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B/">HTTPS通信过程</a></p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ul><li>介绍项目</li><li>垃圾回收策略</li><li>HotSpot垃圾收集器，G1的特点，优缺点…<ul><li><a href="http://blog.jiangdongyu.space/2018/06/06/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/">垃圾收集器与内存分配策略</a></li></ul></li><li>为什么Eden: Survivor: Survivor是8:1:1 ?</li><li>IOC，IOC的初始化过程？</li><li>AOP，AOP的动态代理怎么做？ <ul><li>InvocationHandler接口</li></ul></li><li>concurrent包里有些啥？</li><li><strong>ThreadPoolExecutor类得看源码</strong></li><li>Java锁机制，Java怎么实现CAS的？多线程i++问题？AtomicInteger？UnSafe类？</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Keep Java 开发实习生 面试&lt;/p&gt;
    
    </summary>
    
      <category term="面试经历" scheme="blog.jiangdongyu.space/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    
      <category term="2018" scheme="blog.jiangdongyu.space/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018/"/>
    
      <category term="实习" scheme="blog.jiangdongyu.space/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018/%E5%AE%9E%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>对Spring IOC和AOP的理解</title>
    <link href="blog.jiangdongyu.space/2018/07/15/Spring%20IOC%20AOP/"/>
    <id>blog.jiangdongyu.space/2018/07/15/Spring IOC AOP/</id>
    <published>2018-07-15T14:45:00.000Z</published>
    <updated>2018-07-26T11:26:41.906Z</updated>
    
    <content type="html"><![CDATA[<p>在面试中，经常会问，说说你对Spring IOC和AOP的理解，问题很宽泛，似乎不知道从何说起。</p><p><strong>回答思路</strong>：</p><ul><li>先用通俗易懂的话解释下何为IOC和AOP</li><li>各自的实现原理</li><li>自己的项目中如何使用</li></ul><p>以下是个人的一些总结，仅供参考。</p><a id="more"></a><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>许多应用都是通过彼此间的相互合作来实现业务逻辑的，如类A要调用类B的方法，以前我们都是在类A中，通过自身new一个类B，然后在调用类B的方法，现在我们把new类B的事情交给Spring来做，在我们调用的时候，容器会为我们实例化。</p><ul><li>IOC容器的初始化过程<ul><li>资源定位，即定义bean的xml</li><li>载入</li><li>IOC容器注册，注册beanDefinition</li></ul></li></ul><p>IOC容器的初始化过程，一般不包含bean的依赖注入的实现，在Spring IOC设计中，bean的<strong>注册</strong>和<strong>依赖注入</strong>是两个过程，依赖注入一般发生在应用<strong>第一次索取bean</strong>的时候，但是也可以在xm中配置，在容器初始化的时候，这个bean就完成了初始化。</p><p>三种<strong>注入方式</strong>：</p><ul><li>构造器</li><li>接口</li><li>set注入(常用)</li></ul><p>bean是如何创建——<strong>工厂模式</strong></p><p>数据是如何注入——<strong>反射</strong></p><p><a href="http://blog.jiangdongyu.space/2018/07/13/Spring%20IOC%E5%8E%9F%E7%90%86/">IOC的定义及实现原理</a></p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>面向切面编程，在我们的应用中，经常需要做一些事情，但是这些事情<strong>与核心业务无关</strong>，比如，要记录所有update*方法的执行时间时间，操作人等等信息，记录到日志，</p><p>通过Spring的AOP技术，就可以在不修改update*的代码的情况下完成该需求。</p><p>AOP的好处就是你只需要干你的正事，其它事情别人帮你干。</p><p>从Spring的角度看，AOP最大的用途就在于提供了<strong>事务管理</strong>的能力。事务管理就是一个关注点，你的正事就是去访问数据库，而你不想管事务（太烦），所以，Spring在你访问数据库之前，自动帮你开启事务，当你访问数据库结束之后，自动帮你提交/回滚事务！</p><p><a href="http://blog.jiangdongyu.space/2018/07/13/%E7%90%86%E8%A7%A3AOP/">AOP的实现原理——代理</a></p><p><a href="http://blog.jiangdongyu.space/2018/07/15/AOP%E7%9A%84%E5%BA%94%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/">AOP的应用的三种实现方式</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在面试中，经常会问，说说你对Spring IOC和AOP的理解，问题很宽泛，似乎不知道从何说起。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回答思路&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先用通俗易懂的话解释下何为IOC和AOP&lt;/li&gt;
&lt;li&gt;各自的实现原理&lt;/li&gt;
&lt;li&gt;自己的项目中如何使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是个人的一些总结，仅供参考。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="blog.jiangdongyu.space/categories/JavaWeb/"/>
    
      <category term="Spring" scheme="blog.jiangdongyu.space/categories/JavaWeb/Spring/"/>
    
    
      <category term="Spring" scheme="blog.jiangdongyu.space/tags/Spring/"/>
    
      <category term="AOP" scheme="blog.jiangdongyu.space/tags/AOP/"/>
    
      <category term="IOC" scheme="blog.jiangdongyu.space/tags/IOC/"/>
    
  </entry>
  
  <entry>
    <title>AOP的应用的三种实现方式</title>
    <link href="blog.jiangdongyu.space/2018/07/15/AOP%E7%9A%84%E5%BA%94%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>blog.jiangdongyu.space/2018/07/15/AOP的应用的三种实现方式/</id>
    <published>2018-07-15T08:22:00.000Z</published>
    <updated>2018-07-26T11:42:28.765Z</updated>
    
    <content type="html"><![CDATA[<p>Spring有两大核心，IOC和AOP。IOC在java web项目中无时无刻不在使用。然而AOP用的比较少，的确也是一般的项目用的场所不多。<strong>事务控制</strong>基本都用，但却是Spring封装的不需要我们再去实现，但Spring的AOP远不止这些。</p><a id="more"></a><h2 id="概念术语"><a href="#概念术语" class="headerlink" title="概念术语　　"></a>概念术语　　</h2><p>在开始之前，需要理解Spring AOP的一些基本的概念术语(总结的个人理解，并非Spring官方定义)：</p><ul><li><strong>切面</strong>(aspect)：用来切插业务方法的类。</li><li><strong>连接点</strong>(joinpoint)：是切面类和业务类的连接点，其实就是封装了业务方法的一些基本属性，作为通知的参数来解析。</li><li><strong>通知</strong>(advice)：在切面类中，声明对业务方法做额外处理的方法。</li><li><strong>切入点</strong>(pointcut)：业务类中指定的方法，作为切面切入的点。其实就是指定某个方法作为切面切的地方。</li><li><strong>目标对象</strong>(target object)：被代理对象。</li><li><strong>AOP代理</strong>(aop proxy)：代理对象。</li><li><strong>AOP通知类型</strong>：<ul><li>前置通知(before advice)：在切入点之前执行。</li><li>后置通知(after returning advice)：在切入点执行完成后，执行通知。</li><li>环绕通知(around advice)：包围切入点，调用方法前后完成自定义行为。</li><li>异常通知(after throwing advice)：在切入点抛出异常后，执行通知。</li></ul></li></ul><h2 id="Spring-AOP环境"><a href="#Spring-AOP环境" class="headerlink" title="Spring AOP环境"></a>Spring AOP环境</h2><p>要在项目中使用Spring AOP则需要在项目中导入除了spring jar包之外，还有aspectjweaver.jar，aopalliance.jar，asm.jar和cglib.jar 。</p><p>好了，前提工作准备完成，Spring提供了很多的实现AOP的方式，在学习过程中，循序渐进。进行<strong>Spring接口方式</strong>，<strong>Schema配置方式</strong>和<strong>注解</strong>的三种方式进行学习。好了废话不多说了，开始Spring AOP学习之旅：</p><h3 id="AOP接口"><a href="#AOP接口" class="headerlink" title="AOP接口"></a>AOP接口</h3><p>利用Spring AOP接口实现AOP，主要是为了指定自定义通知来供Spring AOP机制识别。主要接口：前置通知 MethodBeforeAdvice，后置通知：AfterReturningAdvice，环绕通知：MethodInterceptor，异常通知：ThrowsAdvice 。见例子代码：</p><h4 id="业务接口："><a href="#业务接口：" class="headerlink" title="业务接口："></a>业务接口：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理类接口，也是业务类接口</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 利用接口的方式，spring aop 将默认通过jdk 动态代理来实现代理类</span></span><br><span class="line"><span class="comment"> * 不利用接口，则spring aop 将通过cglib 来实现代理类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBaseBusiness</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用作代理的切入点方法</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">(String obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这方法不被切面切</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(String obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这方法切不切呢？可以设置</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modify</span><span class="params">(String obj)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务类："><a href="#业务类：" class="headerlink" title="业务类："></a>业务类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务类，也是目标对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBusiness</span> <span class="keyword">implements</span> <span class="title">IBaseBusiness</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切入点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========调用切入点："</span> + obj + <span class="string">"说：你敢删除我！===========\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄～"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"================这个方法不能被切。。。============== \n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄～ 嘿嘿！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modify</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=================这个也设置加入切吧====================\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄改瞄啊！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通知类："><a href="#通知类：" class="headerlink" title="通知类："></a>通知类：</h4><ul><li>前置通知：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前置通知。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBeforeAdvice</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * method : 切入的方法</span></span><br><span class="line"><span class="comment">     * args ：切入方法的参数</span></span><br><span class="line"><span class="comment">     * target ：目标对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========进入beforeAdvice()============ \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"准备在"</span> + target + <span class="string">"对象上用"</span>);</span><br><span class="line">        System.out.print(method + <span class="string">"方法进行对 '"</span>);</span><br><span class="line">        System.out.print(args[<span class="number">0</span>] + <span class="string">"'进行删除！\n\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"要进入切入点方法了 \n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>后置通知：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后置通知</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAfterReturnAdvice</span> <span class="keyword">implements</span> <span class="title">AfterReturningAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * returnValue ：切入点执行完方法的返回值，但不能修改</span></span><br><span class="line"><span class="comment">     * method ：切入点方法</span></span><br><span class="line"><span class="comment">     * args ：切入点方法的参数数组</span></span><br><span class="line"><span class="comment">     * target ：目标对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========进入afterReturning()=========== \n"</span>);</span><br><span class="line">        System.out.println(<span class="string">"切入点方法执行完了 \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(args[<span class="number">0</span>] + <span class="string">"在"</span>);</span><br><span class="line">        System.out.print(target + <span class="string">"对象上被"</span>);</span><br><span class="line">        System.out.print(method + <span class="string">"方法删除了"</span>);</span><br><span class="line">        System.out.print(<span class="string">"只留下："</span> + returnValue + <span class="string">"\n\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>环绕通知：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 环绕通知</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAroundAdvice</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * invocation ：连接点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========进入around环绕方法！=========== \n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用目标方法之前执行的动作</span></span><br><span class="line">        System.out.println(<span class="string">"调用方法之前: 执行！\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法的参数</span></span><br><span class="line">        Object[] args = invocation.getArguments();</span><br><span class="line">        <span class="comment">// 调用的方法</span></span><br><span class="line">        Method method = invocation.getMethod();</span><br><span class="line">        <span class="comment">// 获取目标对象</span></span><br><span class="line">        Object target = invocation.getThis();</span><br><span class="line">        <span class="comment">// 执行完方法的返回值：调用proceed()方法，就会触发切入点方法执行</span></span><br><span class="line">        Object returnValue = invocation.proceed();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"===========结束进入around环绕方法！=========== \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"输出："</span> + args[<span class="number">0</span>] + <span class="string">";"</span> + method + <span class="string">";"</span> + target + <span class="string">";"</span> + returnValue + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"调用方法结束：之后执行！\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>异常通知：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异常通知，接口没有包含任何方法。通知方法自定义</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAfterThrowsAdvice</span> <span class="keyword">implements</span> <span class="title">ThrowsAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知方法，需要按照这种格式书写</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">     *            可选：切入的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     *            可选：切入的方法的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     *            可选：目标对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> throwable</span></span><br><span class="line"><span class="comment">     *            必填 : 异常子类，出现这个异常类的子类，则会进入这个通知。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(Method method, Object[] args, Object target, Throwable throwable)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除出错啦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义指定切点："><a href="#定义指定切点：" class="headerlink" title="定义指定切点："></a>定义指定切点：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个切点，指定对应方法匹配。来供切面来针对方法进行处理&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 继承NameMatchMethodPointcut类，来用方法名匹配</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pointcut</span> <span class="keyword">extends</span> <span class="title">NameMatchMethodPointcut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3990456017285944475L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置单个方法匹配</span></span><br><span class="line">        <span class="keyword">this</span>.setMappedName(<span class="string">"delete"</span>);</span><br><span class="line">        <span class="comment">// 设置多个方法匹配</span></span><br><span class="line">        String[] methods = &#123; <span class="string">"delete"</span>, <span class="string">"modify"</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//也可以用“ * ” 来做匹配符号</span></span><br><span class="line">        <span class="comment">// this.setMappedName("get*");</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setMappedNames(methods);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.matches(method, targetClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context/spring-context-3.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/aop     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ==============================利用spring自己的aop配置================================ --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 声明一个业务类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baseBusiness"</span> <span class="attr">class</span>=<span class="string">"aop.base.BaseBusiness"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 声明通知类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baseBefore"</span> <span class="attr">class</span>=<span class="string">"aop.base.advice.BaseBeforeAdvice"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baseAfterReturn"</span> <span class="attr">class</span>=<span class="string">"aop.base.advice.BaseAfterReturnAdvice"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baseAfterThrows"</span> <span class="attr">class</span>=<span class="string">"aop.base.advice.BaseAfterThrowsAdvice"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baseAround"</span> <span class="attr">class</span>=<span class="string">"aop.base.advice.BaseAroundAdvice"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定切点匹配类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"pointcut"</span> <span class="attr">class</span>=<span class="string">"aop.base.pointcut.Pointcut"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 包装通知，指定切点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"matchBeforeAdvisor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.DefaultPointcutAdvisor"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pointcut"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"pointcut"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"advice"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"baseBefore"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用ProxyFactoryBean 产生代理对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"businessProxy"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 代理对象所实现的接口 ，如果有接口可以这样设置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"proxyInterfaces"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>aop.base.IBaseBusiness<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 设置目标对象 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"baseBusiness"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 代理对象所使用的拦截器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>matchBeforeAdvisor<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>baseAfterReturn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>baseAround<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="测试类："><a href="#测试类：" class="headerlink" title="测试类："></a>测试类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Debug</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"aop/schema_aop.xml"</span>);</span><br><span class="line">        IBaseBusiness business = (IBaseBusiness ) context.getBean(<span class="string">"businessProxy"</span>);</span><br><span class="line">        business.delete(<span class="string">"猫"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的代码实现可以从代码注释中很容易理解<strong>接口方式</strong>的实现。结果也可想而知，前置方法会在切入点方法之前执行，后置会在切入点方法执行之后执行，环绕则会在切入点方法执行前执行同时方法结束也会执行对应的部分。主要是调用proceed()方法来执行切入点方法。来作为环绕通知前后方法的分水岭。然后在实现的过程中，有几点却是可以细揣摩一下的。</p><p>可以看出在xml配置businessProxy这个bean的时候，ProxyFactoryBean类中指定了，proxyInterfaces参数。这里我把他配置了IBaseBusiness接口。因为在项目开发过程中，往往业务类都会有对应的接口，以方便利用IOC解耦。但Spring AOP却也能支持没有接口的代理。这就是为什么需要导入cglib.jar的包。看过spring的源码，知道在目标切入对象如果有实现接口，spring会默认走jdk动态代理来实现代理类。如果没有接口，则会通过cglib来实现代理类。</p><p>这个业务类现在有<strong>前置通知，后置通知，环绕</strong>三个通知同时作用，可能以及更多的通知进行作用。那么这些通知的执行顺序是怎么样的？就这个例子而言，同时实现了三个通知。在例子xml中，则显示执行before通知，然后执行around的前处理，执行切点方法，再执行return处理。最后执行around的后处理。经过测试，知道spring处理顺序是按照xml配置顺序依次处理通知，以队列的方式存放前通知，以压栈的方式存放后通知。所以是<strong>前通知依次执行，后通知到切入点执行完之后，从栈里在后进先出的形式把后通知执行</strong>。</p><p>在实现过程中发现通知执行对应目标对象的整个类中的方法，如何精确到某个方法，则需要定义一个切点匹配的方式：spring提供了方法名匹配或正则方式来匹配。然后通过DefaultPointcutAdvisor来包装通知，指定切点.</p><p>利用方式一的配置起来，可见代码还是非常的厚重的，<strong>定义一个切面就要定义一个切面类，然而切面类中，就一个通知方法</strong>，着实没有必要。所以Spring提供了，依赖aspectj的schema配置和基于aspectj 注解方式。这两种方式非常简介方便使用，也是项目中普遍的使用方式。梳理之：</p><h3 id="schema配置"><a href="#schema配置" class="headerlink" title="schema配置"></a>schema配置</h3><h4 id="业务类：-1"><a href="#业务类：-1" class="headerlink" title="业务类："></a>业务类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectBusiness</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切入点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========调用切入点："</span> + obj + <span class="string">"说：你敢删除我！===========\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄～"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"================这个方法不能被切。。。============== \n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄～ 嘿嘿！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modify</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=================这个也设置加入切吧====================\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄改瞄啊！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切面类："><a href="#切面类：" class="headerlink" title="切面类："></a>切面类：</h4><p>切面类中，包含了所有的通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个切面</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint jp)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========进入before advice============ \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"准备在"</span> + jp.getTarget().getClass() + <span class="string">"对象上用"</span>);</span><br><span class="line">        System.out.print(jp.getSignature().getName() + <span class="string">"方法进行对 '"</span>);</span><br><span class="line">        System.out.print(jp.getArgs()[<span class="number">0</span>] + <span class="string">"'进行删除！\n\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"要进入切入点方法了 \n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jp</span></span><br><span class="line"><span class="comment">     *            连接点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">     *            返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(JoinPoint jp, String result)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========进入after advice=========== \n"</span>);</span><br><span class="line">        System.out.println(<span class="string">"切入点方法执行完了 \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(jp.getArgs()[<span class="number">0</span>] + <span class="string">"在"</span>);</span><br><span class="line">        System.out.print(jp.getTarget().getClass() + <span class="string">"对象上被"</span>);</span><br><span class="line">        System.out.print(jp.getSignature().getName() + <span class="string">"方法删除了"</span>);</span><br><span class="line">        System.out.print(<span class="string">"只留下："</span> + result + <span class="string">"\n\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pjp</span></span><br><span class="line"><span class="comment">     *            连接点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAround</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========进入around环绕方法！=========== \n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用目标方法之前执行的动作</span></span><br><span class="line">        System.out.println(<span class="string">"调用方法之前: 执行！\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法的参数</span></span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        <span class="comment">// 调用的方法名</span></span><br><span class="line">        String method = pjp.getSignature().getName();</span><br><span class="line">        <span class="comment">// 获取目标对象</span></span><br><span class="line">        Object target = pjp.getTarget();</span><br><span class="line">        <span class="comment">// 执行完方法的返回值：调用proceed()方法，就会触发切入点方法执行</span></span><br><span class="line">        Object result = pjp.proceed();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"输出："</span> + args[<span class="number">0</span>] + <span class="string">";"</span> + method + <span class="string">";"</span> + target + <span class="string">";"</span> + result + <span class="string">"\n"</span>);</span><br><span class="line">        System.out.println(<span class="string">"调用方法结束：之后执行！\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doThrow</span><span class="params">(JoinPoint jp, Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除出错啦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context/spring-context-3.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/aop     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ==============================利用spring 利用aspectj来配置AOP================================ --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 声明一个业务类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aspectBusiness"</span> <span class="attr">class</span>=<span class="string">"aop.schema.AspectBusiness"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 声明通知类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aspectAdvice"</span> <span class="attr">class</span>=<span class="string">"aop.schema.advice.AspectAdvice"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"businessAspect"</span> <span class="attr">ref</span>=<span class="string">"aspectAdvice"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置指定切入的对象 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"point_cut"</span> <span class="attr">expression</span>=<span class="string">"execution(* aop.schema.*.*(..))"</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 只匹配add方法作为切入点</span></span><br><span class="line"><span class="comment">            &lt;aop:pointcut id="except_add" expression="execution(* aop.schema.*.add(..))" /&gt;</span></span><br><span class="line"><span class="comment">             --&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 前置通知 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"doBefore"</span> <span class="attr">pointcut-ref</span>=<span class="string">"point_cut"</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 后置通知 returning指定返回参数 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"doAfter"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">pointcut-ref</span>=<span class="string">"point_cut"</span> <span class="attr">returning</span>=<span class="string">"result"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"doAround"</span> <span class="attr">pointcut-ref</span>=<span class="string">"point_cut"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"doThrow"</span> <span class="attr">pointcut-ref</span>=<span class="string">"point_cut"</span> <span class="attr">throwing</span>=<span class="string">"e"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="测试类：-1"><a href="#测试类：-1" class="headerlink" title="测试类："></a>测试类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Debug</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"aop/schema_aop.xml"</span>);</span><br><span class="line">        AspectBusiness business = (AspectBusiness) context.getBean(<span class="string">"aspectBusiness"</span>);</span><br><span class="line">        business.delete(<span class="string">"猫"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="aspectj注解"><a href="#aspectj注解" class="headerlink" title="aspectj注解"></a>aspectj注解</h3><p>注解在项目中已经到处都是了，撇开一些优劣不提，开发的便利性和可读性是非常的方便的。用来配置Spring AOP也非常简单便利</p><h4 id="业务类：-2"><a href="#业务类：-2" class="headerlink" title="业务类："></a>业务类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Business</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切入点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========调用切入点："</span> + obj + <span class="string">"说：你敢删除我！===========\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄～"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"================这个方法不能被切。。。============== \n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄～ 嘿嘿！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modify</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=================这个也设置加入切吧====================\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄改瞄啊！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切面类：-1"><a href="#切面类：-1" class="headerlink" title="切面类："></a>切面类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义切面</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Aspect</span> : 标记为切面类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Pointcut</span> : 指定匹配切点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Before</span> : 指定前置通知，value中指定切入点匹配</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@AfterReturning</span> ：后置通知，具有可以指定返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@AfterThrowing</span> ：异常通知</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定切入点匹配表达式，注意它是以方法的形式进行声明的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* aop.annotation.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(value = <span class="string">"execution(* aop.annotation.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint jp)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========进入before advice============ \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"准备在"</span> + jp.getTarget().getClass() + <span class="string">"对象上用"</span>);</span><br><span class="line">        System.out.print(jp.getSignature().getName() + <span class="string">"方法进行对 '"</span>);</span><br><span class="line">        System.out.print(jp.getArgs()[<span class="number">0</span>] + <span class="string">"'进行删除！\n\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"要进入切入点方法了 \n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jp</span></span><br><span class="line"><span class="comment">     *            连接点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">     *            返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(value = <span class="string">"anyMethod()"</span>, returning = <span class="string">"result"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(JoinPoint jp, String result)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========进入after advice=========== \n"</span>);</span><br><span class="line">        System.out.println(<span class="string">"切入点方法执行完了 \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(jp.getArgs()[<span class="number">0</span>] + <span class="string">"在"</span>);</span><br><span class="line">        System.out.print(jp.getTarget().getClass() + <span class="string">"对象上被"</span>);</span><br><span class="line">        System.out.print(jp.getSignature().getName() + <span class="string">"方法删除了"</span>);</span><br><span class="line">        System.out.print(<span class="string">"只留下："</span> + result + <span class="string">"\n\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pjp</span></span><br><span class="line"><span class="comment">     *            连接点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around</span>(value = <span class="string">"execution(* aop.annotation.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAround</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========进入around环绕方法！=========== \n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用目标方法之前执行的动作</span></span><br><span class="line">        System.out.println(<span class="string">"调用方法之前: 执行！\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法的参数</span></span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        <span class="comment">// 调用的方法名</span></span><br><span class="line">        String method = pjp.getSignature().getName();</span><br><span class="line">        <span class="comment">// 获取目标对象</span></span><br><span class="line">        Object target = pjp.getTarget();</span><br><span class="line">        <span class="comment">// 执行完方法的返回值：调用proceed()方法，就会触发切入点方法执行</span></span><br><span class="line">        Object result = pjp.proceed();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"输出："</span> + args[<span class="number">0</span>] + <span class="string">";"</span> + method + <span class="string">";"</span> + target + <span class="string">";"</span> + result + <span class="string">"\n"</span>);</span><br><span class="line">        System.out.println(<span class="string">"调用方法结束：之后执行！\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(value = <span class="string">"execution(* aop.annotation.*.*(..))"</span>, throwing = <span class="string">"e"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doThrow</span><span class="params">(JoinPoint jp, Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除出错啦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置：-1"><a href="#配置：-1" class="headerlink" title="配置："></a>配置：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context/spring-context-3.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/aop     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"aop.annotation"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 打开aop 注解 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="测试类：-2"><a href="#测试类：-2" class="headerlink" title="测试类："></a>测试类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Debug</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"aop/annotation_aop.xml"</span>);</span><br><span class="line">        Business business = (Business) context.getBean(<span class="string">"business"</span>);</span><br><span class="line">        business.delete(<span class="string">"猫"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring有两大核心，IOC和AOP。IOC在java web项目中无时无刻不在使用。然而AOP用的比较少，的确也是一般的项目用的场所不多。&lt;strong&gt;事务控制&lt;/strong&gt;基本都用，但却是Spring封装的不需要我们再去实现，但Spring的AOP远不止这些。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="blog.jiangdongyu.space/categories/JavaWeb/"/>
    
      <category term="Spring" scheme="blog.jiangdongyu.space/categories/JavaWeb/Spring/"/>
    
      <category term="AOP" scheme="blog.jiangdongyu.space/categories/JavaWeb/Spring/AOP/"/>
    
    
      <category term="Spring" scheme="blog.jiangdongyu.space/tags/Spring/"/>
    
      <category term="AOP" scheme="blog.jiangdongyu.space/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>AOP的定义实现原理——代理</title>
    <link href="blog.jiangdongyu.space/2018/07/13/%E7%90%86%E8%A7%A3AOP/"/>
    <id>blog.jiangdongyu.space/2018/07/13/理解AOP/</id>
    <published>2018-07-13T12:05:00.000Z</published>
    <updated>2018-07-30T08:30:41.131Z</updated>
    
    <content type="html"><![CDATA[<p>Aspect Oriented Programming面向切面编程。解耦是程序员编码开发过程中一直追求的。AOP也是为了解耦所诞生。</p><p><strong>具体思想</strong>是：定义一个切面，在切面的纵向定义处理方法，处理完成之后，回到横向业务流。</p><p>AOP在Spring框架中被作为核心组成部分之一，的确Spring将AOP发挥到很强大的功能。最常见的就是<strong>事务控制</strong>。</p><p>AOP 主要是利用<strong>代理模式</strong>的技术来实现的。</p><a id="more"></a><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><blockquote><p>就是设计模式中的proxy模式</p></blockquote><ul><li>业务接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象主题角色：声明了真实主题和代理主题的共同接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITalk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String msg)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>业务实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真实主题角色：定义真实的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeopleTalk</span> <span class="keyword">implements</span> <span class="title">ITalk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String username;</span><br><span class="line">    <span class="keyword">public</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PeopleTalk</span><span class="params">(String username, String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(msg + <span class="string">"!你好,我是"</span> + username + <span class="string">"，我年龄是"</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代理对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理主题角色：内部包含对真实主题的引用，并且提供和真实主题角色相同的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkProxy</span> <span class="keyword">implements</span> <span class="title">ITalk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ITalk talker;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TalkProxy</span><span class="params">(ITalk talker)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// super();</span></span><br><span class="line">        <span class="keyword">this</span>.talker = talker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        talker.talk(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String msg, String singname)</span> </span>&#123;</span><br><span class="line">        talker.talk(msg);</span><br><span class="line">        sing(singname);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">(String singname)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"唱歌："</span> + singname);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理测试类，使用代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyPattern</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不需要执行额外方法的。</span></span><br><span class="line">        ITalk people = <span class="keyword">new</span> PeopleTalk(<span class="string">"AOP"</span>, <span class="string">"18"</span>);</span><br><span class="line">        people.talk(<span class="string">"No ProXY Test"</span>);</span><br><span class="line">        System.out.println(<span class="string">"-----------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要执行额外方法的（切面）</span></span><br><span class="line">        TalkProxy talker = <span class="keyword">new</span> TalkProxy(people);</span><br><span class="line">        talker.talk(<span class="string">"ProXY Test"</span>, <span class="string">"代理"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码可以看出来，代理模式其实就是AOP的雏形。上端代码中talk(String msg, String singname)是一个切面。在代理类中的sing(singname)方法是个后置处理方法。</p><p>这样就实现了，其他的辅助方法和业务方法的解耦。业务不需要专门去调用，而是走到talk方法，顺理成章的调用sing方法</p><p>再从这段代码看：</p><ul><li>要实现代理方式，必须要定义接口。</li><li>每个业务类，需要一个代理类。</li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><blockquote><p>jdk1.5中提供，利用反射。实现InvocationHandler接口。</p><p>业务接口还是必须得，业务接口，业务类同上。</p></blockquote><ul><li>代理类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 需要代理的目标类 */</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写法固定，aop专用:绑定委托对象并返回一个代理类</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delegate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Object</span></span><br><span class="line"><span class="comment">     *            target：指被代理的对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Method</span></span><br><span class="line"><span class="comment">     *            method：要调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Object</span></span><br><span class="line"><span class="comment">     *            [] args：方法调用时所需要的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 切面之前执行</span></span><br><span class="line">        System.out.println(<span class="string">"切面之前执行"</span>);</span><br><span class="line">        <span class="comment">// 执行业务</span></span><br><span class="line">        result = method.invoke(target, args);</span><br><span class="line">        <span class="comment">// 切面之后执行</span></span><br><span class="line">        System.out.println(<span class="string">"切面之后执行"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 绑定代理，这种方式会在所有的方法都加上切面方法</span></span><br><span class="line">        ITalk iTalk = (ITalk) <span class="keyword">new</span> DynamicProxy().bind(<span class="keyword">new</span> PeopleTalk());</span><br><span class="line">        iTalk.talk(<span class="string">"业务说明"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果会是：</p><pre><code>切面之前执行people talk业务说明切面之后执行</code></pre><p>说明只要在业务调用方法切面之前，是可以动态的加入需要处理的方法。</p><p>从代码来看，如果再建立一个业务模块，也只需要一个代理类。ITalk iTalk = (ITalk) new DynamicProxy().bind(new PeopleTalk()); 将业务接口和业务类绑定到动态代理类。</p><p>但是这种方式：还是需要定义接口。</p><h3 id="利用cglib"><a href="#利用cglib" class="headerlink" title="利用cglib"></a>利用cglib</h3><blockquote><p>CGLIB是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强。采用的是继承的方式。</p></blockquote><ul><li>业务类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeopleTalk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"people talk"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>cglib代理类</li></ul><blockquote><p>MethodInterceptor</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用cglib动态代理</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建代理对象</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());</span><br><span class="line">        <span class="comment">// 回调方法</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">"事物开始"</span>);</span><br><span class="line">        result = methodProxy.invokeSuper(proxy, args);</span><br><span class="line">        System.out.println(<span class="string">"事物结束"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PeopleTalk peopleTalk = (PeopleTalk) <span class="keyword">new</span> CglibProxy().getInstance(<span class="keyword">new</span> PeopleTalk());</span><br><span class="line">        peopleTalk.talk(<span class="string">"业务方法"</span>);</span><br><span class="line">        peopleTalk.spreak(<span class="string">"业务方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出结果：</p><pre><code>事物开始people talk业务方法事物结束事物开始spreak chinese业务方法事物结束</code></pre><h3 id="AOP创建过程"><a href="#AOP创建过程" class="headerlink" title="AOP创建过程"></a>AOP创建过程</h3><p><img src="http://p9fh1pach.bkt.clouddn.com/aop9.png" alt="avatar"></p><ul><li>如何选择JDK动态代理还是继承cglib</li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/aop10.png" alt="avatar"></p><p><img src="http://p9fh1pach.bkt.clouddn.com/aop11.png" alt="avatar"></p><p>多个AOP的类调用，采用<strong>责任链模式</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Aspect Oriented Programming面向切面编程。解耦是程序员编码开发过程中一直追求的。AOP也是为了解耦所诞生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体思想&lt;/strong&gt;是：定义一个切面，在切面的纵向定义处理方法，处理完成之后，回到横向业务流。&lt;/p&gt;
&lt;p&gt;AOP在Spring框架中被作为核心组成部分之一，的确Spring将AOP发挥到很强大的功能。最常见的就是&lt;strong&gt;事务控制&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;AOP 主要是利用&lt;strong&gt;代理模式&lt;/strong&gt;的技术来实现的。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="blog.jiangdongyu.space/categories/JavaWeb/"/>
    
      <category term="Spring" scheme="blog.jiangdongyu.space/categories/JavaWeb/Spring/"/>
    
      <category term="AOP" scheme="blog.jiangdongyu.space/categories/JavaWeb/Spring/AOP/"/>
    
    
      <category term="Spring" scheme="blog.jiangdongyu.space/tags/Spring/"/>
    
      <category term="AOP" scheme="blog.jiangdongyu.space/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>IOC的定义及实现原理——反射</title>
    <link href="blog.jiangdongyu.space/2018/07/13/Spring%20IOC%E5%8E%9F%E7%90%86/"/>
    <id>blog.jiangdongyu.space/2018/07/13/Spring IOC原理/</id>
    <published>2018-07-13T11:22:00.000Z</published>
    <updated>2018-07-26T11:42:38.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IOC-DI"><a href="#IOC-DI" class="headerlink" title="IOC(DI)"></a>IOC(DI)</h2><p>Java程序员都知道：Java程序中的每个业务逻辑至少需要两个或以上的对象来协作完成，通常，每个对象在使用他的合作对象时，自己均要使用像new object()这样的语法来完成合作对象的申请工作。你会发现，对象间的耦合度高了。而IOC的<strong>思想</strong>是: <strong>Spring容器来实现这些相互依赖对象的创建、协调工作</strong>。对象只需要关系业务逻辑本身就可以了。从这方面来说，对象如何得到他的协作对象的责任被反转了(IOC、DI)。</p><a id="more"></a><p>DI其实就是IOC的另外一种说法。DI是由Martin Fowler 在2004年初的一篇论文中首次提出的。他总结：<strong>控制的什么被反转了？就是：获得依赖对象的方式反转了</strong>。</p><h3 id="IOC与DI"><a href="#IOC与DI" class="headerlink" title="IOC与DI"></a>IOC与DI</h3><p>首先想说说IOC(Inversion of Control，控制倒转)。这是Spring的<strong>核心</strong>，贯穿始终。所谓IOC，对于Spring框架来说，就是<strong>由Spring来负责控制对象的生命周期和对象间的关系</strong>。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，<strong>在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。</strong></p><p>那么IOC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，<strong>所有的类都会在Spring容器中登记</strong>，告诉Spring你是个什么东西，你需要什么东西，然后Spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。<strong>所有的类的创建、销毁都由Spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是Spring</strong>。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被Spring控制，所以这叫控制反转。</p><p>IOC的一个重点是在系统运行中，<strong>动态</strong>地向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了Spring我们就只需要告诉Spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，Spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖Connection才能正常运行，而这个Connection是由Spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢? Java 1.3之后一个重要特征是<strong>反射</strong>(reflection)，它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，<strong>Spring就是通过反射来实现注入的</strong>。</p><h3 id="Spring是怎么运行的"><a href="#Spring是怎么运行的" class="headerlink" title="Spring是怎么运行的"></a>Spring是怎么运行的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> ApplicationContext context = <span class="keyword">new</span> FileSystemXmlApplicationContext(</span><br><span class="line"><span class="string">"applicationContext.xml"</span>);</span><br><span class="line"> Animal animal = (Animal) context.getBean(<span class="string">"animal"</span>);</span><br><span class="line"> animal.say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>applicationContext.xml</strong>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"animal"</span> <span class="attr">class</span>=<span class="string">"phz.springframework.test.Cat"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"kitty"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>类phz.springframework.test.Cat:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"I am "</span> + name + <span class="string">"!"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = name;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了phz.springframework.test.Animal接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显上面的代码输出<strong>I am kitty!</strong></p><h3 id="实现Spring"><a href="#实现Spring" class="headerlink" title="实现Spring"></a>实现Spring</h3><p>那么到底Spring是如何做到的呢？</p><p>接下来就让我们自己写个Spring来看看Spring到底是怎么运行的吧！ </p><p>首先，我们定义一个Bean类，这个类用来存放一个Bean拥有的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/* Bean Id */</span></span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"><span class="comment">/* Bean Class */</span></span><br><span class="line"><span class="keyword">private</span> String type;</span><br><span class="line"><span class="comment">/* Bean Property */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; properties = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br></pre></td></tr></table></figure><p>一个Bean包括id,type,和Properties。 </p><p>接下来Spring就开始加载我们的配置文件了，将我们配置的信息保存在一个HashMap中，HashMap的key就是Bean的Id，HasMap的value是这个Bean，只有这样我们才能通过context.getBean(“animal”)这个方法获得Animal这个类。我们都知道Spirng可以注入基本类型，而且可以注入像List，Map这样的类型，接下来就让我们以Map为例看看Spring是怎么保存的。</p><p>Map配置可以像下面的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">class</span>=<span class="string">"Test"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testMap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"b"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring是怎样保存上面的配置呢？代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(beanProperty.element(<span class="string">"map"</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line"> Map&lt;String, Object&gt; propertiesMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"> Element propertiesListMap = (Element) beanProperty</span><br><span class="line">.elements().get(<span class="number">0</span>);</span><br><span class="line"> Iterator&lt;?&gt; propertiesIterator = propertiesListMap</span><br><span class="line">.elements().iterator();</span><br><span class="line"> <span class="keyword">while</span> (propertiesIterator.hasNext()) &#123;</span><br><span class="line">  Element vet = (Element) propertiesIterator.next();</span><br><span class="line">  <span class="keyword">if</span> (vet.getName().equals(<span class="string">"entry"</span>)) &#123;</span><br><span class="line">   String key = vet.attributeValue(<span class="string">"key"</span>);</span><br><span class="line">   Iterator&lt;?&gt; valuesIterator = vet.elements()</span><br><span class="line">.iterator();</span><br><span class="line">   <span class="keyword">while</span> (valuesIterator.hasNext()) &#123;</span><br><span class="line">Element value = (Element) valuesIterator.next();</span><br><span class="line"><span class="keyword">if</span> (value.getName().equals(<span class="string">"value"</span>)) &#123;</span><br><span class="line"> propertiesMap.put(key, value.getText());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (value.getName().equals(<span class="string">"ref"</span>)) &#123;</span><br><span class="line"> propertiesMap.put(key, <span class="keyword">new</span> String[] &#123; value.attributeValue(<span class="string">"bean"</span>) &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  bean.getProperties().put(name, propertiesMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就进入最核心部分了，让我们看看Spring到底是怎么<strong>依赖注入</strong>的吧，其实依赖注入的思想也很简单，它是通过<strong>反射</strong>机制实现的，在实例化一个类时，它通过<strong>反射调用类中set方法将事先保存在HashMap中的类属性注入到类中</strong>。让我们看看具体它是怎么做的吧。</p><p>首先<strong>实例化</strong>一个类，像这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line"> Class&lt;?&gt; cls = <span class="keyword">null</span>;</span><br><span class="line"> Object obj = <span class="keyword">null</span>;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  cls = Class.forName(className);</span><br><span class="line">  obj = cls.newInstance();</span><br><span class="line"> &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着它将这个<strong>类的依赖注入进去</strong>，像这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setProperty</span><span class="params">(Object obj, String name, String value)</span> </span>&#123;</span><br><span class="line"> Class&lt;? extends Object&gt; clazz = obj.getClass();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  String methodName = returnSetMthodName(name);</span><br><span class="line">  Method[] ms = clazz.getMethods();</span><br><span class="line">  <span class="keyword">for</span> (Method m : ms) &#123;</span><br><span class="line">   <span class="keyword">if</span> (m.getName().equals(methodName)) &#123;</span><br><span class="line"><span class="keyword">if</span> (m.getParameterTypes().length == <span class="number">1</span>) &#123;</span><br><span class="line"> Class&lt;?&gt; clazzParameterType = m.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line"> setFieldValue(clazzParameterType.getName(), value, m,obj);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后它将这个类的实例返回给我们，我们就可以用了。我们还是以Map为例看看它是怎么做的，我写的代码里面是创建一个HashMap并把该HashMap注入到需要注入的类中，像这样，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line"> Iterator&lt;?&gt; entryIterator = ((Map&lt;?, ?&gt;) value).entrySet().iterator();</span><br><span class="line"> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"> <span class="keyword">while</span> (entryIterator.hasNext()) &#123;</span><br><span class="line">  Entry&lt;?, ?&gt; entryMap = (Entry&lt;?, ?&gt;) entryIterator.next();</span><br><span class="line">  <span class="keyword">if</span> (entryMap.getValue() <span class="keyword">instanceof</span> String[]) &#123;</span><br><span class="line">map.put((String) entryMap.getKey(),</span><br><span class="line">getBean(((String[]) entryMap.getValue())[<span class="number">0</span>]));</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> BeanProcesser.setProperty(obj, property, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，这样我们就可以用Spring给我们创建的类了，是不是也不是很难啊？当然Spring能做到的远不止这些，这个示例程序仅仅提供了Spring最核心的依赖注入功能中的一部分。 </p><p>本文参考了大量文章无法一一感谢，在这一起感谢，如果侵犯了你的版权深表歉意，很希望对大家有帮助！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;IOC-DI&quot;&gt;&lt;a href=&quot;#IOC-DI&quot; class=&quot;headerlink&quot; title=&quot;IOC(DI)&quot;&gt;&lt;/a&gt;IOC(DI)&lt;/h2&gt;&lt;p&gt;Java程序员都知道：Java程序中的每个业务逻辑至少需要两个或以上的对象来协作完成，通常，每个对象在使用他的合作对象时，自己均要使用像new object()这样的语法来完成合作对象的申请工作。你会发现，对象间的耦合度高了。而IOC的&lt;strong&gt;思想&lt;/strong&gt;是: &lt;strong&gt;Spring容器来实现这些相互依赖对象的创建、协调工作&lt;/strong&gt;。对象只需要关系业务逻辑本身就可以了。从这方面来说，对象如何得到他的协作对象的责任被反转了(IOC、DI)。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="blog.jiangdongyu.space/categories/JavaWeb/"/>
    
      <category term="Spring" scheme="blog.jiangdongyu.space/categories/JavaWeb/Spring/"/>
    
      <category term="IOC" scheme="blog.jiangdongyu.space/categories/JavaWeb/Spring/IOC/"/>
    
    
      <category term="Spring" scheme="blog.jiangdongyu.space/tags/Spring/"/>
    
      <category term="IOC" scheme="blog.jiangdongyu.space/tags/IOC/"/>
    
  </entry>
  
  <entry>
    <title>String</title>
    <link href="blog.jiangdongyu.space/2018/07/11/String/"/>
    <id>blog.jiangdongyu.space/2018/07/11/String/</id>
    <published>2018-07-11T09:35:00.000Z</published>
    <updated>2018-07-13T07:07:42.835Z</updated>
    
    <content type="html"><![CDATA[<h3 id="38-Count-and-Say"><a href="#38-Count-and-Say" class="headerlink" title="38.Count and Say"></a>38.Count and Say</h3><p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p><a id="more"></a><pre><code>1.     12.     113.     214.     12115.     111221</code></pre><p>1 is read off as “one 1” or 11.</p><p>11 is read off as “two 1s” or 21.</p><p>21 is read off as “one 2, then one 1” or 1211.</p><p>Given an integer n, generate the nth term of the count-and-say sequence.</p><p><strong>Note</strong>: Each term of the sequence of integers will be represented as a string.</p><p><strong>Example 1</strong>:</p><pre><code>Input: 1Output: &quot;1&quot;</code></pre><p><strong>Example 2</strong>:</p><pre><code>Input: 4Output: &quot;1211&quot;</code></pre><blockquote><p>题目有些晦涩，就以上面的例子解释，“1”读出来是“一个1”，因此第二行就是“11”，“11”读出来是“两个1”,因此第三行就是“21”,“21”读出来是“一个2一个1”，因此第四行就是“1211”，以此类推</p></blockquote><p><strong>思路</strong></p><ul><li>如果我们要获得第n个字符串，那我们首先要获得第n-1个字符串的值。所以我们设置一个prev变量来保存每一次操作的到的字符串的值，从而进行下一次操作。</li><li>操作其实就是从前到后对每一个字符(say)连续出现的次数计数(count)，如果字符变了，那么就将刚才count和say的值加入curr字符串中。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder cur = <span class="keyword">new</span> StringBuilder(<span class="string">"1"</span>);</span><br><span class="line">        StringBuilder pre;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">char</span> say = pre.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; pre.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pre.charAt(j) != say)&#123;</span><br><span class="line">                    cur.append(count).append(say);</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                    say = pre.charAt(j);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    count++; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.append(count).append(say);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.toString();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-Zigzag-Conversion"><a href="#6-Zigzag-Conversion" class="headerlink" title="6.Zigzag Conversion"></a>6.Zigzag Conversion</h3><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p><pre><code>P   A   H   NA P L S I I GY   I   R</code></pre><p>And then read line by line: “PAHNAPLSIIGYIR”</p><p>Write the code that will take a string and make this conversion given a number of rows:</p><p>string convert(string s, int numRows);</p><p><strong>Example 1</strong>:</p><pre><code>Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3Output: &quot;PAHNAPLSIIGYIR&quot;</code></pre><p><strong>Example 2</strong>:</p><pre><code>Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4Output: &quot;PINALSIGYAHRPI&quot;Explanation:P     I    NA   L S  I GY A   H RP     I</code></pre><ul><li>重要是找准规律！</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> length = c.length;</span><br><span class="line">        StringBuilder[] sb = <span class="keyword">new</span> StringBuilder[numRows];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; numRows;i++) sb[i] = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; length)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; numRows &amp;&amp; i &lt; length;j++)&#123;</span><br><span class="line">                sb[j].append(c[i++]);<span class="comment">//垂直往下</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = numRows-<span class="number">2</span>;j &gt; <span class="number">0</span> &amp;&amp; i &lt; length;j--)&#123;</span><br><span class="line">                sb[j].append(c[i++]);<span class="comment">//斜着向上</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; numRows;j++)&#123;</span><br><span class="line">            sb[<span class="number">0</span>].append(sb[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb[<span class="number">0</span>].toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="58-Length-of-Last-word"><a href="#58-Length-of-Last-word" class="headerlink" title="58.Length of Last word"></a>58.Length of Last word</h3><p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.</p><p>If the last word does not exist, return 0.</p><p>Note: A word is defined as a character sequence consists of non-space characters only.</p><p><strong>Example:</strong></p><pre><code>Input: &quot;Hello World&quot;Output: 5</code></pre><ul><li>比较简单</li><li>记得trim(),再进行split操作</li></ul><h3 id="165-Compare-Version-Number"><a href="#165-Compare-Version-Number" class="headerlink" title="165.Compare Version Number"></a>165.Compare Version Number</h3><p>Compare two version numbers version1 and version2.<br>If <strong>version1 &gt; version2</strong> return <strong>1</strong>; if <strong>version1 &lt; version2</strong> return <strong>-1</strong>;otherwise return <strong>0</strong>.</p><p>You may assume that the version strings are non-empty and contain only digits and the . character.<br>The . character does not represent a decimal point and is used to separate number sequences.<br>For instance, 2.5 is not “two and a half” or “half way to version three”, it is the fifth second-level revision of the second first-level revision.</p><p><strong>Example 1:</strong></p><pre><code>Input: version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot;Output: -1</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: version1 = &quot;1.0.1&quot;, version2 = &quot;1&quot;Output: 1</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;Output: -1</code></pre><ul><li>还是挺简单的，但是要注意split的时候”.”的表示</li><li>在java中“\”代表转义字符，而“.”代表一个元字符，要表示一个“.”就需要用“.”，所以”\.” 在实际编译中就代表“.”</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(String version1, String version2)</span> </span>&#123;</span><br><span class="line">        String[] ver1 = version1.split(<span class="string">"\\."</span>);</span><br><span class="line">        String[] ver2 = version2.split(<span class="string">"\\."</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = Math.max(ver1.length,ver2.length);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = i &lt; ver1.length ? Integer.parseInt(ver1[i]):<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> num2 = i &lt; ver2.length ? Integer.parseInt(ver2[i]):<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(num1 &gt; num2)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num1 &lt; num2)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="151-Reverse-Words-in-a-String"><a href="#151-Reverse-Words-in-a-String" class="headerlink" title="151.Reverse Words in a String"></a>151.Reverse Words in a String</h3><p>Given an input string, reverse the string word by word.</p><p><strong>Example:</strong>  </p><pre><code>Input: &quot;the sky is blue&quot;,Output: &quot;blue is sky the&quot;.</code></pre><p><strong>Note:</strong></p><ul><li>A word is defined as a sequence of non-space characters.</li><li>Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces.</li><li>You need to reduce multiple spaces between two words to a single space in the reversed string.</li></ul><p><strong>注意两个单词之间可能有多个空格</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String[] arr = s.trim().split(<span class="string">" +"</span>);<span class="comment">//处理一个或多个空格</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            sb.append(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="186-Reverse-Words-in-a-String-II"><a href="#186-Reverse-Words-in-a-String-II" class="headerlink" title="186.Reverse Words in a String II"></a>186.Reverse Words in a String II</h3><p>Given an input string, reverse the string word by word. A word is defined as a sequence of non-space characters.</p><p>The input string <strong>does not contain</strong> leading or trailing spaces and the words are always separated by a single space.</p><p>For example, Given s = “the sky is blue”, return “blue is sky the”.</p><p>Could you do it in-place without allocating extra space?</p><ul><li>先反转整个数组，再对每个单词进行反转</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseWords</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        reverse(s, <span class="number">0</span>, s.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">                reverse(s, start, i - <span class="number">1</span>);</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(s, start, s.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = s[start];</span><br><span class="line">            s[start] = s[end];</span><br><span class="line">            s[end] = tmp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Palindrome"><a href="#Palindrome" class="headerlink" title="Palindrome"></a>Palindrome</h3><h4 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5.Longest Palindromic Substring"></a>5.Longest Palindromic Substring</h4><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer.</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: &quot;cbbd&quot;Output: &quot;bb&quot;</code></pre><p><strong>暴力枚举</strong></p><ul><li>穷举所有子字符串的可能，然后依次按位判断其是否是回文，并更新结果。虽然其时间复杂度很高，但它对空间的要求很低。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxStart = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; len - i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isPalindrome(s,i,j) &amp;&amp; (i+<span class="number">1</span>) &gt; maxLen)&#123;</span><br><span class="line">                    maxLen = i+<span class="number">1</span>;</span><br><span class="line">                    maxStart = j;</span><br><span class="line">                &#125;      </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxStart,maxStart+maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = j;</span><br><span class="line">        <span class="keyword">int</span> right = i+j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left) != s.charAt(right))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态规划</strong></p><ul><li>dp[i][j]代表字符串从i到j是否为回文串</li><li>当s.charAt(i)==s.charAt(j)并且dp[i+1][j-1]为true时，dp[i][j] = true</li><li>需要注意上述i,j相邻以及i,j中间有别的字符时，上式也成立</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxStart = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(j)==s.charAt(i) &amp;&amp; (j-<span class="number">2</span> &lt;= i || dp[i+<span class="number">1</span>][j-<span class="number">1</span>]))&#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(maxLength &lt; j-i+<span class="number">1</span>)&#123;</span><br><span class="line">                        maxLength = j -i + <span class="number">1</span>;</span><br><span class="line">                        maxStart = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxStart,maxStart + maxLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>中心扩散法</strong></p><ul><li>从小到大连续以某点为个中心的所有子字符串进行计算</li><li>外层循环遍历的是子字符串的中心点，内层循环则是从中心扩散</li><li>中心对称有两种情况，一是奇数个字母以某个字母对称，而是偶数个字母以两个字母中间为对称</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    String longest = <span class="string">""</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="comment">//计算奇数子字符串</span></span><br><span class="line">            helper(s, i, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//计算偶数子字符串</span></span><br><span class="line">            helper(s, i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(String s, <span class="keyword">int</span> idx, <span class="keyword">int</span> offset)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = idx;</span><br><span class="line">        <span class="keyword">int</span> right = idx + offset;</span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span> &amp;&amp; right&lt;s.length() &amp;&amp; s.charAt(left)==s.charAt(right))&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 截出当前最长的子串</span></span><br><span class="line">        String currLongest = s.substring(left + <span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">// 判断是否比全局最长还长</span></span><br><span class="line">        <span class="keyword">if</span>(currLongest.length() &gt; longest.length())&#123;</span><br><span class="line">            longest = currLongest;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="214-Shortest-Palindrome"><a href="#214-Shortest-Palindrome" class="headerlink" title="214.Shortest Palindrome"></a>214.Shortest Palindrome</h4><p>Given a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;aacecaaa&quot;Output: &quot;aaacecaaa&quot;</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: &quot;abcd&quot;Output: &quot;dcbabcd&quot;</code></pre><p><strong>暴力求解</strong></p><ul><li>补充之后的回文字符串的中心肯定在原字符串中</li><li>从原字符的第一个字符为起点至少存在一个回文串，找到原字符串中以第一个字符为起点最长的回文串，找到之后剩下的工作就是把剩余部分的翻转补充到原字符串头部</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || s.length() == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> len = s.length(), tail = len;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (tail &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(s.substring(<span class="number">0</span>, tail))) &#123;</span><br><span class="line">                builder = builder.append(s.substring(tail, len)).reverse();<span class="comment">//substring()从beginIndex开始取，到endIndex结束，从0开始数，其中不包括endIndex位置的字符</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tail--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.append(s).toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) != str.charAt(len - i - <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>KMP</strong>: O(n)</p><h3 id="242-Valid-Anagram"><a href="#242-Valid-Anagram" class="headerlink" title="242.Valid Anagram"></a>242.Valid Anagram</h3><p>Given two strings s and t , write a function to determine if t is an anagram of s.</p><p><strong>Example 1:</strong></p><pre><code>Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;Output: true</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: s = &quot;rat&quot;, t = &quot;car&quot;Output: false</code></pre><p><strong>Note:</strong></p><p>You may assume the string contains only lowercase alphabets.</p><p><strong>Follow up:</strong></p><p>What if the inputs contain unicode characters? How would you adapt your solution to such case?</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()!=t.length())&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">char</span>[] s1 = s.toCharArray();</span><br><span class="line">            <span class="keyword">char</span>[] s2 = t.toCharArray();</span><br><span class="line">            Arrays.sort(s1);</span><br><span class="line">            Arrays.sort(s2);</span><br><span class="line">            <span class="keyword">return</span> Arrays.equals(s1,s2);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="49-Group-Anagram"><a href="#49-Group-Anagram" class="headerlink" title="49.Group Anagram"></a>49.Group Anagram</h3><p>Given an array of strings, group anagrams together.</p><p><strong>Example:</strong></p><pre><code>Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],Output:[  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],  [&quot;nat&quot;,&quot;tan&quot;],  [&quot;bat&quot;]]</code></pre><p><strong>Note:</strong></p><ul><li>All inputs will be in lowercase.</li><li>The order of your output does not matter.</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        Map&lt;String,List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(String s:strs)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] c = s.toCharArray();<span class="comment">//String转char数组</span></span><br><span class="line">            Arrays.sort(c);</span><br><span class="line">            String key = String.valueOf(c);<span class="comment">//char数组转String</span></span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(key)) map.put(key,<span class="keyword">new</span> ArrayList());</span><br><span class="line">            map.get(key).add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(map.values());<span class="comment">//返回一个HashMap的值的Collection</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;38-Count-and-Say&quot;&gt;&lt;a href=&quot;#38-Count-and-Say&quot; class=&quot;headerlink&quot; title=&quot;38.Count and Say&quot;&gt;&lt;/a&gt;38.Count and Say&lt;/h3&gt;&lt;p&gt;The count-and-say sequence is the sequence of integers with the first five terms as following:&lt;/p&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode Category" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/LeetCode-Category/"/>
    
    
      <category term="String" scheme="blog.jiangdongyu.space/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>线程安全与锁优化</title>
    <link href="blog.jiangdongyu.space/2018/07/08/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/"/>
    <id>blog.jiangdongyu.space/2018/07/08/线程安全与锁优化/</id>
    <published>2018-07-08T06:20:00.000Z</published>
    <updated>2018-07-10T09:01:47.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>Brian Goetz对线程安全的定义：当多个线程访问一个对象时，如果不考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调度方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。</p><a id="more"></a><h3 id="Java语言中的线程安全"><a href="#Java语言中的线程安全" class="headerlink" title="Java语言中的线程安全"></a>Java语言中的线程安全</h3><p>按照线程安全的“安全程度”由强至弱来排序，java里面各种操作共享的数据分为以下5类：<strong>不可变，绝对线程安全，相对线程安全，线程兼容，线程对立</strong>。</p><ul><li><strong>不可变</strong>：可以是基本类型的<strong>final</strong>；可以是final对象，但对象的行为不会对其状态产生任何影响，比如<strong>String</strong>的subString就是new一个String对象，<strong>枚举类型</strong>，各种<strong>Number类型</strong>如BigInteger和BigDecimal等<strong>大数据类型</strong>都是不可变的，但是同为Number子类型的AtomicInteger和AtomicLong则并非不可变我觉得原因是它里面状态对象是unsafe对象，所做的操作都是CAS操作，可以保证原子性。</li><li><strong>绝对线程安全</strong>：他是完全满足Brian Goetz给出的线程安全的定义，一个类要达到这种程度，需要付出很大的，甚至不切实际的代价。</li><li><strong>相对线程安全</strong>：这就是我们通常意义上的线程安全。需要<strong>保证对象单独的操作时线程安全的</strong>。比如Vector，HashTable，synchronizedCollection包装集合等。</li><li><strong>线程兼容</strong>：<strong>对象本身不是线程安全的，但可以通过同步手段实现</strong>。一般我们说的不是线程安全的，绝大多数是指这个。比如ArrayList，HashMap等。</li><li><strong>线程对立</strong>：<strong>不管调用端是否采用了同步的措施，都无法在并发中使用的代码</strong>。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。</li></ul><h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><ul><li>互斥同步<ul><li>在多线程访问的时候，保证<strong>同一时间只有一条线程使用</strong>。而<strong>互斥是实现同步的一种手段</strong>，临界区(Critical Section)，互斥量(Mutex)，信号量(Semaphore)都是主要的互斥实现方式。java里最基本的互斥同步手段是<strong>synchronized</strong>，编译之后会形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象，还有个锁的计数器，来记录拥有锁的次数</li><li>其实在“Java与线程”里已经提到，java的线程是映射到操作系统的<strong>原生线程</strong>之上的，不管阻塞还是唤醒都需要操作系统的帮忙完成，都需要从用户态转换到核心态，这是很耗费时间的，是java语言中的一个<strong>重量级</strong>(Heavyweight)操作，虽然虚拟机本身会做一点优化的操作，比如通知操作系统阻塞之前会加一段自旋等待的过程，避免频繁切换到核心态。</li><li>还可以使用<strong>java.util.concurrent包中的重入锁（ReentrantLock）来实现同步</strong>，ReentrantLock比synchronized增加了一些高级功能：等待可中断、可实现公平锁以及锁可以绑定多个条件。</li></ul></li><li>非阻塞同步（Non-Blocking Synchronization）<ul><li><strong>互斥和同步最主要的问题就是阻塞和唤醒所带来的性能问题，所以这通常叫阻塞同步(悲观的并发策略)</strong>。随着硬件指令集的发展，我们有另外的选择：<strong>基于冲突检测的乐观并发策略</strong>，通俗讲就是先操作，如果没有其他线程争用共享的数据，操作就成功，如果有，则进行其他的补偿(最常见就是不断的重试)，这种乐观的并发策略许多实现都不需要把线程挂起，这种同步操作被称为<strong>非阻塞同步</strong>。</li></ul></li><li>无同步方案<ul><li>有一些代码天生就是线程安全的，不需要同步。其中有如下两类：</li><li><strong>可重入代码</strong>(Reentrant Code): 纯代码，具有不依赖存储在堆上的数据和公用的系统资源，用到的状态量都由参数中传入，不调用非可重入的方法等特征，它的返回结果是可以预测的。</li><li><strong>线程本地存储</strong>(Thread Local Storage): <strong>把共享数据的可见范围限制在同一个线程之内</strong>，这样就无须同步也能保证线程之间不出现数据争用问题。可以通过java.lang.ThreadLocal类来实现线程本地存储的功能。</li></ul></li></ul><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>为了在线程之间更高效的共享数据，以及解决竞争问题，从而提高程序的执行效率，创建了各种<strong>锁优化技术</strong>：适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、 锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）等。</p><ul><li><strong>自旋锁与自适应自旋</strong>：<ul><li>线程挂起和恢复的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力，在许多应用中，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得，可以让后请求锁的线程等待一会儿，但不放弃处理器的执行时间，让线程执行一个<strong>忙循环(自旋)</strong>。</li><li>自旋锁默认的自旋次数值是10次，可以使用参数-XX:PreBlockSpin更改。</li><li>自适应自旋意味着<strong>自旋的时间不再固定</strong>，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</li></ul></li><li><strong>锁消除</strong>：<ul><li>虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到<strong>不可能存在共享数据竞争的锁进行消除</strong>。锁消除的主要判定依据来源于<strong>逃逸分析</strong>的数据支持。</li></ul></li><li><strong>锁粗化</strong>：<ul><li>如果虚拟机探测到有一系列连续操作都<strong>对同一个对象反复加锁和解锁</strong>，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。</li></ul></li><li><strong>轻量级锁</strong>：<ul><li>使用对象头的Mark Word中锁标志位代替操作系统互斥量实现的锁。轻量级锁并不是用来代替重量级锁，它的本意是<strong>在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗</strong>。</li><li>轻量级锁是在无竞争的情况下使用CAS（Compare-and-Swap）操作去消除同步使用的互斥量。</li></ul></li><li><strong>偏向锁</strong>：<ul><li>和轻量级锁原理基本一致，但偏向锁在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程安全&quot;&gt;&lt;a href=&quot;#线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程安全&quot;&gt;&lt;/a&gt;线程安全&lt;/h2&gt;&lt;p&gt;Brian Goetz对线程安全的定义：当多个线程访问一个对象时，如果不考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调度方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="读书笔记" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深入理解Java虚拟机" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="高效并发" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
      <category term="Thread" scheme="blog.jiangdongyu.space/tags/Thread/"/>
    
      <category term="Lock" scheme="blog.jiangdongyu.space/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型与线程</title>
    <link href="blog.jiangdongyu.space/2018/07/06/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>blog.jiangdongyu.space/2018/07/06/Java内存模型与线程/</id>
    <published>2018-07-06T11:30:00.000Z</published>
    <updated>2018-07-10T09:02:05.462Z</updated>
    
    <content type="html"><![CDATA[<p>衡量一个服务性能的高低好坏，每秒事物处理数(TPS)是最重要的指标之一，它代表着一秒内服务端平均能响应的请求总数，而TPS的值与程序的<strong>并发</strong>能力又有密切的关系。对于计算量相同的任务，程序线程并发协调越有条不紊，效率自然就越高；反之，线程之间频繁阻塞甚至死锁，将会大大降低程序的并发能力。</p><a id="more"></a><h2 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h2><p>物理机并发问题与虚拟机的情况有不少相似之处。</p><p>计算机的存储设备与处理器的运算速度有几个数量级的差距，因而加入高速缓存来作为内存与处理器之间的缓冲，引入新的问题：<strong>缓存一致性</strong>。</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG299.jpeg" alt="avatar"></p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p>Java内存模型的主要目标是定义程序中各个变量的<strong>访问规则</strong>，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量，包括了<strong>实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数</strong>，因为后者是线程私有的，不会被共享，自然没有竞争问题。</p><p>Java内存模型规定了所有的变量都存储在<strong>主内存</strong>中。每条<strong>线程</strong>还有自己的<strong>工作内存</strong>，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，<strong>线程对变量的所有操作都必须在工作内存中进行</strong>，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG300.jpeg" alt="avatar"></p><h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的(对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外)：</p><ul><li>lock(锁定): 作用于<strong>主内存</strong>的变量，它把一个变量标识为一条线程独占的状态</li><li>unlock(解锁): 作用于<strong>主内存</strong>的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read(读取): 作用于<strong>主内存</strong>变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li>load(载入): 作用于<strong>工作内存</strong>的变量，它把read操作从主内存中得到的变量值放入到工作内存的变量副本中。</li><li>use(使用): 作用于<strong>工作内存</strong>的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个<strong>需要使用到变量</strong>的值的字节码指令的时候将会执行这个操作。</li><li>assign(赋值): 作用于<strong>工作内存</strong>的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个<strong>给变量赋值</strong>的字节码指令时将会执行这个操作。</li><li>store(存储): 作用于<strong>工作内存</strong>变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li><li>write(写入): 作用于<strong>主内存</strong>变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ul><p>Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：</p><ol><li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</li><li>不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步会主内存中。</li><li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use和store操作之前，必须先执行过assign和load操作。</li><li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock之后，只有执行相同次数的unlock操作，变量才会被解锁。</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定住的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store和write操作）。</li></ol><h3 id="对于volatile型变量的特殊规则"><a href="#对于volatile型变量的特殊规则" class="headerlink" title="对于volatile型变量的特殊规则"></a>对于volatile型变量的特殊规则</h3><p>关键字volatile可以说是Java虚拟机提供的<strong>最轻量级的同步机制</strong>。当一个变量被定义成volatile之后，它将具备两种特性，第一是<strong>保证此变量对所有线程的可见性</strong>，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以<strong>立即得知的</strong>。</p><p>由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性。</p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li><li>变量不需要与其他的状态变量共同参与不变约束。</li></ul><p>第二个特性是<strong>禁止指令重排序优化</strong>。普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这样就是Java内存模型中描述的所谓的“线程内表现为串行的语义”。</p><h3 id="对于long和double型变量的特殊规则"><a href="#对于long和double型变量的特殊规则" class="headerlink" title="对于long和double型变量的特殊规则"></a>对于long和double型变量的特殊规则</h3><p>Java内存模型要求lock、unlock、read、load、assign、use、store和write这8个操作都具有原子性，但是对于64位的数据类型long和double，在模型中特别定义了一条宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这四个操作的原子性，这点就是所谓的long和double的<strong>非原子性协定</strong>。</p><p>如果有多个线程共享一个未被声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读到一个既非原值，也非其他线程修改值的代表了“半个变量”的数值。</p><p>不过这种读取到“半个变量”的情况非常罕见，因为Java内存模型虽然允许虚拟机不把long和double变量的读写实现成原子操作，但<strong>允许虚拟机选择把这些操作实现为具有原子性的操作</strong>，而且还“强烈建议”虚拟机这样实现。目前各种平台下的商用虚拟机几乎都选择吧64位数据的读写操作作为原子操作来对待，因此在编码时，不需要将long和double变量专门声明为volatile。</p><h3 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h3><p>Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的：</p><ul><li>原子性(Atomicity):<ul><li>由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，我们大致可以认为基本数据类型的访问读写是具备原子性的。</li><li>在synchronized块之间的操作也具备原子性。</li></ul></li><li>可见性(Visibility): <ul><li>指当一个线程修改了共享变量的值，其他线程能够<strong>立即</strong>得知这个修改。</li><li>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介实现可见性的</li><li>普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能<strong>立即</strong>同步到主内存，以及每次使用前立即从主内存刷新。</li><li>除了volatile之外，synchronized和final也能实现可见性。同步块的可见性是由“<strong>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中</strong>”这条规则获得的，而final关键字的可见性是指：<strong>被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去，那在其他线程中就能看见final字段的值</strong></li></ul></li><li>有序性(Ordering): <ul><li>Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。</li><li>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了<strong>禁止指令重排序</strong>的语义，而synchronized则是由“<strong>一个变量在同一个时刻只允许一条线程对其进行lock操作</strong>”这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能<strong>串行</strong>地进入</li></ul></li></ul><h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p>先行发生是Java内存模型中定义的两项操作之间的<strong>偏序关系</strong>，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了小写、调用了方法等。</p><p>下面是Java内存模型下一些“天然的”先行发生关系，这些先行发送关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，他们就没有顺序性保障，虚拟机可以对它们进行随意重新排序。</p><ul><li>程序次序规则(Program Order Rule): 在一个线程内，按照程序<strong>代码顺序</strong>，书写在钱吗的操作先于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li><li>管程锁定规则(Monitor Lock Rule): 一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。</li><li>volatile变量规则(Volatile Variable Rule): 对一个volatile变量的写操作先行发生于后面对这个变量的读操作。“后面”是指时间上的先后顺序。</li><li>线程启动规则(Thread Start Rule): Thread对象的start()方法先行发生于此线程的每一个动作。</li><li>线程终止规则(Thread Termination Rule): 线程中所有操作都先行发生于此线程的终止检测。</li><li>线程中断规则(Thread Interruption Rule): 对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li><li>对象终结规则(Finalizer Rule): 一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</li><li>传递性(Transitivity): 如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得到操作A先行发生于操作C。</li></ul><h2 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h2><h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><ul><li>使用内核线程实现<ul><li>内核线程(Kernel Thread，KLT)就是直接由操作系统内核支持的线程，这种线程由<strong>内核</strong>来完成<strong>线程切换</strong>，内核通过操纵<strong>调度器</strong>对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程都可以看做是内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就叫<strong>多线程内核</strong>。</li><li>程序一般不会直接使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程(Light Weight Process，LWP)，轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。<br><img src="http://p9fh1pach.bkt.clouddn.com/20141214145942631.png" alt="avatar"></li><li>由于内核线程的支持，每个轻量级进程都成为一个<strong>独立</strong>的调度单元，即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作，但轻量级进程具有它的局限性：基于线程内核实现，各种线程操作都需要进行<strong>系统调用</strong>，系统调用代价高，需要在用户态和内核态中来回切换；轻量级进程都需要有一个内核线程的支持，<strong>消耗内核资源</strong></li></ul></li><li>使用用户线程实现<ul><li><strong>广义</strong>上，一个线程只要不是内核线程，那就可以认为是用户线程(User Thread，UT)。</li><li><strong>狭义</strong>上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到线程存在的实现。<br><img src="http://p9fh1pach.bkt.clouddn.com/20141214150247703.png" alt="avatar"></li><li>使用用户线程的<strong>优势劣势</strong>都在于没有系统内核的支援，所有线程操作都需要用户程序自己处理，困难，实现复杂，放弃使用  </li></ul></li><li>使用用户线程加轻量级进程混合实现<ul><li>线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式。在这种混合实现下，既存在用户线程，也存在轻量级进程。<br><img src="http://p9fh1pach.bkt.clouddn.com/20141214150313341.png" alt="avatar"></li></ul></li></ul><h3 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h3><p>线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是<strong>协同式线程调度</strong>(Cooperative Threads-Scheduling)和<strong>抢占式线程调度</strong>(Preemptive Threads-Scheduling)。</p><ul><li>如果使用<strong>协同式</strong>调度的多线程系统，线程的执行时间由<strong>线程</strong>本身来控制，线程把自己的工作执行完毕后，要主动通知系统切换到另一个线程上去。</li><li>如果使用<strong>抢占式</strong>调度的多线程系统，那么每个线程将由<strong>系统</strong>来分配执行时间，线程的切换不由线程本身来决定(在Java中，Thread.yield()可以让出执行时间，但要获取执行时间的话，线程本身是没有什么办法)。Java使用抢占式调度。线程优先级</li></ul><h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>Java语言定义了5种线程状态，在任意一个时间点，一个线程只能有且只有其中的一种状态，这5种状态分别是：</p><ul><li>新建(New): 创建后尚未启动</li><li>运行(Runable): Runable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待CPU为它分配执行时间</li><li>无期限等待(Waiting): 不会被分配CPU执行时间，需要等待被其他线程显式地唤醒</li><li>期限等待(Timed Waiting): 不会被分配CPU执行时间，无须等待被其他线程显式地唤醒，在一定时间之后会由系统自动唤醒</li><li>阻塞(Blocked): 线程被阻塞了，“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是等待一段时间，或者唤醒动作的发生</li><li>结束(Terminated): 已终止线程的线程状态，线程已经结束执行</li></ul><p>上述5种状态在遇到特定事件发生的时候会相互转换。<br><img src="http://p9fh1pach.bkt.clouddn.com/20141214150758572.png" alt="avatar"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;衡量一个服务性能的高低好坏，每秒事物处理数(TPS)是最重要的指标之一，它代表着一秒内服务端平均能响应的请求总数，而TPS的值与程序的&lt;strong&gt;并发&lt;/strong&gt;能力又有密切的关系。对于计算量相同的任务，程序线程并发协调越有条不紊，效率自然就越高；反之，线程之间频繁阻塞甚至死锁，将会大大降低程序的并发能力。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="读书笔记" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深入理解Java虚拟机" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="高效并发" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
      <category term="Thread" scheme="blog.jiangdongyu.space/tags/Thread/"/>
    
  </entry>
  
</feed>
