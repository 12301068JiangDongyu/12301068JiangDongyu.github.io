<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>M&amp;Y</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="blog.jiangdongyu.space/"/>
  <updated>2018-06-12T08:08:29.690Z</updated>
  <id>blog.jiangdongyu.space/</id>
  
  <author>
    <name>Agnes</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Heap</title>
    <link href="blog.jiangdongyu.space/2018/06/12/Heap/"/>
    <id>blog.jiangdongyu.space/2018/06/12/Heap/</id>
    <published>2018-06-12T04:09:00.000Z</published>
    <updated>2018-06-12T08:08:29.690Z</updated>
    
    <content type="html"><![CDATA[<h3 id="272-Closest-Binary-Search-Tree-Value-II"><a href="#272-Closest-Binary-Search-Tree-Value-II" class="headerlink" title="272.Closest Binary Search Tree Value II"></a>272.Closest Binary Search Tree Value II</h3><p>Given a non-empty binary search tree and a target value, find <strong>k</strong> values in the BST that are closest to the target.</p><p><strong>Note:</strong></p><p>Given target value is a floating point. You may assume k is always valid, that is: k ≤ total nodes. You are guaranteed to have only one unique set of k values in the BST that are closest to the target. </p><a id="more"></a><p><strong>Follow up:</strong></p><p>Assume that the BST is balanced, could you solve it in less than O(n) runtime (where n = total nodes)?</p><p><strong>Hint:</strong></p><p>Consider implement these two helper functions: getPredecessor(N), which returns the next smaller node to N. getSuccessor(N), which returns the next larger node to N.</p><ul><li>中序遍历法<ul><li>二叉搜索树的中序遍历就是顺序输出二叉搜索树</li><li>中序遍历二叉搜索树，同时维护一个大小为K的队列</li><li>前K个数直接加入队列</li><li>之后每来一个新的数（较大的数），如果该数和目标的差，相比于队头的数离目标的差来说，更小，则将队头拿出来，将新数加入队列</li><li>更大，则直接退出并返回这个队列</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">closestKValues</span><span class="params">(TreeNode root, <span class="keyword">double</span> target, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; klist = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stk = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="comment">// 迭代中序遍历二叉搜索树的代码</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stk.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stk.isEmpty())&#123;</span><br><span class="line">            TreeNode curr = stk.pop();</span><br><span class="line">            <span class="comment">// 维护一个大小为k的队列</span></span><br><span class="line">            <span class="comment">// 队列不到k时直接加入</span></span><br><span class="line">            <span class="keyword">if</span>(klist.size() &lt; k)&#123;</span><br><span class="line">                klist.offer(curr.val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 队列到k时，判断下新的数是否更近，更近就加入队列并去掉队头</span></span><br><span class="line">                <span class="keyword">int</span> first = klist.peek();</span><br><span class="line">                <span class="keyword">if</span>(Math.abs(first - target) &gt; Math.abs(curr.val - target))&#123;</span><br><span class="line">                    klist.poll();</span><br><span class="line">                    klist.offer(curr.val);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果不是更近则直接退出，后面的数只会更大</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 中序遍历的代码</span></span><br><span class="line">            <span class="keyword">if</span>(curr.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                curr = curr.right;</span><br><span class="line">                <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    stk.push(curr);</span><br><span class="line">                    curr = curr.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 强制转换成List，是用LinkedList实现的所以可以转换</span></span><br><span class="line">        <span class="keyword">return</span> (List&lt;Integer&gt;)klist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>相似的题：<br>270.Closest Binary Search Tree Value</strong></p><p>Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target.</p><p><strong>Note:</strong></p><p>Given target value is a floating point. You are guaranteed to have only one unique value in the BST that is closest to the target.</p><ul><li>递归<ul><li>当遍历到某个根节点时，最近的那个节点要么是在子树里面，要么就是根节点本身</li><li>根据这个递归，返回子树中最近的节点，和根节点中更近的那个</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">closestValue</span><span class="params">(TreeNode root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 选出子树的根节点</span></span><br><span class="line">        TreeNode kid = target &lt; root.val ? root.left : root.right;</span><br><span class="line">        <span class="comment">// 如果没有子树，也就是递归到底时，直接返回当前节点值</span></span><br><span class="line">        <span class="keyword">if</span>(kid == <span class="keyword">null</span>) <span class="keyword">return</span> root.val;</span><br><span class="line">        <span class="comment">// 找出子树中最近的那个节点</span></span><br><span class="line">        <span class="keyword">int</span> closest = closestValue(kid, target);</span><br><span class="line">        <span class="comment">// 返回根节点和子树最近节点中，更近的那个节点</span></span><br><span class="line">        <span class="keyword">return</span> Math.abs(root.val - target) &lt; Math.abs(closest - target) ? root.val : closest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>迭代<ul><li>记录一个最近的值，然后沿着二叉搜索的路径一路比较下去，并更新这个最近值</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">closestValue</span><span class="params">(TreeNode root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> closest = root.val;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果该节点的离目标更近，则更新到目前为止的最近值</span></span><br><span class="line">            closest = Math.abs(closest - target) &lt; Math.abs(root.val - target) ? closest : root.val;</span><br><span class="line">            <span class="comment">// 二叉搜索</span></span><br><span class="line">            root = target &lt; root.val ? root.left : root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> closest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="239-Sliding-Window-Maximum"><a href="#239-Sliding-Window-Maximum" class="headerlink" title="239.Sliding Window Maximum"></a>239.Sliding Window Maximum</h3><p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.</p><p><strong>Example:</strong></p><pre><code>Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3Output: [3,3,5,5,6,7] Explanation: Window position                Max---------------               -----[1  3  -1] -3  5  3  6  7       3 1 [3  -1  -3] 5  3  6  7       3 1  3 [-1  -3  5] 3  6  7       5 1  3  -1 [-3  5  3] 6  7       5 1  3  -1  -3 [5  3  6] 7       6 1  3  -1  -3  5 [3  6  7]      7</code></pre><p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ input array’s size for non-empty array.</p><p><strong>Follow up:</strong><br>Could you solve it in linear time?</p><p><strong>思路与代码</strong></p><p>就看题目中的例子，[1 3 -1] -3 5 3 6 7，我们知道这个窗口中的最大值为3。我们同时也可以确定，3之前的数字无需加入后面大小的比较，因为它们一定比3小。</p><p>按照这种规则，我们可以维护一个存储了可比较数字的链表。这个链表中的数字可以和当前准备加入链表的值进行比较。那么我们看一下将一个值加入该链表有什么场景：</p><ul><li>链表为空，直接加入</li><li>链表的数量大于窗口，则删除最左侧的值</li><li>链表中有值，且有些值小于即将加入的值，则这些小于的值都被抛弃</li><li>链表中的值均大于即将加入的值，则不进行任何操作</li></ul><p><strong>代码</strong>： 可以用deque</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;nums.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(list.size() != <span class="number">0</span> &amp;&amp; list.getFirst() &lt; i-k+<span class="number">1</span>)&#123;</span><br><span class="line">            list.remove(<span class="number">0</span>);<span class="comment">//deq.poll()</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(list.size()!=<span class="number">0</span> &amp;&amp; nums[list.getLast()] &lt; nums[i])&#123;</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);<span class="comment">//deq.pollLast()</span></span><br><span class="line">        &#125;</span><br><span class="line">        list.addLast(i);</span><br><span class="line">        <span class="keyword">if</span>(i - k + <span class="number">1</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            result[i-k+<span class="number">1</span>] = nums[list.getFirst()];<span class="comment">//deq.peek()</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="480-Sliding-Window-Median"><a href="#480-Sliding-Window-Median" class="headerlink" title="480.Sliding Window Median"></a>480.Sliding Window Median</h3><blockquote><p>与上一题不同的是这次找的是中位数</p></blockquote><p>For example,<br>Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.</p><pre><code>Window position                Median---------------               -----[1  3  -1] -3  5  3  6  7       1 1 [3  -1  -3] 5  3  6  7       -1 1  3 [-1  -3  5] 3  6  7       -1 1  3  -1 [-3  5  3] 6  7       3 1  3  -1  -3 [5  3  6] 7       5 1  3  -1  -3  5 [3  6  7]      6</code></pre><p>Therefore, return the median sliding window as [1,-1,-1,3,5,6].</p><ul><li>minHeap和maxHeap，maxHeap在保存较小的一半元素，minHeap保存较大的一半元素</li><li>然后调整最大堆和最小堆的大小。根据k值可以分两种情况讨论：<ul><li>若k为偶数，则需要最大堆中元素和最小堆中元素数量相等</li><li>若k为奇数，此时最小堆的堆顶元素即为此时窗口元素的median</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;Integer&gt; minHeap;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; maxHeap;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] medianSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">double</span>[] result = <span class="keyword">new</span> <span class="keyword">double</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k/<span class="number">2</span> + <span class="number">1</span>, (a, b) -&gt; b.compareTo(a));</span><br><span class="line">        minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k/<span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// delete the element beyond the window</span></span><br><span class="line">            <span class="keyword">if</span>(maxHeap.size() + minHeap.size() == k) slide(nums[i - k]);</span><br><span class="line">            <span class="comment">// add new element to the window</span></span><br><span class="line">            add(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                result[i - k + <span class="number">1</span>] = getMedian();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">slide</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(minHeap.contains(target)) minHeap.remove(target);</span><br><span class="line">        <span class="keyword">else</span> maxHeap.remove(target);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        maxHeap.add(num);</span><br><span class="line">        minHeap.add(maxHeap.poll());</span><br><span class="line">        <span class="keyword">if</span>(maxHeap.size() + <span class="number">1</span> &lt; minHeap.size()) maxHeap.add(minHeap.poll());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// window size is even</span></span><br><span class="line">        <span class="keyword">if</span>(minHeap.size() == maxHeap.size()) <span class="keyword">return</span> minHeap.peek()/<span class="number">2.0</span> + maxHeap.peek()/<span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;272-Closest-Binary-Search-Tree-Value-II&quot;&gt;&lt;a href=&quot;#272-Closest-Binary-Search-Tree-Value-II&quot; class=&quot;headerlink&quot; title=&quot;272.Closest Binary Search Tree Value II&quot;&gt;&lt;/a&gt;272.Closest Binary Search Tree Value II&lt;/h3&gt;&lt;p&gt;Given a non-empty binary search tree and a target value, find &lt;strong&gt;k&lt;/strong&gt; values in the BST that are closest to the target.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given target value is a floating point. You may assume k is always valid, that is: k ≤ total nodes. You are guaranteed to have only one unique set of k values in the BST that are closest to the target. &lt;/p&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode Category" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/LeetCode-Category/"/>
    
    
      <category term="Heap" scheme="blog.jiangdongyu.space/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>HashTable</title>
    <link href="blog.jiangdongyu.space/2018/06/09/HashTable/"/>
    <id>blog.jiangdongyu.space/2018/06/09/HashTable/</id>
    <published>2018-06-09T02:38:00.000Z</published>
    <updated>2018-06-12T08:11:45.424Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><h3 id="217-Contains-Duplicate"><a href="#217-Contains-Duplicate" class="headerlink" title="217.Contains Duplicate"></a>217.Contains Duplicate</h3><p>Given an array of integers, find if the array contains any duplicates.</p><p>Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p><a id="more"></a><p><strong>Example 1:</strong></p><pre><code>Input: [1,2,3,1]Output: true</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: [1,2,3,4]Output: false</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: [1,1,1,3,3,4,3,2,4,2]Output: true</code></pre><ul><li>直接使用hashset</li><li>排序，对相邻的做比较</li></ul><h3 id="219-Contains-Duplicate-II"><a href="#219-Contains-Duplicate-II" class="headerlink" title="219.Contains Duplicate II"></a>219.Contains Duplicate II</h3><blockquote><p>判断数组是否存在i,j位置相同的数，同时j-i &lt;= k</p></blockquote><ul><li>hashmap<ul><li>key: nums[i], value: i</li><li>判断是否存在key,，存在则接着比较index</li><li>无论存在与否，都需要put，相同key被覆盖</li></ul></li><li>hashset<ul><li>i&gt;k则删除nums[i-k-1]</li><li>判断!set.add(nums[i])</li></ul></li></ul><h3 id="220-Contains-Duplicate-III"><a href="#220-Contains-Duplicate-III" class="headerlink" title="220.Contains Duplicate III"></a>220.Contains Duplicate III</h3><blockquote><p>判断数组是否存在i,j位置，num[j]-nums[i] &lt;= t，同时j-i &lt;= k</p></blockquote><p>类似sliding window,移动的时候增加和减少element，但对每一个value,需要考察[value-t,value+t]，时间复杂度太高…</p><ul><li>利用Bucket Sort<ul><li>构建一个大小为t+1的bucket, 比如[0, 1, 2, 3, … , t], 最大绝对值差的两个数就是t和0. </li><li>如果两个数字出现在同一个Bucket内，说明我们已经找到了。 如果不是，则在相邻的两个bucket内再找。</li><li>如果相邻的bucket内元素绝对值只差在t以内，说明我们知道到了，返回true.</li><li>为了保证j - i &lt;= k，我们在i&gt;=k时，删除 nums[i-k]对应的Bucket.</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( k &lt; <span class="number">1</span> || t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map&lt;Long, Long&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">// [-t, 0] [0, t] 的元素都会落在bucket[0]里。</span></span><br><span class="line">            <span class="comment">// 为了解决这个问题，所有元素横移Integer.MIN_VALUE。</span></span><br><span class="line">            <span class="keyword">long</span> remappedNum = (<span class="keyword">long</span>) nums[i] - Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">long</span> bucket = remappedNum / ((<span class="keyword">long</span>)t + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(bucket) </span><br><span class="line">                ||(map.containsKey(bucket-<span class="number">1</span>) &amp;&amp; remappedNum - map.get(bucket-<span class="number">1</span>) &lt;= t)</span><br><span class="line">                    || (map.containsKey(bucket+<span class="number">1</span>) &amp;&amp; map.get(bucket+<span class="number">1</span>) - remappedNum &lt;= t) )</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastBucket = ((<span class="keyword">long</span>) nums[i-k] - Integer.MIN_VALUE) / ((<span class="keyword">long</span>)t + <span class="number">1</span>);</span><br><span class="line">                map.remove(lastBucket);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(bucket,remappedNum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用treeset</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( k &lt; <span class="number">1</span> || t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        TreeSet&lt;Long&gt; tree = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//floor() 小于等于</span></span><br><span class="line">            Long floor = tree.floor((<span class="keyword">long</span>)nums[i] + t);</span><br><span class="line">            <span class="comment">//ceiling() 大于等于</span></span><br><span class="line">            Long ceil = tree.ceiling((<span class="keyword">long</span>)nums[i] - t);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>((floor != <span class="keyword">null</span> &amp;&amp; floor &gt;= nums[i])</span><br><span class="line">                || (ceil != <span class="keyword">null</span> &amp;&amp; ceil &lt;= nums[i]) )</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">            tree.add((<span class="keyword">long</span>)nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k)&#123;</span><br><span class="line">                tree.remove((<span class="keyword">long</span>)nums[i-k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="243-Shortest-Word-Distance"><a href="#243-Shortest-Word-Distance" class="headerlink" title="243.Shortest Word Distance"></a>243.Shortest Word Distance</h3><p>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p><p>For example, Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”].</p><p>Given word1 = “coding”, word2 = “practice”, return 3. Given word1 = “makes”, word2 = “coding”, return 1.</p><p>Note: You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.</p><ul><li>双指针法 <ul><li>分别记录word1和word2的位置</li><li>更新distance</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(String[] words, String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ind1 = -<span class="number">1</span>, ind2 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> distance = Integer.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; words.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(words[i].equals(word1))&#123;</span><br><span class="line">                ind1 = i;</span><br><span class="line">                <span class="keyword">if</span>(ind2 != -<span class="number">1</span>) distance = Math.min(distance, ind1 - ind2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(words[i].equals(word2))&#123;</span><br><span class="line">                ind2 = i;</span><br><span class="line">                <span class="keyword">if</span>(ind1 != -<span class="number">1</span>) distance = Math.min(distance, ind2 - ind1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="244-Shortest-Word-Distance-II"><a href="#244-Shortest-Word-Distance-II" class="headerlink" title="244.Shortest Word Distance II"></a>244.Shortest Word Distance II</h3><p>This is a follow up of Shortest Word Distance. The only difference is now you are given the list of words and your method <strong>will be called repeatedly many times</strong> with different parameters. How would you optimize it?</p><p>Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list.</p><ul><li>多次call, 那就需要记录下所有的word的下标</li><li>同时，一个word可能出现多次，应该是个list</li><li>比较的时候，类似merge two sorted list的做法, 先比较最小的，然后把较小的去掉，接着比较</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordDistance</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    HashMap&lt;String, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String, List&lt;Integer&gt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordDistance</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 统计每个单词出现的下标存入哈希表中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">            List&lt;Integer&gt; cnt = map.get(words[i]);</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="keyword">null</span>)&#123;</span><br><span class="line">                cnt = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            cnt.add(i);</span><br><span class="line">            map.put(words[i], cnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortest</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; idx1 = map.get(word1);</span><br><span class="line">        List&lt;Integer&gt; idx2 = map.get(word2);</span><br><span class="line">        <span class="keyword">int</span> distance = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 每次比较两个下标列表最小的下标，然后把跳过较小的那个</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; idx1.size() &amp;&amp; j &lt; idx2.size())&#123;</span><br><span class="line">            distance = Math.min(Math.abs(idx1.get(i) - idx2.get(j)), distance);</span><br><span class="line">            <span class="keyword">if</span>(idx1.get(i) &lt; idx2.get(j))&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="245-Shortest-Word-Distance-III"><a href="#245-Shortest-Word-Distance-III" class="headerlink" title="245.Shortest Word Distance III"></a>245.Shortest Word Distance III</h3><p>This is a follow up of Shortest Word Distance. The only difference is now word1 <strong>could be the same</strong> as word2.</p><p>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p><p>word1 and word2 may be the same and they represent <strong>two individual words</strong> in the list.</p><p>For example, Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”].</p><p>Given word1 = “makes”, word2 = “coding”, return 1. Given word1 = “makes”, word2 = “makes”, return 3.</p><p>Note: You may assume word1 and word2 are both in the list.</p><ul><li>和I相似，区别就在于两个词可能相同</li><li>需要区分第一次遇到和第二次遇到这个词。加入一个turns，如果是相同单词的话，每次遇到一个单词turn加1，这样可以根据turn来判断是否要switch</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(String[] words, String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ind1 = -<span class="number">1</span>, ind2 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> distance = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> turns = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> inc = word1.equals(word2) ? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; words.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(words[i].equals(word1) &amp;&amp; turns % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                ind1 = i;</span><br><span class="line">                <span class="keyword">if</span>(ind2 != -<span class="number">1</span>) distance = Math.min(distance, ind1 - ind2);</span><br><span class="line">                turns += inc;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(words[i].equals(word2))&#123;</span><br><span class="line">                ind2 = i;</span><br><span class="line">                <span class="keyword">if</span>(ind1 != -<span class="number">1</span>) distance = Math.min(distance, ind2 - ind1);</span><br><span class="line">                turns += inc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><h3 id="202-Happy-Number"><a href="#202-Happy-Number" class="headerlink" title="202.Happy Number"></a>202.Happy Number</h3><p>Write an algorithm to determine if a number is “happy”.</p><p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p><p><strong>Example:</strong></p><pre><code>Input: 19Output: trueExplanation: 1^2 + 9^2 = 828^2 + 2^2 = 686^2 + 8^2 = 1001^2 + 0^2 + 0^2 = 1</code></pre><ul><li>用set记录在计算过程中出现的值</li><li>如果再次出现，说明不行</li><li>否则一直计算直到结果为1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(set.add(n))&#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> digit = n%<span class="number">10</span>;</span><br><span class="line">                res += digit * digit;</span><br><span class="line">                n /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(res == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                n = res;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="3-Longest-Substring-without-repeat-characters"><a href="#3-Longest-Substring-without-repeat-characters" class="headerlink" title="3.Longest Substring without repeat characters"></a>3.Longest Substring without repeat characters</h3><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><p><strong>Examples:</strong></p><p>Given “abcabcbb”, the answer is “abc”, which the length is 3.</p><p>Given “bbbbb”, the answer is “b”, with the length of 1.</p><p>Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p><ul><li>sliding window + set解法<ul><li>两个指针p1,p2，p1是window的左边界，p2是右边界</li><li>左边界不动时，右边界尽可能往右扩展，直到不能满足条件</li><li>左边界移动，删除set中左边的元素</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt; length)&#123;</span><br><span class="line">            <span class="keyword">while</span>(p2 &lt; length &amp;&amp; set.add(s.substring(p2, p2+<span class="number">1</span>)))&#123;</span><br><span class="line">                max = Math.max(max, p2-p1+<span class="number">1</span>);</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">            set.remove(s.substring(p1, p1+<span class="number">1</span>));</span><br><span class="line">            p1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="159-Longest-Substring-with-at-most-Two-Distinct-Characters"><a href="#159-Longest-Substring-with-at-most-Two-Distinct-Characters" class="headerlink" title="159.Longest Substring with at most Two Distinct Characters"></a>159.Longest Substring with at most Two Distinct Characters</h3><p>Given a string, find the length of the longest substring T that contains at most 2 distinct characters.</p><p>For example, Given s = “eceba”,</p><p>T is “ece” which its length is 3.</p><ul><li>两个指针，一个map来记录字符及其出现次数。</li><li>一个右指针先移动，不断更新map, </li><li>当发现map里的字符个数大于规定个数的时候，开始移动左指针，同时更新map,</li><li>直到map里的字符个数等于规定个数，</li><li>中间不断更新包含规定字符个数的最大长度。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length()) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 根据右指针指的当前字符更新map</span></span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(c)) &#123;</span><br><span class="line">                map.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(c, map.get(c) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 移动左指针，直到map中字符数量降至规定数量</span></span><br><span class="line">            <span class="keyword">while</span> (map.size() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">char</span> leftChar = s.charAt(left);</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(leftChar)) &#123;</span><br><span class="line">                </span><br><span class="line">                    <span class="comment">// 注意会有重复元素，所以先减小次数，只有次数降至0，才删除元素</span></span><br><span class="line">                    map.put(leftChar, map.get(leftChar) - <span class="number">1</span>);                     </span><br><span class="line">                    <span class="keyword">if</span> (map.get(leftChar) == <span class="number">0</span>) &#123; </span><br><span class="line">                        map.remove(leftChar);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;               </span><br><span class="line">            maxLen = Math.max(maxLen, i - left + <span class="number">1</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Follow up</strong>: 340.Longest Substring with at most k Distinct Characters</p><blockquote><p>最多允许k个字符</p></blockquote><p>上面的代码直接把2改成k即可。</p><h3 id="76-Minimum-Window-Substring"><a href="#76-Minimum-Window-Substring" class="headerlink" title="76.Minimum Window Substring"></a>76.Minimum Window Substring</h3><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p><p><strong>Example:</strong></p><pre><code>Input: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;Output: &quot;BANC&quot;</code></pre><p><strong>Note:</strong></p><ul><li>If there is no such window in S that covers all characters in T, return the empty string “”.</li><li><p>If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</p></li><li><p>类似于Longest Substring with At Most Two Distinct Characters。</p></li><li>此类window题型，我们都需要用<strong>两个指针</strong>，用<strong>一个map</strong>记录字符及其出现次数，</li><li>不同的是由于这里题目要求是覆盖字符串T中所有字符，所以我们需要用一个变量如<strong>count</strong>来记录window中覆盖字符串T中有效字符的个数。</li><li>只要count == T.length(), 便可更新window的最短长度。</li><li>同时，我们必须移动左指针，直到window中包含的字符个数小于规定的数量，我们才开始移动右指针。另外要注意何时更新count的值。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 建map, 记录被包含字符串中字符及其个数</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = t.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(c)) &#123;</span><br><span class="line">                map.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(c, map.get(c) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minStart = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minLen = s.length() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.get(c) &gt; <span class="number">0</span>)  </span><br><span class="line">                    count++; <span class="comment">// 注意count++的条件</span></span><br><span class="line">                map.put(c, map.get(c) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (count == t.length()) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 不断更新最值</span></span><br><span class="line">                <span class="keyword">if</span> (i - l + <span class="number">1</span> &lt; minLen) &#123;</span><br><span class="line">                    minLen = i - l + <span class="number">1</span>;</span><br><span class="line">                    minStart = l;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 移动左指针</span></span><br><span class="line">                <span class="keyword">char</span> leftChar = s.charAt(l);</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(leftChar)) &#123;</span><br><span class="line">                    map.put(leftChar, map.get(leftChar) + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (map.get(leftChar) &gt; <span class="number">0</span>) &#123; </span><br><span class="line">                        count--; <span class="comment">// 注意count--条件</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (minLen == s.length() + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(minStart, minLen + minStart);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="30-Substring-with-Concatenation-of-All-Words"><a href="#30-Substring-with-Concatenation-of-All-Words" class="headerlink" title="30.Substring with Concatenation of All Words"></a>30.Substring with Concatenation of All Words</h3><p>You are given a string, <strong>s</strong>, and a list of words, <strong>words</strong>, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.</p><p><strong>Example 1:</strong></p><pre><code>Input:  s = &quot;barfoothefoobarman&quot;,  words = [&quot;foo&quot;,&quot;bar&quot;]Output: [0,9]Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively.The output order does not matter, returning [9,0] is fine too.</code></pre><p><strong>Example 2:</strong></p><pre><code>Input:  s = &quot;wordgoodstudentgoodword&quot;,  words = [&quot;word&quot;,&quot;student&quot;]Output: []</code></pre><blockquote><p>输入一个字符串s和一个字符串数组words，其中words中的每个word的长度都相等。在字符串中找到所有子字符串的起始下标，只要该子字符串满足words中所有单词的连接结果（顺序无关）</p></blockquote><ul><li>把每个词当作一个字母来看待，但是要遍历K次，K是单词的长度，因为我们要分别统计从下标0开头，从下标1开头。。。直到下标K-1开头的字符串。</li><li>通过哈希表维护一个窗口，比如foo|bar|foo中，我们先拿出foo。如果foo都不在数组中，那说明根本不能拼进去，则哈希表全部清零，从下一个词开始重新匹配。</li><li>但是foo是在数组中的，所以给当前搜索的哈希表计数器加上1，如果发现当前搜索中foo出现的次数已经比给定数组中foo出现的次数多了，我们就要把上一次出现foo之前的所有词都从窗口中去掉</li><li>如果没有更多，则看下一个词bar，不过在这之前，我们还要看看窗口中有多少个词了，如果词的个数等于数组中词的个数，说明我们找到了一个结果。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(words == <span class="keyword">null</span> || words.length == <span class="number">0</span> || s == <span class="keyword">null</span> || s.equals(<span class="string">""</span>)) <span class="keyword">return</span> res;</span><br><span class="line">        HashMap&lt;String, Integer&gt; freq = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">        <span class="comment">// 统计数组中每个词出现的次数，放入哈希表中待用</span></span><br><span class="line">        <span class="keyword">for</span>(String word : words)&#123;</span><br><span class="line">            freq.put(word, freq.containsKey(word) ? freq.get(word) + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到每个词的长度</span></span><br><span class="line">        <span class="keyword">int</span> len = words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="comment">// 错开位来统计</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="comment">// 建一个新的哈希表，记录本轮搜索中窗口内单词出现次数</span></span><br><span class="line">            HashMap&lt;String, Integer&gt; currFreq = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">            <span class="comment">// start是窗口的开始，count表明窗口内有多少词</span></span><br><span class="line">            <span class="keyword">int</span> start = i, count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= s.length() - len; j += len)&#123;</span><br><span class="line">                String sub = s.substring(j, j + len);</span><br><span class="line">                <span class="comment">// 看下一个词是否是给定数组中的</span></span><br><span class="line">                <span class="keyword">if</span>(freq.containsKey(sub))&#123;</span><br><span class="line">                    <span class="comment">// 窗口中单词出现次数加1</span></span><br><span class="line">                    currFreq.put(sub, currFreq.containsKey(sub) ? currFreq.get(sub) + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="comment">// 如果该单词出现次数已经超过给定数组中的次数了，说明多来了一个该单词，所以要把窗口中该单词上次出现的位置及之前所有单词给去掉</span></span><br><span class="line">                    <span class="keyword">while</span>(currFreq.get(sub) &gt; freq.get(sub))&#123;</span><br><span class="line">                        String leftMost = s.substring(start, start + len);</span><br><span class="line">                        currFreq.put(leftMost, currFreq.get(leftMost) - <span class="number">1</span>);</span><br><span class="line">                        start = start + len;</span><br><span class="line">                        count--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果窗口内单词数和总单词数一样，则找到结果</span></span><br><span class="line">                    <span class="keyword">if</span>(count == words.length)&#123;</span><br><span class="line">                        String leftMost = s.substring(start, start + len);</span><br><span class="line">                        currFreq.put(leftMost, currFreq.get(leftMost) - <span class="number">1</span>);</span><br><span class="line">                        res.add(start);</span><br><span class="line">                        start = start + len;</span><br><span class="line">                        count--;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="comment">// 如果截出来的单词都不在数组中，前功尽弃，重新开始</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    currFreq.clear();</span><br><span class="line">                    start = j + len;</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="249-Group-Shift-Strings"><a href="#249-Group-Shift-Strings" class="headerlink" title="249.Group Shift Strings"></a>249.Group Shift Strings</h3><p>Given a string, we can “shift” each of its letter to its successive letter, for example: “abc” -&gt; “bcd”. We can keep “shifting” which forms the sequence:</p><pre><code>&quot;abc&quot; -&gt; &quot;bcd&quot; -&gt; ... -&gt; &quot;xyz&quot;</code></pre><p>Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence.</p><p>For example, given: [“abc”, “bcd”, “acef”, “xyz”, “az”, “ba”, “a”, “z”], </p><p>A solution is:</p><pre><code>[[&quot;abc&quot;,&quot;bcd&quot;,&quot;xyz&quot;],[&quot;az&quot;,&quot;ba&quot;],[&quot;acef&quot;],[&quot;a&quot;,&quot;z&quot;]]</code></pre><ul><li>同一组string, 他们的间隔是一样的</li><li>判断间隔，以间隔为key</li><li>value为相同间隔的string的list</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; groupStrings(String[] strings) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String str : strings) &#123;</span><br><span class="line">            String key = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> offset = str.charAt(i) - str.charAt(i - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//在为负数的时候，当经过z, a的时候，数值大小会很大得反转</span></span><br><span class="line">                key += offset &lt; <span class="number">0</span> ? offset + <span class="number">26</span> : offset;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(key)) map.put(key, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">            map.get(key).add(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; list : map.values()) &#123;</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="288-Unique-Word-Abbreviation"><a href="#288-Unique-Word-Abbreviation" class="headerlink" title="288.Unique Word Abbreviation"></a>288.Unique Word Abbreviation</h3><p>An abbreviation of a word follows the form <first letter=""><number><last letter="">. Below are some examples of word abbreviations:</last></number></first></p><pre><code>a) it                      --&gt; it    (no abbreviation)     1b) d|o|g                   --&gt; d1g              1    1  1     1---5----0----5--8c) i|nternationalizatio|n  --&gt; i18n              1     1---5----0d) l|ocalizatio|n          --&gt; l10n</code></pre><p>Assume you have a dictionary and given a word, find whether its abbreviation is unique in the dictionary.<br>A word abbreviation is unique if no other word from the dictionary has the same abbreviation.</p><p><strong>Example:</strong></p><pre><code>Given dictionary = [ &quot;deer&quot;, &quot;door&quot;, &quot;cake&quot;, &quot;card&quot; ]isUnique(&quot;dear&quot;) -&gt; falseisUnique(&quot;cart&quot;) -&gt; trueisUnique(&quot;cane&quot;) -&gt; falseisUnique(&quot;make&quot;) -&gt; true</code></pre><ul><li>首字母+中间str长度+尾字母</li><li>判断是否唯一</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidWordAbbr</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Set&lt;String&gt; &gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ValidWordAbbr</span><span class="params">(String[] dictionary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dictionary.length; i++) &#123;</span><br><span class="line">            String s = dictionary[i];</span><br><span class="line">            <span class="keyword">if</span>(s.length() &gt; <span class="number">2</span> ) &#123;</span><br><span class="line">                s = s.charAt(<span class="number">0</span>) + Integer.toString(s.length()-<span class="number">2</span>) + s.charAt(s.length()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s) ) &#123;</span><br><span class="line">                map.get(s).add(dictionary[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">                set.add(dictionary[i]);</span><br><span class="line">                map.put(s, set);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//input check</span></span><br><span class="line">        String s = word;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &gt; <span class="number">2</span> ) &#123;</span><br><span class="line">            s = s.charAt(<span class="number">0</span>) + Integer.toString(s.length()-<span class="number">2</span>) + s.charAt(s.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(s)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> map.get(s).contains(word) &amp;&amp; map.get(s).size()&lt;=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Array&quot;&gt;&lt;a href=&quot;#Array&quot; class=&quot;headerlink&quot; title=&quot;Array&quot;&gt;&lt;/a&gt;Array&lt;/h2&gt;&lt;h3 id=&quot;217-Contains-Duplicate&quot;&gt;&lt;a href=&quot;#217-Contains-Duplicate&quot; class=&quot;headerlink&quot; title=&quot;217.Contains Duplicate&quot;&gt;&lt;/a&gt;217.Contains Duplicate&lt;/h3&gt;&lt;p&gt;Given an array of integers, find if the array contains any duplicates.&lt;/p&gt;
&lt;p&gt;Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.&lt;/p&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode Category" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/LeetCode-Category/"/>
    
    
      <category term="Array" scheme="blog.jiangdongyu.space/tags/Array/"/>
    
      <category term="String" scheme="blog.jiangdongyu.space/tags/String/"/>
    
      <category term="HashTable" scheme="blog.jiangdongyu.space/tags/HashTable/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集器与内存分配策略</title>
    <link href="blog.jiangdongyu.space/2018/06/06/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <id>blog.jiangdongyu.space/2018/06/06/垃圾收集器与内存分配策略/</id>
    <published>2018-06-06T10:54:00.000Z</published>
    <updated>2018-06-08T12:22:08.360Z</updated>
    
    <content type="html"><![CDATA[<p><strong>垃圾回收主要是对Java堆、方法区内存的回收</strong></p><h2 id="对象已死吗"><a href="#对象已死吗" class="headerlink" title="对象已死吗"></a>对象已死吗</h2><p>堆中存放着几乎所有的对象实例，回收前，需要对对象是否存活进行确定，判断是否能进行回收</p><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><ul><li>给对象添加一个引用计数器</li><li>引用则加1</li><li>引用失效，则减1</li><li>计数器为0的对象就可以被回收</li></ul><p><strong>优点：</strong><br>实现简单，效率高<br><a id="more"></a></p><p><strong>缺点：</strong><br>Java中不用，<strong>很难解决循环引用问题</strong></p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><ul><li>“GC Roots”对象为起点，开始向下搜索</li><li>搜索走过的路径称为<strong>引用链</strong></li><li>当一个对象到“GC Roots”没有引用链相连时，该对象不可用</li></ul><p><strong>Java和C#中都是采用该算法来判定对象是否存活的。</strong></p><p>Java中，可作为GC Roots的对象如下:</p><ol><li>虚拟机栈（栈桢中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI引用的对象</li></ol><h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>强引用、软引用、弱引用、虚引用，强度依次减弱</p><ul><li>强引用，类似Object obj = new Object(), 只要强引用还在，系统不会回收</li><li>软引用，还有用但非必需的对象，会在内存不足的时候释放</li><li>弱引用，非必需对象，被弱引用关联的对象只能生存到下一次垃圾回收之前</li><li>虚应用，不能用虚引用获得一个实例对象，存在是为了在对象被回收后获得系统反馈</li></ul><h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><ul><li>可达性分析算法中不可达，也不一定是“非死不可”</li><li>真正被回收，至少要经历两次标记过程：<ul><li>进行可达性分析后没有与GC Roots相连接的引用链，第一次标记并筛选，筛选的条件是对象是否有必要执行<strong>finalize()</strong>方法（对象未覆盖finalize()方法或者该方法已经被调用过，视为“没有必要执行”）</li><li>如果判定为有必要，则该对象会被放置在F-Queue队列中，会有低优先级的线程去触发</li><li>稍后GC对F-Queue中对象进行二次标记，如果对象在finalize()方法中重新产生引用链，则被移出“即将回收”集合</li></ul></li></ul><p><strong>一个对象的finalize()方法最多只会被系统自动调用一次</strong></p><h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>方法区（HotSpot中的永久代）垃圾回收率很低。</p><p>永久代垃圾回收收集废弃常量和无用的类。</p><ul><li>回收常量：没有引用即可</li><li>回收类，无用的类的判定：<ul><li>类的所有实例被回收，Java堆中不存在该类的任何实例</li><li>加载该类的ClassLoader被回收</li><li>该类对应的java.lang.Class对象没有被引用，无法通过反射访问该类的方法</li></ul></li><li>虚拟机<strong>可以</strong>对符合上述条件的类回收</li><li>是否对类回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息</li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>标记需要回收对象，统一回收，不作处理</p><p><strong>优点：</strong><br>不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效。</p><p><strong>缺点：</strong></p><ul><li>标记和清除过程的效率都不高（这种方法需要使用一个空闲列表来记录所有的空闲区域以及大小。对空闲列表的管理会增加分配对象时的工作量）</li><li>标记清除后会产生大量不连续的内存碎片。虽然空闲区域的大小是足够的，但是可能没有足够大的连续空间。</li></ul><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><ul><li>内存等量分为两块，每次只使用一块</li><li>当一块用完时，将存活对象复制到另一块上</li><li>把再把已使用过的内存空间一次清理掉</li></ul><p><strong>复制算法比较适合于新生代（短生存期的对象），在老年代（长生存期的对象）中，对象存活率比较高，如果执行较多的复制操作，效率将会变低，所以老年代一般会选用其他算法，如标记—整理算法。</strong></p><p><strong>优点：</strong></p><ul><li>标记阶段和复制阶段可以同时进行。</li><li>每次只对一块内存进行回收，运行高效。</li><li>只需移动栈顶指针，按顺序分配内存即可，实现简单。</li><li>内存回收时不用考虑内存碎片的出现（得活动对象所占的内存空间之间没有空闲间隔）。</li></ul><p><strong>缺点：</strong><br>需要一块能容纳下所有存活对象的额外的内存空间。因此，可一次性分配的最大内存缩小了一半。</p><p>HotSpot虚拟机默认Eden和Survivor的大小比例是8:1, 当Survivor内存不够时，需要依赖其他内存（老年代）进行分配担保。</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>将所有对象内存向一端移动，清除端外的。</p><p><strong>优点：</strong></p><ul><li>经过整理之后，新对象的分配只需要通过指针碰撞便能完成（Pointer Bumping），相当简单。</li><li>使用这种方法空闲区域的位置是始终可知的，也不会再有碎片的问题了。</li></ul><p><strong>缺点：</strong><br>GC暂停的时间会增长，因为你需要将所有的对象都拷贝到一个新的地方，还得更新它们的引用地址。</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>新生代：复制<br>老年代：标记-清除、标记-整理算法</p><h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><p>GC Roots找引用链，需要消耗很多时间</p><p>GC停顿需要在保持<strong>一致性</strong>的快照中进行（分析期间，对象引用关系不变），GC停顿指GC进行时停顿所有Java执行线程。</p><p>使用准确式GC，直接得知哪些地方存放着对象引用。HotSpot使用OopMap来达到这一目的，在类加载完成时，HotSpot把对象内什么偏移量时什么类型数据计算出来，在JIT编译过程中，在<strong>安全点</strong>记录下栈和寄存器中哪些位置是引用。</p><p>程序执行时在安全点才会停下来GC，安全点的选定是以程序“是否具有让程序长时间执行的特征”为标准进行选定的，“长时间执行”最明显的特征是<strong>指令序列复用</strong>，例如方法调用、循环跳转、异常跳转等。</p><p>GC发生时有两种方案让所有线程都“跑”到最近的安全点才停顿下来：</p><ul><li>抢先式中断(几乎不用)：GC发生时，把线程全部中断，如果线程不在安全点，就恢复，让它“跑”在安全点上</li><li>主动式中断：设置标志，线程去轮询，标志为真时就中断挂起。轮询标志和安全点是重合的，另外再加上创建对象需要分配内存的地方。</li></ul><p>安全点保证了<strong>程序运行时</strong>，能在不太长时间内遇到可进入GC的安全点。但程序“不执行”、<strong>没有分配CPU时</strong>，比如线程处于sleep或blocked时，就需要<strong>安全区域</strong>。</p><p>执行到Safe Region中的代码时，首先标识进入了Safe Region，线程要离开Safe Region时，检查系统是否已经完成根节点枚举（or整个GC过程）,如果完成，线程继续执行，否则必须等待知道收到可以离开的信号。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>讨论的收集器基于JDK    1.7 Update 14之后的HotSpot虚拟机，虚拟机包含的所有收集器如下图：</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG253.jpeg" alt="avatar"></p><p>如果两个收集器之前存在连线，则说明可以搭配使用。虚拟机所处的区域，表示它属于新生代还是老年代。</p><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>单线程收集器，只使用一个CPU或一条收集线程去完成垃圾收集工作，收集时，<strong>暂停其他所有工作线程</strong>，直至收集结束。</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG254.jpeg" alt="avatar"></p><p><strong>优点：</strong><br>简单而高效（与其他收集器的单线程比）</p><p><strong>缺点：</strong><br>Stop The World，其它工作线程在用户不可见时全部停掉</p><p><strong>使用场景：</strong><br>运行在Client模式下的虚拟机</p><h3 id="ParNew收集器（并行）"><a href="#ParNew收集器（并行）" class="headerlink" title="ParNew收集器（并行）"></a>ParNew收集器（并行）</h3><p>Serial收集器的多线程版本，进行垃圾收集时也会停止工作线程</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG255.jpeg" alt="avatar"></p><p>是许多运行在Server模式下的虚拟机中首选的新生代收集器，很大原因在于，只有Serial收集器和ParNew收集器能与CMS收集器配合工作</p><p><strong>注意</strong></p><ul><li><p>并行（parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；</p></li><li><p>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。</p></li></ul><h3 id="Parallel-Scavenge收集器（并行）"><a href="#Parallel-Scavenge收集器（并行）" class="headerlink" title="Parallel Scavenge收集器（并行）"></a>Parallel Scavenge收集器（并行）</h3><p>新生代收集器、使用复制算法、并行的多线程收集器</p><p>不能与CMS收集器配合使用，目标达到一个<strong>可控制的吞吐量</strong>（Throughput）。吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间)</p><p>停顿时间越短越适合需要与用户交互的程序，良好的响应时间速度能提升用户体验，而高吞吐量可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>控制最大垃圾收集停顿时间：-XX:MaxGCPauseMillis，直接设置吞吐量大小参数：-XX: GCTimeRatio（0-100）。</p><p>-XX：+UseAdaptiveSizePlicvy，开关参数，当参数打开之后，就不需要手工指定新生代大小-Xmn、Eden与Survivor区的比例-XX:SurviviorRatio、晋升到老年代对象年龄-XX:PretenureSizeThreshold等细节参数了，虚拟机会根据当前系统运行情况收集性能监控信息，动态调整这些参数以提供合适的停顿时间或者最大吞吐量，这种调节方式称为<strong>GC自适应的调节策略</strong>（GC Ergonomics）。</p><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial收集器老年代版本，也是用于给Client模式下的虚拟机使用</p><p>在Server模式下，两大用途：</p><ul><li>在JDK1.5及以上，与Parallel Scavenge收集器搭配使用（Parallel Scavenge收集器架构中本身有PS MarkSweep收集器进行老年代的收集，并非直接使用Serial Old，但Serial Old与PS MarkSweep实现非常接近）</li><li>作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用</li></ul><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Scavenge老年代版本，使用多线程和“标记-整理”算法</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG259.jpeg" alt="avatar"></p><p><strong>使用场景：</strong><br>注重高吞吐量以及CPU资源敏感的场合，可以考虑Parallel Scavenge加Parallel Old</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上。基于“标记-清除”算法实现。</p><ul><li>初始标记：Stop the World，只是标记一下GC Roots能直接关联到的对象，用户进程停顿</li><li>并发标记：进行GC Roots Tracing（追踪）的过程，并发用户进程</li><li>重新标记：Stop the World，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，用户进程停顿</li><li>并发删除：并发用户进程</li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG260.jpeg" alt="avatar"></p><p><strong>优点：</strong><br>并发收集、低停顿</p><p><strong>缺点：</strong></p><ul><li>对CPU资源敏感，并发阶段，占用线程（CPU资源）导致应用程序变慢，总吞吐量降低</li><li>无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。“浮动垃圾”指在并发清理过程中用户进程仍在运行，自然会产生垃圾，这部分垃圾出现在标记过程之后，CMS无法当次集中处理，只好留到下一次GC.</li><li>基于“标记-清除”算法，空间碎片过多，但无法找到足够大的连续空间用以分配，触发Full GC</li></ul><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>面向服务端的垃圾收集器</p><p><strong>特点：</strong></p><ul><li>并行与并发：缩短Stop the World停顿时间</li><li>分代收集：采用不同方式处理新对象和存活一段时间的对象</li><li>空间整合：与CMS的标记-清理算法不同，整体基于标记-整理算法，从局部（两个Region之间）基于复制算法。不会产生空间碎片。</li><li>可预测的停顿，之所以能做到，是因为能有计划避免在整个堆中进行全区域的垃圾收集</li></ul><p>将堆划分为等大小的独立区域（Region），跟踪各个Region里垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p><p>使用Remembered Set避免全堆扫描，处于不同的Region，则记录到被引用对象的Region中，在GC根节点枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</p><p>不计算维护Remembered Set操作，大致分为以下步骤：</p><ul><li>初始标记：标记一下GC Roots能直接关联到的对象，并修改TAMS(Next Top at Mark Start)的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，<strong>停顿</strong>线程</li><li>并发标记：进行GC Roots Tracing（追踪）的过程，<strong>并发</strong>用户进程</li><li>最终标记：修正在并发标记期间因用户程序继续运作而导致标记表动的那一部分标记记录，虚拟机将并发标记期间的对象变化记录在Remembered Set Logs中，在这阶段将这部分数据合并到Remembered Set中，<strong>停顿线程，但可并行执行</strong></li><li>筛选回收：对各Region的回收价值和成本排序，根据用户所期望的GC停顿来制定回收计划，可以做到并发，但意义不大</li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG261.jpeg" alt="avatar"></p><h3 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h3><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG262.jpeg" alt="avatar"></p><ul><li>“33.125”和“100.667”代表GC发生的<strong>时间</strong>，是从Java虚拟机启动以来经过的秒数</li><li>“[GC”和”[Full GC”说明<strong>垃圾收集的停顿类型</strong>，如果有”Full”说明是发生了Stop-The-World，如果是调用System.gc()触发的收集，则显示”[Full GC(System)”</li><li>“[DefNew”(Default New Generation)、”[ParNew”(Parallel New Generation)、”[PSYoungGen”(Parallel Scavenge)表示GC发生的<strong>区域</strong></li><li>方括号内部的”3324K-&gt;152(3712K)”指“GC前该内存区域已使用容量-&gt;GC后该内存区域已使用容量(该内存区域总容量)”;方括号之外的“3324K-&gt;152(11904K)”表示“GC前Java堆已使用容量-&gt;GC后Java堆已使用容量(Java堆总容量)”</li><li>“0.0025925secs”表示该内存区域GC所占用的时间</li></ul><h3 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h3><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG264.jpeg" alt="avatar"><br><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG263.jpeg" alt="avatar"></p><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><ul><li>对象优先在Eden分配，当Eden区没有足够空间进行分配时，虚拟机发起Minor GC，分配担保机制提前将原占用Eden的资源转移到老年代中<ul><li>新生代GC(Minor GC): 发生在新生代的垃圾收集行为，频繁，回收速度快</li><li>老年代GC(Major GC/Full GC): 发生在老年代的GC,经常伴随至少一次的Minor GC(非绝对),比Minor GC慢10倍以上</li></ul></li><li>大对象(需要大量连续内存空间的对象)直接进入老年代</li><li>长期存活的对象将进入老年代</li></ul><p>虚拟机采用<strong>分代收集</strong>思想管理内存，那么内存回收时就必须能识别对象放在哪。虚拟机给每个对象定义了一个<strong>对象年龄(Age)</strong>计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Surviror容纳得话，将被移到Surviror空间中，并且对象年龄设为1。对象在Surviror区每熬过一次Minor GC, 年龄就增加1岁，当年龄增加到一定程度(默认15岁)，就会被晋升到老年代中。</p><p>虚拟机并不是永远要求对象年龄必须达到了MaxTenuringThreshold才能晋升到老年代，如果在Surviror空间中<strong>相同年龄的所有对象大小总和大于Surviror空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代</strong>，无须等到MaxTenuringThreshold要求的年龄。</p><p>发生Minor GC前，先检查老年代最大可用连续空间是否能够存放新生代所有对象，能则确保Minor GC安全。否则，则看HandlePromotionFailure是否允许担保失败。如果允许，则继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，大于则进行Minor GC；如果小于，或者HandlePromotionFailure设置不允许冒险，则进行Full GC。</p><p>在JDK 6 Update 24后，<strong>只要老年代的联系空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则Full GC</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;垃圾回收主要是对Java堆、方法区内存的回收&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;对象已死吗&quot;&gt;&lt;a href=&quot;#对象已死吗&quot; class=&quot;headerlink&quot; title=&quot;对象已死吗&quot;&gt;&lt;/a&gt;对象已死吗&lt;/h2&gt;&lt;p&gt;堆中存放着几乎所有的对象实例，回收前，需要对对象是否存活进行确定，判断是否能进行回收&lt;/p&gt;
&lt;h3 id=&quot;引用计数算法&quot;&gt;&lt;a href=&quot;#引用计数算法&quot; class=&quot;headerlink&quot; title=&quot;引用计数算法&quot;&gt;&lt;/a&gt;引用计数算法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;给对象添加一个引用计数器&lt;/li&gt;
&lt;li&gt;引用则加1&lt;/li&gt;
&lt;li&gt;引用失效，则减1&lt;/li&gt;
&lt;li&gt;计数器为0的对象就可以被回收&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;br&gt;实现简单，效率高&lt;br&gt;
    
    </summary>
    
      <category term="Java基础" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="深入理解Java虚拟机" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="自动内存管理机制" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
    
      <category term="JVM" scheme="blog.jiangdongyu.space/tags/JVM/"/>
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java内存区域与内存溢出异常</title>
    <link href="blog.jiangdongyu.space/2018/06/05/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
    <id>blog.jiangdongyu.space/2018/06/05/Java内存区域与内存溢出异常/</id>
    <published>2018-06-05T06:00:00.000Z</published>
    <updated>2018-06-05T08:29:52.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java技术体系"><a href="#Java技术体系" class="headerlink" title="Java技术体系"></a>Java技术体系</h2><p>Java程序设计语言、Java虚拟机、Java API类库三部分统称为<strong>JDK</strong>，JDK是用于支持Java程序开发的最小环境。Java API类库中的Java SE API子集和Java虚拟机这两个部分统称为<strong>JRE</strong>，JRE是支持Java程序运行的标准环境。</p><a id="more"></a><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="http://p9fh1pach.bkt.clouddn.com/Java2.png" alt="avatar"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>线程独立，唯一没有规定OutOfMemoryError的区域</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><ul><li>线程私有，生命周期和线程相同</li><li>平时所谓的堆、栈、方法区，栈就是指<strong>虚拟机栈</strong>，或者说是其中的<strong>局部变量表</strong>部分</li><li>两种异常状况<ul><li>StackOverflowError: 线程请求栈深度大于所允许</li><li>OutOfMemoryError: 扩展无法申请足够内存</li></ul></li></ul><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>和虚拟机栈发挥作用相似</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><ul><li>线程共享，虚拟机启动时创建，<strong>存放对象实例</strong></li><li>GC管理的主要区域</li><li>内存空间不连续</li><li>OutOfMemoryError: 堆中没有内存完成实例分配并且无法扩展时</li></ul><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul><li>线程共享</li><li>存放类信息、常量、静态变量、即时编译器编译后的代码</li><li>OutOfMemoryError: 无法满足内存分配需求时</li></ul><h3 id="JVM实例"><a href="#JVM实例" class="headerlink" title="JVM实例"></a>JVM实例</h3><p><img src="http://p9fh1pach.bkt.clouddn.com/%E5%A0%86%E6%A0%88%E6%96%B9%E6%B3%95%E5%8C%BA.jpg" alt="avatar"></p><h2 id="HotSpot虚拟机对象揭秘"><a href="#HotSpot虚拟机对象揭秘" class="headerlink" title="HotSpot虚拟机对象揭秘"></a>HotSpot虚拟机对象揭秘</h2><p>HotSpot虚拟机在Java堆中对象分配、布局、访问的全过程</p><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><ul><li>虚拟机遇到new指令，检查指令的参数能否在常量池中定位到一个类的符号引用</li><li>检查所代表的类是否已被加载、解析和初始化过</li><li>没有，则先执行类加载过程</li><li>虚拟机为新生对象分配内存，对象所需内存大小在类加载完成后便可确定<ul><li>指针碰撞: 假设Java堆内存绝对规整，用过的内存和没用过的严格分开，有一个指针作为分界点的指示器，移动指针即可</li><li>空闲列表: 内存不规整，维护列表，记录是否可用，需要在列表中找一块足够大的区域</li></ul></li><li>对象创建频繁，可能会导致在并发情况下线程不安全<ul><li>对分配内存动作加上同步处理: CAS+失败重试</li><li>按线程划分在不同空间，每个线程预先分配<strong>本地线程分配缓冲(TLAB)</strong>，哪个线程需要分配内存，就在哪个线程的TLAB分配，只有在用完并分配新的TLAB时才同步锁定</li></ul></li><li>将分配到的内存空间初始化为零值</li><li>根据<strong>对象头</strong>对对象进行必要的设置</li><li>执行<init>方法</init></li></ul><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>HotSpot中分3块区域: 对象头、实例数据、对齐填充</p><ul><li>对象头<ol><li>存储对象自身运行时数据: 哈希码、GC分代年龄…</li><li>类型指针，对象指向其类原数据的指针，<strong>确定对象是哪个类的实例</strong>（不是所有虚拟机实现都必须保留该指针）</li></ol></li><li>实例数据: 在代码中定义的各种类型的字段内容<ul><li>HotSpot默认相同宽度字段被分配到一起，比如shorts/chars，父类的变量在子类之前</li></ul></li><li>对齐填充(不一定存在，占位作用)</li></ul><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>使用对象需要通过<strong>栈</strong>上的reference来操作<strong>堆</strong>上的具体对象，引用如何去定位，主流有两种：</p><ul><li>句柄（稳定）<ul><li>reference存储对象的句柄地址，句柄中包含对象实例数据和类型数据的具体信息<br><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG239.jpeg" alt="avatar"></li></ul></li><li>直接指针（速度快，HotSpot）<ul><li>reference存储对象的地址<br><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG240.jpeg" alt="avatar"></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java技术体系&quot;&gt;&lt;a href=&quot;#Java技术体系&quot; class=&quot;headerlink&quot; title=&quot;Java技术体系&quot;&gt;&lt;/a&gt;Java技术体系&lt;/h2&gt;&lt;p&gt;Java程序设计语言、Java虚拟机、Java API类库三部分统称为&lt;strong&gt;JDK&lt;/strong&gt;，JDK是用于支持Java程序开发的最小环境。Java API类库中的Java SE API子集和Java虚拟机这两个部分统称为&lt;strong&gt;JRE&lt;/strong&gt;，JRE是支持Java程序运行的标准环境。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="深入理解Java虚拟机" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="自动内存管理机制" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
    
      <category term="JVM" scheme="blog.jiangdongyu.space/tags/JVM/"/>
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Quick Select</title>
    <link href="blog.jiangdongyu.space/2018/06/04/QuickSelect/"/>
    <id>blog.jiangdongyu.space/2018/06/04/QuickSelect/</id>
    <published>2018-06-04T03:50:00.000Z</published>
    <updated>2018-06-05T06:49:00.451Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>Quick Select是由quick sort而来，只是它只用了quick sort前面partition的部分</p><p>平均时间复杂度：O(n),最差: O(n^2)</p><a id="more"></a><h2 id="模板思路"><a href="#模板思路" class="headerlink" title="模板思路"></a>模板思路</h2><h3 id="选最后一个"><a href="#选最后一个" class="headerlink" title="选最后一个"></a>选最后一个</h3><ol><li>每次选一个pivot，可以选最后一个</li><li>两个变量，一个存比pivot小的数left，一个存比pivot大的数right</li><li>初始化: left = 0, right = length - 1</li><li>left == right则break</li></ol><p><strong>核心代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(nums[left] &lt; pivot &amp;&amp; left &lt; right)&#123;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(nums[right] &gt;= pivot &amp;&amp; left &lt; right)&#123;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left == right) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选第一个"><a href="#选第一个" class="headerlink" title="选第一个"></a>选第一个</h3><ol><li>每次选一个pivot，可以选第一个</li><li>两个变量，一个存比pivot小的数left，一个存比pivot大的数right</li><li>初始化: left = 0, right = length - 1</li><li>p从0开始遇到right结束</li></ol><p><strong>核心代码</strong></p><pre><code>while(p &lt;= right){    if(nums[left] &lt; pivot){        swap(nums, left, p);        left++;        p++;    }else if(nums[right] == pivot){        p++;    }else{        swap(nums, right, p);        right--;    }}</code></pre><h3 id="215-Kth-Largest-Element-in-an-Array"><a href="#215-Kth-Largest-Element-in-an-Array" class="headerlink" title="215.Kth Largest Element in an Array"></a>215.Kth Largest Element in an Array</h3><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p><strong>Example 1:</strong></p><pre><code>Input: [3,2,1,5,6,4] and k = 2Output: 5</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: [3,2,3,1,2,4,5,5,6] and k = 4Output: 4</code></pre><p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p><ul><li>直接排序，返回排序后nums[nums.length-k]</li><li>建小顶堆(默认)，size大于k则poll，最后返回堆顶元素</li><li>QuickSelect</li></ul><p><strong>QuickSelect方法代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[end];</span><br><span class="line">    <span class="keyword">int</span> left = start, right = end;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">       <span class="keyword">while</span>(nums[left] &lt; pivot &amp;&amp; left &lt; right)&#123;</span><br><span class="line">           left++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(nums[right] &gt;= pivot &amp;&amp; left &lt; right)&#123;</span><br><span class="line">           right--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(left == right) <span class="keyword">break</span>;</span><br><span class="line">       swap(nums,left,right);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums,left,end);</span><br><span class="line">    <span class="keyword">if</span>(left+<span class="number">1</span> == k) <span class="keyword">return</span> pivot;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(left+<span class="number">1</span> &lt; k) <span class="keyword">return</span> findKth(nums, k, left+<span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> findKth(nums, k, start, left-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="75-Sort-Color"><a href="#75-Sort-Color" class="headerlink" title="75.Sort Color"></a>75.Sort Color</h3><blockquote><p>3种颜色(0,1,2)，排序使得相同颜色相邻</p></blockquote><p>直接使用模板方法即可</p><h3 id="143-Sort-Color-II-Lintcode"><a href="#143-Sort-Color-II-Lintcode" class="headerlink" title="143.Sort Color II(Lintcode)"></a>143.Sort Color II(Lintcode)</h3><blockquote><p>k种颜色(1-k)，排序使得相同颜色相邻</p></blockquote><p>可以仍然使用以上模板方法，变化的只是需要每次找数组中的最大最小值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors2</span><span class="params">(<span class="keyword">int</span>[] colors, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>,start = <span class="number">0</span>,end = colors.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(count &lt; k)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE,max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i &lt;= end;i++)&#123;</span><br><span class="line">            min = Math.min(min,colors[i]);</span><br><span class="line">            max = Math.max(max,colors[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = start,right = end, p = start;</span><br><span class="line">        <span class="keyword">while</span>(p &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(colors[p] == min)&#123;</span><br><span class="line">                swap(colors,p,left);</span><br><span class="line">                p++;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(colors[p] &gt; min &amp;&amp; colors[p] &lt; max)&#123;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                swap(colors,p,right);</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count += <span class="number">2</span>;</span><br><span class="line">        start = left;</span><br><span class="line">        end = right;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;Quick Select是由quick sort而来，只是它只用了quick sort前面partition的部分&lt;/p&gt;
&lt;p&gt;平均时间复杂度：O(n),最差: O(n^2)&lt;/p&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode Category" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/LeetCode-Category/"/>
    
    
      <category term="Array" scheme="blog.jiangdongyu.space/tags/Array/"/>
    
      <category term="QuickSelect" scheme="blog.jiangdongyu.space/tags/QuickSelect/"/>
    
  </entry>
  
  <entry>
    <title>Two Pointer</title>
    <link href="blog.jiangdongyu.space/2018/05/31/TwoPointer/"/>
    <id>blog.jiangdongyu.space/2018/05/31/TwoPointer/</id>
    <published>2018-05-31T07:28:00.000Z</published>
    <updated>2018-06-04T03:28:24.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="双指针法的常见应用"><a href="#双指针法的常见应用" class="headerlink" title="双指针法的常见应用"></a>双指针法的常见应用</h2><p>所谓双指针，指的是在<strong>遍历对象</strong>的过程中，不是普通的使用单个指针进行访问，而是使用<strong>两个</strong>相同方向或者相反方向的指针进行扫描，从而达到相应的目的。</p><p>换言之，双指针法充分使用了<strong>数组有序</strong>这一特征，从而在某些情况下能够简化一些运算。</p><p>(注：这里的<strong>指针</strong>，并非专指c中指针的概念，而是指<strong>索引，游标或指针，可迭代对象等</strong>)</p><a id="more"></a><h3 id="209-Minimum-Size-Subarray-Sum"><a href="#209-Minimum-Size-Subarray-Sum" class="headerlink" title="209.Minimum Size Subarray Sum"></a>209.Minimum Size Subarray Sum</h3><p>Given an array of n positive integers and a positive integer s, find the minimal length of a subarray of which the sum ≥ s. If there isn’t one, return 0 instead.</p><p>For example, given the array [2,3,1,2,4,3] and s = 7, the subarray [4,3] has the minimal length under the problem constraint.</p><ul><li>最短子串和</li></ul><p><strong>思路一</strong></p><ul><li>Two Pointer<ul><li>是用两个指针形成一个移动窗口</li><li>当sum的值小于s时，将右边界向右扩张，sum += arr[right++]</li><li>当sum的值大于s时，则将左边届右移，判断取较小的count</li><li>循环条件是right &lt;= length, left &lt;= right</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, sum = <span class="number">0</span>, count = nums.length + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt;= nums.length &amp;&amp; left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; s)&#123;</span><br><span class="line">                <span class="keyword">if</span>(right &lt; nums.length)&#123;</span><br><span class="line">                    sum += nums[right];</span><br><span class="line">                &#125;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count = Math.min(count,right - left);</span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &lt;= nums.length? count:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路二</strong></p><ul><li>二分法(适用subarray sum问题)<ul><li>构造sum数组，sum[i+1] = sum[i]+nums[i]</li><li>sum数组递增</li><li>遍历数组sum，对每一个i，寻找j(右边界)，使得i～j区间的值大于s</li><li>不断更新找出最小值</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, min = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] sums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            sums[i] = nums[i] + (i == <span class="number">0</span> ? <span class="number">0</span> : sums[i - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = findWindowEnd(i, sums, s);</span><br><span class="line">            <span class="keyword">if</span> (j == nums.length) <span class="keyword">break</span>;</span><br><span class="line">            min = Math.min(j - i + <span class="number">1</span>, min);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> min == Integer.MAX_VALUE ? <span class="number">0</span> : min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findWindowEnd</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span>[] sums, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = start, j = sums.length - <span class="number">1</span>, offset = start == <span class="number">0</span> ? <span class="number">0</span> : sums[start - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = sums[m] - offset;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= s) j = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> i = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Valid-Palindrome"><a href="#Valid-Palindrome" class="headerlink" title="Valid Palindrome"></a>Valid Palindrome</h3><h4 id="125-I"><a href="#125-I" class="headerlink" title="125.I"></a>125.I</h4><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p><p>Note: For the purpose of this problem, we define empty string as valid palindrome.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;A man, a plan, a canal: Panama&quot;Output: true</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: &quot;race a car&quot;Output: false</code></pre><ul><li>双指针，首尾</li><li>注意大小写转换</li><li>isValid(char c)判断是否是a-z||A-Z||0-9</li></ul><h4 id="680-II"><a href="#680-II" class="headerlink" title="680.II"></a>680.II</h4><p>Given a non-empty string s, you may delete <strong>at most one</strong> character. Judge whether you can make it a palindrome.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;aba&quot;Output: True</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: &quot;abca&quot;Output: TrueExplanation: You could delete the character &apos;c&apos;.</code></pre><ul><li>String的题</li><li>一个用于判断是否是回文的方法</li><li>主函数判断start和end的值是否相等</li><li>不相等，则判断start+1和end||start和end-1的值是否相等</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(start) != s.charAt(end))&#123;</span><br><span class="line">                <span class="keyword">return</span> isValid(s, start+<span class="number">1</span>, end) || isValid(s, start, end-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) != s.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-Container-with-Most-Water"><a href="#11-Container-with-Most-Water" class="headerlink" title="11.Container with Most Water"></a>11.Container with Most Water</h3><p>Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p>Note: You may not slant the container and n is at least 2.</p><p><strong>问题转换成数列中选两个值使得中间的面积最大</strong></p><ul><li>首尾指针，遍历</li><li>求局部面积</li><li>如果左边较低，则将左边向中间移一点</li><li>如果右边较低，则将右边向中间移一点</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>, left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            maxArea = Math.max(maxArea,Math.min(height[left],height[right]) * (right-left));</span><br><span class="line">            <span class="keyword">if</span>(height[left] &gt; height[right])&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="42-Trapping-Rain-Water"><a href="#42-Trapping-Rain-Water" class="headerlink" title="42.Trapping Rain Water"></a>42.Trapping Rain Water</h3><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p><p><img src="http://p9fh1pach.bkt.clouddn.com/rainwatertrap.png" alt="avatar"></p><p>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p><p><strong>Example:</strong></p><pre><code>Input: [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6</code></pre><p><strong>解题方法</strong></p><p>从两边开始灌水，总是从低的一边开始灌，高的地方保持不动，同时记录下可以灌的水的总量，不断更新</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height == <span class="keyword">null</span> || height.length &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftbound = height[left], rightbound = height[right];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(leftbound &lt; rightbound)&#123;</span><br><span class="line">                <span class="comment">//左边低，从左边开始灌</span></span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span>(height[left] &lt;= leftbound)&#123;</span><br><span class="line">                    <span class="comment">//比现有的bound低，可以灌</span></span><br><span class="line">                    res += leftbound - height[left];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//比现有的bound高，更新左边的bound</span></span><br><span class="line">                    leftbound = height[left];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">                <span class="keyword">if</span>(height[right] &lt;= rightbound)&#123;</span><br><span class="line">                    res += rightbound - height[right];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    rightbound = height[right];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="61-Rotate-List"><a href="#61-Rotate-List" class="headerlink" title="61.Rotate List"></a>61.Rotate List</h3><p>Given a linked list, rotate the list to the right by k places, where k is non-negative.</p><p><strong>Example 1:</strong></p><pre><code>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULLExplanation:rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULLrotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4Output: 2-&gt;0-&gt;1-&gt;NULLExplanation:rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULLrotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULLrotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULLrotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</code></pre><ul><li>获得链表的长度n，k%n才是需要移动的</li><li>找到最后结果的链表的tail:first,循环n-k-1次找next即可</li><li>遍历找到原链表的tail:second</li><li>second.next = head</li><li>result = first.next</li><li>first.next = null</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;双指针法的常见应用&quot;&gt;&lt;a href=&quot;#双指针法的常见应用&quot; class=&quot;headerlink&quot; title=&quot;双指针法的常见应用&quot;&gt;&lt;/a&gt;双指针法的常见应用&lt;/h2&gt;&lt;p&gt;所谓双指针，指的是在&lt;strong&gt;遍历对象&lt;/strong&gt;的过程中，不是普通的使用单个指针进行访问，而是使用&lt;strong&gt;两个&lt;/strong&gt;相同方向或者相反方向的指针进行扫描，从而达到相应的目的。&lt;/p&gt;
&lt;p&gt;换言之，双指针法充分使用了&lt;strong&gt;数组有序&lt;/strong&gt;这一特征，从而在某些情况下能够简化一些运算。&lt;/p&gt;
&lt;p&gt;(注：这里的&lt;strong&gt;指针&lt;/strong&gt;，并非专指c中指针的概念，而是指&lt;strong&gt;索引，游标或指针，可迭代对象等&lt;/strong&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode Category" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/LeetCode-Category/"/>
    
    
      <category term="Array" scheme="blog.jiangdongyu.space/tags/Array/"/>
    
      <category term="TwoPointer" scheme="blog.jiangdongyu.space/tags/TwoPointer/"/>
    
  </entry>
  
  <entry>
    <title>商汤</title>
    <link href="blog.jiangdongyu.space/2018/05/18/%E5%95%86%E6%B1%A4Java%E5%AE%9E%E4%B9%A0%E7%94%9F/"/>
    <id>blog.jiangdongyu.space/2018/05/18/商汤Java实习生/</id>
    <published>2018-05-18T10:26:00.000Z</published>
    <updated>2018-05-28T10:51:52.810Z</updated>
    
    <content type="html"><![CDATA[<p>商汤Java实习生面试<br><a id="more"></a></p><ul><li>Collections框架体系<br><img src="http://p9fh1pach.bkt.clouddn.com/20170309094509415.jpeg" alt="avatar"></li><li>HashSet的特性<ul><li>基于HashMap实现</li><li>无序不重复</li></ul></li><li>HashMap结构<ul><li>哈希表，数组+链表</li></ul></li><li>HashMap和ConcurrentHashMap区别</li><li>锁的了解</li><li>线程池有哪些？</li><li>怎么实现线程？</li><li>并发包…</li><li>SpringBoot中@ReseController注解对应哪两个<ul><li>@ResponseBody和@Controller的组合注解。</li></ul></li><li>Redis支持哪些类型？<ul><li>Strings</li><li>Lists</li><li>Sets 求交集、并集</li><li>Sorted Set</li><li>hashes</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;商汤Java实习生面试&lt;br&gt;
    
    </summary>
    
      <category term="实习面试经历" scheme="blog.jiangdongyu.space/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    
      <category term="2018" scheme="blog.jiangdongyu.space/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>简历相关准备</title>
    <link href="blog.jiangdongyu.space/2018/04/30/%E7%AE%80%E5%8E%86%E5%87%86%E5%A4%87/"/>
    <id>blog.jiangdongyu.space/2018/04/30/简历准备/</id>
    <published>2018-04-30T08:30:00.000Z</published>
    <updated>2018-05-28T11:48:34.187Z</updated>
    
    <content type="html"><![CDATA[<p>简单的自我介绍<br><a id="more"></a></p><p><img src="http://p9fh1pach.bkt.clouddn.com/%E7%AE%80%E5%8E%86.png" alt="avatar"></p><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>我叫姜栋煜，现在在北京大学软件与微电子学院读研究生二年级，预计2019年6月份毕业，本科就读于北京交通大学。3月中旬结束在微软亚洲研究院的实习，主要做了课程数据的收集、维护，pipeline的日常导入以及一些数据的简单分析。此外，还做过一些导师和企业合作的项目，主要就是智慧教室，都是java web的一些项目。</p><h2 id="实习经历"><a href="#实习经历" class="headerlink" title="实习经历"></a>实习经历</h2><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>在小英组，主要产品是微软小英和Microsoft Learning Chinese，都是一些教授中小学生以及外国人学英语/中文的app，这些app会有一些对应的课程信息（json文本），课程信息的录入工具是由我去维护开发的，包括对文本、音频、视频、图片等的录入，存储主要是用了Azure Blob，音频、视频、图片存在对应的mooncake中国镜像上。</p><p>小英的用户量在200-300万左右，每天的数据量大，而且之前的pipeline导入方式费时，不易监控，就改为使用data factory,还会完成一些简单的分析工作，比如活跃用户、日留存、周留存、月留存等。。。</p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><ul><li>用于录入数据的网站，可以自动merge数据，减少人工干预</li><li>pipeline导入做到了高效，速度比原来快了3倍多，出错会发邮件</li><li>分析信息用于确定用户使用情况</li></ul><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><ul><li>内部网站数据混乱，会出现直接修改merge之后文件，而导致不一致问题的出现</li><li>data factory全靠自己看英文文档，教程少</li></ul><h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><h3 id="智慧教室"><a href="#智慧教室" class="headerlink" title="智慧教室"></a>智慧教室</h3><blockquote><p>简单而言，就是一个课堂直播的一个平台，主要分为三个端，web/phone端，树莓派，PC。web/phone端和树莓派通过websocket通信，主要传输一些控制指令，树莓派和PC通过串口直接相连。</p></blockquote><p>web端主要完成教室设备的CRUD，权限控制，还有就是给树莓派发送指令，具体的操作，比如操作教室推流真正还是由PC去完成。这个项目已经在河北邢台的一些中小学开始试用了。</p><p><strong>难点（问题）</strong></p><ul><li>SpringBoot和websocket无法注入bean的问题，其实不是不能注入，是已经注入了，但是客户端每建立一个链接就会创建一个对象，这个对象没有任何的bean注入操作,<strong>最后使用静态变量</strong></li><li>websocket不稳定，异常处理机制，树莓派定时心跳，异常重连</li></ul><h3 id="即时通讯"><a href="#即时通讯" class="headerlink" title="即时通讯"></a>即时通讯</h3><p>类似于朋友圈，可发布状态，点赞、评论等</p><p>使用MongoDB是因为便于存储点赞/评论list，非结构化<br>Redis用于缓存朋友圈动态信息，前N条经常被浏览</p><h2 id="比赛经历"><a href="#比赛经历" class="headerlink" title="比赛经历"></a>比赛经历</h2><p>Google Girl Hackthon 主题是机器学习，给了一些新闻的数据，让自己从中分析出自己想要的信息,主要是做了数据的处理，对train得到的数据，处理成前端可展示的json格式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单的自我介绍&lt;br&gt;
    
    </summary>
    
      <category term="Java面试" scheme="blog.jiangdongyu.space/categories/Java%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="简历" scheme="blog.jiangdongyu.space/tags/%E7%AE%80%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>BackTracking</title>
    <link href="blog.jiangdongyu.space/2018/04/29/BackTracking/"/>
    <id>blog.jiangdongyu.space/2018/04/29/BackTracking/</id>
    <published>2018-04-29T15:32:00.000Z</published>
    <updated>2018-06-09T13:35:12.073Z</updated>
    
    <content type="html"><![CDATA[<p><strong>思想</strong></p><ol><li>试错</li><li>分步解决问题</li><li>不符合则取消上一步或上几步</li></ol><p><strong>BackTracking可大致分为全排列问题、数独等问题</strong><br><a id="more"></a></p><h2 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h2><h3 id="类型1"><a href="#类型1" class="headerlink" title="类型1"></a>类型1</h3><ul><li>subsets</li><li>subset II </li><li>permutations </li><li>permutations II </li><li>Combinations </li><li>Combinations Sum </li><li>Combinations Sum II </li><li>N Queen</li><li>N Queen II</li><li>letter combination of a phone number</li></ul><h3 id="类型2（基于全排列的问题）"><a href="#类型2（基于全排列的问题）" class="headerlink" title="类型2（基于全排列的问题）"></a>类型2（基于全排列的问题）</h3><ul><li>Next Permutation</li><li>Previous Permutation􏰍􏴤􏴥􏴓􏲌(与next permutation类似)</li><li>Permutation Sequence</li><li>Permutation Index</li><li>Permutation Index II (hard)</li></ul><p><strong>permuataions有序，subsets无序</strong></p><h4 id="Subsets"><a href="#Subsets" class="headerlink" title="Subsets"></a>Subsets</h4><ul><li>Sort原数组</li><li>dfs</li><li>判断是否取这个数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line">subset(results, result, nums, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subset</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; results, List&lt;Integer&gt; result, <span class="keyword">int</span>[] num, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">results.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(result));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; num.length; i++) &#123;</span><br><span class="line">result.add(num[i]);</span><br><span class="line">subset(results, result, num, i + <span class="number">1</span>);</span><br><span class="line">result.remove(result.size()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Subsets-II"><a href="#Subsets-II" class="headerlink" title="Subsets II"></a>Subsets II</h3><blockquote><p>contain duplicates, nums</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i != index &amp;&amp; num[i] == num[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><h3 id="Permutations"><a href="#Permutations" class="headerlink" title="Permutations"></a>Permutations</h3><p>Given a collection of distinct integers, return all possible permutations.</p><p><strong>Example:</strong></p><pre><code>Input: [1,2,3]Output:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]]</code></pre><ul><li>用一个数组记录是否被使用过</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> results;</span><br><span class="line"> List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        permute(results, result, nums, used);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">permute</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; results, List&lt;Integer&gt; result, <span class="keyword">int</span>[] num, <span class="keyword">boolean</span>[] used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num.length == result.size()) results.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(result));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[i])&#123;</span><br><span class="line">                result.add(num[i]);</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line">    permute(results, result, num, used);</span><br><span class="line">    result.remove(result.size()-<span class="number">1</span>); </span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Permutation-II"><a href="#Permutation-II" class="headerlink" title="Permutation II"></a>Permutation II</h3><blockquote><p>might contain duplicates</p></blockquote><ul><li>对数组排序</li><li>判断num[i] == num[i-1] &amp;&amp; !used[i-1]</li><li>如果前一个已经用了，当前值相同再被用，不会重复</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i !=<span class="number">0</span> &amp;&amp; num[i] == num[i-<span class="number">1</span>] &amp;&amp; !used[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><h3 id="Combinations"><a href="#Combinations" class="headerlink" title="Combinations"></a>Combinations</h3><p>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p><p><strong>Example:</strong></p><pre><code>Input: n = 4, k = 2Output:[  [2,4],  [3,4],  [2,3],  [1,2],  [1,3],  [1,4],]</code></pre><p>类似subset</p><h3 id="Combination-Sum"><a href="#Combination-Sum" class="headerlink" title="Combination Sum"></a>Combination Sum</h3><p>Given a set of candidate numbers (candidates) (<strong>without duplicates</strong>) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</p><p>The same repeated number may be chosen from candidates <strong>unlimited number of times.</strong></p><p><strong>Note:</strong></p><ul><li>All numbers (including target) will be <strong>positive integers</strong>.</li><li>The solution set must <strong>not contain duplicate combinations.</strong></li></ul><p><strong>Example 1:</strong></p><pre><code>Input: candidates = [2,3,6,7], target = 7,A solution set is:[  [7],  [2,2,3]]</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: candidates = [2,3,5], target = 8,A solution set is:[  [2,2,2,2],  [2,3,3],  [3,5]]</code></pre><ul><li>求sum</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(candidates == <span class="keyword">null</span> || candidates.length == <span class="number">0</span>) <span class="keyword">return</span> results;</span><br><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        combinationSum(results, result, candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">combinationSum</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; results, List&lt;Integer&gt; result, <span class="keyword">int</span>[] candidate, <span class="keyword">int</span> target, <span class="keyword">int</span> index, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target) results.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(result));</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; candidate.length; i++) &#123;</span><br><span class="line">            result.add(candidate[i]);</span><br><span class="line">            sum += candidate[i];</span><br><span class="line">    combinationSum(results, result, candidate, target, i, sum);</span><br><span class="line">result.remove(result.size()-<span class="number">1</span>);  </span><br><span class="line">sum -= candidate[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Combination-Sum-II"><a href="#Combination-Sum-II" class="headerlink" title="Combination Sum II"></a>Combination Sum II</h3><p>Each number in candidates may only be used <strong>once</strong> in the combination.</p><ul><li>增加sort</li><li>增加去重</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i != index &amp;&amp; candidate[i] == candidate[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><h3 id="Combination-Sum-III"><a href="#Combination-Sum-III" class="headerlink" title="Combination Sum III"></a>Combination Sum III</h3><p>Find all possible combinations of <strong>k numbers</strong> that <strong>add up to a number n</strong>, given that only numbers from <strong>1 to 9</strong> can be used and each combination should be a unique set of numbers.</p><p><strong>Note:</strong></p><ul><li>All numbers will be positive integers.</li><li>The solution set must not contain duplicate combinations.</li></ul><p><strong>Example 1:</strong></p><pre><code>Input: k = 3, n = 7Output: [[1,2,4]]</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: k = 3, n = 9Output: [[1,2,6], [1,3,5], [2,3,4]]</code></pre><ul><li>同时考虑sum和list长度</li></ul><h3 id="Letter-Combinations-of-a-Phone-Number"><a href="#Letter-Combinations-of-a-Phone-Number" class="headerlink" title="Letter Combinations of a Phone Number"></a>Letter Combinations of a Phone Number</h3><ul><li>存储对应关系</li><li>像subset那样处理即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String[] map = &#123;<span class="string">""</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span>[] resultStr= <span class="keyword">new</span> <span class="keyword">char</span>[digits.length()];</span><br><span class="line">        letterCombinations(result, digits, map, resultStr, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">letterCombinations</span><span class="params">(List&lt;String&gt; result, String digits, String[] map, <span class="keyword">char</span>[] resultStr, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(digits.length() == count)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> String(resultStr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String str = map[digits.charAt(count)-<span class="string">'0'</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; str.length();i++)&#123;</span><br><span class="line">            resultStr[count] = str.charAt(i);</span><br><span class="line">            letterCombinations(result, digits, map, resultStr, count+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Generate-Parentheses"><a href="#Generate-Parentheses" class="headerlink" title="Generate Parentheses"></a>Generate Parentheses</h3><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><p>For example, given n = 3, a solution set is:</p><pre><code>[  &quot;((()))&quot;,  &quot;(()())&quot;,  &quot;(())()&quot;,  &quot;()(())&quot;,  &quot;()()()&quot;]</code></pre><ul><li>如果左括号数量小于n，则可以再有左括号</li><li>如果左括号数量大于右括号数量，则可以再有右括号</li></ul><h3 id="Next-Permutation"><a href="#Next-Permutation" class="headerlink" title="Next Permutation"></a>Next Permutation</h3><p>输入一个整数数组，该整数数组按照下标顺序代表一个数字，例如[1,2,3]代表整数123，要求改变数组中元素的顺序，找到<strong>比当前数字大的生成数中的最小值</strong>。如果当前数字代表的整数值已经是所有排列组合中的<strong>最大值</strong>，则返回当前数字组成的<strong>最小值</strong>。</p><ul><li>从右往左扫，找到第一个满足：nums[i-1] &lt; nums[i]条件的，</li><li>再找到从右到左第一个比nums[i-1]大的数，把它们swap，</li><li>再把所有i-1之后的数字swap即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i-<span class="number">1</span>] &lt; nums[i]) <span class="keyword">break</span>;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i = 0, decreasing</span></span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; nums[i-<span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i-<span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// swap all elements after i-1</span></span><br><span class="line">        <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; end) swap(nums, i++, end--);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Permutation-Sequence"><a href="#Permutation-Sequence" class="headerlink" title="Permutation Sequence"></a>Permutation Sequence</h3><p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p><p>By listing and labeling all of the permutations in order, we get the following sequence for n = 3:</p><ol><li>“123”</li><li>“132”</li><li>“213”</li><li>“231”</li><li>“312”</li><li>“321”</li></ol><p>Given n and k, return the kth permutation sequence.</p><p><strong>Note:</strong></p><ul><li>Given n will be between 1 and 9 inclusive.</li><li>Given k will be between 1 and n! inclusive.</li></ul><p><strong>Example 1:</strong></p><pre><code>Input: n = 3, k = 3Output: &quot;213&quot;</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: n = 4, k = 9Output: &quot;2314&quot;</code></pre><p><strong>找规律！！！</strong></p><p><strong>复杂度</strong></p><p>时间 O(N) 空间 O(1)</p><p><strong>思路</strong></p><p>由于我们只要得到第K个全排列，而不是所有全排列，我们不一定要将所有可能都搜索一遍。根据全排列顺序的性质，我们可以总结出一个规律：假设全排列有n个数组成，则<strong>第k个全排列的第一位是k/(n-1)!</strong>。为了更形象一点，举例如下：</p><pre><code>123132213231312321</code></pre><p>在这种情况下，第一个数字每2!=2个情况就改变一次，<strong>假设求第6个排列，我们先将其减1，方便整除运算，然后5/2=2。对于第一位，我们有三种可选数字1、2、3，所以5/2=2意味着我们选择第3个数字，也就是3（如果商是s，则选第s+1个数字）。然后将5%2得到1，这个1就是下一轮的k。</strong></p><p><strong>注意</strong></p><p>这里有一个技巧，就是用一个列表将1到n存起来，每选用一个数就是移出那个数，就能保证不选重复数字的同时，其顺序也是一样的。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1</span>;</span><br><span class="line">        List&lt;Integer&gt; candidates = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// 先得到n!和候选数字列表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            mod = mod * i;</span><br><span class="line">            candidates.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将k先减1方便整除</span></span><br><span class="line">        k--;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            mod = mod / (n - i);</span><br><span class="line">            <span class="comment">// 得到当前应选数字的序数</span></span><br><span class="line">            <span class="keyword">int</span> first = k / mod;</span><br><span class="line">            <span class="comment">// 得到用于计算下一位的k</span></span><br><span class="line">            k = k % mod;</span><br><span class="line">            sb.append(candidates.get(first));</span><br><span class="line">            <span class="comment">// 在列表中移出该数字</span></span><br><span class="line">            candidates.remove(first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Permutation-Index"><a href="#Permutation-Index" class="headerlink" title="Permutation Index"></a>Permutation Index</h3><blockquote><p>给定一个排列数，每位都不重复，返回它在全排列中的index,index从1开始</p></blockquote><ul><li>对于某一个给定的位数A[i],需要判断在它后面有几个小于它的数，记下这个数字和A[i]所在的位置。</li><li>比如对于一个四位数，5316，第一位后面有2小于它的数，如果这两个数排在第一位，那么（1和3）各有3！的排列组合数小于（5316）.</li><li>同理，对于第二位，其后有1个小于它的数，如果它放在第二位，那么有2！种排列。</li><li>因此判断一个给定数位于排列组合的第几位，则可以按照以下公式进行</li></ul><p><strong>count1*(A.length-1)!+count2*(A.length-2)!+……+countn*(0)!</strong></p><p>为方便计算，从右往左遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">permutationIndex</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> fact = <span class="number">1</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> rank = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; A.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[j] &lt; A[i]) rank++;</span><br><span class="line">            &#125;</span><br><span class="line">            index += rank * fact;</span><br><span class="line">            fact *= (A.length-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Permutation-Index-II"><a href="#Permutation-Index-II" class="headerlink" title="Permutation Index II"></a>Permutation Index II</h3><blockquote><p>存在重复</p></blockquote><ul><li>与上一题的不同之处时会有<strong>重复的数。</strong></li><li>在发现是重复数的那一位用(rank * fact)/dup+index即可。</li><li>当然，每个重复数的dup都要阶乘，例如有3个2，4个8，dup就是3! * 4! = 144。</li><li>index是所有previous排列的次数和，返回下一次index+1。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">permutationIndexII</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> index = <span class="number">0</span>, fact = <span class="number">1</span>, dup = <span class="number">1</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(A[i])) map.put(A[i], <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(A[i], map.get(A[i])+<span class="number">1</span>);</span><br><span class="line">                dup *= map.get(A[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> rank = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; A.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[j] &lt; A[i]) rank++;</span><br><span class="line">            &#125;</span><br><span class="line">            index += rank * fact / dup;</span><br><span class="line">            fact *= (A.length - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sudoku"><a href="#Sudoku" class="headerlink" title="Sudoku"></a>Sudoku</h2><h3 id="Valid-Sudoku"><a href="#Valid-Sudoku" class="headerlink" title="Valid Sudoku"></a>Valid Sudoku</h3><p>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:</p><ol><li>Each row must contain the digits 1-9 without repetition.</li><li>Each column must contain the digits 1-9 without repetition.</li><li>Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.</li></ol><p><img src="http://p9fh1pach.bkt.clouddn.com/250px-Sudoku-by-L2G-20050714.svg.png" alt="avatar"></p><p>A partially filled sudoku which is valid.</p><p>The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’.</p><p><strong>Example 1:</strong></p><pre><code>Input:[  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]Output: true</code></pre><p><strong>Example 2:</strong></p><pre><code>Input:[  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]Output: falseExplanation: Same as Example 1, except with the 5 in the top left corner being     modified to 8. Since there are two 8&apos;s in the top left 3x3 sub-box, it is invalid.</code></pre><p><strong>Note:</strong></p><ul><li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li><li>Only the filled cells need to be validated according to the mentioned rules.</li><li>The given board contain only digits 1-9 and the character ‘.’.</li><li>The given board size is always 9x9.</li></ul><p><strong>解题思路</strong></p><ul><li>9行9列</li><li>每行1-9，每列1-9，9个3*3的小数独，也是1-9，均不重复</li></ul><p><strong>方法</strong></p><ul><li>遍历每个格子判断是否合法</li><li>如果格子的值相同且不是”.”，但是行，列不同则不合法</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span> &amp;&amp; !isvalid(board, i, j)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isvalid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[row][col] == board[i][col] &amp;&amp; row != i) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[row][col] == board[row][i] &amp;&amp; col != i) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row/<span class="number">3</span>*<span class="number">3</span>; i &lt; row/<span class="number">3</span>*<span class="number">3</span>+<span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = col/<span class="number">3</span>*<span class="number">3</span>; j &lt; col/<span class="number">3</span>*<span class="number">3</span>+<span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == board[row][col] &amp;&amp; !(i == row &amp;&amp; j == col)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sudoku-Solver"><a href="#Sudoku-Solver" class="headerlink" title="Sudoku Solver"></a>Sudoku Solver</h3><p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p><p>A sudoku solution must satisfy all of the following rules:</p><ol><li>Each of the digits 1-9 must occur exactly once in each row.</li><li>Each of the digits 1-9 must occur exactly once in each column.</li><li>Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.</li></ol><p>Empty cells are indicated by the character ‘.’.</p><ul><li>dfs</li><li>对”.”的位置尝试填入1-9，待下次判断</li><li>可使用上一题的<strong>isvalid(char[][] board, int row, int col)</strong>方法剪枝</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length != <span class="number">9</span> || board[<span class="number">0</span>].length != <span class="number">9</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        solve(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">9</span>)</span><br><span class="line">            <span class="keyword">return</span> solve(board, i + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">9</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">9</span>; k++) &#123;</span><br><span class="line">                board[i][j] = (<span class="keyword">char</span>) (k + <span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">if</span> (isValid(board, i, j)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (solve(board, i, j + <span class="number">1</span>))</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> solve(board, i, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k != i &amp;&amp; board[k][j] == board[i][j])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k != j &amp;&amp; board[i][k] == board[i][j])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = i / <span class="number">3</span> * <span class="number">3</span>; row &lt; i / <span class="number">3</span> * <span class="number">3</span> + <span class="number">3</span>; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = j / <span class="number">3</span> * <span class="number">3</span>; col &lt; j / <span class="number">3</span> * <span class="number">3</span> + <span class="number">3</span>; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row != i &amp;&amp; col != j &amp;&amp; board[i][j] == board[row][col])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Flip-Game"><a href="#Flip-Game" class="headerlink" title="Flip Game"></a>Flip Game</h3><h4 id="I"><a href="#I" class="headerlink" title="I"></a>I</h4><p>You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip twoconsecutive “++” into “–”. The game ends when a person can no longer make a move and therefore the other person will be the winner.</p><p>Write a function to compute all possible states of the string after one valid move.</p><p>For example, given s = “++++”, after one move, it may become one of the following states:</p><pre><code>[  &quot;--++&quot;,  &quot;+--+&quot;,  &quot;++--&quot;]</code></pre><p>If there is no valid move, return an empty list [].</p><ul><li>直接遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">generatePossibleNextMoves</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || s.length() == <span class="number">1</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &lt; s.length() &amp;&amp; s.substring(i,i+<span class="number">2</span>).equals(<span class="string">"++"</span>))&#123;</span><br><span class="line">            res.add(s.substring(<span class="number">0</span>,i)+<span class="string">"--"</span>+s.substring(i+<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="II"><a href="#II" class="headerlink" title="II"></a>II</h4><blockquote><p>需要确保开始的人能赢</p></blockquote><ul><li>和I的做法类似</li><li>增加下一步替换后不能赢的判断即可</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canWin</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || s.length() == <span class="number">1</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &lt; s.length() &amp;&amp; s.substring(i,i+<span class="number">2</span>).equals(<span class="string">"++"</span>) &amp;&amp; !canWin(s.substring(<span class="number">0</span>,i)+<span class="string">"--"</span>+s.substring(i+<span class="number">2</span>)))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Nim-Game"><a href="#Nim-Game" class="headerlink" title="Nim Game"></a>Nim Game</h3><p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p><p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p><p><strong>Example:</strong></p><pre><code>Input: 4Output: false Explanation: If there are 4 stones in the heap, then you will never win the game;             No matter 1, 2, or 3 stones you remove, the last stone will always be              removed by your friend.</code></pre><ul><li>找规律的题</li><li>如果是4的倍数就输</li></ul><h3 id="N-Queen"><a href="#N-Queen" class="headerlink" title="N Queen"></a>N Queen</h3><ul><li>Queen不能在同一行，同一列，对角线上</li><li>也就是说可以将N Queen放置在数组中，一个数组下标表示行值，数组下标对应的数组值可表示其所属列 </li></ul><h4 id="I-1"><a href="#I-1" class="headerlink" title="I"></a>I</h4><blockquote><p>给出所有解</p></blockquote><p>类似用一个全局static的list存储结果</p><h4 id="II-1"><a href="#II-1" class="headerlink" title="II"></a>II</h4><blockquote><p>给出解的数量</p></blockquote><p>用一个全局static变量计数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveNQueens</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n, List&lt;Integer&gt; matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(matrix)) count++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n;k++)&#123;</span><br><span class="line">            matrix.add(k);</span><br><span class="line">            <span class="keyword">if</span>(isValid(matrix))&#123;</span><br><span class="line">                solveNQueens(i+<span class="number">1</span>, n, matrix);</span><br><span class="line">            &#125;</span><br><span class="line">            matrix.remove(matrix.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断queen是否合法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(List&lt;Integer&gt; matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> col = matrix.get(row);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; row;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> row1 = i;</span><br><span class="line">            <span class="keyword">int</span> col1 =  matrix.get(i);</span><br><span class="line">            <span class="keyword">if</span>(col1 == col) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(row - row1 == col - col1) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(row - row1 == col1 - col) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Palindrome-Partitioning"><a href="#Palindrome-Partitioning" class="headerlink" title="Palindrome Partitioning"></a>Palindrome Partitioning</h3><h4 id="I-2"><a href="#I-2" class="headerlink" title="I"></a>I</h4><p>Given a string s, partition s such that every substring of the partition is a palindrome.</p><p>Return all possible palindrome partitioning of s.</p><p><strong>Example:</strong></p><pre><code>Input: &quot;aab&quot;Output:[  [&quot;aa&quot;,&quot;b&quot;],  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]]</code></pre><ul><li>dfs+判断回文回溯</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(result, list, s);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;String&gt;&gt; result, List&lt;String&gt; list, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isPalindrome(s.substring(<span class="number">0</span>,i)))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(s.substring(<span class="number">0</span>, i));</span><br><span class="line">            helper(result, list, s.substring(i));</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(l) != s.charAt(r))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="II-2"><a href="#II-2" class="headerlink" title="II"></a>II</h4><p>Given a string s, partition s such that every substring of the partition is a palindrome.</p><p>Return the minimum cuts needed for a palindrome partitioning of s.</p><p><strong>Example:</strong></p><pre><code>Input: &quot;aab&quot;Output: 1Explanation: The palindrome partitioning [&quot;aa&quot;,&quot;b&quot;] could be produced using 1 cut.</code></pre><ul><li>DFS + backtracking<ul><li>按照I求出所有解，再找出长度最少的</li></ul></li><li>DP<ul><li>用cuts[i]表示当前位置最少需要切几次使每个部分都是回文。</li><li>如果s(j,i)这部分是回文，就有cuts[i] = cuts[j-1] + 1。</li><li>matrix[j] [i]表示j到i这部分是回文。</li><li>如果s.charAt(i) == s.charAt(j) &amp;&amp; isPalindrome[j+1] [i-1]是回文，则不需重复该部分的搜索。isPalindrome[j] [i]也是回文。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] cuts = <span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">// cuts[i] = cut[j-1] + 1 if [j,i] is panlindrome</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] isPalindrome = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n]; <span class="comment">// isPalindrome[j][i] means  [j,i] is panlidrome</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;       <span class="comment">// maximun cuts for position i, each panlidrome only length of one</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j) &amp;&amp; ( j + <span class="number">1</span> &gt; i - <span class="number">1</span> || isPalindrome[j+<span class="number">1</span>][i-<span class="number">1</span>]) )&#123;</span><br><span class="line">                    isPalindrome[j][i] = <span class="keyword">true</span>;</span><br><span class="line">                    min = j == <span class="number">0</span> ? <span class="number">0</span> : Math.min(min, cuts[j-<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cuts[i] = min;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cuts[n-<span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Palindrome-Permutation"><a href="#Palindrome-Permutation" class="headerlink" title="Palindrome Permutation"></a>Palindrome Permutation</h3><h4 id="I-3"><a href="#I-3" class="headerlink" title="I"></a>I</h4><p>Given a string, determine if a permutation of the string could form a palindrome.</p><p>For example, “code” -&gt; False, “aab” -&gt; True, “carerac” -&gt; True.</p><ul><li>根据回文性质，只有出现在中心的数是奇数</li></ul><p><strong>思路</strong></p><ul><li>HashMap计数，判断奇数是否最多出现了一次</li><li>HashSet消除，出现第偶数次消除，第奇数次加入Set，最后判断set的size是否不大于1</li></ul><h4 id="II-3"><a href="#II-3" class="headerlink" title="II"></a>II</h4><p>Given a string s, return all the palindromic permutations (without duplicates) of it. Return an empty list if no palindromic permutation could be form.</p><pre><code>For example:Given s = &quot;aabb&quot;, return [&quot;abba&quot;, &quot;baab&quot;].Given s = &quot;abc&quot;, return [].</code></pre><p><strong>Hint:</strong></p><ul><li>If a palindromic permutation exists, we just need to generate the first half of the string.</li><li>To generate all distinct permutations of a (half of) string, use a similar approach from: Permutations II or Next Permutation.</li></ul><p><strong>思路</strong></p><ul><li>回文分为三部分，在s中出现了偶数次的一半+奇数次的+一半的reverse</li><li>对在s中出现了偶数次的一半找全排列类似Permutations II</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">generatePalindromes</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        String mid = <span class="string">""</span>;</span><br><span class="line">        List&lt;Character&gt; list = <span class="keyword">new</span> ArrayList&lt;Character&gt;();</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character,Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            map.put(c,map.containsKey(c)?map.get(c)+<span class="number">1</span>:<span class="number">1</span>);</span><br><span class="line">            odd=odd+(map.get(c)%<span class="number">2</span>==<span class="number">1</span>?<span class="number">1</span>:-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(odd&gt;<span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Character,Integer&gt; entry:map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">char</span> key = entry.getKey();</span><br><span class="line">            <span class="keyword">int</span> val = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span>(val%<span class="number">2</span>==<span class="number">1</span>) mid=mid+key;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;val/<span class="number">2</span>;i++)&#123;</span><br><span class="line">                list.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        backtracking(res,mid,list,<span class="keyword">new</span> StringBuilder(),<span class="keyword">new</span> <span class="keyword">boolean</span>[list.size()]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(List&lt;String&gt; res,String mid,List&lt;Character&gt; list,StringBuilder sb,<span class="keyword">boolean</span>[] used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sb.length()==list.size())&#123;</span><br><span class="line">            res.add(sb.toString()+mid+sb.reverse().toString());</span><br><span class="line">            sb.reverse();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(used[i]||i&gt;<span class="number">0</span>&amp;&amp;list.get(i)==list.get(i-<span class="number">1</span>)&amp;&amp;!used[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line">                sb.append(list.get(i));</span><br><span class="line">                backtracking(res,mid,list,sb,used);</span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">                sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Additive-Number"><a href="#Additive-Number" class="headerlink" title="Additive Number"></a>Additive Number</h3><p>Additive number is a string whose digits can form additive sequence.</p><p>A valid additive sequence should contain <strong>at least</strong> three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.</p><p>Given a string containing only digits ‘0’-‘9’, write a function to determine if it’s an additive number.</p><p><strong>Note</strong>: Numbers in the additive sequence <strong>cannot</strong> have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;112358&quot;Output: true Explanation: The digits can form an additive sequence: 1, 1, 2, 3, 5, 8.              1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: &quot;199100199&quot;Output: true Explanation: The additive sequence is: 1, 99, 100, 199.              1 + 99 = 100, 99 + 100 = 199</code></pre><p><strong>Follow up:</strong><br>How would you handle overflow for very large input integers?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAdditiveNumber</span><span class="params">(String num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num.charAt(<span class="number">0</span>) == <span class="string">'0'</span> &amp;&amp; i &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            BigInteger x1 = <span class="keyword">new</span> BigInteger(num.substring(<span class="number">0</span>, i));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; Math.max(j, i) &lt;= n - i - j; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num.charAt(i) == <span class="string">'0'</span> &amp;&amp; j &gt; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                BigInteger x2 = <span class="keyword">new</span> BigInteger(num.substring(i, i + j));</span><br><span class="line">                <span class="keyword">if</span> (isValid(x1, x2, j + i, num)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(BigInteger x1, BigInteger x2, <span class="keyword">int</span> start, String num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == num.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        x2 = x2.add(x1);</span><br><span class="line">        x1 = x2.subtract(x1);</span><br><span class="line">        String sum = x2.toString();</span><br><span class="line">        <span class="keyword">return</span> num.startsWith(sum, start) &amp;&amp; isValid(x1, x2, start + sum.length(), num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;思想&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;试错&lt;/li&gt;
&lt;li&gt;分步解决问题&lt;/li&gt;
&lt;li&gt;不符合则取消上一步或上几步&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;BackTracking可大致分为全排列问题、数独等问题&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode Category" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/LeetCode-Category/"/>
    
    
      <category term="BackTracking" scheme="blog.jiangdongyu.space/tags/BackTracking/"/>
    
      <category term="Array" scheme="blog.jiangdongyu.space/tags/Array/"/>
    
      <category term="DFS" scheme="blog.jiangdongyu.space/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Dynamic Programming</title>
    <link href="blog.jiangdongyu.space/2018/04/29/DynamicProgramming/"/>
    <id>blog.jiangdongyu.space/2018/04/29/DynamicProgramming/</id>
    <published>2018-04-29T15:31:00.000Z</published>
    <updated>2018-05-29T15:46:29.589Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>利用存储历史信息来减少重复计算，以空间换时间</p></blockquote><h2 id="DP四要素"><a href="#DP四要素" class="headerlink" title="DP四要素"></a>DP四要素</h2><ul><li><strong>function</strong> 方程，如何从子问题到父问题</li><li><strong>state</strong>    状态，存储子问题的结果</li><li><strong>init</strong>        初始化，最小问题</li><li><strong>result</strong>    结果，最大问题</li></ul><h2 id="标记函数"><a href="#标记函数" class="headerlink" title="标记函数"></a>标记函数</h2><p>要先想好标记数组到底标记的是什么。<br>最标准的：问的什么就标记什么。</p><a id="more"></a><h2 id="常见的四种DP类型"><a href="#常见的四种DP类型" class="headerlink" title="常见的四种DP类型"></a>常见的四种DP类型</h2><ul><li>Sequence DP</li><li>2 Sequence DP</li><li>Matrix DP</li><li>Others<ul><li>背包类</li><li>区间类</li></ul></li></ul><h2 id="什么时候可能使用DP"><a href="#什么时候可能使用DP" class="headerlink" title="什么时候可能使用DP"></a>什么时候可能使用DP</h2><ul><li>求max/min</li><li>yes/no 求能否达到</li><li>count(*) 求数量</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>多空一位0.</p><h2 id="一维DP"><a href="#一维DP" class="headerlink" title="一维DP"></a>一维DP</h2><h3 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h3><ul><li>Climbing Stairs</li><li>Decode Ways</li><li>Unique Binary Search Trees </li><li>Maximum Subarray</li><li>Maximum Product Subarray </li><li>Best Time to Buy and Sell Stock</li></ul><h3 id="什么时候可能不是DP"><a href="#什么时候可能不是DP" class="headerlink" title="什么时候可能不是DP"></a>什么时候可能不是DP</h3><ul><li>要求给出具体解决方案</li><li>输入的是集合而不是序列</li></ul><h3 id="类型一"><a href="#类型一" class="headerlink" title="类型一"></a>类型一</h3><ul><li>climbing chairs</li><li>jump game</li><li>decode ways</li><li>unique binary search trees</li></ul><h3 id="类型二-global-local"><a href="#类型二-global-local" class="headerlink" title="类型二 global,local"></a>类型二 global,local</h3><ul><li>maximum subarray</li><li>maximum product subarray </li><li>best time to but and sell stock</li></ul><p><strong>思路</strong></p><ul><li>当看到题目是选择包含还是不包含当前value[i]时</li><li>需要维护两个DP，global(全局最优，不一定包含当前值)，local(包含当前值的局部最优)</li><li>找出递推关系</li></ul><h3 id="Triangle"><a href="#Triangle" class="headerlink" title="Triangle"></a>Triangle</h3><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p><p>For example, given the following triangle</p><pre><code>[     [2],    [3,4],   [6,5,7],  [4,1,8,3]]</code></pre><p>The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</p><p>Note:</p><p>Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</p><p><strong>dp[i][j] 以 tri[i][j]为终点的path sum的最小值</strong></p><ul><li>state </li><li>function: <strong>dp[i][j] = min(dp[i-1][j],dp[i-1][j-1])+tri[i][j]</strong></li><li>init state </li><li>result</li></ul><p><strong>漂亮的代码：</strong>省去二维，不断更新，自底向上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] A = <span class="keyword">new</span> <span class="keyword">int</span>[triangle.size()+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=triangle.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;triangle.get(i).size();j++)&#123;</span><br><span class="line">            A[j] = Math.min(A[j],A[j+<span class="number">1</span>])+triangle.get(i).get(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Pascal’s-Triangle-I-amp-II"><a href="#Pascal’s-Triangle-I-amp-II" class="headerlink" title="Pascal’s Triangle I &amp; II"></a>Pascal’s Triangle I &amp; II</h3><blockquote><p>I：给定行数，输出三角</p></blockquote><p>每一层元素是它上面两个元素的和</p><blockquote><p>II:给定某一行行号，输出这一行</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        cur.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= rowIndex;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i-<span class="number">1</span>;j &gt; <span class="number">0</span>;j--)&#123;</span><br><span class="line">                cur.set(j,cur.get(j-<span class="number">1</span>)+cur.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">            cur.add(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="House-Robber"><a href="#House-Robber" class="headerlink" title="House Robber"></a>House Robber</h3><blockquote><p>相邻房子不能抢，global，local问题</p></blockquote><p><strong>dp[i]打劫到第i间时的最大值</strong></p><ul><li>state </li><li>function: <strong>dp[i] = max(dp[i-1],dp[i-2]+nums[i-1])</strong></li><li>init state: <strong>dp[0] = nums[0],dp[1] = max(nums[0],nums[1])</strong></li><li>result: <strong>dp[length-1]</strong></li></ul><h3 id="House-Robber-II"><a href="#House-Robber-II" class="headerlink" title="House Robber II"></a>House Robber II</h3><blockquote><p>房子是一个环，也就是说第一间和最后一间不能同时抢</p></blockquote><ul><li>拆分成两个数组</li><li>一个包含第一间，一个包含最后一间</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> Math.max(rob(nums,<span class="number">0</span>,n-<span class="number">2</span>),rob(nums,<span class="number">1</span>,n-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rob = <span class="number">0</span>,notRob = <span class="number">0</span>,preNot = <span class="number">0</span>,preYes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = lo;i &lt;= hi;i++)&#123;</span><br><span class="line">            rob = preNot + nums[i];</span><br><span class="line">            notRob = Math.max(preYes,preNot);</span><br><span class="line">            preNot = notRob;</span><br><span class="line">            preYes = rob;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(rob,notRob);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Best-Time-to-Buy-and-Sell-Stock"><a href="#Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Best Time to Buy and Sell Stock"></a>Best Time to Buy and Sell Stock</h3><h4 id="I"><a href="#I" class="headerlink" title="I"></a>I</h4><blockquote><p>交易一次</p></blockquote><p>略</p><h4 id="II"><a href="#II" class="headerlink" title="II"></a>II</h4><blockquote><p>不限交易次数，买入前必须不持有</p></blockquote><ul><li>贪心</li><li>方法一<ul><li>计算局部的峰值，谷值</li><li>求和</li></ul></li><li>方法二<ul><li>循环，只要prices[i] &gt; prices[i-1],求差值</li><li>求和</li></ul></li></ul><h4 id="III"><a href="#III" class="headerlink" title="III"></a>III</h4><blockquote><p>最多交易两次，买入前必须不持有</p></blockquote><p><strong>思路1</strong>：双向动态规划</p><ul><li>构造两个数组，left和right，left[i]表示从0到i天的最大获益，right[i]表示从i到最后一天的最大获益。</li><li>求left时，记录前i天的最低价minPrice与最大获益max，求left[i]：考虑要在第i天卖出，那么买进的时间必然是在0到i之间（闭区间），这个时候只需要比较prices[i]-minPrice和max就可以求出截止到第i天的最大获益，然后根据需要更新minPrice。</li><li>求right时，记录从第i天往后的最高价maxPrice与最大获益max，求right[i]：考虑要再第i天买进，那么卖出时间必然是在i到最后一天之间（闭区间），这个时候只需要比较maxPrice-prices[i]和max就可以求出从第i天开始的最大获益，然后根据需要更新maxPrice。</li><li>对于left和right的构造算法复杂度都是O(n)。</li><li>构造完left和right之后，只要求left[i]+right[i]的最大值就行了。</li></ul><p><strong>思路2</strong>：滚动扫描法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hold1 = Integer.MIN_VALUE, hold2 = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> release1 = <span class="number">0</span>, release2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="comment">//在该价格点卖出第二笔股票后手里剩的钱，等于上一轮买入第二笔股票后手里剩的钱加上卖出当前股票价格的钱，或者上一轮卖出第二笔股票后手里剩的钱两者中较大的</span></span><br><span class="line">            release2 = Math.max(release2, hold2 + prices[i]);</span><br><span class="line">            <span class="comment">//在该价格点买入第二笔股票后手里剩的钱，等于上一轮卖出第一笔股票后手里剩的钱减去买入当前股票价格的钱，或者上一轮买入第二笔股票后手里剩的钱两者中较大的</span></span><br><span class="line">            hold2 = Math.max(hold2, release1 - prices[i]);</span><br><span class="line">            <span class="comment">//在该价格点卖出第一笔股票后手里剩的钱，等于上一轮买入第一笔股票后手里剩的钱加上卖出当前股票价格的钱，或者上一轮卖出第一笔股票后手里剩的钱两者中较大的</span></span><br><span class="line">            release1 = Math.max(release1, hold1 + prices[i]);</span><br><span class="line">            <span class="comment">//在该价格点买入第一笔股票后手里剩的钱，等于初始资金减去买入当前股票价格的钱或者初始资金（不买）中较大的</span></span><br><span class="line">            hold1 = Math.max(hold1, -prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> release2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="IV"><a href="#IV" class="headerlink" title="IV"></a>IV</h4><blockquote><p>最多k次交易，III的延伸</p></blockquote><p><strong>动态规划</strong></p><ul><li>复杂度<ul><li>时间 O(Nk) 空间 O(Nk)</li></ul></li><li>思路<ul><li>第i天已经执行j笔交易的<strong>最大收益</strong>作为全局变量global，将第i天<strong>正好</strong>完成第j笔交易的最大收益作为局部变量local。</li><li>int diff = prices[i] - prices[i-1];</li><li>global[i][j] = max(global[i-1][j], local[i][j])</li><li>local[i][j] = max(global[i-1][j-1]+max(0, diff), local[i-1][j]+diff)</li><li>对于local，第i天正好完成第j笔交易的最大收益，可以基于第i-1天正好完成第j-1笔交易的最大收益加上当天交易的差值，还有第i-1天正好完成第j笔交易的最大收益加上当天交易的差值。</li><li>要注意的是，第i-1天正好完成第j-1笔交易这种情况，当前交易的差值取0和实际昨天今天差价中较大的，因为我们还有一次自由交易的余地，所以如果亏的话完全可以当天买卖避免损失。</li><li>但第i-1天正好完成第j笔交易这种情况来推导第i天正好完成第j笔交易时，相当于第i天已经要连着第i-1天交易，使得第i-1天正好完成的第j笔交易和第i天正好完成的第j笔交易是同一个交易。</li></ul></li><li>注意<ul><li>对于k &gt; prices.length / 2的情况，我们可以用II的解法来节省空间。因为按照题意必须先买后卖，那么对于n天交易，能够产生有效收益的交易次数是小于等于n/2的，只有不同天买卖才能产生差价。对于大于n/2的那部分交易，必定是当天买卖没有任何收益的，无论交易多少次都是一样的。所以如果k &gt; prices.length / 2，就相当于无限次交易。</li><li>数组的第二维初始化长度是k+1，因为我们要预留完成0笔交易的收益，是0。</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//用II的解法优化k &gt; prices.length / 2的情况</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt; prices.length / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(prices[i]&gt;prices[i-<span class="number">1</span>]) sum += prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化全局变量和局部变量</span></span><br><span class="line">        <span class="keyword">int</span>[][] global = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[][] local = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> diff = prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; k + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="comment">//更新局部变量</span></span><br><span class="line">                local[i][j] = Math.max(global[i-<span class="number">1</span>][j-<span class="number">1</span>]+Math.max(<span class="number">0</span>, diff), local[i-<span class="number">1</span>][j]+diff);</span><br><span class="line">                <span class="comment">//更新全局变量</span></span><br><span class="line">                global[i][j] = Math.max(global[i-<span class="number">1</span>][j], local[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> global[prices.length - <span class="number">1</span>][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>滚动扫描法</strong></p><p>时间 O(N) 空间 O(k)</p><blockquote><p>需要2k个变量来记录k次交易。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用II的解法优化k &gt; prices.length / 2的情况</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt; prices.length / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(prices[i]&gt;prices[i-<span class="number">1</span>]) sum += prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化买卖股票后剩余金钱的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] release = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] hold = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            hold[i]=Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; k+<span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="comment">//卖出第j笔交易，所剩余的钱</span></span><br><span class="line">                release[j] = Math.max(release[j], hold[j]+prices[i]);</span><br><span class="line">                <span class="comment">//买入第j笔交易，所剩余的钱</span></span><br><span class="line">                hold[j] = Math.max(hold[j], release[j-<span class="number">1</span>]-prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> release[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Best-time-to-buy-and-sell-stock-with-cool-down"><a href="#Best-time-to-buy-and-sell-stock-with-cool-down" class="headerlink" title="Best time to buy and sell stock with cool down"></a>Best time to buy and sell stock with cool down</h3><blockquote><p>不限交易次数，卖出后需要一天冷却</p></blockquote><p><strong>动态规划</strong></p><p>股票有<strong>三种</strong>状态: buy, sell, cooldown, sell与cooldown我们可以合并成一种状态，因为手里最终都<strong>没股票</strong>，最终需要的结果是sell，即手里股票卖了获得最大利润。所以我们可以用两个DP数组分别记录当前持股跟未持股的状态。然后根据题目中的限制条件，理清两个DP数组的表达式。</p><p>对于当天最终未持股的状态，最终最大利润有两种可能，一是今天没动作跟昨天未持股状态一样，二是昨天持股了，今天卖了。所以我们只要取这两者之间最大值即可，表达式如下：</p><pre><code>sellDp[i] = Math.max(sellDp[i - 1], buyDp[i - 1] + prices[i]);</code></pre><p>对于当天最终持股的状态，最终最大利润有两种可能，一是今天没动作跟昨天持股状态一样，二是前天还没持股，今天买了股票，这里是因为cooldown的原因，所以今天买股要追溯到前天的状态。我们只要取这两者之间最大值即可，表达式如下：</p><pre><code>buyDp[i] = Math.max(buyDp[i - 1], sellDp[i - 2] - prices[i]);</code></pre><p>最终我们要求的结果是</p><pre><code>sellDp[n - 1] 表示最后一天结束时手里没股票时的累积最大利润</code></pre><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 表示当天最终未持股的情况下，当天结束后的累计最大利润</span></span><br><span class="line">        <span class="keyword">int</span>[] sellDp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        <span class="comment">// 表示当天最终持股的情况下，当天结束后的累计最大利润</span></span><br><span class="line">        <span class="keyword">int</span>[] buyDp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 考虑初始情况</span></span><br><span class="line">        buyDp[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        sellDp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            sellDp[i] = Math.max(sellDp[i - <span class="number">1</span>], buyDp[i - <span class="number">1</span>] + prices[i]);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                buyDp[i] = Math.max(buyDp[i - <span class="number">1</span>], sellDp[i - <span class="number">2</span>] - prices[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buyDp[i] = Math.max(buyDp[i - <span class="number">1</span>], -prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sellDp[prices.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>滚动扫描法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* sell[i] = Math.max(sell[i-1], buy[i-1] + prices[i])</span></span><br><span class="line"><span class="comment">         * buy[i] = Math.max(sell[i-2]-prices[i], buy[i-1])</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> preBuy = Integer.MIN_VALUE, curBuy = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> preSell = <span class="number">0</span>, curSell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            preBuy = curBuy;</span><br><span class="line">            curBuy = Math.max(preSell - price, preBuy);</span><br><span class="line">            preSell = curSell;</span><br><span class="line">            curSell = Math.max(preSell, preBuy + price);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> curSell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Word-Break"><a href="#Word-Break" class="headerlink" title="Word Break"></a>Word Break</h3><h4 id="I-1"><a href="#I-1" class="headerlink" title="I"></a>I</h4><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p><p><strong>Note:</strong></p><ul><li>The same word in the dictionary may be reused multiple times in the segmentation.</li><li>You may assume the dictionary does not contain duplicate words.</li></ul><p><strong>Example 1:</strong></p><pre><code>Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]Output: trueExplanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]Output: trueExplanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.Note that you are allowed to reuse a dictionary word.</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]Output: false</code></pre><ul><li>state <ul><li>dp[i] 表示前i个字符能否做Word Break</li></ul></li><li>function <ul><li>canBreak[i] = True if canBreak[j] and dict.contains(s.substring(j, i)) j from 0 to i</li></ul></li><li>result<ul><li>canBreak[len(s)]</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; dicts)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String str: dicts)&#123;</span><br><span class="line">           dict.add(str); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &amp;&amp; dict.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="II-1"><a href="#II-1" class="headerlink" title="II"></a>II</h4><p>Given a string s and a dictionary of words dict, add spaces in s to construct a sentence where each word is a valid dictionary word.</p><p>Return all such possible sentences.</p><pre><code>For example, givens = &quot;catsanddog&quot;,dict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;].A solution is [&quot;cats and dog&quot;, &quot;cat sand dog&quot;].</code></pre><ul><li>如果要返回所有组合的话，我们可以考虑两种方法，</li><li>一种是DP，时间复杂度较低，但是比较耗内存，意味着对于每个Index, 我们可能都要存其对应所有解。</li><li>另一种是DFS，空间复杂度较低，但是时间时间复杂度较高，我们可以采用memorization优化时间复杂度。</li></ul><p><strong>复杂度</strong></p><ul><li>DP: time: O(n^2*k), space: O(nk), 假设k表示平均每个长度对应解的个数</li><li>DFS: time: O(2^n), space: O(n)</li></ul><p><strong>动态规划</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否能够分解</span></span><br><span class="line">        <span class="keyword">if</span> (!helper(s, wordDict)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录字符串s.substring(0, i)对应的解</span></span><br><span class="line">        HashMap&lt;Integer, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, List&lt;String&gt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        map.get(<span class="number">0</span>).add(<span class="string">""</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(j) &amp;&amp; wordDict.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!map.containsKey(i))</span><br><span class="line">                        map.put(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                    <span class="keyword">for</span> (String str : map.get(j)) &#123;</span><br><span class="line">                        map.get(i).add(str + (str.equals(<span class="string">""</span>) ? <span class="string">""</span> : <span class="string">" "</span>) + s.substring(j, i));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> map.get(s.length());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> dp[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; wordDict.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DFS</strong></p><ul><li>从头开始扫描，dict包含则对接下来的递归dfs</li><li>直至返回的str的长度等于s</li><li>接着返回上一层递归</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来记录s.substring(i)这个字符串能否分解</span></span><br><span class="line">        <span class="keyword">boolean</span>[] possible = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(possible, <span class="keyword">true</span>);</span><br><span class="line">        dfs(res, <span class="string">""</span>, s, wordDict,  <span class="number">0</span>, possible);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;String&gt; res, String cur, String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> start, <span class="keyword">boolean</span>[] possible)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">            res.add(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            String str = s.substring(start, i);</span><br><span class="line">            <span class="keyword">if</span> (wordDict.contains(str) &amp;&amp; possible[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> prevSize = res.size();</span><br><span class="line">                dfs(res, cur + (cur.equals(<span class="string">""</span>) ? <span class="string">""</span> : <span class="string">" "</span>) + str, s, wordDict, i, possible);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// DFS后面部分结果没有变化，说明后面是没有解的</span></span><br><span class="line">                <span class="keyword">if</span> (res.size() == prevSize)</span><br><span class="line">                    possible[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维DP"><a href="#二维DP" class="headerlink" title="二维DP"></a>二维DP</h2><h3 id="Dungeon-Game"><a href="#Dungeon-Game" class="headerlink" title="Dungeon Game"></a>Dungeon Game</h3><p>The demons had captured the princess (<strong>P</strong>) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (<strong>K</strong>) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.</p><p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.</p><p>Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0’s) or contain magic orbs that increase the knight’s health (positive integers).</p><p>In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.</p><p><strong>Write a function to determine the knight’s minimum initial health so that he is able to rescue the princess.</strong></p><p><strong>Notes:</strong></p><ul><li>The knight’s health has no upper bound.</li><li>Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.</li></ul><p><strong>动态规划</strong></p><ul><li>state : dp[i][j] 表示从i,j出发到终点所需要的最少的体力值</li><li>init: dp[m-1][n-1] = max(-dungeon[m-1][n-1],0)+1</li><li>function : dp[i][j] = min(dp[i+1][j],dp[i][j+1]) - dungeon[i][j]</li></ul><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = dungeon.length;</span><br><span class="line">        <span class="keyword">int</span> n = dungeon[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        dp[m-<span class="number">1</span>][n-<span class="number">1</span>] = Math.max(- dungeon[m-<span class="number">1</span>][n-<span class="number">1</span>], <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt;= m-<span class="number">1</span> &amp;&amp; j + <span class="number">1</span> &lt;= n-<span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i+<span class="number">1</span>][j], dp[i][j+<span class="number">1</span>]) - dungeon[i][j];;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( i + <span class="number">1</span> &lt;= m-<span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j] - dungeon[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= n-<span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j+<span class="number">1</span>] - dungeon[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &lt;= <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Maximal-Rectangle"><a href="#Maximal-Rectangle" class="headerlink" title="Maximal Rectangle"></a>Maximal Rectangle</h3><p>是Largest Rectangle in Histogram的晋升题</p><h4 id="Largest-Rectangle-in-Histogram"><a href="#Largest-Rectangle-in-Histogram" class="headerlink" title="Largest Rectangle in Histogram"></a>Largest Rectangle in Histogram</h4><p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. </p><p><img src="http://p9fh1pach.bkt.clouddn.com/1418713310-55de4fd532244.png" alt="avatar"></p><p>Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].</p><p><img src="http://p9fh1pach.bkt.clouddn.com/765770818-55de4fe7f3337.png" alt="avatar"></p><p>The largest rectangle is shown in the shaded area, which has area = 10 unit.</p><ul><li>栈，存放数组的index</li><li>判断遍历的数是否大于等于栈顶元素，大于则直接push</li><li>小于则pop，直到数组的下一个元素大于栈顶元素</li></ul><p>把数组中的每个元素都作为矩形高度，计算了一遍该高度下矩形的最大面积。只是每次都<strong>贪心</strong>最大，避免了重复计算，所以效率高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>, largestArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; height.length || (index == height.length &amp;&amp; !stack.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index != height.length &amp;&amp; (stack.isEmpty() || height[stack.peek()] &lt; height[index])) &#123;</span><br><span class="line">                stack.push(index++);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = height[stack.pop()];</span><br><span class="line">                <span class="keyword">int</span> w = stack.isEmpty() ? index : index - stack.peek() - <span class="number">1</span>;</span><br><span class="line">                largestArea = Math.max(largestArea, h * w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> largestArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Maximal-Rectangle-1"><a href="#Maximal-Rectangle-1" class="headerlink" title="Maximal Rectangle"></a>Maximal Rectangle</h4><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing all 1’s and return its area.</p><ul><li>要求最大的矩形，实际上可以将矩阵的每一行，转化为上一题的直方图，</li><li>而直方图的每个竖条的数字，就是该行对应坐标正上方，向上方向有多少个连续的1。</li><li>要转化为直方图，方法是每一行的数值都累加上一行计算出来的数值，而第一行的数值就是本身。如果原始矩阵中遇到0，则累加中断，重新置0。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 0 1 1 0 -&gt; 0 0 1 1 0</span><br><span class="line">0 0 1 1 0 -&gt; 0 0 2 2 0</span><br><span class="line">1 1 0 0 0 -&gt; 1 1 0 0 0</span><br><span class="line">1 1 1 0 0 -&gt; 2 2 1 0 0</span><br></pre></td></tr></table></figure><ul><li>dp[i][j]化为直方图的值</li><li>接着对dp[i][j]进行Largest Rectangle in Histogram计算即可</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i == 0 --&gt; dp[i][j] = matrix[i][j] - &apos;0&apos;</span><br><span class="line">i != 0 --&gt; </span><br><span class="line">matrix[i][j] == 1 --&gt; dp[i][j] = dp[i-1][j] + matrix[i][j] - &apos;0&apos;</span><br><span class="line">matrix[i][j] != 1 --&gt; dp[i][j] = 0</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="comment">// 如果是第一行就是自身，如果遇到0则停止累加</span></span><br><span class="line">                dp[i][j] =  i == <span class="number">0</span> ? matrix[i][j] - <span class="string">'0'</span> : matrix[i][j] == <span class="string">'1'</span> ? dp[i-<span class="number">1</span>][j] + matrix[i][j] - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++)&#123;</span><br><span class="line">            <span class="comment">//找每行的最大矩形</span></span><br><span class="line">            <span class="keyword">int</span> tmp = findRowMax(i, dp);</span><br><span class="line">            max = Math.max(max, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findRowMax</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span>[][] matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[row].length== <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stk = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, max = matrix[row][<span class="number">0</span>];</span><br><span class="line">        stk.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(i &lt; matrix[row].length || (i == matrix[row].length &amp;&amp; !stk.isEmpty()))&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != matrix[row].length &amp;&amp; ( stk.isEmpty() || matrix[row][i] &gt;= matrix[row][stk.peek()] ))&#123;</span><br><span class="line">                stk.push(i);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> top = matrix[row][stk.pop()];</span><br><span class="line">                <span class="keyword">int</span> currMax = !stk.isEmpty() ? top * (i - stk.peek() - <span class="number">1</span>) : top * i;</span><br><span class="line">                max = Math.max(currMax, max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Maximal-Square"><a href="#Maximal-Square" class="headerlink" title="Maximal Square"></a>Maximal Square</h3><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p><p><strong>Example:</strong></p><pre><code>Input: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0Output: 4</code></pre><ul><li>构造传递方程：用dp[i][j]存储以当前点matrix[i][j]作为正方形右下角顶点，所存在的最大正方形的边长，由matrix[i][j]左、上、左上三点的dp值共同判定；</li><li>初始化边界：matrix的第一列和第一行；</li><li>自顶向下递推dp并更新max，找到max的最大值求平方得最优解。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//State: dp[i][j] is max length of matrix until (i, j);</span></span><br><span class="line">       <span class="comment">//Function: dp[i][j] = min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + 1 if matrix[i - 1][j - 1] == '1';</span></span><br><span class="line">       <span class="comment">//Initialize: dp[0][0] = 0;</span></span><br><span class="line">       <span class="comment">//Result: dp[matrix.length][matrix[0].length];</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSquare</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i-<span class="number">1</span>][j-<span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>], Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]))+<span class="number">1</span>;</span><br><span class="line">                    mLen = Math.max(mLen, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mLen * mLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Edit-Distance"><a href="#Edit-Distance" class="headerlink" title="Edit Distance"></a>Edit Distance</h3><p>Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.</p><p>You have the following 3 operations permitted on a word:</p><p>Insert a character<br>Delete a character<br>Replace a character</p><p><strong>Example 1:</strong></p><pre><code>Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;Output: 3Explanation: horse -&gt; rorse (replace &apos;h&apos; with &apos;r&apos;)rorse -&gt; rose (remove &apos;r&apos;)rose -&gt; ros (remove &apos;e&apos;)</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;Output: 5Explanation: intention -&gt; inention (remove &apos;t&apos;)inention -&gt; enention (replace &apos;i&apos; with &apos;e&apos;)enention -&gt; exention (replace &apos;n&apos; with &apos;x&apos;)exention -&gt; exection (replace &apos;n&apos; with &apos;c&apos;)exection -&gt; execution (insert &apos;u&apos;)</code></pre><ul><li>典型的动态规划题目。</li><li>维护一个二维数组dis[][]，dis[i][j]表示：word1的前i个元素与word2的前j个元素的edit distance值。递推关系为：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">word1[i] == word2[j] --&gt; dis[i][j] = dis[i][j - <span class="number">1</span>]。</span><br><span class="line">word1[i] != word2[j] --&gt; dis[i][j] = min(dis[i - <span class="number">1</span>][j - <span class="number">1</span>], dis[i] [j - <span class="number">1</span>], dis[i - <span class="number">1</span>][j]) + <span class="number">1</span>。</span><br></pre></td></tr></table></figure><p>解释一下第二种情况下的递推公式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dis[i][j] = dis[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>意味着替换字符</span><br><span class="line">dis[i][j] = dis[i - <span class="number">1</span>][j] + <span class="number">1</span>意味着删除字符</span><br><span class="line">dis[i][j] = dis[i][j - <span class="number">1</span>] + <span class="number">1</span>意味着插入字符</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = word1.length() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l2 = word2.length() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dis = <span class="keyword">new</span> <span class="keyword">int</span>[l1][l2];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; l2; j++) &#123; dis[<span class="number">0</span>][j] = j; &#125; <span class="comment">// 插入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l1; i++) &#123; dis[i][<span class="number">0</span>] = i; &#125; <span class="comment">// 删除</span></span><br><span class="line">        <span class="keyword">char</span>[] arr1 = word1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] arr2 = word2.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; l1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; l2; j++) &#123;</span><br><span class="line">                dis[i][j] = Math.min(Math.min(dis[i-<span class="number">1</span>][j]+<span class="number">1</span>, dis[i][j-<span class="number">1</span>]+<span class="number">1</span>), dis[i-<span class="number">1</span>][j-<span class="number">1</span>] + (arr1[i-<span class="number">1</span>] == arr2[j-<span class="number">1</span>] ? <span class="number">0</span> : <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[l1-<span class="number">1</span>][l2-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hard-problems"><a href="#Hard-problems" class="headerlink" title="Hard problems"></a>Hard problems</h2><h3 id="Regular-Expression-Matching"><a href="#Regular-Expression-Matching" class="headerlink" title="Regular Expression Matching"></a>Regular Expression Matching</h3><ul><li>动态规划</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>, If p.charAt(j) == s.charAt(i) :  dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line"><span class="number">2</span>, If p.charAt(j) == <span class="string">'.'</span> : dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line"><span class="number">3</span>, If p.charAt(j) == <span class="string">'\*'</span>: </span><br><span class="line">   here are two sub conditions:</span><br><span class="line">       <span class="number">1</span> <span class="keyword">if</span> p.charAt(j-<span class="number">1</span>) != s.charAt(i) : dp[i][j] = dp[i][j-<span class="number">2</span>]  <span class="comment">//in this case, a* only counts as empty</span></span><br><span class="line">       <span class="number">2</span> <span class="keyword">if</span> p.charAt(i-<span class="number">1</span>) == s.charAt(i) or p.charAt(i-<span class="number">1</span>) == <span class="string">'.'</span>:</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j]    <span class="comment">//in this case, a* counts as multiple a </span></span><br><span class="line">            or dp[i][j] = dp[i][j-<span class="number">1</span>]   <span class="comment">// in this case, a* counts as single a</span></span><br><span class="line">            or dp[i][j] = dp[i][j-<span class="number">2</span>]   <span class="comment">// in this case, a* counts as empty</span></span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>][p.length()+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.charAt(i) == <span class="string">'*'</span> &amp;&amp; dp[<span class="number">0</span>][i-<span class="number">1</span>]) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j) == <span class="string">'.'</span>) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j) == s.charAt(i)) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j-<span class="number">1</span>) != s.charAt(i) &amp;&amp; p.charAt(j-<span class="number">1</span>) != <span class="string">'.'</span>) &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = (dp[i+<span class="number">1</span>][j] || dp[i][j+<span class="number">1</span>] || dp[i+<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()][p.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>递归</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern.isEmpty()) <span class="keyword">return</span> text.isEmpty();</span><br><span class="line">        <span class="keyword">boolean</span> first_match = (!text.isEmpty() &amp;&amp; </span><br><span class="line">                               (pattern.charAt(<span class="number">0</span>) == text.charAt(<span class="number">0</span>) || pattern.charAt(<span class="number">0</span>) == <span class="string">'.'</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pattern.length() &gt;= <span class="number">2</span> &amp;&amp; pattern.charAt(<span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (isMatch(text, pattern.substring(<span class="number">2</span>)) || </span><br><span class="line">                    (first_match &amp;&amp; isMatch(text.substring(<span class="number">1</span>), pattern)));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> first_match &amp;&amp; isMatch(text.substring(<span class="number">1</span>), pattern.substring(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Wildcard-Matching"><a href="#Wildcard-Matching" class="headerlink" title="Wildcard Matching"></a>Wildcard Matching</h3><p>Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for ‘?’ and ‘*’.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;?&apos; Matches any single character.</span><br><span class="line">&apos;*&apos; Matches any sequence of characters (including the empty sequence).</span><br></pre></td></tr></table></figure><p>The matching should cover the entire input string (not partial).</p><p><strong>Note:</strong></p><ul><li>s could be empty and contains only lowercase letters a-z.</li><li>p could be empty and contains only lowercase letters a-z, and characters like ? or *.</li></ul><p><strong>动态规划</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* boolean dp[len(s) + 1][len(p) + 1] </span></span><br><span class="line"><span class="comment">     * dp[i+1][j+1] means if s[0, i] match p[0, j]</span></span><br><span class="line"><span class="comment">     * function: dp[i+1][j+1] </span></span><br><span class="line"><span class="comment">     *         a. p[j] = * =&gt; 1. empty: dp[i+1][j]</span></span><br><span class="line"><span class="comment">     *                        2. one: dp[i][j]</span></span><br><span class="line"><span class="comment">     *                        3. multiple: dp[i][j+1]</span></span><br><span class="line"><span class="comment">     *         b. p[j] = s[i] | p[j] = ? =&gt; dp[i][j]</span></span><br><span class="line"><span class="comment">     * start: dp[0][0] = true, dp[0][j+1] = dp[0][j] &amp; p[j] = *</span></span><br><span class="line"><span class="comment">     * result: dp[len(s)][len(p)]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">         </span><br><span class="line">     <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>][p.length() + <span class="number">1</span>];</span><br><span class="line">     <span class="comment">// start</span></span><br><span class="line">     dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.length(); j++) </span><br><span class="line">         dp[<span class="number">0</span>][j+<span class="number">1</span>] = dp[<span class="number">0</span>][j] &amp; (p.charAt(j) == <span class="string">'*'</span>);</span><br><span class="line">         </span><br><span class="line">     <span class="comment">// loop</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.length(); j++) &#123;</span><br><span class="line">             <span class="keyword">if</span>(p.charAt(j) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                 dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j] | dp[i][j] | dp[i][j+<span class="number">1</span>];</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span>(p.charAt(j) == s.charAt(i) || p.charAt(j) == <span class="string">'?'</span>)</span><br><span class="line">                 dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> dp[s.length()][p.length()];        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>贪心</strong></p><ul><li>star符号和前面的character没有关系</li><li>用两个指针i和j分别扫描s和p，loop过程中有以下几种情况：<ul><li>成功匹配：s[i] == p[j] or p[j] == ‘?’ =&gt; i++, j++</li><li>出现星号：p[j] == ‘*’</li><li>p[j]匹配0个 =&gt; j++； p[j]匹配1个 =&gt; j++, i += 1； p[j]匹配2个 =&gt; j++, i += 2；……</li><li>匹配不上：return false</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> stari = -<span class="number">1</span>, starj = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.length()) &#123;</span><br><span class="line">            <span class="comment">// 1. match</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; p.length() &amp;&amp; (s.charAt(i) == p.charAt(j) || p.charAt(j) == <span class="string">'?'</span>)) &#123;</span><br><span class="line">                i++; j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. star</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &lt; p.length() &amp;&amp; p.charAt(j) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="comment">// first match 0</span></span><br><span class="line">                stari = i;</span><br><span class="line">                starj = ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// different number that '*' matches </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(stari != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// match number +1</span></span><br><span class="line">                i = ++stari;</span><br><span class="line">                j = starj;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3. not match and no star</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// remove last '*' in p</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt; p.length() &amp;&amp; p.charAt(j) == <span class="string">'*'</span>) j++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> j == p.length();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>递归</strong></p><p><strong>思路</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(s[l] == p[r] || p[r] == <span class="string">'?'</span>) match(l, r) = match(l + <span class="number">1</span>, r + <span class="number">1</span>) 。</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(p[r] == <span class="string">'*'</span>) &#123;</span><br><span class="line">     <span class="keyword">while</span>(l &lt; s.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(match(l, r)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        l++;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(r == p.length()) <span class="keyword">return</span> l == s.length();  </span><br><span class="line">    <span class="keyword">if</span>(p.charAt(r) == <span class="string">'*'</span>) &#123;  </span><br><span class="line">        <span class="keyword">while</span>(r &lt; p.length() &amp;&amp; p.charAt(r) == <span class="string">'*'</span>) r++;   <span class="comment">// Move the index at p to a non-start char.  </span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; s.length()) &#123;  </span><br><span class="line">            <span class="keyword">if</span>(isMatch(s, p, l, r)) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// Find one match, return true.  </span></span><br><span class="line">            l++; <span class="comment">// Try the next one.  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> isMatch(s, p, l, r);  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(l &lt; s.length() &amp;&amp; (p.charAt(r) == <span class="string">'?'</span> || s.charAt(l) == p.charAt(r)))  </span><br><span class="line">        <span class="keyword">return</span> isMatch(s, p, l + <span class="number">1</span>, r + <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;利用存储历史信息来减少重复计算，以空间换时间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;DP四要素&quot;&gt;&lt;a href=&quot;#DP四要素&quot; class=&quot;headerlink&quot; title=&quot;DP四要素&quot;&gt;&lt;/a&gt;DP四要素&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;function&lt;/strong&gt; 方程，如何从子问题到父问题&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;state&lt;/strong&gt;    状态，存储子问题的结果&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;init&lt;/strong&gt;        初始化，最小问题&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;result&lt;/strong&gt;    结果，最大问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;标记函数&quot;&gt;&lt;a href=&quot;#标记函数&quot; class=&quot;headerlink&quot; title=&quot;标记函数&quot;&gt;&lt;/a&gt;标记函数&lt;/h2&gt;&lt;p&gt;要先想好标记数组到底标记的是什么。&lt;br&gt;最标准的：问的什么就标记什么。&lt;/p&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode Category" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/LeetCode-Category/"/>
    
    
      <category term="Array" scheme="blog.jiangdongyu.space/tags/Array/"/>
    
      <category term="DynamicProgramming" scheme="blog.jiangdongyu.space/tags/DynamicProgramming/"/>
    
  </entry>
  
  <entry>
    <title>微软Office STCA</title>
    <link href="blog.jiangdongyu.space/2018/04/24/%E5%BE%AE%E8%BD%AFOffice%20STCA/"/>
    <id>blog.jiangdongyu.space/2018/04/24/微软Office STCA/</id>
    <published>2018-04-24T10:26:00.000Z</published>
    <updated>2018-05-28T10:56:09.817Z</updated>
    
    <content type="html"><![CDATA[<p>微软Office STCA暑期实习面试<br><a id="more"></a></p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ul><li>介绍azure table为什么能做到一个用户的数据在一台机器上</li><li>介绍datafactory入hive的过程，如果将copy和hive分开，怎么做？用socket？为什么websocket能做到双方发消息？</li><li>多态是在编译时知道？还是<em>运行时</em>？ B extends A;<ul><li>A a = new A() <strong>编译时</strong></li><li>A a = new B() <strong>运行时</strong></li></ul></li><li><p>给定一个正整数，求阶乘？ 越界？ 非递归？</p><ul><li>n较小时</li></ul><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getNFactorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>{     <span class="keyword">if</span>(n==<span class="number">0</span>){         <span class="keyword">return</span> <span class="number">1l</span>;     }     <span class="keyword">return</span> n*getNFactorial1(n-<span class="number">1</span>);}</code></pre><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getNFactorial1</span><span class="params">(<span class="keyword">int</span> n)</span></span>{      <span class="keyword">if</span>(n==<span class="number">0</span>){          <span class="keyword">return</span> <span class="number">1l</span>;      }      <span class="keyword">long</span> sum=<span class="number">1l</span>;      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){          sum=sum*i;      }      <span class="keyword">return</span> sum;} </code></pre><ul><li>n较大时</li></ul><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getNFactorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{      <span class="keyword">int</span> num[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000</span>];      <span class="keyword">int</span> i, j;      <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">0</span>) {          System.out.println(<span class="number">1</span>);      } <span class="keyword">else</span> {          <span class="keyword">int</span> p, h;<span class="comment">// p 存放当前结果的位数，h为进位；</span>          p = <span class="number">1</span>;          h = <span class="number">0</span>;          num[<span class="number">1</span>] = <span class="number">1</span>;          <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) {              <span class="comment">// 使得a[]的每位与i相乘</span>              <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= p; j++) {                  num[j] = num[j] * i + h;                  h = num[j] / <span class="number">10</span>;                  num[j] = num[j] % <span class="number">10</span>;              }              <span class="comment">// 表示向新的位置进位</span>              <span class="keyword">while</span> (h &gt; <span class="number">0</span>) {                  num[j] = h % <span class="number">10</span>;                  h = h / <span class="number">10</span>;                  j++;              }              p = j - <span class="number">1</span>;          }          <span class="keyword">for</span> (i = p; i &gt;= <span class="number">1</span>; i--) {              System.out.print(num[i]);          }      }  }</code></pre></li></ul><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ul><li>2 Sum &amp; 3 Sum</li><li>int parse(String str)的测试用例</li><li>为什么用azure？</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微软Office STCA暑期实习面试&lt;br&gt;
    
    </summary>
    
      <category term="实习面试经历" scheme="blog.jiangdongyu.space/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    
      <category term="2018" scheme="blog.jiangdongyu.space/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Sort</title>
    <link href="blog.jiangdongyu.space/2018/04/22/Sort/"/>
    <id>blog.jiangdongyu.space/2018/04/22/Sort/</id>
    <published>2018-04-22T09:52:00.000Z</published>
    <updated>2018-05-29T15:46:50.899Z</updated>
    
    <content type="html"><![CDATA[<p>Sort可分为基于比较和非基于比较两大类排序<br><a id="more"></a></p><h2 id="非基于比较的排序"><a href="#非基于比较的排序" class="headerlink" title="非基于比较的排序"></a>非基于比较的排序</h2><p><strong>基于比较的排序是不可能突破O(NlogN)􏰑的</strong></p><ul><li>计数排序<ul><li><a href="http://www.cs.usfca.edu/~galles/visualization/CountingSort.html" target="_blank" rel="noopener">直接看教学吧</a></li><li>适合数的范围比较小的情况</li></ul></li><li>桶排序<ul><li>尽量增大桶的数量，但是不能有太多无效桶）（将所有的元素分到一定区间条件的桶里，在桶里执行其他排序方法</li></ul></li><li>基数排序<ul><li>拓展的桶排序</li><li>多关键字</li></ul></li></ul><h2 id="基本排序算法"><a href="#基本排序算法" class="headerlink" title="基本排序算法"></a>基本排序算法</h2><table><thead><tr><th style="text-align:center">Algorithm</th><th style="text-align:center">Average Time</th><th style="text-align:center">Worst Time</th><th style="text-align:center">Space</th><th style="text-align:center">Stable</th></tr></thead><tbody><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">n^2</td><td style="text-align:center">n^2</td><td style="text-align:center">1</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">选择排序</td><td style="text-align:center">n^2</td><td style="text-align:center">n^2</td><td style="text-align:center">1</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">插入排序</td><td style="text-align:center">n^2</td><td style="text-align:center">n^2</td><td style="text-align:center"></td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center">nlog(n)</td><td style="text-align:center">n^2</td><td style="text-align:center"></td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center">nlog(n)</td><td style="text-align:center">nlog(n)</td><td style="text-align:center"></td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">nlog(n)</td><td style="text-align:center">nlog(n)</td><td style="text-align:center"></td><td style="text-align:center">N</td></tr></tbody></table><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><pre><code>public static void sort(int[] nums, int left,int right){        if(left &lt; right){            int mid = partition(nums,left,right);            sort(nums,left,mid-1);            sort(nums,mid+1,right);        }    }    public static int partition(int[] nums,int low,int high){        int pivot = nums[low];        while(low &lt; high){            while(nums[high] &gt;= pivot &amp;&amp; low &lt; high){                high--;            }            nums[low] = nums[high];            while(nums[low] &lt;= pivot &amp;&amp; low &lt; high){                low++;            }            nums[high] = nums[low];        }        nums[low] = pivot;        return low;}</code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><pre><code>public static void sort(int[] nums, int left,int right){            int mid = (left + right)/2;            if(left &lt; right){                sort(nums,left,mid);                sort(nums,mid+1,right);                merge(nums,left,mid,right);            }    }    public static void merge(int[] nums,int low,int mid,int high){            int[] tem = new int[high-low+1];            int i = low;            int j = mid+1;            int k = 0;            while(i &lt;= mid &amp;&amp; j &lt;= high){                if(nums[i] &lt; nums[j]) tem[k++] = nums[i++];                else tem[k++] = nums[j++];            }            while(i &lt;= mid) tem[k++] = nums[i++];            while(j &lt;= high) tem[k++] = nums[j++];            for(int m = 0;m &lt; tem.length;m++){                nums[m+low] = tem[m];            }    }</code></pre><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> n = nums.length;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = n/<span class="number">2</span> -<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">      heapify(nums,n,i);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">      swap(nums,<span class="number">0</span>,i);</span><br><span class="line">      heapify(nums,i,<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> n,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> largest = i;</span><br><span class="line"> <span class="keyword">int</span> l = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">int</span> r = <span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(l &lt; n &amp;&amp; nums[l] &gt; nums[largest])&#123;</span><br><span class="line">      largest = l;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(r &lt; n &amp;&amp; nums[r] &gt; nums[largest])&#123;</span><br><span class="line">      largest = r;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(largest != i)&#123;</span><br><span class="line">      swap(nums,i,largest);</span><br><span class="line">      heapify(nums,n,largest);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> tem = nums[i];</span><br><span class="line"> nums[i] = nums[j];</span><br><span class="line"> nums[j] = tem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Wiggle-Sort"><a href="#Wiggle-Sort" class="headerlink" title="Wiggle Sort"></a>Wiggle Sort</h3><blockquote><p>Given an unsorted array nums, reorder it in-place such that nums[0] &lt;= nums[1] &gt;= nums[2] &lt;= nums[3]….</p><p>For example, given nums = [3, 5, 2, 1, 6, 4], one possible answer is [1, 6, 2, 5, 3, 4].</p></blockquote><ul><li>排序法<ul><li>先将数组排序，</li><li>这时候从第3个元素开始，将第3个元素和第2个元素交换。</li><li>然后再从第5个元素开始，将第5个元素和第4个元素交换，</li><li>以此类推。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先将数组排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// 将数组中一对一对交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[i-<span class="number">1</span>];</span><br><span class="line">            nums[i-<span class="number">1</span>] = nums[i];</span><br><span class="line">            nums[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>交换法<ul><li>如果i是奇数，nums[i] &gt;= nums[i - 1]</li><li>如果i是偶数，nums[i] &lt;= nums[i - 1]</li><li>遍历一遍数组，把不符合的情况交换一下就行了。</li><li>具体来说，如果nums[i] &gt; nums[i - 1]， 则交换以后肯定有nums[i] &lt;= nums[i - 1]。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 需要交换的情况：奇数时nums[i] &lt; nums[i - 1]或偶数时nums[i] &gt; nums[i - 1]</span></span><br><span class="line">            <span class="keyword">if</span>((i % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; nums[i] &lt; nums[i-<span class="number">1</span>]) || (i % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; nums[i] &gt; nums[i-<span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[i-<span class="number">1</span>];</span><br><span class="line">                nums[i-<span class="number">1</span>] = nums[i];</span><br><span class="line">                nums[i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sort-Colors"><a href="#Sort-Colors" class="headerlink" title="Sort Colors"></a>Sort Colors</h3><blockquote><p>给定一组分别具有红白蓝颜色的对象，重新排序他们使得相同颜色的对象相邻。排序后的顺序是红白蓝。</p></blockquote><blockquote><p>这里我们用 0, 1, and 2 来分别表示红白蓝三个颜色。</p></blockquote><p><strong>注意：不能用库中的排序函数。</strong></p><ul><li>遍历，计数</li><li>类似快排的partition<ul><li>左边存放0和1，右边存放2.两边往中间靠。</li><li>设置两个index，left记录第一个1的位置，left左边为0，right记录第一个非2的位置，right右边为2.</li><li>然后使用i从头到尾扫一遍，直到与right相遇。</li><li>i遇到0就换到左边去，遇到2就换到右边去，遇到1就跳过。</li><li>需要注意的是：由于left记录第一个1的位置，因此A[left]与A[i]交换后，A[left]为0,A[i]为1，因此i++；</li><li>而right记录第一个非2的位置，可能为0或1，因此A[right]与A[i]交换后，A[right]为2,A[i]为0或1，i不能前进，要后续判断。</li><li>由此该数组分为4段：[0,left)–&gt;0; [left,i)–&gt;1; [i,right]–&gt;乱序; (right,n-1]–&gt;2</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums,i,left);</span><br><span class="line">                i++;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                swap(nums,i,right);</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tem = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sort-List"><a href="#Sort-List" class="headerlink" title="Sort List"></a>Sort List</h3><ul><li>归并排序<ul><li>快慢指针将链表分为两个部分</li><li>慢指针的next为null</li><li>再合并两个排序好的链表</li></ul></li></ul><h3 id="Insertion-Sort-List"><a href="#Insertion-Sort-List" class="headerlink" title="Insertion Sort List"></a>Insertion Sort List</h3><ul><li>选择排序，i前有序，i后无序，两层循环</li><li>链表的插入排序，同样两层循环，考虑到头指针也需要被排序，需要新增一个fakeHead。</li><li>链表的插入需要维护三个指针，pre，cur，next，</li><li>pre始终指向有序链表的fakeHead，cur指向当前需要排序的节点，next指向下一个待排序的节点。</li><li>当有序链表为空或者pre.next所指向的元素的值比当前节点的值大时，需要将cur插入到pre.next之前的位置，</li><li>否则，则将pre指针后移，最后返回fakeHead.next即可。</li></ul><h3 id="Maximum-Gap"><a href="#Maximum-Gap" class="headerlink" title="Maximum Gap"></a>Maximum Gap</h3><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p><p>Return 0 if the array contains less than 2 elements.</p><p>Example 1:</p><pre><code>Input: [3,9,6,1]Output: 3Explanation: The sorted form of the array is [1,3,6,9], either 3,6 or 6,9 has the maximum difference 3. </code></pre><p>Example 2:</p><pre><code>Input: [10]Output: 0Explanation: The array contains less than 2 elements, therefore return 0.</code></pre><p>Notes:</p><p>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.</p><p>Try to solve it in linear time/space.</p><ul><li>直接排序</li><li>桶排序，取相邻两个桶，后一个桶的最小值和前一个桶的最大值可能就是那个值</li></ul><h3 id="Best-Meeting-Point"><a href="#Best-Meeting-Point" class="headerlink" title="Best Meeting Point"></a>Best Meeting Point</h3><blockquote><p>A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.</p></blockquote><p>For example, given three people living at (0,0), (0,4), and (2,2):</p><pre><code>1 - 0 - 0 - 0 - 1|   |   |   |   |0 - 0 - 0 - 0 - 0|   |   |   |   |0 - 0 - 1 - 0 - 0</code></pre><p>The point (0,2) is an ideal meeting point, as the total travel<br>distance of 2+2+2=6 is minimal. So return 6.</p><ul><li>曼哈顿距离，我们可以分开计算横坐标和纵坐标</li><li>算出各个横坐标到中点横坐标的距离，加上各个纵坐标到中点纵坐标的距离，就是结果</li></ul><h2 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h2><h3 id="Meeting-Rooms"><a href="#Meeting-Rooms" class="headerlink" title="Meeting Rooms"></a>Meeting Rooms</h3><blockquote><p>Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],…] (si &lt; ei), determine if a person could attend all meetings.</p></blockquote><ul><li>判断区间是否重合</li><li>先对数组按照开始时间排序，如果下一个的开始时间早于前一个的结束时间则不行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canAttendMeetings</span><span class="params">(Interval[] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span>(intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// sort</span></span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; a.start == b.start ? a.end - b.end : a.start - b.start);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//or</span></span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;Interval&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Interval i1, Interval i2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i1.start-i2.start;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i].end &gt; intervals[i+<span class="number">1</span>].start) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Meeting-Rooms-II"><a href="#Meeting-Rooms-II" class="headerlink" title="Meeting Rooms II"></a>Meeting Rooms II</h3><blockquote><p>Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],…] (si &lt; ei), find the minimum number of conference rooms required.</p></blockquote><p><strong>思路</strong></p><p>overlap的条件依然是：intervals[i].end &gt; intervals[j].start<br>不同的是这题需要求房间数。还是先sort，i指向之前有overlap的最小end的那一个。</p><p><strong>复杂度</strong></p><p>Time Complexity: O(NlogN)，Space: O(N)。</p><p><strong>heap</strong></p><p>因为要知道之前有overlap的最小的end，所以可以用一个min heap。每次检查新的start是否比heap的top元素小，是的话就把保存原来的end，同时放进新的end；否则就放新的end同时poll出原来的，因为没有overlap且新的end较大。最后heap的大小就是需要的房间数。比如：</p><p>[1, 5], [2, 4], [3, 6], [5, 7]</p><pre><code>heap: [5]。[2, 4]的start是2，比5小，所以放入4。heap: [4, 5]。接着[3 ,6]的start是3，比4小，所以又放入6。heap: [4, 5, 6]。[5, 7]的start是5，比4大，因此poll出4，放入7。heap: [5, 6, 7]。最后heap的size为3。</code></pre><p>4被pop出来是因为[2, 4]和[5, 7]公用一个房间，只要放7进去就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(Interval[] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span>(intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// sort</span></span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; a.start == b.start ? a.end - b.end : a.start - b.start);</span><br><span class="line">        <span class="comment">// min heap to store the end</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        minHeap.offer(intervals[<span class="number">0</span>].end);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="comment">// no overlap</span></span><br><span class="line">            <span class="keyword">if</span>(minHeap.peek() &lt;= intervals[i].start) minHeap.poll();</span><br><span class="line">            minHeap.offer(intervals[i].end);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> minHeap.size();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Insert-Intervals"><a href="#Insert-Intervals" class="headerlink" title="Insert Intervals"></a>Insert Intervals</h3><blockquote><p>即向有序、不重叠的区间序列中插入一个区间。如区间产生重叠，则合并。求插入新区间后的区间序列。</p><p>如：A = [1,3],[6,9]，插入[2,6]，插入后新序列为[1,9]。</p></blockquote><ul><li>对新给的序列，有三种对应情况</li><li>旧区间在新区间之前</li><li>新区间在旧区间之前</li><li>有重叠</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">insert</span><span class="params">(List&lt;Interval&gt; intervals, Interval newInterval)</span> </span>&#123;</span><br><span class="line">        List&lt;Interval&gt; ans = <span class="keyword">new</span> ArrayList&lt;Interval&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; intervals.size() ;i++)&#123;</span><br><span class="line">            Interval now = intervals.get(i);</span><br><span class="line">            <span class="keyword">if</span>(now.end &lt; newInterval.start)&#123; <span class="comment">//intervals before the newInterval</span></span><br><span class="line">                ans.add(now);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(now.start &gt; newInterval.end)&#123; <span class="comment">//intervals after the newInterval</span></span><br><span class="line">                ans.add(newInterval);</span><br><span class="line">                ans.addAll(intervals.subList(i,intervals.size())); <span class="comment">//add all remaining intervals and return</span></span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">//intervals overlap the newInterval , update the interval range</span></span><br><span class="line">                newInterval.start = Math.min(newInterval.start, now.start);</span><br><span class="line">                newInterval.end = Math.max(newInterval.end, now.end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(newInterval); <span class="comment">//if there are no intervals after the newInterval, than add it and return</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Merge-Intervals"><a href="#Merge-Intervals" class="headerlink" title="Merge Intervals"></a>Merge Intervals</h3><p>Given a collection of intervals, merge all overlapping intervals.</p><p>Example 1:</p><pre><code>Input: [[1,3],[2,6],[8,10],[15,18]]Output: [[1,6],[8,10],[15,18]]Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</code></pre><p>Example 2:</p><pre><code>Input: [[1,4],[4,5]]Output: [[1,5]]Explanation: Intervals [1,4] and [4,5] are considerred overlapping.</code></pre><ul><li>先根据start排序</li><li>再遍历判断是否重叠，interval.start &lt;= end重叠</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * public class Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() &#123; start = 0; end = 0; &#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) &#123; start = s; end = e; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">merge</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">        </span><br><span class="line">        Collections.sort(intervals, (a, b) -&gt; a.start == b.start ? a.end - b.end : a.start - b.start);</span><br><span class="line">        List&lt;Interval&gt; merged = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start = intervals.get(<span class="number">0</span>).start;</span><br><span class="line">        <span class="keyword">int</span> end = intervals.get(<span class="number">0</span>).end;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(Interval interval:intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span>(interval.start &lt;= end )&#123;</span><br><span class="line">                end = Math.max(interval.end,end);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                merged.add(<span class="keyword">new</span> Interval(start,end));</span><br><span class="line">                start = interval.start;</span><br><span class="line">                end = interval.end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        merged.add(<span class="keyword">new</span> Interval(start,end));</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Largest-Number"><a href="#Largest-Number" class="headerlink" title="Largest Number"></a>Largest Number</h3><p>Given a list of non negative integers, arrange them such that they form the largest number.</p><p>Example 1:</p><pre><code>Input: [10,2]Output: 210</code></pre><p>Example 2:</p><pre><code>Input: [3,30,34,5,9]Output: 9534330</code></pre><p>Note: The result may be very large, so you need to return a string instead of an integer.</p><ul><li>对哪个数放在前面的问题，其实对ab两个数进行排序</li><li>如果ab &gt; ba，那么a应该在b之前，写一个符合条件的comparator即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            arr[i] = String.valueOf(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//逆序，方便之后append</span></span><br><span class="line">        Arrays.sort(arr, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span></span>&#123;</span><br><span class="line">                String s1 = a+b;</span><br><span class="line">                String s2 = b+a;</span><br><span class="line">                <span class="keyword">return</span> s2.compareTo(s1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">0</span>].equals(<span class="string">"0"</span>)) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span>(String s: arr)&#123;</span><br><span class="line">        sb.append(s);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bucket-Sort"><a href="#Bucket-Sort" class="headerlink" title="Bucket Sort"></a>Bucket Sort</h2><h3 id="First-Missing-Positive"><a href="#First-Missing-Positive" class="headerlink" title="First Missing Positive"></a>First Missing Positive</h3><p>Given an unsorted integer array, find the smallest missing positive integer.</p><p>Example 1:</p><pre><code>Input: [1,2,0]Output: 3</code></pre><p>Example 2:</p><pre><code>Input: [3,4,-1,1]Output: 2</code></pre><p>Example 3:</p><pre><code>Input: [7,8,9,11,12]Output: 1</code></pre><p>Note:</p><p>Your algorithm should run in O(n) time and uses constant extra space.</p><ul><li>交换数组元素，使得数组中第i位存放数值(i+1)。</li><li>最后遍历数组，寻找第一个不符合此要求的元素，返回其下标。</li><li>整个过程需要遍历两次数组，复杂度为O(n)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i+<span class="number">1</span> &amp;&amp; nums[i] &gt;= <span class="number">1</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[i] != nums[nums[i]-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> tem = nums[nums[i]-<span class="number">1</span>];</span><br><span class="line">                nums[nums[i]-<span class="number">1</span>] = nums[i];</span><br><span class="line">                nums[i] = tem;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] != j+<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> j+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Sort可分为基于比较和非基于比较两大类排序&lt;br&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode Category" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/LeetCode-Category/"/>
    
    
      <category term="Array" scheme="blog.jiangdongyu.space/tags/Array/"/>
    
      <category term="Sort" scheme="blog.jiangdongyu.space/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>BFS</title>
    <link href="blog.jiangdongyu.space/2018/04/18/BFS/"/>
    <id>blog.jiangdongyu.space/2018/04/18/BFS/</id>
    <published>2018-04-18T12:52:00.000Z</published>
    <updated>2018-05-29T15:46:01.675Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目列表</strong></p><h3 id="Binary-Tree-Right-Side-View"><a href="#Binary-Tree-Right-Side-View" class="headerlink" title="Binary Tree Right Side View"></a>Binary Tree Right Side View</h3><blockquote><p>层次遍历，输出最右边的数</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// reverse level traversal</span></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">                TreeNode cur = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) result.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Populating-Next-Right-Pointers-in-Each-Node"><a href="#Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="Populating Next Right Pointers in Each Node"></a>Populating Next Right Pointers in Each Node</h3><p>For example,<br>Given the following perfect binary tree,</p><pre><code>     1   /  \  2    3 / \  / \4  5  6  7</code></pre><p>After calling your function, the tree should look like:</p><pre><code>     1 -&gt; NULL   /  \  2 -&gt; 3 -&gt; NULL / \  / \4-&gt;5-&gt;6-&gt;7 -&gt; NULL</code></pre><ul><li>由于是<strong>完全二叉树</strong>，所以若节点的<strong>左子结点存在的话，其右子节点必定存在</strong>，</li><li>所以<strong>左子结点的next指针可以直接指向其右子节点</strong>，</li><li>对于其右子节点的处理方法是，判断其<strong>父节点的next</strong>是否为空，若不为空，则指向其next指针指向的节点的左子结点，若为空则指向NULL</li></ul><h3 id="Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="Populating Next Right Pointers in Each Node II"></a>Populating Next Right Pointers in Each Node II</h3><blockquote><p>不是完全二叉树</p></blockquote><p>借助dummy结点的解法！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</span><br><span class="line">        TreeLinkNode dummy = <span class="keyword">new</span> TreeLinkNode(<span class="number">0</span>);</span><br><span class="line">        TreeLinkNode cur = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                cur.next = root.left;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                cur.next = root.right;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root.next;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">                cur = dummy;</span><br><span class="line">                root = cur.next;</span><br><span class="line">                cur.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Word-Ladder"><a href="#Word-Ladder" class="headerlink" title="Word Ladder"></a>Word Ladder</h3><p>For example,</p><p>Given:</p><p>beginWord = “hit”</p><p>endWord = “cog”</p><p>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</p><p>As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,</p><p>return its length 5.</p><p><strong>Note:</strong></p><ul><li>Return 0 if there is no such transformation sequence.</li><li>All words have the same length.</li><li>All words contain only lowercase alphabetic characters.</li><li>You may assume no duplicates in the word list.</li><li>You may assume beginWord and endWord are non-empty and are not the same.</li></ul><p><strong>解题思路</strong></p><ul><li>BFS</li><li>可以想象成一棵树，根节点是start字符串，</li><li>第二层是所有的和它相差一个字母的字符串（之前出现过的，之后就没有必要出现了，因为出现的话，也是abc变成bbc又变回abs，没有意义），</li><li>需要一个队列来实现广度优先搜索，因为是从顶层到底层来遍历的，所以发现等于end的时候的层数值就是最小的，返回即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(beginWord);</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">0</span>; q &lt; size; q++) &#123;</span><br><span class="line">                <span class="keyword">char</span>[] cur = queue.poll().toCharArray();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; cur.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">char</span> tmp = cur[i];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">char</span> chr=<span class="string">'a'</span>; chr &lt;= <span class="string">'z'</span>; chr++) &#123;</span><br><span class="line">                        cur[i] = chr;</span><br><span class="line">                        String dest = <span class="keyword">new</span> String(cur);</span><br><span class="line">                        <span class="keyword">if</span> (dict.contains(dest)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (dest.equals(endWord)) <span class="keyword">return</span> level+<span class="number">1</span>;</span><br><span class="line">                            queue.add(dest);</span><br><span class="line">                            dict.remove(dest);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur[i] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Word-Ladder-II"><a href="#Word-Ladder-II" class="headerlink" title="Word Ladder II"></a>Word Ladder II</h3><blockquote><p>需要返回所有的最短路径</p></blockquote><p>呃，有点难。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目列表&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;Binary-Tree-Right-Side-View&quot;&gt;&lt;a href=&quot;#Binary-Tree-Right-Side-View&quot; class=&quot;headerlink&quot; title=&quot;Binary Tree Right Side View&quot;&gt;&lt;/a&gt;Binary Tree Right Side View&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;层次遍历，输出最右边的数&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode Category" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/LeetCode-Category/"/>
    
    
      <category term="BFS" scheme="blog.jiangdongyu.space/tags/BFS/"/>
    
      <category term="BinaryTree" scheme="blog.jiangdongyu.space/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search</title>
    <link href="blog.jiangdongyu.space/2018/04/18/BinarySearch/"/>
    <id>blog.jiangdongyu.space/2018/04/18/BinarySearch/</id>
    <published>2018-04-18T12:34:00.000Z</published>
    <updated>2018-06-05T08:31:11.807Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有序数组，用于查找</p></blockquote><h2 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h2><p>需要优化O(n)复杂度时，一般只能二分法</p><a id="more"></a><h2 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">int</span> high = arr.length-<span class="number">1</span>;   </span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high) &#123;   </span><br><span class="line">        <span class="keyword">int</span> middle = low + (high - low)/<span class="number">2</span>;   </span><br><span class="line">        <span class="keyword">if</span>(x == arr[middle]) &#123;   </span><br><span class="line">             <span class="keyword">return</span> middle;   </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x &lt;arr[middle]) &#123;   </span><br><span class="line">             high = middle - <span class="number">1</span>;   </span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;   </span><br><span class="line">             low = middle + <span class="number">1</span>;   </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h2><h3 id="第一类"><a href="#第一类" class="headerlink" title="第一类"></a>第一类</h3><blockquote><p>考察基本用法，题目并没有说明没有重复值，需要继续查找</p></blockquote><ul><li>search insert position</li><li>search for a range</li><li>isBadVersion</li><li>Closest Binary Search Tree Value <ul><li>二叉搜索树找离target最近的node的值</li><li>二分判断左右</li></ul></li><li>Find Peak Element<ul><li><strong>二分查找折半</strong>后中间那个元素后，</li><li>和<strong>紧跟</strong>的那个元素比较下大小，</li><li>如果<strong>大于</strong>，则说明峰值在前面，</li><li>如果<strong>小于</strong>则在后面。这样就可以找到一个峰值了</li></ul></li><li>Median of Two Sorted Arrays</li></ul><h4 id="Search-for-a-range"><a href="#Search-for-a-range" class="headerlink" title="Search for a range"></a>Search for a range</h4><blockquote><p>查找等于target的一个范围，即找到最先出现的target和最后出现的target</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = &#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = nums.length-<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(nums[low] &lt; nums[high])&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>; </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[low] &lt; target) low++;</span><br><span class="line">                <span class="keyword">if</span>(nums[high] &gt; target) high--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[low] == target)&#123;</span><br><span class="line">            res[<span class="number">0</span>] = low;</span><br><span class="line">            res[<span class="number">1</span>] = high;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Median-of-Two-Sorted-Arrays"><a href="#Median-of-Two-Sorted-Arrays" class="headerlink" title="Median of Two Sorted Arrays"></a>Median of Two Sorted Arrays</h4><h3 id="第二类"><a href="#第二类" class="headerlink" title="第二类"></a>第二类</h3><blockquote><p>和数学相关</p></blockquote><ul><li>sqrt(X) </li><li>pow(x, n) </li><li>fastPower</li></ul><h4 id="sqrt-X"><a href="#sqrt-X" class="headerlink" title="sqrt(X)"></a>sqrt(X)</h4><blockquote><p>i * i &lt;= x &amp;&amp; (i+1)(i+1) &gt; x</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">1</span>, end = x;</span><br><span class="line"><span class="keyword">while</span> (start &lt; end) &#123; </span><br><span class="line"><span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (mid &lt;= x / mid &amp;&amp; (mid + <span class="number">1</span>) &gt; x / (mid + <span class="number">1</span>))<span class="comment">// Found the result</span></span><br><span class="line"><span class="keyword">return</span> mid; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mid &gt; x / mid)<span class="comment">// Keep checking the left part</span></span><br><span class="line">end = mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">start = mid + <span class="number">1</span>;<span class="comment">// Keep checking the right part</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pow-x-n"><a href="#pow-x-n" class="headerlink" title="pow(x, n)"></a>pow(x, n)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            n = -n;</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (n%<span class="number">2</span> == <span class="number">0</span>) ? pow(x*x, n/<span class="number">2</span>) : x*pow(x*x, n/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三类"><a href="#第三类" class="headerlink" title="第三类"></a>第三类</h3><blockquote><p>二维上运用</p></blockquote><ul><li>Search a 2d Matrix <ul><li>矩阵从左到右递增，第二行最小值比第一行最大值大</li><li>可转化为一维的二分，matrix[mid/col][mid%col] == target</li></ul></li><li>Search a 2d Matrix II<ul><li>矩阵从左到右递增，从上到下递增</li></ul></li></ul><h3 id="第四类"><a href="#第四类" class="headerlink" title="第四类"></a>第四类</h3><blockquote><p>部分sorted的数组或者rotated的数组</p></blockquote><ul><li>search in rotated sorted array</li><li>search in rotated sorted array II(duplicate allowed) </li><li>find min in rotated sorted array</li><li>find min in rotated sorted array II(duplicate allowed)</li></ul><h4 id="Search-in-Rotated-Sorted-Array"><a href="#Search-in-Rotated-Sorted-Array" class="headerlink" title="Search in Rotated Sorted Array"></a>Search in Rotated Sorted Array</h4><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>解题方案</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (nums[start] &lt;= nums[mid])&#123;</span><br><span class="line">                 <span class="keyword">if</span> (target &lt; nums[mid] &amp;&amp; target &gt;= nums[start]) </span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= nums[end])&#123;</span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end])</span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Search-in-rotated-sorted-array-II-duplicate-allowed"><a href="#Search-in-rotated-sorted-array-II-duplicate-allowed" class="headerlink" title="Search in rotated sorted array II(duplicate allowed)"></a>Search in rotated sorted array II(duplicate allowed)</h4><p>nums may contain duplicates.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[start] == nums[mid])&#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[start] &lt; nums[mid])&#123;</span><br><span class="line">                 <span class="keyword">if</span> (target &lt; nums[mid] &amp;&amp; target &gt;= nums[start]) </span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end])</span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Find-min-in-rotated-sorted-array"><a href="#Find-min-in-rotated-sorted-array" class="headerlink" title="Find min in rotated sorted array"></a>Find min in rotated sorted array</h4><blockquote><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p></blockquote><blockquote><p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p></blockquote><blockquote><p>Find the minimum element.</p></blockquote><ul><li>If rotate, A[min] &lt; A[min - 1]; </li><li>If not, A[0]. </li><li>If not, there are 2 conditions as well: </li><li>If it is greater than both left and right element, then minimum element should be on its right, otherwise on its left.</li></ul><h4 id="Find-Minimum-in-Rotated-Sorted-Array-II"><a href="#Find-Minimum-in-Rotated-Sorted-Array-II" class="headerlink" title="Find Minimum in Rotated Sorted Array II"></a>Find Minimum in Rotated Sorted Array II</h4><blockquote><p>The array may contain duplicates.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[end])&#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[end])&#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Longest-Increasing-Subsequence"><a href="#Longest-Increasing-Subsequence" class="headerlink" title="Longest Increasing Subsequence"></a>Longest Increasing Subsequence</h4><p><strong>动态规划</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxval = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    maxval = Math.max(maxval, dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = maxval + <span class="number">1</span>;</span><br><span class="line">            maxans = Math.max(maxans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二分查找</strong></p><ul><li>if x is larger than all tails, append it, increase the size by 1</li><li>if tails[i-1] &lt; x &lt;= tails[i], update tails[i]</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPositionToReplace</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid;</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (a[mid] == x)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; x)</span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> | nums.length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = nums.length, len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] increasingSequence = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">increasingSequence[len++] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; increasingSequence[len - <span class="number">1</span>])</span><br><span class="line">increasingSequence[len++] = nums[i];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> position = findPositionToReplace(increasingSequence, <span class="number">0</span>, len - <span class="number">1</span>, nums[i]);</span><br><span class="line">increasingSequence[position] = nums[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有序数组，用于查找&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;何时使用&quot;&gt;&lt;a href=&quot;#何时使用&quot; class=&quot;headerlink&quot; title=&quot;何时使用&quot;&gt;&lt;/a&gt;何时使用&lt;/h2&gt;&lt;p&gt;需要优化O(n)复杂度时，一般只能二分法&lt;/p&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode Category" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/LeetCode-Category/"/>
    
    
      <category term="Array" scheme="blog.jiangdongyu.space/tags/Array/"/>
    
      <category term="BinarySearch" scheme="blog.jiangdongyu.space/tags/BinarySearch/"/>
    
  </entry>
  
  <entry>
    <title>DFS</title>
    <link href="blog.jiangdongyu.space/2018/04/18/DFS/"/>
    <id>blog.jiangdongyu.space/2018/04/18/DFS/</id>
    <published>2018-04-18T12:33:00.000Z</published>
    <updated>2018-05-29T15:46:23.582Z</updated>
    
    <content type="html"><![CDATA[<p>遇到要求所有组合，可能，排列等解集的问题，一般都是用DFS/BFS + backtracking来做</p><a id="more"></a><h3 id="Path-Sum"><a href="#Path-Sum" class="headerlink" title="Path Sum"></a>Path Sum</h3><blockquote><p>给定一个值，判断是否有一个从根到叶子的路径的value之和等于这个值</p></blockquote><ul><li>非递归<ul><li>DFS，两个栈，一个放node，一个放到当前node的curSum</li><li>如果node是叶子结点，并且curSum等于给定的那个值时，返回true</li></ul></li><li>递归<ul><li>判断root为null</li><li>判断左右子树为null，且该值等于root.val</li><li>减去root.val对左右子树递归判断</li></ul></li></ul><h3 id="Path-Sum-II"><a href="#Path-Sum-II" class="headerlink" title="Path Sum II"></a>Path Sum II</h3><blockquote><p>需要返回所有可能的路径</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    pathSum(ans, path, root, sum);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pathSum</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; path,</span></span></span><br><span class="line"><span class="function"><span class="params">TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">List&lt;Integer&gt; newPath = <span class="keyword">new</span> ArrayList&lt;&gt;(path);</span><br><span class="line">newPath.add(root.val);</span><br><span class="line"><span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == sum) &#123;</span><br><span class="line">ans.add(newPath);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">pathSum(ans, newPath, root.left, sum - root.val);</span><br><span class="line">pathSum(ans, newPath, root.right, sum - root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sum-Root-to-Leaf-Numbers"><a href="#Sum-Root-to-Leaf-Numbers" class="headerlink" title="Sum Root to Leaf Numbers"></a>Sum Root to Leaf Numbers</h3><p>Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.</p><p>An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123.</p><p>Find the total sum of all root-to-leaf numbers.</p><p>For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br></pre></td></tr></table></figure><p>The root-to-leaf path 1-&gt;2 represents the number 12.</p><p>The root-to-leaf path 1-&gt;3 represents the number 13.</p><p>Return the sum = 12 + 13 = 25.</p><ul><li>和上一题类似</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;遇到要求所有组合，可能，排列等解集的问题，一般都是用DFS/BFS + backtracking来做&lt;/p&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode Category" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/LeetCode-Category/"/>
    
    
      <category term="Array" scheme="blog.jiangdongyu.space/tags/Array/"/>
    
      <category term="DFS" scheme="blog.jiangdongyu.space/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>腾讯</title>
    <link href="blog.jiangdongyu.space/2018/04/16/%E8%85%BE%E8%AE%AF/"/>
    <id>blog.jiangdongyu.space/2018/04/16/腾讯/</id>
    <published>2018-04-16T03:26:00.000Z</published>
    <updated>2018-05-28T10:54:24.511Z</updated>
    
    <content type="html"><![CDATA[<p>腾讯后台开发实习生暑期实习面试<br><a id="more"></a></p><ul><li>自我介绍</li><li>写hql <ul><li>给定腾讯新闻数据，三个表</li><li>第一个表：腾讯新闻版面id，文章id</li><li>第二个表，浏览行为数据：时间戳，版面id，文章id</li><li>第三个表，评论行为数据：时间戳，版面id，文章id</li><li>求每天文章/版面的曝光</li><li>曝光 = 评论/浏览</li></ul></li><li>求两个数组的交集<ul><li>hashset</li><li>排序，再比较</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;腾讯后台开发实习生暑期实习面试&lt;br&gt;
    
    </summary>
    
      <category term="实习面试经历" scheme="blog.jiangdongyu.space/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    
      <category term="2018" scheme="blog.jiangdongyu.space/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree</title>
    <link href="blog.jiangdongyu.space/2018/04/12/BinaryTree/"/>
    <id>blog.jiangdongyu.space/2018/04/12/BinaryTree/</id>
    <published>2018-04-12T12:00:00.000Z</published>
    <updated>2018-05-29T15:46:17.961Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Binary-Tree遍历"><a href="#Binary-Tree遍历" class="headerlink" title="Binary Tree遍历"></a>Binary Tree遍历</h2><p>前序、中序、后序遍历</p><a id="more"></a><p><strong>解法</strong></p><ul><li>递归</li><li>非递归，用stack</li><li>Morris解法，非递归，不用栈，O(1)空间，二叉搜索树</li></ul><h3 id="Binary-Tree-Preorder-Traversal"><a href="#Binary-Tree-Preorder-Traversal" class="headerlink" title="Binary Tree Preorder Traversal"></a>Binary Tree Preorder Traversal</h3><p>根-左-右</p><ul><li>递归</li><li>非递归<ul><li>根先入栈</li><li>右孩子不为空则入栈</li><li>左孩子不为空则入栈</li><li>循环跳出条件为栈为空</li></ul></li></ul><h3 id="Inorder-Traversal"><a href="#Inorder-Traversal" class="headerlink" title="Inorder Traversal"></a>Inorder Traversal</h3><p>左-根-右</p><ul><li>递归</li><li>非递归<ul><li>root入栈</li><li>不断找root = root.left入栈</li><li>当root为null时出栈，同时root = root.right</li></ul></li></ul><h3 id="postOrder-Traversal"><a href="#postOrder-Traversal" class="headerlink" title="postOrder Traversal"></a>postOrder Traversal</h3><p>左-右-根</p><ul><li>递归</li><li>非递归<ul><li>根入栈</li><li>当栈不为空时，判断栈顶元素node的左右孩子，都为null，则出栈</li><li>右孩子不为空，右孩子入栈,node.right = null</li><li>左孩子不为空，左孩子入栈,node.left = null</li></ul></li></ul><h3 id="Binary-Tree-Level-Order-Traversal-amp-II"><a href="#Binary-Tree-Level-Order-Traversal-amp-II" class="headerlink" title="Binary Tree Level Order Traversal &amp; II"></a>Binary Tree Level Order Traversal &amp; II</h3><h3 id="Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="Binary Tree Zigzag Level Order Traversal"></a>Binary Tree Zigzag Level Order Traversal</h3><p><strong>层次遍历</strong></p><ul><li>queue</li><li>根入队列</li><li>当队列不为空时，node出队列并打印结点，判断左右孩子，分别入队列</li></ul><p>将List顺序反转</p><p>Collections.reverse(subList);</p><h2 id="Binary-Tree-Recursion"><a href="#Binary-Tree-Recursion" class="headerlink" title="Binary Tree Recursion"></a>Binary Tree Recursion</h2><ul><li>pre order </li><li>in order </li><li>post order</li></ul><hr><ul><li>Max Depth</li><li>Min Depth</li><li>Is Balanced Tree</li></ul><hr><ul><li>Same Tree</li></ul><hr><ul><li>Symmetric Tree</li><li>Validate Binary Search Tree</li></ul><hr><ul><li>Recover Binary Search Tree</li></ul><hr><ul><li>Construct Binary Tree from pre-order and in-order </li><li>Construct Binary Tree from post-order and in-order </li><li>Convert Sorted Array to BST</li><li>Convert Sorted LinkedList to BST</li></ul><h3 id="Max-Depth-of-Binary-Tree"><a href="#Max-Depth-of-Binary-Tree" class="headerlink" title="Max Depth of Binary Tree"></a>Max Depth of Binary Tree</h3><ul><li>递归<ul><li>对左右子树深度求Max</li></ul></li><li>非递归<ul><li>层次遍历</li></ul></li></ul><h3 id="Minimum-Depth-of-Binary-Tree"><a href="#Minimum-Depth-of-Binary-Tree" class="headerlink" title="Minimum Depth of Binary Tree"></a>Minimum Depth of Binary Tree</h3><ul><li>递归<ul><li>左右孩子都不为空时，取Min()</li><li>否则，取Max</li></ul></li><li>非递归<ul><li>层次遍历</li><li>当左右孩子都为空时return当前深度</li><li>否则入队列，深度++</li></ul></li></ul><h3 id="Balanced-Binary-Tree"><a href="#Balanced-Binary-Tree" class="headerlink" title="Balanced Binary Tree"></a>Balanced Binary Tree</h3><blockquote><p>平衡二叉树每一个结点的左右子树的深度相差不超过1</p></blockquote><ul><li>递归求深度差是否满足即可</li></ul><h3 id="Symmetric-Tree"><a href="#Symmetric-Tree" class="headerlink" title="Symmetric Tree"></a>Symmetric Tree</h3><blockquote><p>二叉树是否镜像对称</p></blockquote><ul><li>递归<ul><li>停止条件是 left==None &amp; right==None</li><li>left.val==right.val 比较left.left right.right &amp; left.right right.left</li></ul></li><li>非递归</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.add(root);</span><br><span class="line">    q.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        TreeNode t1 = q.poll();</span><br><span class="line">        TreeNode t2 = q.poll();</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1.val != t2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        q.add(t1.left);</span><br><span class="line">        q.add(t2.right);</span><br><span class="line">        q.add(t1.right);</span><br><span class="line">        q.add(t2.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Valid-Binary-Search-Tree"><a href="#Valid-Binary-Search-Tree" class="headerlink" title="Valid Binary Search Tree"></a>Valid Binary Search Tree</h3><blockquote><p>是否满足结点的值左&lt;根&lt;右</p></blockquote><ul><li>递归<ul><li>判断结点的值是否在取值范围内</li></ul></li><li>非递归<ul><li>中序遍历</li><li>一旦出现先pop的node的值比后面的大，则不是</li></ul></li></ul><h3 id="Flatten-Binary-Tree-to-Linked-List"><a href="#Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="Flatten Binary Tree to Linked List"></a>Flatten Binary Tree to Linked List</h3><p>For example,</p><p>Given</p><pre><code>    1   / \  2   5 / \   \3   4   6 </code></pre><p>The flattened tree should look like:</p><pre><code>1 \  2   \    3     \      4       \        5         \          6</code></pre><p><strong>思路1</strong></p><ul><li>递归<ul><li>DFS找到最左结点，然后返回其父结点</li><li>把其父节点和右子节点断开</li><li>将原左子结点连上父节点的右子节点上</li><li>然后再把原右子节点连到新右子节点的右子节点上</li><li>然后再回到上一父节点做相同操作</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) flatten(root.left);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) flatten(root.right);</span><br><span class="line">        </span><br><span class="line">        TreeNode tem = root.right;</span><br><span class="line">        root.right = root.left;</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">           root =  root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        root.right = tem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路2</strong></p><ul><li>非递归<ul><li>从根节点开始出发，先检测其左子结点是否存在</li><li>如存在则将根节点和其右子节点断开，</li><li>将左子结点及其后面所有结构一起连到原右子节点的位置，</li><li>把原右子节点连到元左子结点最后面的右子节点之后</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                TreeNode p = cur.left;</span><br><span class="line">                <span class="keyword">while</span>(p.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    p = p.right;</span><br><span class="line">                &#125;</span><br><span class="line">                p.right = cur.right;</span><br><span class="line">                cur.right = cur.left;</span><br><span class="line">                cur.left = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="Lowest Common Ancestor of a Binary Tree"></a>Lowest Common Ancestor of a Binary Tree</h3><blockquote><p>给定两个结点，求最小公共祖先</p></blockquote><p><strong>代码</strong></p><pre><code>public class Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        //发现目标节点则通过返回值标记该子树发现了某个目标结点        if(root == null || root == p || root == q) return root;        //查看左子树中是否有目标结点，没有为null        TreeNode left = lowestCommonAncestor(root.left, p, q);        //查看右子树是否有目标节点，没有为null        TreeNode right = lowestCommonAncestor(root.right, p, q);        //都不为空，说明做右子树都有目标结点，则公共祖先就是本身        if(left!=null&amp;&amp;right!=null) return root;        //如果发现了目标节点，则继续向上标记为该目标节点        return left == null ? right : left;    }}</code></pre><h3 id="Binary-Tree-Longest-Consecutive-Sequence"><a href="#Binary-Tree-Longest-Consecutive-Sequence" class="headerlink" title="Binary Tree Longest Consecutive Sequence"></a>Binary Tree Longest Consecutive Sequence</h3><p>For example,</p><pre><code>1 \  3 / \2   4     \      5</code></pre><p>Longest consecutive sequence path is 3-4-5, so return 3.</p><pre><code>  2   \    3   /   2     / 1</code></pre><p>Longest consecutive sequence path is 2-3,not3-2-1, so return 2.</p><p><strong>解题思路</strong></p><ul><li>先序遍历</li><li>判断后一个结点是否比前一个结点的值大一</li><li>如果是则长度加1，否则长度重置为1，然后更新结果res</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> result = Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root, <span class="number">0</span>, root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> cur, TreeNode pre)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val == pre.val+<span class="number">1</span>)</span><br><span class="line">            cur++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur = <span class="number">1</span>;</span><br><span class="line">        result = Math.max(result, cur);</span><br><span class="line">        dfs(root.left, cur, root);</span><br><span class="line">        dfs(root.right, cur, root);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Recover-Binary-Search-Tree"><a href="#Recover-Binary-Search-Tree" class="headerlink" title="Recover Binary Search Tree"></a>Recover Binary Search Tree</h3><blockquote><p>二叉排序树中有两个节点被交换了，要求把树恢复成二叉排序树。空间复杂度为常数</p></blockquote><ul><li><p>递归中序遍历二叉树，空间复杂度是O(logn)，最差仍是O(n)</p><ul><li>设置一个pre指针，记录当前节点中序遍历时的前节点，</li><li>如果当前节点大于pre节点的值，说明需要调整次序。</li><li>有一个技巧是如果遍历整个序列过程中只出现了一次次序错误，说明就是这两个相邻节点需要被交换。</li></ul></li><li><p>非递归，空间复杂度是O(logn)，最差仍是O(n)</p><ul><li>栈</li><li>中序遍历</li></ul></li><li><p>Morris<br>待更新</p></li></ul><h3 id="Count-Complete-Tree-Nodes"><a href="#Count-Complete-Tree-Nodes" class="headerlink" title="Count Complete Tree Nodes"></a>Count Complete Tree Nodes</h3><p>最后一层结点可能是1～2^(树的深度-1)</p><ul><li>获得最左子树的深度和最右子树的深度，判断是否相同，相同则直接返回2^（深度）-1</li><li>如果不是，则递归计算左右子树，再加1</li></ul><h3 id="Binary-Tree-Maximum-Path-Sum"><a href="#Binary-Tree-Maximum-Path-Sum" class="headerlink" title="Binary Tree Maximum Path Sum"></a>Binary Tree Maximum Path Sum</h3><blockquote><p>路径至少包含一个结点，可以不包含根结点，求path中结点的值的最大和</p></blockquote><p>思路：递归求一条经过root的最大路径，这条路径可能是：</p><p>1) 左边某条路径 + root + 右边某条路径</p><p>2) 左边某条路径 + root</p><p>3) root + 右边某条路径</p><p>4) root</p><p><strong>对left和right与0比较，可MMath.max(maxValue, left + right + node.val)</strong></p><p>递归函数的返回值是<strong>以当前node为根的最大path sum</strong>,相当于local max<br>最后计算global的时候需要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxValue;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        maxValue = Integer.MIN_VALUE;</span><br><span class="line">        maxPathDown(root);</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxPathDown</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = Math.max(<span class="number">0</span>, maxPathDown(node.left));</span><br><span class="line">        <span class="keyword">int</span> right = Math.max(<span class="number">0</span>, maxPathDown(node.right));</span><br><span class="line">        maxValue = Math.max(maxValue, left + right + node.val);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + node.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Construct-Binary-Tree-from-Inorder-and-Preorder"><a href="#Construct-Binary-Tree-from-Inorder-and-Preorder" class="headerlink" title="Construct Binary Tree from Inorder and Preorder"></a>Construct Binary Tree from Inorder and Preorder</h3><ul><li>有两个矩阵，则对前序遍历的矩阵pre,根结点即为pre[0]</li><li>那么对应的中序遍历矩阵，找到根结点，假设是in[4]，那么in[0-3]即为左子树，in[5-length]即为右子树</li><li>递归即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length != inorder.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(<span class="number">0</span>,preorder.length-<span class="number">1</span>,preorder,<span class="number">0</span>,inorder.length-<span class="number">1</span>,inorder);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span> preStart,<span class="keyword">int</span> preEnd,<span class="keyword">int</span>[] preorder,<span class="keyword">int</span> instart,<span class="keyword">int</span> inEnd,<span class="keyword">int</span>[] inorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart&gt;preEnd || instart&gt;inEnd) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = instart; i &lt;= inEnd; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == root.val) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> lengthLeft = index - instart;</span><br><span class="line">        root.left = build(preStart+<span class="number">1</span>,preStart+lengthLeft,preorder,instart,index-<span class="number">1</span>,inorder);</span><br><span class="line">        root.right = build(preStart+lengthLeft+<span class="number">1</span>,preEnd,preorder,index+<span class="number">1</span>,inEnd,inorder);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Construct-Binary-Tree-from-Inorder-and-Postorder"><a href="#Construct-Binary-Tree-from-Inorder-and-Postorder" class="headerlink" title="Construct Binary Tree from Inorder and Postorder"></a>Construct Binary Tree from Inorder and Postorder</h3><ul><li>和上一个类似</li><li>对后序遍历的矩阵post,根结点即为post[length-1]</li><li>那么对应的中序遍历矩阵，找到根结点，假设是in[4]，那么in[0-3]即为左子树，in[5-length]即为右子树</li><li>递归即可</li></ul><h3 id="Unique-Binary-Search-Tree"><a href="#Unique-Binary-Search-Tree" class="headerlink" title="Unique Binary Search Tree"></a>Unique Binary Search Tree</h3><blockquote><p>当给定 n 时，要求出有 n 个节点的不重复的二叉查找树</p></blockquote><p><strong>动态规划</strong></p><ul><li>卡特兰数</li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/catalan.png" alt="avatar"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从节点数2开始计算到节点数为n的BST</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//计算根是第一个数的BST数量，直到根是最后一个数的BST数量，这里j可以理解为根左边的节点数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="comment">//有n的节点的BST一共有 G(n)=F(1,n-1)+F(2,n-1)+...+F(n-1,n-1)个</span></span><br><span class="line">                <span class="comment">//以i为根总共n个节点的BST有 F(i,n)=G(i-1)*G(i+1-&gt;n)个</span></span><br><span class="line">                <span class="comment">//BST形态数量之和一共有多少个节点有关 G(i+1-&gt;n)=G(n-i)</span></span><br><span class="line">                <span class="comment">//所以G(n)= G(0)*G(n-1)+G(1)*G(n-2)+...</span></span><br><span class="line">                dp[i] += dp[j] * dp[i - j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数学方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) </span><br><span class="line">         c = <span class="number">2</span>*(<span class="number">2</span>*i-<span class="number">1</span>)*c/(i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归</strong></p><ul><li>求出以 i 为根节点的所有不重复二叉查找树的和，其中 i 从 1 到 n。</li><li>当 i 为根节点时，1~i-1 都在根节点的左子树上，i+1~n 都在根节点的右子树上。</li><li>左右子树也都是二叉查找树。根据排列组合可以知道，当i为根节点时，不重复二叉查找树的数量因该是左子树的数量乘以右子树的数量。<strong>即Root( i ) = numTrees( i - 1 ) * numTrees( n - i )。</strong></li><li>numTrees( n ) = Root( 1 ) + Root( 2 ) + Root( 3 ) + …… + Root( n ).</li></ul><h3 id="Unique-Binary-Search-Tree-II"><a href="#Unique-Binary-Search-Tree-II" class="headerlink" title="Unique Binary Search Tree II"></a>Unique Binary Search Tree II</h3><blockquote><p>和上一题不一样在于需要输出所有情况</p></blockquote><ul><li>边界条件的处理<ul><li>当start &lt; end时，正常处理</li><li>当start = end时，说明只剩下一个数字可用，也就只有一种子树了</li><li>当start &gt; end时，说明上一个递归里选了start或者end做root，那么左右子树就是null，返回null</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; result = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            result.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;TreeNode&gt; left =  generateTrees(start, i-<span class="number">1</span>);</span><br><span class="line">            List&lt;TreeNode&gt; right = generateTrees(i+<span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; left.size(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; right.size(); k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root.left = left.get(j);</span><br><span class="line">                    root.right = right.get(k);</span><br><span class="line">                    result.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Binary-Tree遍历&quot;&gt;&lt;a href=&quot;#Binary-Tree遍历&quot; class=&quot;headerlink&quot; title=&quot;Binary Tree遍历&quot;&gt;&lt;/a&gt;Binary Tree遍历&lt;/h2&gt;&lt;p&gt;前序、中序、后序遍历&lt;/p&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode Category" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/LeetCode-Category/"/>
    
    
      <category term="BFS" scheme="blog.jiangdongyu.space/tags/BFS/"/>
    
      <category term="BinaryTree" scheme="blog.jiangdongyu.space/tags/BinaryTree/"/>
    
      <category term="DFS" scheme="blog.jiangdongyu.space/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Greedy</title>
    <link href="blog.jiangdongyu.space/2018/04/11/Greedy/"/>
    <id>blog.jiangdongyu.space/2018/04/11/Greedy/</id>
    <published>2018-04-11T11:52:00.000Z</published>
    <updated>2018-05-29T15:46:35.208Z</updated>
    
    <content type="html"><![CDATA[<p>贪心的奥义就是每一步都选择<strong>当前</strong>回合”可见范围“（即可得知的信息）内的<strong>最优</strong>，而在每一步都仅选择当前回合”可见范围“内的最优这一策略下能够导致<strong>全局最优</strong>的结果的情况使用贪心就会是正确的，否则不适用贪心（或不适用当前对贪心中的最优的定义）。</p><p>因此，贪心一个点是选择<strong>当前最优</strong>，另一个点是这个最优要怎么定义，比如是选使得A最小的还是选使得A-B或A/B最小的等等。</p><p>贪心的正确性其实都要通过<strong>归纳法或反证法</strong>等手段进行严格地证明，而这也是算法分析课程的一个重要讲授内容。</p><a id="more"></a><h2 id="Jump-Game"><a href="#Jump-Game" class="headerlink" title="Jump Game"></a>Jump Game</h2><blockquote><p>For example:</p><p>A = [2,3,1,1,4], return true.</p><p>A = [3,2,1,0,4], return false.</p></blockquote><p>数组里的每个元素表示从该位置可以跳出的最远距离，要求问从第一个元素（index=0）开始，能否达到数组的最后一个元素</p><ul><li>贪心<ul><li>设一个值max，遍历更新max = Math.max(max,i+nums[i])</li><li>最后判断max是否大于等于nums.length-1</li></ul></li><li>动态规划<ul><li>dp[i] i处可到的最远距离</li><li>dp[i] = Math.max(dp[i-1],i+nums[i]) i可达</li><li>dp[i] = dp[i-1] i不可达</li></ul></li></ul><h2 id="Jump-Game-II"><a href="#Jump-Game-II" class="headerlink" title="Jump Game II"></a>Jump Game II</h2><blockquote><p>给定一个非负整数数组，给定的初始化位置在数组的起始位置。数组中的每个元素代表着你能都在此位置跳跃的最大的距离。你的目标是用最少的跳跃数达到数组的末尾</p></blockquote><ul><li>贪心<ul><li>一次循环判断，当前所能到达的最远位置</li><li>如果到不了当前位置，则step加1</li></ul></li></ul><ul><li>动态规划<ul><li>dp[i] 到达i处的最少步数</li><li>两重循环，dp[i]&gt;dp[j]+1 ？dp[i]=dp[j]+1：dp[i] （i &gt; j ,i from 0 to n, j+nums[j] &gt;= i）</li></ul></li></ul><h2 id="Gas-Station"><a href="#Gas-Station" class="headerlink" title="Gas Station"></a>Gas Station</h2><blockquote><p>在一个圆形路径上有N个加油站，在位置 i 上的汽油的数目为gas[i].</p></blockquote><blockquote><p>你有一个汽车，这个汽车的油箱是无限容量的，它从加油站 i 到 加油站 （i+1）需要耗费的汽油数为cost[i]. 开始这段旅程的时候，你的起始状态是在加油站中的一个，油箱为空的.</p></blockquote><blockquote><p>若一次性完成整个的圆形路途，返回你的其实加油站的序号，若不能完成整个路途，返回-1.</p></blockquote><ol><li><p>如果total为<strong>负数</strong>，则无论如何都开不完一圈。</p></li><li><p><strong>如果从一个加油站i出发，开到加油站j所属路段的时候油耗尽，那么从i,j之间的任一个加油站出发都会在j路段或j之前路段耗尽油(相邻的加油站到达必须剩余油量&gt;=0)</strong></p></li></ol><ul><li>循环计算走一环的total和到某站点i的sum</li><li>如果sum&lt;0，则开始的站点变为i+1</li><li>最后判断total</li></ul><h2 id="Candy"><a href="#Candy" class="headerlink" title="Candy"></a>Candy</h2><blockquote><p>多个小朋友站成一排，根据他们的得分分发糖果，得分高的小朋友要比旁边得分低的小朋友得到的糖果多，每个小朋友至少得到一枚糖果，问最少要准备多少糖果？</p></blockquote><ul><li>每个人初始为1</li><li>先从左到右扫描一遍，使得右边比左边得分高的小朋友糖果数比左边多。</li><li>再从右到左扫描一遍，使得左边比右边得分高的小朋友糖果数比右边多。</li></ul><h2 id="Product-of-Array-Except-Self"><a href="#Product-of-Array-Except-Self" class="headerlink" title="Product of Array Except Self"></a>Product of Array Except Self</h2><blockquote><p>除本身之外的数组之积 O(n) 不能用除法</p></blockquote><ul><li>两次遍历</li><li>对result[i]来说，先保存从左到右计算0 ~ i-1的乘积x</li><li>再从右到左计算i+1 ~ n的乘积y,计算x与y的乘积即可</li></ul><h2 id="Meeting-Rooms-II"><a href="#Meeting-Rooms-II" class="headerlink" title="Meeting Rooms II"></a>Meeting Rooms II</h2><p>因为要知道之前有overlap的最小的end，所以可以用一个<strong>min heap</strong>。每次检查<strong>新的start是否比heap的top元素小，是的话就把保存原来的end，同时放进新的end；否则就放新的end同时poll出原来的</strong>，因为没有overlap且新的end较大。最后heap的大小就是需要的房间数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(Interval[] intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(intervals==<span class="keyword">null</span>||intervals.length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;Interval&gt;()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Interval i1, Interval i2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i1.start-i2.start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Arrays.sort可替换成：</span></span><br><span class="line">    <span class="comment">//Arrays.sort(intervals, (a, b) -&gt; a.start == b.start ? a.end - b.end : a.start - b.start);</span></span><br><span class="line"> </span><br><span class="line">    PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">    queue.offer(intervals[<span class="number">0</span>].end);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;intervals.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals[i].start &gt;= queue.peek())&#123;</span><br><span class="line">            queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        queue.offer(intervals[i].end);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> queue.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Task-Scheduler"><a href="#Task-Scheduler" class="headerlink" title="Task Scheduler"></a>Task Scheduler</h2><blockquote><p>安排CPU的任务，规定在两个相同任务之间至少隔n个时间点</p></blockquote><p>Input: tasks = [‘A’,’A’,’A’,’B’,’B’,’B’], n = 2</p><p>Output: 8</p><p>Explanation: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B.</p><p>我们首先考虑出现<strong>频率最高</strong>的task，我们仍假设为A，出现的频率为x，我们知道，要满足A的时间需求，我们至少应该有 x-1个n的间隔。对于频率小于x的任务，假设为B，我们按序插入任务B，可以发现，这样的插入也是满足要求的。</p><p>AB-AB-AB<br><strong>模块的次数为任务最大次数减1，模块的长度为n+1，最后加上的字母个数为出现次数最多的任务，可能有多个并列。</strong></p><p>如例题中模块AB-的次数为2，长度为3，结果即为2*3+2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> t : tasks)&#123;  </span><br><span class="line">            c[t - <span class="string">'A'</span>]++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        Arrays.sort(c);  </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">25</span>;  </span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; c[i] == c[<span class="number">25</span>]) i--;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> Math.max(tasks.length, (c[<span class="number">25</span>] - <span class="number">1</span>) * (n + <span class="number">1</span>) + <span class="number">25</span> - i);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;贪心的奥义就是每一步都选择&lt;strong&gt;当前&lt;/strong&gt;回合”可见范围“（即可得知的信息）内的&lt;strong&gt;最优&lt;/strong&gt;，而在每一步都仅选择当前回合”可见范围“内的最优这一策略下能够导致&lt;strong&gt;全局最优&lt;/strong&gt;的结果的情况使用贪心就会是正确的，否则不适用贪心（或不适用当前对贪心中的最优的定义）。&lt;/p&gt;
&lt;p&gt;因此，贪心一个点是选择&lt;strong&gt;当前最优&lt;/strong&gt;，另一个点是这个最优要怎么定义，比如是选使得A最小的还是选使得A-B或A/B最小的等等。&lt;/p&gt;
&lt;p&gt;贪心的正确性其实都要通过&lt;strong&gt;归纳法或反证法&lt;/strong&gt;等手段进行严格地证明，而这也是算法分析课程的一个重要讲授内容。&lt;/p&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode Category" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/LeetCode-Category/"/>
    
    
      <category term="Array" scheme="blog.jiangdongyu.space/tags/Array/"/>
    
      <category term="DynamicProgramming" scheme="blog.jiangdongyu.space/tags/DynamicProgramming/"/>
    
      <category term="Greedy" scheme="blog.jiangdongyu.space/tags/Greedy/"/>
    
      <category term="Sort" scheme="blog.jiangdongyu.space/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>腾讯云</title>
    <link href="blog.jiangdongyu.space/2018/04/10/%E8%85%BE%E8%AE%AF%E4%BA%91/"/>
    <id>blog.jiangdongyu.space/2018/04/10/腾讯云/</id>
    <published>2018-04-10T03:26:00.000Z</published>
    <updated>2018-05-28T10:55:17.542Z</updated>
    
    <content type="html"><![CDATA[<p>腾讯云后台开发实习生暑期实习面试<br><a id="more"></a></p><ul><li>介绍项目</li><li>多线程的实现方式，线程的状态<ul><li>new Thread / implements Runnable</li></ul></li><li>gc,什么时候gc，内存溢出<ul><li><a href="http://blog.jiangdongyu.space/2018/03/18/Java%20JVM/">Java GC</a></li></ul></li><li>Linux指令，怎么查看内存线程使用情况</li><li>Mysql索引，group by &amp; union</li><li>TCP的…四次挥手，为什么等待2MSL?</li><li>用过哪些大数据框架</li><li>怎么判断一棵二叉树是镜像的？<ul><li>层次遍历，每次取左子树左右结点，右子树右左结点，判断是否相同</li></ul></li><li><p>栈实现O(1)获得最小的数getMin()</p><ul><li>非常棒的一道题。原理很简单，但是需要思考清楚为什么可以。原理可以参考下图：<br><img src="http://p9fh1pach.bkt.clouddn.com/%E6%A0%88%E6%9C%80%E5%B0%8F.png" alt="avatar"></li><li>准备两个栈，一个正常栈，一个辅助栈，正常栈做pop和push。辅助栈push更新最小值，pop出正常栈的最小值。</li><li>过程很简单，当正常栈push的时候，查看辅助栈的栈顶元素，如果是比辅助栈栈顶还小或者等于，那么更新到栈顶。否则不加如辅助栈。<ul><li>当正常栈做pop，查看辅助栈栈顶是否相等，相等的话一起pop，否则不动。</li></ul></li><li><p>PS：注意当做push的时候，辅助栈栈顶元素和新元素相等，还是要入栈，因为再做pop把元素出栈后，正常栈其实后面还是有这个元素。</p></li><li><p>原理：其实就是类似动态规划的原理，辅助栈里的元素，全是到正常栈该元素位置的最小值是谁。所以除非正常栈做出栈弹出到这个值，否则辅助栈的栈顶就是当前的最小值。</p></li></ul></li><li>1000瓶水，1瓶有毒，一只小白鼠喝了有毒的一周死亡，现给10只小白鼠一周时间，怎么做？<ul><li>二进制 标记</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;腾讯云后台开发实习生暑期实习面试&lt;br&gt;
    
    </summary>
    
      <category term="实习面试经历" scheme="blog.jiangdongyu.space/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    
      <category term="2018" scheme="blog.jiangdongyu.space/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>今日头条</title>
    <link href="blog.jiangdongyu.space/2018/04/09/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1/"/>
    <id>blog.jiangdongyu.space/2018/04/09/今日头条/</id>
    <published>2018-04-09T03:26:00.000Z</published>
    <updated>2018-05-28T10:50:42.629Z</updated>
    
    <content type="html"><![CDATA[<p>今日头条后台开发面试<br><a id="more"></a></p><ul><li>自我介绍</li><li>给定一个结点，确定二叉树中序遍历的后继结点（结点有左指针，右指针，父亲指针）<ul><li>判断是否有右子树，有就找右子树最左的结点</li><li>没有，则不断找父亲结点，直到当前结点是父亲结点的左孩子</li></ul></li><li>介绍项目</li><li>hashmap的equals和hashcode方法，怎么判断key存在（底层）<ul><li>首先<strong>hash(key)得到key的hashcode()</strong>，hashmap根据获得的hashcode找到要插入的位置所在的链，在这个链里面放的都是hashcode相同的Entry键值对，在找到这个链之后，会通过<strong>equals()</strong>方法判断是否已经存在要插入的键值对，而这个equals比较的其实就是key。</li><li>判断key是否存在的时候是先比较key的hashCode，再比较相等或equals的</li></ul></li><li>Http的keep-alive长连接的特性，多个json怎么区分（content-length）</li><li>数据库事务的一致性<ul><li>事务执行前与执行后数据内在的逻辑始终是成立的。比如转账前与转账后两人存款的总和始终不变。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今日头条后台开发面试&lt;br&gt;
    
    </summary>
    
      <category term="实习面试经历" scheme="blog.jiangdongyu.space/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    
      <category term="2018" scheme="blog.jiangdongyu.space/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
  </entry>
  
</feed>
