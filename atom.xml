<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>M&amp;Y</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="blog.jiangdongyu.space/"/>
  <updated>2018-07-30T11:44:24.838Z</updated>
  <id>blog.jiangdongyu.space/</id>
  
  <author>
    <name>Agnes</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java多线程基础</title>
    <link href="blog.jiangdongyu.space/2018/07/30/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>blog.jiangdongyu.space/2018/07/30/Java多线程基础/</id>
    <published>2018-07-30T10:53:00.000Z</published>
    <updated>2018-07-30T11:44:24.838Z</updated>
    
    <content type="html"><![CDATA[<p>在一个程序中，能够独立运行的程序片段叫做“线程”，利用它进行编写的程序叫做多线程处理程序。通常情况下，多线程程序能够更好低利用计算机资源，提高程序执行的效率。多线程编程具有重要的意义，每个程序猿都应该掌握。</p><a id="more"></a><p><a href="http://www.cnblogs.com/hanganglin/articles/3517178.html" target="_blank" rel="noopener">本文原文链接</a></p><h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><ul><li>新建状态：用Thread的new语句创建了线程对象，此时对象只在堆内存中分配了内存。</li><li>就绪状态：当新建状态下的线程对象调用了start()方法后，该线程就进入了就绪状态，处于这个状态的线程位于可运行池中，等待获得CPU使用权。</li><li>运行状态：正在被CPU执行的线程状态。</li><li>阻塞状态：当线程因为某种原因处于阻塞状态时，JVM不会给线程分配CPU，直到线程重新进入就绪状态，才有机会被CPU运行。<ul><li>位于对象<strong>等待池</strong>中的阻塞状态：当线程运行获取对象锁后，执行了Object.wait()方法，JVM就会把该线程加入对象的等待池中，这种状态必须等待其他线程调用同个对象的notify()或notifyAll()方法时才有可能激活为就绪状态；</li><li>位于<strong>对象锁</strong>中的阻塞状态：当线程运行时，试图获取某个对象的同步锁时，如果该对象的同步锁已被其他线程占用，则JVM就会把当前线程放入对象的锁池中，当对象的同步锁被释放后，JVM就会根据一定的调度算法，将处于对象锁中阻塞状态的某个线程激活为就绪状态；</li><li>其他阻塞状态：当线程执行了sleep()方法，或者调用了其他线程的join()方法，或发出了I/O请求时，线程就会进入这个状态。</li></ul></li></ul><h2 id="Java创建多线程的几种方式"><a href="#Java创建多线程的几种方式" class="headerlink" title="Java创建多线程的几种方式"></a>Java创建多线程的几种方式</h2><p>Java通过线程类Thread来创建多线程，每个线程是Thread类或其子类的实例对象，每个对象描述了一个单独的线程。Java中创建一个线程，有两种实现方法，详细介绍如下。</p><h3 id="通过继承Thread类创建线程（了解即可，不常用）"><a href="#通过继承Thread类创建线程（了解即可，不常用）" class="headerlink" title="通过继承Thread类创建线程（了解即可，不常用）"></a>通过继承Thread类创建线程（了解即可，不常用）</h3><ul><li>通过这种方式创建的线程之间是彼此相互独立的，各自有用自己的资源，互不干扰。</li><li><strong>缺点</strong>：<ul><li>Java是单继承的，继承Thead类后不能继承其他类，可能不满足开发需求；</li><li>多线程之间无法共享资源。</li></ul></li></ul><h3 id="通过实现Runnable接口创建线程（推荐使用）"><a href="#通过实现Runnable接口创建线程（推荐使用）" class="headerlink" title="通过实现Runnable接口创建线程（推荐使用）"></a>通过实现Runnable接口创建线程（推荐使用）</h3><p>通过继承Thread类创建的多线程可以满足非协同工作的多线程需求，但当要求各个线程之间需要处理共享资源时，只能通过实现Runnable接口的方式。</p><p><strong>优点</strong>：</p><ul><li>避免了Java但继承带来的局限性；</li><li>多线程之间可以共享资源，相互协作。</li></ul><h3 id="通过FutureTask类创建带返回值的线程（需要获得线程返回值时使用）"><a href="#通过FutureTask类创建带返回值的线程（需要获得线程返回值时使用）" class="headerlink" title="通过FutureTask类创建带返回值的线程（需要获得线程返回值时使用）"></a>通过FutureTask类创建带返回值的线程（需要获得线程返回值时使用）</h3><p>FutureTask是一种可以取消的异步的计算任务。它的计算是通过Callable实现的，它等价于<strong>可以携带返回值的Runnable</strong>。</p><p>FutureTask是为了弥补Thread的不足而设计的，它可以让程序员准确地知道线程什么时候执行完成并获得到线程执行完成后返回的结果（如果有需要）。</p><p><strong>FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果</strong></p><h3 id="通过TimerTask类创建计划任务类线程"><a href="#通过TimerTask类创建计划任务类线程" class="headerlink" title="通过TimerTask类创建计划任务类线程"></a>通过TimerTask类创建计划任务类线程</h3><p>Timer和TimerTask是用来创建定时任务，定时任务实质就是一个线程。TimerTask继承了Runnable接口，通过Timer启动计划任务入口有schedule和scheduleAtFixedRate两种方法。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>Java语言的关键字，用它来修饰一个方法或一个代码块的时候，能够保证在同一个时刻最多只有一个线程执行该段代码，可保证修饰的代码在执行过程中不会被其他线程干扰，即<strong>原子性</strong>。</p><h3 id="synchronized可修饰的对象"><a href="#synchronized可修饰的对象" class="headerlink" title="synchronized可修饰的对象"></a>synchronized可修饰的对象</h3><ul><li>synchronized {普通方法}<ul><li>同一时间只能有一个线程访问<strong>同一个对象</strong>的该方法。</li><li>缺点：同步整个方法<strong>效率不高</strong>。 </li><li>synchronized void method() { … }相当于void method( synchronized(this) { … } )</li></ul></li><li>synchronized {代码块}<ul><li>对代码块执行线程同步，效率要高于对整个函数执行同步，<strong>推荐</strong>使用这种方法。</li></ul></li><li>synchronized {static方法}<ul><li>加锁的对象是<strong>类</strong>，同一时间，该类的所有对象中的synchronized static方法只能有一个线程访问。 </li><li>class Foo { public synchronized static fun(){…}}等价于在class Foo { public static fun(){ synchronized(Foo.class){ … } }}</li></ul></li><li>synchronized {run方法}：此时为同步普通方法的特殊情况，由于在线程的整个生命期内run方法一直在运行，因此<strong>同一个Runnable对象的多个线程只能串行运行</strong>。 </li></ul><h3 id="使用synchronized应重点理解以下细节："><a href="#使用synchronized应重点理解以下细节：" class="headerlink" title="使用synchronized应重点理解以下细节："></a>使用synchronized应重点理解以下细节：</h3><ul><li>当多个并发线程访问同一个对象的同步代码块时，一段时间内只能有一个线程得到执行，其他线程必须等待当前线程执行完代码块后再执行代码；</li><li>当一个线程访问一个对象的同步代码块时，其他线程可以访问该对象的中的非同步代码块；</li><li><strong>当一个线程访问一个对象的同步代码块时，其他线程对该对象中的所有同步代码块均不能访问</strong></li></ul><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal主要用来更方便地访问线程内部变量，提供了保持对象的方法和避免参数传递的方便的对象访问方式。查阅了网上很多资料，大都观点说ThreadLocal是用来解决多线程共享对象的访问问题的，对此，本人完全不赞同，这压根就是两码事。当线程调用ThreadLocal.set()方法时，具体的值是保存在线程内部的ThreadLocal.ThreadLocalMap对象中，也就是说，每个线程设值的变量都只限于本线程访问，对于其他线程是隔离的，这与线程同步完全是两码事。</p><p>假设三个打印机进程共享一台打印机资源，通常我们使用同步方法（如synchronized、Lock等）来对打印机进行同步操作，这是为了解决多线程下的安全问题。使用ThreadLocal，相当于增加了两台打印机资源，给每个打印进程分配了一台打印机。</p><p>因此，<strong>ThreadLocal不是用来解决对象共享访问问题的，也不是为线程提供共享变量的副本，而仅仅是为线程隔离对象</strong>。</p><p>此外，线程的数据是保存在线程内部的变量中的，而非保存在ThreadLocal对象中，ThreadLocal的get与set方法可以直接操作线程Thread内部ThreadLocal.ThreadLocalMap对象。在ThreadLocal.ThreadLocalMap中保存了一个Entry数组，通过ThreadLocal对象作为数组下标操作数据。</p><p>在ThreadLocal.ThreadLocalMap中，使用了弱引用WeakReference，避免了内存泄露。</p><p>多线程共享一个数据库连接等适用，为每个线程单独建立一个连接资源。</p><h2 id="线程其他常用操作方法"><a href="#线程其他常用操作方法" class="headerlink" title="线程其他常用操作方法"></a>线程其他常用操作方法</h2><p>1、Object.wait()、Object.notify()和Object.notifyAll()</p><p>Object.wait是指线程在获取对象锁后，由于某些条件的不成立，主动<strong>释放对象锁</strong>，同时本线程进入对象等待池中处于阻塞状态。在synchronized同步块中，一旦线程捕获某个对象的同步锁，系统就很难控制线程，必须等待线程主动释放对象锁，这时候，在同步块内，使用Object.wait()可以使线程在进入synchronized同步块后主动释放对象锁。因此Object.wait()、Object.notify()和Object.notifyAll()方法<strong>必须在synchronized同步块内使用</strong>，否则会抛出IllegalMonitorStateException异常。</p><ul><li>Object.wait() ：线程调用此方法后，只有当其他线程调用同个对象的notify()或notifyAll()方法后，才可能激活为就绪状态；</li><li>Object.wait(long timeout) ：线程调用此方法后，当其他线程调用同个对象的notify()或notifyAll()方法，<strong>或者超过时间timeout</strong>，线程都可能激活为就绪状态。</li></ul><p>当其他线程调用Object.notify()后，JVM会根据调度策略调取一个对象等待池中的线程，将其从阻塞状态激活为就绪状态，当此线程<strong>再次获得对象锁和CPU后</strong>，就可以进入执行状态。</p><p>方法Object.notify()和方法Object.notifyAll()用于将处于wait等待状态的线程激活为就绪状态，notify()是根据调度策略激活某一个线程，notifyAll()是将所有处于等待线程池中的线程全部激活为就绪状态，但是激活后就绪状态的线程要想重新执行，必须再次获得对象锁。 </p><p>2、Thread.sleep(long millis)和Thread.yield()</p><p>这两个方法都会让当前正在执行的线程处于<strong>暂时停止执行</strong>的状态，交出CPU的使用权一段时间。与Object.wait()方法不同的是，Thread.sleep(long millis)和Thread.yield()在暂停线程的同时<strong>不会释放已获得的对象锁</strong>，而Object.wait()会暂停线程并且释放对象锁。</p><p>两者的<strong>区别</strong>如下：</p><ul><li>Thread.sleep方法必须带一个时间参数，单位毫秒，当线程执行sleep后，在指定时间内，将转为<strong>阻塞</strong>状态；Thread.yield方法不带参数，当线程执行yield后，线程将进入<strong>就绪</strong>状态。</li><li>Thread.sleep会抛出InterruptedException异常，而Thread.yield方法不会抛出异常。</li><li>sleep()方法比yield()方法具有更好的移植性。</li><li>sleep()方法会给其他线程运行的机会，而不考虑其他线程的优先级，因此会给较低线程一个运行的机会；yield()方法只会给相同优先级或者更高优先级的线程一个运行的机会。</li></ul><p>实际上，yield()方法对应了如下操作： </p><p>先检测当前是否有<strong>相同优先级</strong>的线程处于同可运行状态，如有，则把 CPU 的占有权交给此线程，否则继续运行原来的线程。所以yield()方法称为“<strong>退让</strong>”，它把运行机会让给了同等优先级的其他线程。yield()只是提前结束当前线程占用CPU的时间，线程转为就绪状态，等待下一个时间片再继续获得CPU并执行。</p><p>3、Thread.join()</p><p>Thread.join()可以将多线程的异步变为同步，在父线程调用子线程的join方法后，必须等待子线程执行结束，父线程才会继续执行下去。Thread.join()方法会抛出InterruptedException异常。</p><p>4、volatile关键字</p><p>volatile是synchronized的一种弱实现，它可以保证变量的<strong>可见性</strong>，而不能保证程序执行的原子性。JVM运行多线程时，在主内存中保存着共享变量，每个线程运行时有一个自己的栈，用来保存从本线程运行需要的变量。当线程访问一个变量值的时候，首先通过对象的引用找到在主内存的地址，然后把变量的值拷贝到本线程的栈中，建立一个变量的副本。在线程对该变量计算的过程中，该变量副本和主内存的原始变量就没有任何关系了，当线程结算结束时，再将变量副本写回到主内存中对象变量的地址中，更新内存中的共享变量，详细的交互过程如下图所示。</p><p><img src="http://p9fh1pach.bkt.clouddn.com/191326344702.jpg" alt="avatar"></p><p>使用volatile修饰的变量，JVM只能保证从主内存加载到线程工作栈中的值是最新的，但使用过程不能完全保证线程对该变量同步的情况，因此，建议少使用volatile，对需要同步的地方使用synchronized。</p><p>5、Thread.start()和Thread.run() </p><p><strong>启动线程应该使用Thread.start()，Thread.run()只是调用Runnable中的run方法，并没有启动线程，此时整个程序还是只有一个线程，顺序执行。</strong></p><p>6、Thread.setDaemon()设置守护线程</p><p>Java中有两类线程，分别是用户线程(User Thread)和守护线程(Daemon Thread)。守护线程是指在程序运行时后台提供一种通用服务的线程，如垃圾回收线程就是一个守护线程，当所有的非守护线程结束时，程序也就终止了，同时会结束所有的守护进程。用户线程和守护线程唯一的区别就是，当程序中只剩守护线程时，程序就会结束，而只要程序中还存在一个非守护线程，程序就不会终止。</p><ul><li>普通线程转换为守护线程。Thread.SetDaemon(true)可以将普通线程转换为守护线程，但是设置必须在Thread.start()之前，否则会报IllegalThreadStateException异常。</li><li>Daemon线程产生的子线程也是Daemon的。</li><li>守护线程应该永远不去访问固有资源，如文件和数据库等，因为他可能随时会中断。</li></ul><p>7、<a href="http://jiangzhengjun.iteye.com/blog/652269" target="_blank" rel="noopener">Thread.interrput()中断线程</a></p><p>调用线程的Thread.interrupt方法中断线程时，JVM将会将对应线程内的中断状态位设置为true，可以在线程执行的方法中调用Thread.interrupted()或Thread.currentThread().isInterrupted()来检测中断位是否为true，至于线程下一步是死亡还是继续执行完全取决于程序本身，这一点与强制结束线程的已废弃的方法stop不同。</p><p>当其他线程通过Thread.interrupt请求中断当前线程时，当前线程可能正处于非阻塞状态、阻塞状态或请求锁临时状态，下面来分析各种状态下如何来中断当前线程。</p><ul><li>被请求中断时，当前线程处于非阻塞状态。<ul><li>此时可以在程序中调用方法获取线程内中断状态位的值，并根据该值自由决定是否结束当前线程。获取中断位值建议有两种方法:</li><li>Thread.currentThread().isInterrupted()方法，返回状态值</li><li>Thread.interrupted()静态方法，返回状态值，<strong>并将中断位状态值重置为false</strong>。也就是说，此时若调用两次Thread.interrupted()方法，第二次方法返回值为false。因此<strong>建议使用方法Thread.currentThread().isInterrupted()来获取中断位状态值</strong>，常见线程循环时的中断方式如下所示：</li><li>另一种实现方式-使用中断信号量(共享变量)中断非阻塞状态线程也是一种很受欢迎的方式，其实笔者认为，这种方式与使用Thread.interrupt来实现中断的内部机理是一样的。</li></ul></li></ul><pre><code>while(!Thread.currentThread().isInterrupted() &amp;&amp; more work to do){      do more work  } </code></pre><ul><li>被请求中断时，当前线程处于阻塞状态。 <ul><li>对于由于调用Object.wait()、Thread.sleep()或Thread.join()等方式而处于阻塞状态的线程，被请求中断时会<strong>抛出异常InterruptException</strong>，使当前线程从阻塞状态激活进入异常代码块，便于结束。注意，在抛出异常InterruptException后，中断状态位会被重置为false，因此<strong>在使用Thread.currentThread().isInterrupted()检测循环是否中断的代码块内，若捕捉到此异常，必须将状态位重新设置为true，否则线程循环将永不停止。</strong><ul><li>对由于请求I/O操作而处于阻塞状态的线程，被请求中断时，I/O通道会立即被关闭，并抛出异常ClosedByInterruptException，处理方式与上述一致。</li><li>被请求中断时，当前线程正处于获取锁的过程中，这时候线程是无法响应中断的，也就是说，<strong>当线程采用synchronized争夺锁资源而发生死锁时，使用Thread.interrupt是无法使线程中断的。补充一点，当使用Lock锁并且通过方法lockInterruptibly()设置响应中断锁时，线程可以被中断</strong>。</li></ul></li></ul></li></ul><p>8、TimeUnit枚举工具</p><p>TimeUnit是一个枚举，可以使用它来简化某些操作，如让线程休眠5分钟，可以写成：TimeUnit.MINUTES.sleep(5)，相当于Thread.sleep(5*60*1000)，时间会在TimeUnit内部自动转化。</p><p>9、Condition.await()、Condition.signal()和Condition.signalAll()</p><p>同Object.wait()、Object.notify()和Object.notifyAll()对应功能一致，Object的方法用于synchronized同步块中，而Condition的方法用于ReentrantLock的lock()与unlock()之间。</p><p>可用Reentrant.newCondition()来产生一个新的Condition。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一个程序中，能够独立运行的程序片段叫做“线程”，利用它进行编写的程序叫做多线程处理程序。通常情况下，多线程程序能够更好低利用计算机资源，提高程序执行的效率。多线程编程具有重要的意义，每个程序猿都应该掌握。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="blog.jiangdongyu.space/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>揭秘Spring AOP</title>
    <link href="blog.jiangdongyu.space/2018/07/26/%E6%8F%AD%E7%A7%98Spring%20AOP/"/>
    <id>blog.jiangdongyu.space/2018/07/26/揭秘Spring AOP/</id>
    <published>2018-07-26T11:33:00.000Z</published>
    <updated>2018-07-30T08:48:02.143Z</updated>
    
    <content type="html"><![CDATA[<p>AOP要解决的问题：分离功能性需求和非功能性需求</p><p><strong>使用场景</strong></p><ul><li>权限控制</li><li>缓存控制</li><li>事务控制</li><li>审计日志</li><li>性能监控</li></ul><h3 id="切面表达式"><a href="#切面表达式" class="headerlink" title="切面表达式"></a>切面表达式</h3><ul><li>designators指示器，描述通过什么方式去匹配类的哪些方法</li><li>Wildcards通配符</li><li>operators运算符</li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/aop1.png" alt="avatar"></p><p><img src="http://p9fh1pach.bkt.clouddn.com/aop2.png" alt="avatar"></p><ul><li>within表达式</li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/aop3.png" alt="avatar"></p><p><img src="http://p9fh1pach.bkt.clouddn.com/aop4.png" alt="avatar"></p><p><img src="http://p9fh1pach.bkt.clouddn.com/aop5.png" alt="avatar"></p><p><img src="http://p9fh1pach.bkt.clouddn.com/aop6.png" alt="avatar"></p><ul><li>execution表达式</li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/aop7.png" alt="avatar"></p><p>?表示可以省略</p><ul><li>advice注解<br><img src="http://p9fh1pach.bkt.clouddn.com/aop8.png" alt="avatar"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AOP要解决的问题：分离功能性需求和非功能性需求&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用场景&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;权限控制&lt;/li&gt;
&lt;li&gt;缓存控制&lt;/li&gt;
&lt;li&gt;事务控制&lt;/li&gt;
&lt;li&gt;审计日志&lt;/li&gt;
&lt;li&gt;性能监控&lt;/li&gt;
&lt;/ul
      
    
    </summary>
    
      <category term="JavaWeb" scheme="blog.jiangdongyu.space/categories/JavaWeb/"/>
    
      <category term="Spring" scheme="blog.jiangdongyu.space/categories/JavaWeb/Spring/"/>
    
      <category term="AOP" scheme="blog.jiangdongyu.space/categories/JavaWeb/Spring/AOP/"/>
    
    
      <category term="Spring" scheme="blog.jiangdongyu.space/tags/Spring/"/>
    
      <category term="AOP" scheme="blog.jiangdongyu.space/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="blog.jiangdongyu.space/2018/07/26/Redis/"/>
    <id>blog.jiangdongyu.space/2018/07/26/Redis/</id>
    <published>2018-07-26T07:39:00.000Z</published>
    <updated>2018-07-26T10:20:30.162Z</updated>
    
    <content type="html"><![CDATA[<h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><p>为什么需要NoSQL？</p><ul><li>高并发读写</li><li>海量数据的高效率存储与访问</li><li>高可扩展性和高可用性</li></ul><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul><li>应用场景<ul><li>缓存</li><li>任务队列</li><li>应用排行榜</li><li>网站访问统计</li><li>数据过期处理</li><li>分布式集群架构中的session分离</li></ul></li><li>数据类型<ul><li>String</li><li>List：rpoplpush</li><li>Set</li><li>Hash</li><li>Sorted Set </li></ul></li><li>持久化<ul><li>RDB：定时内存快照，在指定的时间间隔写入硬盘</li><li>AOF：将以日志，记录每一个操作，服务器启动后就构建数据库，修改同步</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;NoSQL&quot;&gt;&lt;a href=&quot;#NoSQL&quot; class=&quot;headerlink&quot; title=&quot;NoSQL&quot;&gt;&lt;/a&gt;NoSQL&lt;/h3&gt;&lt;p&gt;为什么需要NoSQL？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高并发读写&lt;/li&gt;
&lt;li&gt;海量数据的高效率存储与访问&lt;/li&gt;
      
    
    </summary>
    
      <category term="数据库基础" scheme="blog.jiangdongyu.space/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Redis" scheme="blog.jiangdongyu.space/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Redis/"/>
    
    
      <category term="Redis" scheme="blog.jiangdongyu.space/tags/Redis/"/>
    
      <category term="NoSQL" scheme="blog.jiangdongyu.space/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>菜鸟二面</title>
    <link href="blog.jiangdongyu.space/2018/07/24/%E8%8F%9C%E9%B8%9F%E4%BA%8C%E9%9D%A2/"/>
    <id>blog.jiangdongyu.space/2018/07/24/菜鸟二面/</id>
    <published>2018-07-24T13:41:00.000Z</published>
    <updated>2018-07-25T11:53:50.427Z</updated>
    
    <content type="html"><![CDATA[<p>还是聊了半个小时- -</p><a id="more"></a><ul><li>介绍学习、实习、项目情况</li><li>介绍影响最深、提升能力最快的项目</li><li>问一些相对比较难的题</li><li>SpringBoot和Spring的区别<ul><li>SpringBoot是在Spring上的快速开发包</li><li>SpringBoot内嵌了一些容器，比如tomcat</li><li>问内嵌的tomcat和不内嵌的有什么区别？内嵌的无需部署war文件</li></ul></li><li>MyBatis和Hibernate有什么区别？<ul><li>MyBatis半自动，Hibernate全自动</li><li>Hibernate为什么能实现全自动？</li><li>通过对象关系模型来实现对数据库的操作，并且拥有完整的JavaBean对象来自动拼装SQL语句。</li></ul></li><li>问觉得阿里和微软的区别</li><li>给了些建议- -</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;还是聊了半个小时- -&lt;/p&gt;
    
    </summary>
    
      <category term="面试经历" scheme="blog.jiangdongyu.space/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    
      <category term="2018" scheme="blog.jiangdongyu.space/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018/"/>
    
      <category term="秋招" scheme="blog.jiangdongyu.space/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018/%E7%A7%8B%E6%8B%9B/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>79. Word Search</title>
    <link href="blog.jiangdongyu.space/2018/07/24/79.%20Word%20Search/"/>
    <id>blog.jiangdongyu.space/2018/07/24/79. Word Search/</id>
    <published>2018-07-24T10:00:00.000Z</published>
    <updated>2018-07-24T10:12:00.908Z</updated>
    
    <content type="html"><![CDATA[<p>Given a 2D board and a word, find if the word exists in the grid.</p><p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><a id="more"></a><p><strong>Example:</strong></p><pre><code>board =[  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]Given word = &quot;ABCCED&quot;, return true.Given word = &quot;SEE&quot;, return true.Given word = &quot;ABCB&quot;, return false.</code></pre><p><strong>思路：</strong><br>还算是比较明显的dfs的题。</p><ul><li>首先需要找到word首字母的位置，才能接着判断</li><li>接下来就是递归的过程，上下左右都有可能</li><li>同时为了避免当前再被递归到，需要将当前值先修改再恢复</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word == <span class="keyword">null</span> || word.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="keyword">null</span> || board.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; board.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; board[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == word.charAt(<span class="number">0</span>) &amp;&amp; exists(board, word, i, j, <span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(<span class="keyword">char</span>[][] board, String word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word.length() == start) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; board.length &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; board[<span class="number">0</span>].length &amp;&amp; board[i][j] == word.charAt(start))&#123;</span><br><span class="line">            board[i][j] = <span class="string">'$'</span>;</span><br><span class="line">            <span class="keyword">boolean</span> res = exists(board, word, i-<span class="number">1</span>, j, start+<span class="number">1</span>) || exists(board, word, i+<span class="number">1</span>, j, start+<span class="number">1</span>) || exists(board, word, i, j-<span class="number">1</span>, start+<span class="number">1</span>) || exists(board, word, i, j+<span class="number">1</span>, start+<span class="number">1</span>);</span><br><span class="line">            board[i][j] = word.charAt(start);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a 2D board and a word, find if the word exists in the grid.&lt;/p&gt;
&lt;p&gt;The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.&lt;/p&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
      <category term="刷题打卡" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/"/>
    
    
      <category term="Array" scheme="blog.jiangdongyu.space/tags/Array/"/>
    
      <category term="BackTracking" scheme="blog.jiangdongyu.space/tags/BackTracking/"/>
    
  </entry>
  
  <entry>
    <title>第四范式</title>
    <link href="blog.jiangdongyu.space/2018/07/19/%E7%AC%AC%E5%9B%9B%E8%8C%83%E5%BC%8F/"/>
    <id>blog.jiangdongyu.space/2018/07/19/第四范式/</id>
    <published>2018-07-19T06:30:00.000Z</published>
    <updated>2018-07-20T12:10:50.513Z</updated>
    
    <content type="html"><![CDATA[<p>第四范式 Java 开发实习生 面试</p><a id="more"></a><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ul><li>自我介绍</li><li>介绍一下项目</li><li>Exception &amp;&amp; Error      </li><li>synchronized关键字static修饰和没有static修饰<ul><li>比如synchronized修饰方法，让循环输出1-10，new两个类，调用该线程</li><li>作用域不同，static修饰指同步类，输出两次1-10</li><li>非static修饰，是同步局部变量，不能确定结果</li></ul></li><li>final修饰字段，方法，类<ul><li>字段不可变</li><li>方法不可override</li><li>类不能被继承</li></ul></li><li>String,StringBuilder,StringBuffer <ul><li>String不可变，源码是用final修饰的private数组，同时方法等没改变数组的值</li><li>StringBuilder，StringBuffer都可变，StringBuffer线程安全</li></ul></li><li>ArrayList和LinkedList<ul><li>同：实现List接口</li><li>异：ArrayList查 O(1),增删 O(n)</li><li>LinkedList查 O(n),增删 O(1)</li></ul></li><li>知不知道Dequeue?</li><li>实现最小栈GetMin()<ul><li>leetcode原题155.Min Stack</li></ul></li></ul><p><strong>Q: Exception &amp;&amp; Error</strong></p><p><img src="http://p9fh1pach.bkt.clouddn.com/20160603151809323.jpeg" alt="avatar"></p><p>A: Error和Exception都继承自<strong>Throwable</strong>；</p><p><strong>Exception：</strong></p><blockquote><p>RuntimeException 类及其子类表示“JVM 常用操作”引发的错误</p></blockquote><ul><li>可以是可被控制（checked）或者不可控制（unchecked）；<ul><li>unchecked exception（非检查异常）: 运行时异常,比如常见的NullPointerException、IndexOutOfBoundsException。对于运行时异常，java编译器<strong>不要求</strong>必须进行异常捕获处理或者抛出声明，由程序员自行决定。</li><li>checked exception（检查异常，编译异常）: 非运行时异常,java编译器<strong>强制</strong>程序员必须进行捕获处理，比如常见的IOExeption和SQLException。对于非运行时异常如果不进行捕获或者抛出声明处理，编译都不会通过。</li></ul></li><li>表示一个由<strong>程序员</strong>导致的错误；</li><li>应该在应用程序级被处理；</li></ul><p><strong>Error：</strong></p><blockquote><p>大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。</p></blockquote><ul><li>总是不可控制的（unchecked）；</li><li>经常用来表示<strong>系统错误或者底层资源</strong>错误；</li><li>如果可能的话，应该在系统级被捕捉；</li></ul><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ul><li>自我介绍</li><li>项目介绍比较详细</li><li>问了下熟悉的技术</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第四范式 Java 开发实习生 面试&lt;/p&gt;
    
    </summary>
    
      <category term="面试经历" scheme="blog.jiangdongyu.space/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    
      <category term="2018" scheme="blog.jiangdongyu.space/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018/"/>
    
      <category term="实习" scheme="blog.jiangdongyu.space/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018/%E5%AE%9E%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS通信过程</title>
    <link href="blog.jiangdongyu.space/2018/07/19/HTTPS%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B/"/>
    <id>blog.jiangdongyu.space/2018/07/19/HTTPS通信过程/</id>
    <published>2018-07-19T05:04:00.000Z</published>
    <updated>2018-07-26T11:23:29.901Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取。所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。</p><a id="more"></a><h3 id="HTTPS简介"><a href="#HTTPS简介" class="headerlink" title="HTTPS简介"></a>HTTPS简介</h3><p>HTTPS其实是有两部分组成：<strong>HTTP + SSL / TLS</strong>，也就是在HTTP上又加了一层<strong>处理加密信息的模块</strong>。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。具体是如何进行加密，解密，验证的，且看下图。</p><p><img src="http://p9fh1pach.bkt.clouddn.com/20121130144420002.png" alt="avatar"></p><ul><li>客户端发起HTTPS请求<ul><li>这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。</li></ul></li><li>服务端的配置<ul><li>采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对<strong>公钥和私钥</strong>。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</li></ul></li><li>传送证书<ul><li>这个证书其实就是<strong>公钥</strong>，只是包含了很多信息，如证书的颁发机构，过期时间等等。</li></ul></li><li>客户端解析证书<ul><li>这部分工作是有客户端的TLS来完成的，首先会<strong>验证公钥是否有效</strong>，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就<strong>生成一个随机值</strong>。然后用*8证书对该随机值进行加密**。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</li></ul></li><li>传送加密信息<ul><li>这部分<strong>传送的是用证书加密后的随机值</strong>，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</li></ul></li><li>服务段解密信息<ul><li>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行<strong>对称加密</strong>。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</li></ul></li><li>传输加密后的信息<ul><li>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原</li></ul></li><li>客户端解密信息<ul><li>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取。所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="blog.jiangdongyu.space/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTPS" scheme="blog.jiangdongyu.space/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/"/>
    
    
      <category term="计算机网络" scheme="blog.jiangdongyu.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTPS" scheme="blog.jiangdongyu.space/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>菜鸟一面</title>
    <link href="blog.jiangdongyu.space/2018/07/19/%E8%8F%9C%E9%B8%9F%E4%B8%80%E9%9D%A2/"/>
    <id>blog.jiangdongyu.space/2018/07/19/菜鸟一面/</id>
    <published>2018-07-19T03:24:00.000Z</published>
    <updated>2018-07-25T11:42:14.729Z</updated>
    
    <content type="html"><![CDATA[<p>说了下午有事，就简单聊了半个小时</p><a id="more"></a><ul><li>为什么要用多线程</li><li>线程是不是越多效率越快？</li><li>怎么控制线程，尽可能减少上下文切换？或者说有没有一种方式达到了多线程的效果，但是避免了上下文切换？<ul><li>提示concurrent包里有</li></ul></li><li>讲一下Spring IOC，为什么要控制反转？目的是啥？IOC的过程？</li><li>两个int型的set求交集？</li><li>求交集的同时，还要给出相同的数字的个数？</li><li>如果set特别大，大到无法在内存处理，怎么办？</li><li>Linux的了解？</li><li>问微软的pipeline导入为什么能提高效率？</li><li>问了下职业规划</li></ul><p><strong>如何减少上下文切换？</strong></p><p>减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。</p><ul><li>无锁并发并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。</li><li>CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要加锁。<ul><li>CAS:Compare and Swap,是比较并交换的意思。</li><li>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</li></ul></li><li>使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。</li><li>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说了下午有事，就简单聊了半个小时&lt;/p&gt;
    
    </summary>
    
      <category term="面试经历" scheme="blog.jiangdongyu.space/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    
      <category term="2018" scheme="blog.jiangdongyu.space/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018/"/>
    
      <category term="秋招" scheme="blog.jiangdongyu.space/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018/%E7%A7%8B%E6%8B%9B/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Keep</title>
    <link href="blog.jiangdongyu.space/2018/07/17/Keep/"/>
    <id>blog.jiangdongyu.space/2018/07/17/Keep/</id>
    <published>2018-07-17T06:00:00.000Z</published>
    <updated>2018-07-20T12:10:58.976Z</updated>
    
    <content type="html"><![CDATA[<p>Keep Java 开发实习生 面试</p><a id="more"></a><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ul><li>自我介绍</li><li>问项目</li><li>int[]数组长度为n，问数组中连续m个数的最大值</li><li>链表反转</li><li>20w条ip地址的数据，给一个ip地址，怎么找到？</li><li>设计用户发微博的数据库，以及查看首页功能<ul><li>首页时间线表，但对于大V发微博，告知关注者的时间线处理有问题</li></ul></li><li>微博用户群组问题，怎么做到分群组？<ul><li>图的BFS</li></ul></li><li>对设计的微博的表，怎么建索引？建索引为什么会快？</li><li>http和https的区别？https的加密过程？</li></ul><p>Q：哪些情况需要加索引？</p><ul><li>在经常需要<strong>搜索的列</strong>上，可以加快搜索的速度；</li><li>在作为<strong>主键</strong>的列上，强制该列的唯一性和组织表中数据的排列结构；</li><li>在经常用在<strong>连接的列</strong>上，这些列主要是一些外键，可以加快连接的速度；</li><li>在经常需要<strong>根据范围进行搜索的列</strong>上创建索引，因为索引已经排序，其指定的范围是连续的；</li><li>在经常需要<strong>排序的列</strong>上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li><li>在经常使用在<strong>WHERE子句中的列</strong>上面创建索引，加快条件的判断速度。</li></ul><p>Q：哪些情况不需要加索引？</p><ul><li>第一，对于那些在查询中<strong>很少使用或者参考</strong>的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li><li>第二，对于那些只有<strong>很少数据值</strong>的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</li><li>第三，对于那些定义为<strong>text, image和bit</strong>数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 </li><li>第四，当<strong>修改性能远远大于检索性能时</strong>，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li></ul><p>Q：数据库建立索引为什么会加快查询速度？</p><p>首先明白为什么索引会增加速度，DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行<strong>全表扫描</strong>，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段<strong>增加索引</strong>，查询时就会<strong>先去索引列表中一次定位到特定值的行数</strong>，大大减少遍历匹配的行数，所以能明显增加查询的速度。</p><p><a href="http://blog.jiangdongyu.space/2018/07/19/HTTPS%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B/">HTTPS通信过程</a></p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ul><li>介绍项目</li><li>垃圾回收策略</li><li>HotSpot垃圾收集器，G1的特点，优缺点…<ul><li><a href="http://blog.jiangdongyu.space/2018/06/06/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/">垃圾收集器与内存分配策略</a></li></ul></li><li>为什么Eden: Survivor: Survivor是8:1:1 ?</li><li>IOC，IOC的初始化过程？</li><li>AOP，AOP的动态代理怎么做？ <ul><li>InvocationHandler接口</li></ul></li><li>concurrent包里有些啥？</li><li><strong>ThreadPoolExecutor类得看源码</strong></li><li>Java锁机制，Java怎么实现CAS的？多线程i++问题？AtomicInteger？UnSafe类？</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Keep Java 开发实习生 面试&lt;/p&gt;
    
    </summary>
    
      <category term="面试经历" scheme="blog.jiangdongyu.space/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    
      <category term="2018" scheme="blog.jiangdongyu.space/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018/"/>
    
      <category term="实习" scheme="blog.jiangdongyu.space/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018/%E5%AE%9E%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>对Spring IOC和AOP的理解</title>
    <link href="blog.jiangdongyu.space/2018/07/15/Spring%20IOC%20AOP/"/>
    <id>blog.jiangdongyu.space/2018/07/15/Spring IOC AOP/</id>
    <published>2018-07-15T14:45:00.000Z</published>
    <updated>2018-07-26T11:26:41.906Z</updated>
    
    <content type="html"><![CDATA[<p>在面试中，经常会问，说说你对Spring IOC和AOP的理解，问题很宽泛，似乎不知道从何说起。</p><p><strong>回答思路</strong>：</p><ul><li>先用通俗易懂的话解释下何为IOC和AOP</li><li>各自的实现原理</li><li>自己的项目中如何使用</li></ul><p>以下是个人的一些总结，仅供参考。</p><a id="more"></a><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>许多应用都是通过彼此间的相互合作来实现业务逻辑的，如类A要调用类B的方法，以前我们都是在类A中，通过自身new一个类B，然后在调用类B的方法，现在我们把new类B的事情交给Spring来做，在我们调用的时候，容器会为我们实例化。</p><ul><li>IOC容器的初始化过程<ul><li>资源定位，即定义bean的xml</li><li>载入</li><li>IOC容器注册，注册beanDefinition</li></ul></li></ul><p>IOC容器的初始化过程，一般不包含bean的依赖注入的实现，在Spring IOC设计中，bean的<strong>注册</strong>和<strong>依赖注入</strong>是两个过程，依赖注入一般发生在应用<strong>第一次索取bean</strong>的时候，但是也可以在xm中配置，在容器初始化的时候，这个bean就完成了初始化。</p><p>三种<strong>注入方式</strong>：</p><ul><li>构造器</li><li>接口</li><li>set注入(常用)</li></ul><p>bean是如何创建——<strong>工厂模式</strong></p><p>数据是如何注入——<strong>反射</strong></p><p><a href="http://blog.jiangdongyu.space/2018/07/13/Spring%20IOC%E5%8E%9F%E7%90%86/">IOC的定义及实现原理</a></p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>面向切面编程，在我们的应用中，经常需要做一些事情，但是这些事情<strong>与核心业务无关</strong>，比如，要记录所有update*方法的执行时间时间，操作人等等信息，记录到日志，</p><p>通过Spring的AOP技术，就可以在不修改update*的代码的情况下完成该需求。</p><p>AOP的好处就是你只需要干你的正事，其它事情别人帮你干。</p><p>从Spring的角度看，AOP最大的用途就在于提供了<strong>事务管理</strong>的能力。事务管理就是一个关注点，你的正事就是去访问数据库，而你不想管事务（太烦），所以，Spring在你访问数据库之前，自动帮你开启事务，当你访问数据库结束之后，自动帮你提交/回滚事务！</p><p><a href="http://blog.jiangdongyu.space/2018/07/13/%E7%90%86%E8%A7%A3AOP/">AOP的实现原理——代理</a></p><p><a href="http://blog.jiangdongyu.space/2018/07/15/AOP%E7%9A%84%E5%BA%94%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/">AOP的应用的三种实现方式</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在面试中，经常会问，说说你对Spring IOC和AOP的理解，问题很宽泛，似乎不知道从何说起。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回答思路&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先用通俗易懂的话解释下何为IOC和AOP&lt;/li&gt;
&lt;li&gt;各自的实现原理&lt;/li&gt;
&lt;li&gt;自己的项目中如何使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是个人的一些总结，仅供参考。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="blog.jiangdongyu.space/categories/JavaWeb/"/>
    
      <category term="Spring" scheme="blog.jiangdongyu.space/categories/JavaWeb/Spring/"/>
    
    
      <category term="Spring" scheme="blog.jiangdongyu.space/tags/Spring/"/>
    
      <category term="AOP" scheme="blog.jiangdongyu.space/tags/AOP/"/>
    
      <category term="IOC" scheme="blog.jiangdongyu.space/tags/IOC/"/>
    
  </entry>
  
  <entry>
    <title>AOP的应用的三种实现方式</title>
    <link href="blog.jiangdongyu.space/2018/07/15/AOP%E7%9A%84%E5%BA%94%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>blog.jiangdongyu.space/2018/07/15/AOP的应用的三种实现方式/</id>
    <published>2018-07-15T08:22:00.000Z</published>
    <updated>2018-07-26T11:42:28.765Z</updated>
    
    <content type="html"><![CDATA[<p>Spring有两大核心，IOC和AOP。IOC在java web项目中无时无刻不在使用。然而AOP用的比较少，的确也是一般的项目用的场所不多。<strong>事务控制</strong>基本都用，但却是Spring封装的不需要我们再去实现，但Spring的AOP远不止这些。</p><a id="more"></a><h2 id="概念术语"><a href="#概念术语" class="headerlink" title="概念术语　　"></a>概念术语　　</h2><p>在开始之前，需要理解Spring AOP的一些基本的概念术语(总结的个人理解，并非Spring官方定义)：</p><ul><li><strong>切面</strong>(aspect)：用来切插业务方法的类。</li><li><strong>连接点</strong>(joinpoint)：是切面类和业务类的连接点，其实就是封装了业务方法的一些基本属性，作为通知的参数来解析。</li><li><strong>通知</strong>(advice)：在切面类中，声明对业务方法做额外处理的方法。</li><li><strong>切入点</strong>(pointcut)：业务类中指定的方法，作为切面切入的点。其实就是指定某个方法作为切面切的地方。</li><li><strong>目标对象</strong>(target object)：被代理对象。</li><li><strong>AOP代理</strong>(aop proxy)：代理对象。</li><li><strong>AOP通知类型</strong>：<ul><li>前置通知(before advice)：在切入点之前执行。</li><li>后置通知(after returning advice)：在切入点执行完成后，执行通知。</li><li>环绕通知(around advice)：包围切入点，调用方法前后完成自定义行为。</li><li>异常通知(after throwing advice)：在切入点抛出异常后，执行通知。</li></ul></li></ul><h2 id="Spring-AOP环境"><a href="#Spring-AOP环境" class="headerlink" title="Spring AOP环境"></a>Spring AOP环境</h2><p>要在项目中使用Spring AOP则需要在项目中导入除了spring jar包之外，还有aspectjweaver.jar，aopalliance.jar，asm.jar和cglib.jar 。</p><p>好了，前提工作准备完成，Spring提供了很多的实现AOP的方式，在学习过程中，循序渐进。进行<strong>Spring接口方式</strong>，<strong>Schema配置方式</strong>和<strong>注解</strong>的三种方式进行学习。好了废话不多说了，开始Spring AOP学习之旅：</p><h3 id="AOP接口"><a href="#AOP接口" class="headerlink" title="AOP接口"></a>AOP接口</h3><p>利用Spring AOP接口实现AOP，主要是为了指定自定义通知来供Spring AOP机制识别。主要接口：前置通知 MethodBeforeAdvice，后置通知：AfterReturningAdvice，环绕通知：MethodInterceptor，异常通知：ThrowsAdvice 。见例子代码：</p><h4 id="业务接口："><a href="#业务接口：" class="headerlink" title="业务接口："></a>业务接口：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理类接口，也是业务类接口</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 利用接口的方式，spring aop 将默认通过jdk 动态代理来实现代理类</span></span><br><span class="line"><span class="comment"> * 不利用接口，则spring aop 将通过cglib 来实现代理类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBaseBusiness</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用作代理的切入点方法</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">(String obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这方法不被切面切</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(String obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这方法切不切呢？可以设置</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modify</span><span class="params">(String obj)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务类："><a href="#业务类：" class="headerlink" title="业务类："></a>业务类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务类，也是目标对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBusiness</span> <span class="keyword">implements</span> <span class="title">IBaseBusiness</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切入点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========调用切入点："</span> + obj + <span class="string">"说：你敢删除我！===========\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄～"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"================这个方法不能被切。。。============== \n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄～ 嘿嘿！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modify</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=================这个也设置加入切吧====================\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄改瞄啊！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通知类："><a href="#通知类：" class="headerlink" title="通知类："></a>通知类：</h4><ul><li>前置通知：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前置通知。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBeforeAdvice</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * method : 切入的方法</span></span><br><span class="line"><span class="comment">     * args ：切入方法的参数</span></span><br><span class="line"><span class="comment">     * target ：目标对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========进入beforeAdvice()============ \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"准备在"</span> + target + <span class="string">"对象上用"</span>);</span><br><span class="line">        System.out.print(method + <span class="string">"方法进行对 '"</span>);</span><br><span class="line">        System.out.print(args[<span class="number">0</span>] + <span class="string">"'进行删除！\n\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"要进入切入点方法了 \n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>后置通知：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后置通知</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAfterReturnAdvice</span> <span class="keyword">implements</span> <span class="title">AfterReturningAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * returnValue ：切入点执行完方法的返回值，但不能修改</span></span><br><span class="line"><span class="comment">     * method ：切入点方法</span></span><br><span class="line"><span class="comment">     * args ：切入点方法的参数数组</span></span><br><span class="line"><span class="comment">     * target ：目标对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========进入afterReturning()=========== \n"</span>);</span><br><span class="line">        System.out.println(<span class="string">"切入点方法执行完了 \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(args[<span class="number">0</span>] + <span class="string">"在"</span>);</span><br><span class="line">        System.out.print(target + <span class="string">"对象上被"</span>);</span><br><span class="line">        System.out.print(method + <span class="string">"方法删除了"</span>);</span><br><span class="line">        System.out.print(<span class="string">"只留下："</span> + returnValue + <span class="string">"\n\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>环绕通知：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 环绕通知</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAroundAdvice</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * invocation ：连接点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========进入around环绕方法！=========== \n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用目标方法之前执行的动作</span></span><br><span class="line">        System.out.println(<span class="string">"调用方法之前: 执行！\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法的参数</span></span><br><span class="line">        Object[] args = invocation.getArguments();</span><br><span class="line">        <span class="comment">// 调用的方法</span></span><br><span class="line">        Method method = invocation.getMethod();</span><br><span class="line">        <span class="comment">// 获取目标对象</span></span><br><span class="line">        Object target = invocation.getThis();</span><br><span class="line">        <span class="comment">// 执行完方法的返回值：调用proceed()方法，就会触发切入点方法执行</span></span><br><span class="line">        Object returnValue = invocation.proceed();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"===========结束进入around环绕方法！=========== \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"输出："</span> + args[<span class="number">0</span>] + <span class="string">";"</span> + method + <span class="string">";"</span> + target + <span class="string">";"</span> + returnValue + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"调用方法结束：之后执行！\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>异常通知：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异常通知，接口没有包含任何方法。通知方法自定义</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAfterThrowsAdvice</span> <span class="keyword">implements</span> <span class="title">ThrowsAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知方法，需要按照这种格式书写</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">     *            可选：切入的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     *            可选：切入的方法的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     *            可选：目标对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> throwable</span></span><br><span class="line"><span class="comment">     *            必填 : 异常子类，出现这个异常类的子类，则会进入这个通知。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(Method method, Object[] args, Object target, Throwable throwable)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除出错啦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义指定切点："><a href="#定义指定切点：" class="headerlink" title="定义指定切点："></a>定义指定切点：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个切点，指定对应方法匹配。来供切面来针对方法进行处理&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 继承NameMatchMethodPointcut类，来用方法名匹配</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pointcut</span> <span class="keyword">extends</span> <span class="title">NameMatchMethodPointcut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3990456017285944475L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置单个方法匹配</span></span><br><span class="line">        <span class="keyword">this</span>.setMappedName(<span class="string">"delete"</span>);</span><br><span class="line">        <span class="comment">// 设置多个方法匹配</span></span><br><span class="line">        String[] methods = &#123; <span class="string">"delete"</span>, <span class="string">"modify"</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//也可以用“ * ” 来做匹配符号</span></span><br><span class="line">        <span class="comment">// this.setMappedName("get*");</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setMappedNames(methods);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.matches(method, targetClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context/spring-context-3.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/aop     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ==============================利用spring自己的aop配置================================ --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 声明一个业务类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baseBusiness"</span> <span class="attr">class</span>=<span class="string">"aop.base.BaseBusiness"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 声明通知类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baseBefore"</span> <span class="attr">class</span>=<span class="string">"aop.base.advice.BaseBeforeAdvice"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baseAfterReturn"</span> <span class="attr">class</span>=<span class="string">"aop.base.advice.BaseAfterReturnAdvice"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baseAfterThrows"</span> <span class="attr">class</span>=<span class="string">"aop.base.advice.BaseAfterThrowsAdvice"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baseAround"</span> <span class="attr">class</span>=<span class="string">"aop.base.advice.BaseAroundAdvice"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定切点匹配类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"pointcut"</span> <span class="attr">class</span>=<span class="string">"aop.base.pointcut.Pointcut"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 包装通知，指定切点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"matchBeforeAdvisor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.DefaultPointcutAdvisor"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pointcut"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"pointcut"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"advice"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"baseBefore"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用ProxyFactoryBean 产生代理对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"businessProxy"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 代理对象所实现的接口 ，如果有接口可以这样设置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"proxyInterfaces"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>aop.base.IBaseBusiness<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 设置目标对象 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"baseBusiness"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 代理对象所使用的拦截器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>matchBeforeAdvisor<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>baseAfterReturn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>baseAround<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="测试类："><a href="#测试类：" class="headerlink" title="测试类："></a>测试类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Debug</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"aop/schema_aop.xml"</span>);</span><br><span class="line">        IBaseBusiness business = (IBaseBusiness ) context.getBean(<span class="string">"businessProxy"</span>);</span><br><span class="line">        business.delete(<span class="string">"猫"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的代码实现可以从代码注释中很容易理解<strong>接口方式</strong>的实现。结果也可想而知，前置方法会在切入点方法之前执行，后置会在切入点方法执行之后执行，环绕则会在切入点方法执行前执行同时方法结束也会执行对应的部分。主要是调用proceed()方法来执行切入点方法。来作为环绕通知前后方法的分水岭。然后在实现的过程中，有几点却是可以细揣摩一下的。</p><p>可以看出在xml配置businessProxy这个bean的时候，ProxyFactoryBean类中指定了，proxyInterfaces参数。这里我把他配置了IBaseBusiness接口。因为在项目开发过程中，往往业务类都会有对应的接口，以方便利用IOC解耦。但Spring AOP却也能支持没有接口的代理。这就是为什么需要导入cglib.jar的包。看过spring的源码，知道在目标切入对象如果有实现接口，spring会默认走jdk动态代理来实现代理类。如果没有接口，则会通过cglib来实现代理类。</p><p>这个业务类现在有<strong>前置通知，后置通知，环绕</strong>三个通知同时作用，可能以及更多的通知进行作用。那么这些通知的执行顺序是怎么样的？就这个例子而言，同时实现了三个通知。在例子xml中，则显示执行before通知，然后执行around的前处理，执行切点方法，再执行return处理。最后执行around的后处理。经过测试，知道spring处理顺序是按照xml配置顺序依次处理通知，以队列的方式存放前通知，以压栈的方式存放后通知。所以是<strong>前通知依次执行，后通知到切入点执行完之后，从栈里在后进先出的形式把后通知执行</strong>。</p><p>在实现过程中发现通知执行对应目标对象的整个类中的方法，如何精确到某个方法，则需要定义一个切点匹配的方式：spring提供了方法名匹配或正则方式来匹配。然后通过DefaultPointcutAdvisor来包装通知，指定切点.</p><p>利用方式一的配置起来，可见代码还是非常的厚重的，<strong>定义一个切面就要定义一个切面类，然而切面类中，就一个通知方法</strong>，着实没有必要。所以Spring提供了，依赖aspectj的schema配置和基于aspectj 注解方式。这两种方式非常简介方便使用，也是项目中普遍的使用方式。梳理之：</p><h3 id="schema配置"><a href="#schema配置" class="headerlink" title="schema配置"></a>schema配置</h3><h4 id="业务类：-1"><a href="#业务类：-1" class="headerlink" title="业务类："></a>业务类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectBusiness</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切入点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========调用切入点："</span> + obj + <span class="string">"说：你敢删除我！===========\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄～"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"================这个方法不能被切。。。============== \n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄～ 嘿嘿！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modify</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=================这个也设置加入切吧====================\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄改瞄啊！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切面类："><a href="#切面类：" class="headerlink" title="切面类："></a>切面类：</h4><p>切面类中，包含了所有的通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个切面</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint jp)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========进入before advice============ \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"准备在"</span> + jp.getTarget().getClass() + <span class="string">"对象上用"</span>);</span><br><span class="line">        System.out.print(jp.getSignature().getName() + <span class="string">"方法进行对 '"</span>);</span><br><span class="line">        System.out.print(jp.getArgs()[<span class="number">0</span>] + <span class="string">"'进行删除！\n\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"要进入切入点方法了 \n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jp</span></span><br><span class="line"><span class="comment">     *            连接点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">     *            返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(JoinPoint jp, String result)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========进入after advice=========== \n"</span>);</span><br><span class="line">        System.out.println(<span class="string">"切入点方法执行完了 \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(jp.getArgs()[<span class="number">0</span>] + <span class="string">"在"</span>);</span><br><span class="line">        System.out.print(jp.getTarget().getClass() + <span class="string">"对象上被"</span>);</span><br><span class="line">        System.out.print(jp.getSignature().getName() + <span class="string">"方法删除了"</span>);</span><br><span class="line">        System.out.print(<span class="string">"只留下："</span> + result + <span class="string">"\n\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pjp</span></span><br><span class="line"><span class="comment">     *            连接点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAround</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========进入around环绕方法！=========== \n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用目标方法之前执行的动作</span></span><br><span class="line">        System.out.println(<span class="string">"调用方法之前: 执行！\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法的参数</span></span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        <span class="comment">// 调用的方法名</span></span><br><span class="line">        String method = pjp.getSignature().getName();</span><br><span class="line">        <span class="comment">// 获取目标对象</span></span><br><span class="line">        Object target = pjp.getTarget();</span><br><span class="line">        <span class="comment">// 执行完方法的返回值：调用proceed()方法，就会触发切入点方法执行</span></span><br><span class="line">        Object result = pjp.proceed();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"输出："</span> + args[<span class="number">0</span>] + <span class="string">";"</span> + method + <span class="string">";"</span> + target + <span class="string">";"</span> + result + <span class="string">"\n"</span>);</span><br><span class="line">        System.out.println(<span class="string">"调用方法结束：之后执行！\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doThrow</span><span class="params">(JoinPoint jp, Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除出错啦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context/spring-context-3.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/aop     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ==============================利用spring 利用aspectj来配置AOP================================ --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 声明一个业务类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aspectBusiness"</span> <span class="attr">class</span>=<span class="string">"aop.schema.AspectBusiness"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 声明通知类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aspectAdvice"</span> <span class="attr">class</span>=<span class="string">"aop.schema.advice.AspectAdvice"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"businessAspect"</span> <span class="attr">ref</span>=<span class="string">"aspectAdvice"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置指定切入的对象 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"point_cut"</span> <span class="attr">expression</span>=<span class="string">"execution(* aop.schema.*.*(..))"</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 只匹配add方法作为切入点</span></span><br><span class="line"><span class="comment">            &lt;aop:pointcut id="except_add" expression="execution(* aop.schema.*.add(..))" /&gt;</span></span><br><span class="line"><span class="comment">             --&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 前置通知 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"doBefore"</span> <span class="attr">pointcut-ref</span>=<span class="string">"point_cut"</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 后置通知 returning指定返回参数 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"doAfter"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">pointcut-ref</span>=<span class="string">"point_cut"</span> <span class="attr">returning</span>=<span class="string">"result"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"doAround"</span> <span class="attr">pointcut-ref</span>=<span class="string">"point_cut"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"doThrow"</span> <span class="attr">pointcut-ref</span>=<span class="string">"point_cut"</span> <span class="attr">throwing</span>=<span class="string">"e"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="测试类：-1"><a href="#测试类：-1" class="headerlink" title="测试类："></a>测试类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Debug</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"aop/schema_aop.xml"</span>);</span><br><span class="line">        AspectBusiness business = (AspectBusiness) context.getBean(<span class="string">"aspectBusiness"</span>);</span><br><span class="line">        business.delete(<span class="string">"猫"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="aspectj注解"><a href="#aspectj注解" class="headerlink" title="aspectj注解"></a>aspectj注解</h3><p>注解在项目中已经到处都是了，撇开一些优劣不提，开发的便利性和可读性是非常的方便的。用来配置Spring AOP也非常简单便利</p><h4 id="业务类：-2"><a href="#业务类：-2" class="headerlink" title="业务类："></a>业务类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Business</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切入点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========调用切入点："</span> + obj + <span class="string">"说：你敢删除我！===========\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄～"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"================这个方法不能被切。。。============== \n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄～ 嘿嘿！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modify</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=================这个也设置加入切吧====================\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj + <span class="string">"：瞄改瞄啊！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切面类：-1"><a href="#切面类：-1" class="headerlink" title="切面类："></a>切面类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义切面</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Aspect</span> : 标记为切面类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Pointcut</span> : 指定匹配切点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Before</span> : 指定前置通知，value中指定切入点匹配</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@AfterReturning</span> ：后置通知，具有可以指定返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@AfterThrowing</span> ：异常通知</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定切入点匹配表达式，注意它是以方法的形式进行声明的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* aop.annotation.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(value = <span class="string">"execution(* aop.annotation.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint jp)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========进入before advice============ \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"准备在"</span> + jp.getTarget().getClass() + <span class="string">"对象上用"</span>);</span><br><span class="line">        System.out.print(jp.getSignature().getName() + <span class="string">"方法进行对 '"</span>);</span><br><span class="line">        System.out.print(jp.getArgs()[<span class="number">0</span>] + <span class="string">"'进行删除！\n\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"要进入切入点方法了 \n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jp</span></span><br><span class="line"><span class="comment">     *            连接点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">     *            返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(value = <span class="string">"anyMethod()"</span>, returning = <span class="string">"result"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(JoinPoint jp, String result)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========进入after advice=========== \n"</span>);</span><br><span class="line">        System.out.println(<span class="string">"切入点方法执行完了 \n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(jp.getArgs()[<span class="number">0</span>] + <span class="string">"在"</span>);</span><br><span class="line">        System.out.print(jp.getTarget().getClass() + <span class="string">"对象上被"</span>);</span><br><span class="line">        System.out.print(jp.getSignature().getName() + <span class="string">"方法删除了"</span>);</span><br><span class="line">        System.out.print(<span class="string">"只留下："</span> + result + <span class="string">"\n\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pjp</span></span><br><span class="line"><span class="comment">     *            连接点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around</span>(value = <span class="string">"execution(* aop.annotation.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAround</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========进入around环绕方法！=========== \n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用目标方法之前执行的动作</span></span><br><span class="line">        System.out.println(<span class="string">"调用方法之前: 执行！\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法的参数</span></span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        <span class="comment">// 调用的方法名</span></span><br><span class="line">        String method = pjp.getSignature().getName();</span><br><span class="line">        <span class="comment">// 获取目标对象</span></span><br><span class="line">        Object target = pjp.getTarget();</span><br><span class="line">        <span class="comment">// 执行完方法的返回值：调用proceed()方法，就会触发切入点方法执行</span></span><br><span class="line">        Object result = pjp.proceed();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"输出："</span> + args[<span class="number">0</span>] + <span class="string">";"</span> + method + <span class="string">";"</span> + target + <span class="string">";"</span> + result + <span class="string">"\n"</span>);</span><br><span class="line">        System.out.println(<span class="string">"调用方法结束：之后执行！\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(value = <span class="string">"execution(* aop.annotation.*.*(..))"</span>, throwing = <span class="string">"e"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doThrow</span><span class="params">(JoinPoint jp, Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除出错啦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置：-1"><a href="#配置：-1" class="headerlink" title="配置："></a>配置：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context/spring-context-3.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/aop     </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"aop.annotation"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 打开aop 注解 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="测试类：-2"><a href="#测试类：-2" class="headerlink" title="测试类："></a>测试类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Debug</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"aop/annotation_aop.xml"</span>);</span><br><span class="line">        Business business = (Business) context.getBean(<span class="string">"business"</span>);</span><br><span class="line">        business.delete(<span class="string">"猫"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring有两大核心，IOC和AOP。IOC在java web项目中无时无刻不在使用。然而AOP用的比较少，的确也是一般的项目用的场所不多。&lt;strong&gt;事务控制&lt;/strong&gt;基本都用，但却是Spring封装的不需要我们再去实现，但Spring的AOP远不止这些。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="blog.jiangdongyu.space/categories/JavaWeb/"/>
    
      <category term="Spring" scheme="blog.jiangdongyu.space/categories/JavaWeb/Spring/"/>
    
      <category term="AOP" scheme="blog.jiangdongyu.space/categories/JavaWeb/Spring/AOP/"/>
    
    
      <category term="Spring" scheme="blog.jiangdongyu.space/tags/Spring/"/>
    
      <category term="AOP" scheme="blog.jiangdongyu.space/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>AOP的定义实现原理——代理</title>
    <link href="blog.jiangdongyu.space/2018/07/13/%E7%90%86%E8%A7%A3AOP/"/>
    <id>blog.jiangdongyu.space/2018/07/13/理解AOP/</id>
    <published>2018-07-13T12:05:00.000Z</published>
    <updated>2018-07-30T08:30:41.131Z</updated>
    
    <content type="html"><![CDATA[<p>Aspect Oriented Programming面向切面编程。解耦是程序员编码开发过程中一直追求的。AOP也是为了解耦所诞生。</p><p><strong>具体思想</strong>是：定义一个切面，在切面的纵向定义处理方法，处理完成之后，回到横向业务流。</p><p>AOP在Spring框架中被作为核心组成部分之一，的确Spring将AOP发挥到很强大的功能。最常见的就是<strong>事务控制</strong>。</p><p>AOP 主要是利用<strong>代理模式</strong>的技术来实现的。</p><a id="more"></a><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><blockquote><p>就是设计模式中的proxy模式</p></blockquote><ul><li>业务接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象主题角色：声明了真实主题和代理主题的共同接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITalk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String msg)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>业务实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真实主题角色：定义真实的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeopleTalk</span> <span class="keyword">implements</span> <span class="title">ITalk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String username;</span><br><span class="line">    <span class="keyword">public</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PeopleTalk</span><span class="params">(String username, String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(msg + <span class="string">"!你好,我是"</span> + username + <span class="string">"，我年龄是"</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代理对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理主题角色：内部包含对真实主题的引用，并且提供和真实主题角色相同的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkProxy</span> <span class="keyword">implements</span> <span class="title">ITalk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ITalk talker;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TalkProxy</span><span class="params">(ITalk talker)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// super();</span></span><br><span class="line">        <span class="keyword">this</span>.talker = talker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        talker.talk(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String msg, String singname)</span> </span>&#123;</span><br><span class="line">        talker.talk(msg);</span><br><span class="line">        sing(singname);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">(String singname)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"唱歌："</span> + singname);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理测试类，使用代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyPattern</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不需要执行额外方法的。</span></span><br><span class="line">        ITalk people = <span class="keyword">new</span> PeopleTalk(<span class="string">"AOP"</span>, <span class="string">"18"</span>);</span><br><span class="line">        people.talk(<span class="string">"No ProXY Test"</span>);</span><br><span class="line">        System.out.println(<span class="string">"-----------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要执行额外方法的（切面）</span></span><br><span class="line">        TalkProxy talker = <span class="keyword">new</span> TalkProxy(people);</span><br><span class="line">        talker.talk(<span class="string">"ProXY Test"</span>, <span class="string">"代理"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码可以看出来，代理模式其实就是AOP的雏形。上端代码中talk(String msg, String singname)是一个切面。在代理类中的sing(singname)方法是个后置处理方法。</p><p>这样就实现了，其他的辅助方法和业务方法的解耦。业务不需要专门去调用，而是走到talk方法，顺理成章的调用sing方法</p><p>再从这段代码看：</p><ul><li>要实现代理方式，必须要定义接口。</li><li>每个业务类，需要一个代理类。</li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><blockquote><p>jdk1.5中提供，利用反射。实现InvocationHandler接口。</p><p>业务接口还是必须得，业务接口，业务类同上。</p></blockquote><ul><li>代理类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 需要代理的目标类 */</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写法固定，aop专用:绑定委托对象并返回一个代理类</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delegate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Object</span></span><br><span class="line"><span class="comment">     *            target：指被代理的对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Method</span></span><br><span class="line"><span class="comment">     *            method：要调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Object</span></span><br><span class="line"><span class="comment">     *            [] args：方法调用时所需要的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 切面之前执行</span></span><br><span class="line">        System.out.println(<span class="string">"切面之前执行"</span>);</span><br><span class="line">        <span class="comment">// 执行业务</span></span><br><span class="line">        result = method.invoke(target, args);</span><br><span class="line">        <span class="comment">// 切面之后执行</span></span><br><span class="line">        System.out.println(<span class="string">"切面之后执行"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 绑定代理，这种方式会在所有的方法都加上切面方法</span></span><br><span class="line">        ITalk iTalk = (ITalk) <span class="keyword">new</span> DynamicProxy().bind(<span class="keyword">new</span> PeopleTalk());</span><br><span class="line">        iTalk.talk(<span class="string">"业务说明"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果会是：</p><pre><code>切面之前执行people talk业务说明切面之后执行</code></pre><p>说明只要在业务调用方法切面之前，是可以动态的加入需要处理的方法。</p><p>从代码来看，如果再建立一个业务模块，也只需要一个代理类。ITalk iTalk = (ITalk) new DynamicProxy().bind(new PeopleTalk()); 将业务接口和业务类绑定到动态代理类。</p><p>但是这种方式：还是需要定义接口。</p><h3 id="利用cglib"><a href="#利用cglib" class="headerlink" title="利用cglib"></a>利用cglib</h3><blockquote><p>CGLIB是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强。采用的是继承的方式。</p></blockquote><ul><li>业务类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeopleTalk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"people talk"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>cglib代理类</li></ul><blockquote><p>MethodInterceptor</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用cglib动态代理</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建代理对象</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());</span><br><span class="line">        <span class="comment">// 回调方法</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">"事物开始"</span>);</span><br><span class="line">        result = methodProxy.invokeSuper(proxy, args);</span><br><span class="line">        System.out.println(<span class="string">"事物结束"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PeopleTalk peopleTalk = (PeopleTalk) <span class="keyword">new</span> CglibProxy().getInstance(<span class="keyword">new</span> PeopleTalk());</span><br><span class="line">        peopleTalk.talk(<span class="string">"业务方法"</span>);</span><br><span class="line">        peopleTalk.spreak(<span class="string">"业务方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出结果：</p><pre><code>事物开始people talk业务方法事物结束事物开始spreak chinese业务方法事物结束</code></pre><h3 id="AOP创建过程"><a href="#AOP创建过程" class="headerlink" title="AOP创建过程"></a>AOP创建过程</h3><p><img src="http://p9fh1pach.bkt.clouddn.com/aop9.png" alt="avatar"></p><ul><li>如何选择JDK动态代理还是继承cglib</li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/aop10.png" alt="avatar"></p><p><img src="http://p9fh1pach.bkt.clouddn.com/aop11.png" alt="avatar"></p><p>多个AOP的类调用，采用<strong>责任链模式</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Aspect Oriented Programming面向切面编程。解耦是程序员编码开发过程中一直追求的。AOP也是为了解耦所诞生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体思想&lt;/strong&gt;是：定义一个切面，在切面的纵向定义处理方法，处理完成之后，回到横向业务流。&lt;/p&gt;
&lt;p&gt;AOP在Spring框架中被作为核心组成部分之一，的确Spring将AOP发挥到很强大的功能。最常见的就是&lt;strong&gt;事务控制&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;AOP 主要是利用&lt;strong&gt;代理模式&lt;/strong&gt;的技术来实现的。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="blog.jiangdongyu.space/categories/JavaWeb/"/>
    
      <category term="Spring" scheme="blog.jiangdongyu.space/categories/JavaWeb/Spring/"/>
    
      <category term="AOP" scheme="blog.jiangdongyu.space/categories/JavaWeb/Spring/AOP/"/>
    
    
      <category term="Spring" scheme="blog.jiangdongyu.space/tags/Spring/"/>
    
      <category term="AOP" scheme="blog.jiangdongyu.space/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>IOC的定义及实现原理——反射</title>
    <link href="blog.jiangdongyu.space/2018/07/13/Spring%20IOC%E5%8E%9F%E7%90%86/"/>
    <id>blog.jiangdongyu.space/2018/07/13/Spring IOC原理/</id>
    <published>2018-07-13T11:22:00.000Z</published>
    <updated>2018-07-26T11:42:38.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IOC-DI"><a href="#IOC-DI" class="headerlink" title="IOC(DI)"></a>IOC(DI)</h2><p>Java程序员都知道：Java程序中的每个业务逻辑至少需要两个或以上的对象来协作完成，通常，每个对象在使用他的合作对象时，自己均要使用像new object()这样的语法来完成合作对象的申请工作。你会发现，对象间的耦合度高了。而IOC的<strong>思想</strong>是: <strong>Spring容器来实现这些相互依赖对象的创建、协调工作</strong>。对象只需要关系业务逻辑本身就可以了。从这方面来说，对象如何得到他的协作对象的责任被反转了(IOC、DI)。</p><a id="more"></a><p>DI其实就是IOC的另外一种说法。DI是由Martin Fowler 在2004年初的一篇论文中首次提出的。他总结：<strong>控制的什么被反转了？就是：获得依赖对象的方式反转了</strong>。</p><h3 id="IOC与DI"><a href="#IOC与DI" class="headerlink" title="IOC与DI"></a>IOC与DI</h3><p>首先想说说IOC(Inversion of Control，控制倒转)。这是Spring的<strong>核心</strong>，贯穿始终。所谓IOC，对于Spring框架来说，就是<strong>由Spring来负责控制对象的生命周期和对象间的关系</strong>。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，<strong>在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。</strong></p><p>那么IOC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，<strong>所有的类都会在Spring容器中登记</strong>，告诉Spring你是个什么东西，你需要什么东西，然后Spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。<strong>所有的类的创建、销毁都由Spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是Spring</strong>。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被Spring控制，所以这叫控制反转。</p><p>IOC的一个重点是在系统运行中，<strong>动态</strong>地向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了Spring我们就只需要告诉Spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，Spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖Connection才能正常运行，而这个Connection是由Spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢? Java 1.3之后一个重要特征是<strong>反射</strong>(reflection)，它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，<strong>Spring就是通过反射来实现注入的</strong>。</p><h3 id="Spring是怎么运行的"><a href="#Spring是怎么运行的" class="headerlink" title="Spring是怎么运行的"></a>Spring是怎么运行的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> ApplicationContext context = <span class="keyword">new</span> FileSystemXmlApplicationContext(</span><br><span class="line"><span class="string">"applicationContext.xml"</span>);</span><br><span class="line"> Animal animal = (Animal) context.getBean(<span class="string">"animal"</span>);</span><br><span class="line"> animal.say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>applicationContext.xml</strong>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"animal"</span> <span class="attr">class</span>=<span class="string">"phz.springframework.test.Cat"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"kitty"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>类phz.springframework.test.Cat:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"I am "</span> + name + <span class="string">"!"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = name;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了phz.springframework.test.Animal接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显上面的代码输出<strong>I am kitty!</strong></p><h3 id="实现Spring"><a href="#实现Spring" class="headerlink" title="实现Spring"></a>实现Spring</h3><p>那么到底Spring是如何做到的呢？</p><p>接下来就让我们自己写个Spring来看看Spring到底是怎么运行的吧！ </p><p>首先，我们定义一个Bean类，这个类用来存放一个Bean拥有的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/* Bean Id */</span></span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"><span class="comment">/* Bean Class */</span></span><br><span class="line"><span class="keyword">private</span> String type;</span><br><span class="line"><span class="comment">/* Bean Property */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; properties = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br></pre></td></tr></table></figure><p>一个Bean包括id,type,和Properties。 </p><p>接下来Spring就开始加载我们的配置文件了，将我们配置的信息保存在一个HashMap中，HashMap的key就是Bean的Id，HasMap的value是这个Bean，只有这样我们才能通过context.getBean(“animal”)这个方法获得Animal这个类。我们都知道Spirng可以注入基本类型，而且可以注入像List，Map这样的类型，接下来就让我们以Map为例看看Spring是怎么保存的。</p><p>Map配置可以像下面的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">class</span>=<span class="string">"Test"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testMap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"b"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring是怎样保存上面的配置呢？代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(beanProperty.element(<span class="string">"map"</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line"> Map&lt;String, Object&gt; propertiesMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"> Element propertiesListMap = (Element) beanProperty</span><br><span class="line">.elements().get(<span class="number">0</span>);</span><br><span class="line"> Iterator&lt;?&gt; propertiesIterator = propertiesListMap</span><br><span class="line">.elements().iterator();</span><br><span class="line"> <span class="keyword">while</span> (propertiesIterator.hasNext()) &#123;</span><br><span class="line">  Element vet = (Element) propertiesIterator.next();</span><br><span class="line">  <span class="keyword">if</span> (vet.getName().equals(<span class="string">"entry"</span>)) &#123;</span><br><span class="line">   String key = vet.attributeValue(<span class="string">"key"</span>);</span><br><span class="line">   Iterator&lt;?&gt; valuesIterator = vet.elements()</span><br><span class="line">.iterator();</span><br><span class="line">   <span class="keyword">while</span> (valuesIterator.hasNext()) &#123;</span><br><span class="line">Element value = (Element) valuesIterator.next();</span><br><span class="line"><span class="keyword">if</span> (value.getName().equals(<span class="string">"value"</span>)) &#123;</span><br><span class="line"> propertiesMap.put(key, value.getText());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (value.getName().equals(<span class="string">"ref"</span>)) &#123;</span><br><span class="line"> propertiesMap.put(key, <span class="keyword">new</span> String[] &#123; value.attributeValue(<span class="string">"bean"</span>) &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  bean.getProperties().put(name, propertiesMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就进入最核心部分了，让我们看看Spring到底是怎么<strong>依赖注入</strong>的吧，其实依赖注入的思想也很简单，它是通过<strong>反射</strong>机制实现的，在实例化一个类时，它通过<strong>反射调用类中set方法将事先保存在HashMap中的类属性注入到类中</strong>。让我们看看具体它是怎么做的吧。</p><p>首先<strong>实例化</strong>一个类，像这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line"> Class&lt;?&gt; cls = <span class="keyword">null</span>;</span><br><span class="line"> Object obj = <span class="keyword">null</span>;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  cls = Class.forName(className);</span><br><span class="line">  obj = cls.newInstance();</span><br><span class="line"> &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着它将这个<strong>类的依赖注入进去</strong>，像这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setProperty</span><span class="params">(Object obj, String name, String value)</span> </span>&#123;</span><br><span class="line"> Class&lt;? extends Object&gt; clazz = obj.getClass();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  String methodName = returnSetMthodName(name);</span><br><span class="line">  Method[] ms = clazz.getMethods();</span><br><span class="line">  <span class="keyword">for</span> (Method m : ms) &#123;</span><br><span class="line">   <span class="keyword">if</span> (m.getName().equals(methodName)) &#123;</span><br><span class="line"><span class="keyword">if</span> (m.getParameterTypes().length == <span class="number">1</span>) &#123;</span><br><span class="line"> Class&lt;?&gt; clazzParameterType = m.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line"> setFieldValue(clazzParameterType.getName(), value, m,obj);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后它将这个类的实例返回给我们，我们就可以用了。我们还是以Map为例看看它是怎么做的，我写的代码里面是创建一个HashMap并把该HashMap注入到需要注入的类中，像这样，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line"> Iterator&lt;?&gt; entryIterator = ((Map&lt;?, ?&gt;) value).entrySet().iterator();</span><br><span class="line"> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"> <span class="keyword">while</span> (entryIterator.hasNext()) &#123;</span><br><span class="line">  Entry&lt;?, ?&gt; entryMap = (Entry&lt;?, ?&gt;) entryIterator.next();</span><br><span class="line">  <span class="keyword">if</span> (entryMap.getValue() <span class="keyword">instanceof</span> String[]) &#123;</span><br><span class="line">map.put((String) entryMap.getKey(),</span><br><span class="line">getBean(((String[]) entryMap.getValue())[<span class="number">0</span>]));</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> BeanProcesser.setProperty(obj, property, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，这样我们就可以用Spring给我们创建的类了，是不是也不是很难啊？当然Spring能做到的远不止这些，这个示例程序仅仅提供了Spring最核心的依赖注入功能中的一部分。 </p><p>本文参考了大量文章无法一一感谢，在这一起感谢，如果侵犯了你的版权深表歉意，很希望对大家有帮助！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;IOC-DI&quot;&gt;&lt;a href=&quot;#IOC-DI&quot; class=&quot;headerlink&quot; title=&quot;IOC(DI)&quot;&gt;&lt;/a&gt;IOC(DI)&lt;/h2&gt;&lt;p&gt;Java程序员都知道：Java程序中的每个业务逻辑至少需要两个或以上的对象来协作完成，通常，每个对象在使用他的合作对象时，自己均要使用像new object()这样的语法来完成合作对象的申请工作。你会发现，对象间的耦合度高了。而IOC的&lt;strong&gt;思想&lt;/strong&gt;是: &lt;strong&gt;Spring容器来实现这些相互依赖对象的创建、协调工作&lt;/strong&gt;。对象只需要关系业务逻辑本身就可以了。从这方面来说，对象如何得到他的协作对象的责任被反转了(IOC、DI)。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="blog.jiangdongyu.space/categories/JavaWeb/"/>
    
      <category term="Spring" scheme="blog.jiangdongyu.space/categories/JavaWeb/Spring/"/>
    
      <category term="IOC" scheme="blog.jiangdongyu.space/categories/JavaWeb/Spring/IOC/"/>
    
    
      <category term="Spring" scheme="blog.jiangdongyu.space/tags/Spring/"/>
    
      <category term="IOC" scheme="blog.jiangdongyu.space/tags/IOC/"/>
    
  </entry>
  
  <entry>
    <title>String</title>
    <link href="blog.jiangdongyu.space/2018/07/11/String/"/>
    <id>blog.jiangdongyu.space/2018/07/11/String/</id>
    <published>2018-07-11T09:35:00.000Z</published>
    <updated>2018-07-13T07:07:42.835Z</updated>
    
    <content type="html"><![CDATA[<h3 id="38-Count-and-Say"><a href="#38-Count-and-Say" class="headerlink" title="38.Count and Say"></a>38.Count and Say</h3><p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p><a id="more"></a><pre><code>1.     12.     113.     214.     12115.     111221</code></pre><p>1 is read off as “one 1” or 11.</p><p>11 is read off as “two 1s” or 21.</p><p>21 is read off as “one 2, then one 1” or 1211.</p><p>Given an integer n, generate the nth term of the count-and-say sequence.</p><p><strong>Note</strong>: Each term of the sequence of integers will be represented as a string.</p><p><strong>Example 1</strong>:</p><pre><code>Input: 1Output: &quot;1&quot;</code></pre><p><strong>Example 2</strong>:</p><pre><code>Input: 4Output: &quot;1211&quot;</code></pre><blockquote><p>题目有些晦涩，就以上面的例子解释，“1”读出来是“一个1”，因此第二行就是“11”，“11”读出来是“两个1”,因此第三行就是“21”,“21”读出来是“一个2一个1”，因此第四行就是“1211”，以此类推</p></blockquote><p><strong>思路</strong></p><ul><li>如果我们要获得第n个字符串，那我们首先要获得第n-1个字符串的值。所以我们设置一个prev变量来保存每一次操作的到的字符串的值，从而进行下一次操作。</li><li>操作其实就是从前到后对每一个字符(say)连续出现的次数计数(count)，如果字符变了，那么就将刚才count和say的值加入curr字符串中。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder cur = <span class="keyword">new</span> StringBuilder(<span class="string">"1"</span>);</span><br><span class="line">        StringBuilder pre;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">char</span> say = pre.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; pre.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pre.charAt(j) != say)&#123;</span><br><span class="line">                    cur.append(count).append(say);</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                    say = pre.charAt(j);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    count++; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.append(count).append(say);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.toString();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-Zigzag-Conversion"><a href="#6-Zigzag-Conversion" class="headerlink" title="6.Zigzag Conversion"></a>6.Zigzag Conversion</h3><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p><pre><code>P   A   H   NA P L S I I GY   I   R</code></pre><p>And then read line by line: “PAHNAPLSIIGYIR”</p><p>Write the code that will take a string and make this conversion given a number of rows:</p><p>string convert(string s, int numRows);</p><p><strong>Example 1</strong>:</p><pre><code>Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3Output: &quot;PAHNAPLSIIGYIR&quot;</code></pre><p><strong>Example 2</strong>:</p><pre><code>Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4Output: &quot;PINALSIGYAHRPI&quot;Explanation:P     I    NA   L S  I GY A   H RP     I</code></pre><ul><li>重要是找准规律！</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> length = c.length;</span><br><span class="line">        StringBuilder[] sb = <span class="keyword">new</span> StringBuilder[numRows];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; numRows;i++) sb[i] = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; length)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; numRows &amp;&amp; i &lt; length;j++)&#123;</span><br><span class="line">                sb[j].append(c[i++]);<span class="comment">//垂直往下</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = numRows-<span class="number">2</span>;j &gt; <span class="number">0</span> &amp;&amp; i &lt; length;j--)&#123;</span><br><span class="line">                sb[j].append(c[i++]);<span class="comment">//斜着向上</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; numRows;j++)&#123;</span><br><span class="line">            sb[<span class="number">0</span>].append(sb[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb[<span class="number">0</span>].toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="58-Length-of-Last-word"><a href="#58-Length-of-Last-word" class="headerlink" title="58.Length of Last word"></a>58.Length of Last word</h3><p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.</p><p>If the last word does not exist, return 0.</p><p>Note: A word is defined as a character sequence consists of non-space characters only.</p><p><strong>Example:</strong></p><pre><code>Input: &quot;Hello World&quot;Output: 5</code></pre><ul><li>比较简单</li><li>记得trim(),再进行split操作</li></ul><h3 id="165-Compare-Version-Number"><a href="#165-Compare-Version-Number" class="headerlink" title="165.Compare Version Number"></a>165.Compare Version Number</h3><p>Compare two version numbers version1 and version2.<br>If <strong>version1 &gt; version2</strong> return <strong>1</strong>; if <strong>version1 &lt; version2</strong> return <strong>-1</strong>;otherwise return <strong>0</strong>.</p><p>You may assume that the version strings are non-empty and contain only digits and the . character.<br>The . character does not represent a decimal point and is used to separate number sequences.<br>For instance, 2.5 is not “two and a half” or “half way to version three”, it is the fifth second-level revision of the second first-level revision.</p><p><strong>Example 1:</strong></p><pre><code>Input: version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot;Output: -1</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: version1 = &quot;1.0.1&quot;, version2 = &quot;1&quot;Output: 1</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;Output: -1</code></pre><ul><li>还是挺简单的，但是要注意split的时候”.”的表示</li><li>在java中“\”代表转义字符，而“.”代表一个元字符，要表示一个“.”就需要用“.”，所以”\.” 在实际编译中就代表“.”</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(String version1, String version2)</span> </span>&#123;</span><br><span class="line">        String[] ver1 = version1.split(<span class="string">"\\."</span>);</span><br><span class="line">        String[] ver2 = version2.split(<span class="string">"\\."</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = Math.max(ver1.length,ver2.length);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = i &lt; ver1.length ? Integer.parseInt(ver1[i]):<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> num2 = i &lt; ver2.length ? Integer.parseInt(ver2[i]):<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(num1 &gt; num2)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num1 &lt; num2)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="151-Reverse-Words-in-a-String"><a href="#151-Reverse-Words-in-a-String" class="headerlink" title="151.Reverse Words in a String"></a>151.Reverse Words in a String</h3><p>Given an input string, reverse the string word by word.</p><p><strong>Example:</strong>  </p><pre><code>Input: &quot;the sky is blue&quot;,Output: &quot;blue is sky the&quot;.</code></pre><p><strong>Note:</strong></p><ul><li>A word is defined as a sequence of non-space characters.</li><li>Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces.</li><li>You need to reduce multiple spaces between two words to a single space in the reversed string.</li></ul><p><strong>注意两个单词之间可能有多个空格</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String[] arr = s.trim().split(<span class="string">" +"</span>);<span class="comment">//处理一个或多个空格</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            sb.append(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="186-Reverse-Words-in-a-String-II"><a href="#186-Reverse-Words-in-a-String-II" class="headerlink" title="186.Reverse Words in a String II"></a>186.Reverse Words in a String II</h3><p>Given an input string, reverse the string word by word. A word is defined as a sequence of non-space characters.</p><p>The input string <strong>does not contain</strong> leading or trailing spaces and the words are always separated by a single space.</p><p>For example, Given s = “the sky is blue”, return “blue is sky the”.</p><p>Could you do it in-place without allocating extra space?</p><ul><li>先反转整个数组，再对每个单词进行反转</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseWords</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        reverse(s, <span class="number">0</span>, s.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">                reverse(s, start, i - <span class="number">1</span>);</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(s, start, s.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = s[start];</span><br><span class="line">            s[start] = s[end];</span><br><span class="line">            s[end] = tmp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Palindrome"><a href="#Palindrome" class="headerlink" title="Palindrome"></a>Palindrome</h3><h4 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5.Longest Palindromic Substring"></a>5.Longest Palindromic Substring</h4><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer.</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: &quot;cbbd&quot;Output: &quot;bb&quot;</code></pre><p><strong>暴力枚举</strong></p><ul><li>穷举所有子字符串的可能，然后依次按位判断其是否是回文，并更新结果。虽然其时间复杂度很高，但它对空间的要求很低。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxStart = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; len - i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isPalindrome(s,i,j) &amp;&amp; (i+<span class="number">1</span>) &gt; maxLen)&#123;</span><br><span class="line">                    maxLen = i+<span class="number">1</span>;</span><br><span class="line">                    maxStart = j;</span><br><span class="line">                &#125;      </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxStart,maxStart+maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = j;</span><br><span class="line">        <span class="keyword">int</span> right = i+j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left) != s.charAt(right))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态规划</strong></p><ul><li>dp[i][j]代表字符串从i到j是否为回文串</li><li>当s.charAt(i)==s.charAt(j)并且dp[i+1][j-1]为true时，dp[i][j] = true</li><li>需要注意上述i,j相邻以及i,j中间有别的字符时，上式也成立</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxStart = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(j)==s.charAt(i) &amp;&amp; (j-<span class="number">2</span> &lt;= i || dp[i+<span class="number">1</span>][j-<span class="number">1</span>]))&#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(maxLength &lt; j-i+<span class="number">1</span>)&#123;</span><br><span class="line">                        maxLength = j -i + <span class="number">1</span>;</span><br><span class="line">                        maxStart = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxStart,maxStart + maxLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>中心扩散法</strong></p><ul><li>从小到大连续以某点为个中心的所有子字符串进行计算</li><li>外层循环遍历的是子字符串的中心点，内层循环则是从中心扩散</li><li>中心对称有两种情况，一是奇数个字母以某个字母对称，而是偶数个字母以两个字母中间为对称</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    String longest = <span class="string">""</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="comment">//计算奇数子字符串</span></span><br><span class="line">            helper(s, i, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//计算偶数子字符串</span></span><br><span class="line">            helper(s, i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(String s, <span class="keyword">int</span> idx, <span class="keyword">int</span> offset)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = idx;</span><br><span class="line">        <span class="keyword">int</span> right = idx + offset;</span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span> &amp;&amp; right&lt;s.length() &amp;&amp; s.charAt(left)==s.charAt(right))&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 截出当前最长的子串</span></span><br><span class="line">        String currLongest = s.substring(left + <span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">// 判断是否比全局最长还长</span></span><br><span class="line">        <span class="keyword">if</span>(currLongest.length() &gt; longest.length())&#123;</span><br><span class="line">            longest = currLongest;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="214-Shortest-Palindrome"><a href="#214-Shortest-Palindrome" class="headerlink" title="214.Shortest Palindrome"></a>214.Shortest Palindrome</h4><p>Given a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;aacecaaa&quot;Output: &quot;aaacecaaa&quot;</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: &quot;abcd&quot;Output: &quot;dcbabcd&quot;</code></pre><p><strong>暴力求解</strong></p><ul><li>补充之后的回文字符串的中心肯定在原字符串中</li><li>从原字符的第一个字符为起点至少存在一个回文串，找到原字符串中以第一个字符为起点最长的回文串，找到之后剩下的工作就是把剩余部分的翻转补充到原字符串头部</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || s.length() == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> len = s.length(), tail = len;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (tail &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(s.substring(<span class="number">0</span>, tail))) &#123;</span><br><span class="line">                builder = builder.append(s.substring(tail, len)).reverse();<span class="comment">//substring()从beginIndex开始取，到endIndex结束，从0开始数，其中不包括endIndex位置的字符</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tail--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.append(s).toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) != str.charAt(len - i - <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>KMP</strong>: O(n)</p><h3 id="242-Valid-Anagram"><a href="#242-Valid-Anagram" class="headerlink" title="242.Valid Anagram"></a>242.Valid Anagram</h3><p>Given two strings s and t , write a function to determine if t is an anagram of s.</p><p><strong>Example 1:</strong></p><pre><code>Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;Output: true</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: s = &quot;rat&quot;, t = &quot;car&quot;Output: false</code></pre><p><strong>Note:</strong></p><p>You may assume the string contains only lowercase alphabets.</p><p><strong>Follow up:</strong></p><p>What if the inputs contain unicode characters? How would you adapt your solution to such case?</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()!=t.length())&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">char</span>[] s1 = s.toCharArray();</span><br><span class="line">            <span class="keyword">char</span>[] s2 = t.toCharArray();</span><br><span class="line">            Arrays.sort(s1);</span><br><span class="line">            Arrays.sort(s2);</span><br><span class="line">            <span class="keyword">return</span> Arrays.equals(s1,s2);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="49-Group-Anagram"><a href="#49-Group-Anagram" class="headerlink" title="49.Group Anagram"></a>49.Group Anagram</h3><p>Given an array of strings, group anagrams together.</p><p><strong>Example:</strong></p><pre><code>Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],Output:[  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],  [&quot;nat&quot;,&quot;tan&quot;],  [&quot;bat&quot;]]</code></pre><p><strong>Note:</strong></p><ul><li>All inputs will be in lowercase.</li><li>The order of your output does not matter.</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        Map&lt;String,List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(String s:strs)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] c = s.toCharArray();<span class="comment">//String转char数组</span></span><br><span class="line">            Arrays.sort(c);</span><br><span class="line">            String key = String.valueOf(c);<span class="comment">//char数组转String</span></span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(key)) map.put(key,<span class="keyword">new</span> ArrayList());</span><br><span class="line">            map.get(key).add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(map.values());<span class="comment">//返回一个HashMap的值的Collection</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;38-Count-and-Say&quot;&gt;&lt;a href=&quot;#38-Count-and-Say&quot; class=&quot;headerlink&quot; title=&quot;38.Count and Say&quot;&gt;&lt;/a&gt;38.Count and Say&lt;/h3&gt;&lt;p&gt;The count-and-say sequence is the sequence of integers with the first five terms as following:&lt;/p&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode Category" scheme="blog.jiangdongyu.space/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/LeetCode-Category/"/>
    
    
      <category term="String" scheme="blog.jiangdongyu.space/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>线程安全与锁优化</title>
    <link href="blog.jiangdongyu.space/2018/07/08/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/"/>
    <id>blog.jiangdongyu.space/2018/07/08/线程安全与锁优化/</id>
    <published>2018-07-08T06:20:00.000Z</published>
    <updated>2018-07-10T09:01:47.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>Brian Goetz对线程安全的定义：当多个线程访问一个对象时，如果不考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调度方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。</p><a id="more"></a><h3 id="Java语言中的线程安全"><a href="#Java语言中的线程安全" class="headerlink" title="Java语言中的线程安全"></a>Java语言中的线程安全</h3><p>按照线程安全的“安全程度”由强至弱来排序，java里面各种操作共享的数据分为以下5类：<strong>不可变，绝对线程安全，相对线程安全，线程兼容，线程对立</strong>。</p><ul><li><strong>不可变</strong>：可以是基本类型的<strong>final</strong>；可以是final对象，但对象的行为不会对其状态产生任何影响，比如<strong>String</strong>的subString就是new一个String对象，<strong>枚举类型</strong>，各种<strong>Number类型</strong>如BigInteger和BigDecimal等<strong>大数据类型</strong>都是不可变的，但是同为Number子类型的AtomicInteger和AtomicLong则并非不可变我觉得原因是它里面状态对象是unsafe对象，所做的操作都是CAS操作，可以保证原子性。</li><li><strong>绝对线程安全</strong>：他是完全满足Brian Goetz给出的线程安全的定义，一个类要达到这种程度，需要付出很大的，甚至不切实际的代价。</li><li><strong>相对线程安全</strong>：这就是我们通常意义上的线程安全。需要<strong>保证对象单独的操作时线程安全的</strong>。比如Vector，HashTable，synchronizedCollection包装集合等。</li><li><strong>线程兼容</strong>：<strong>对象本身不是线程安全的，但可以通过同步手段实现</strong>。一般我们说的不是线程安全的，绝大多数是指这个。比如ArrayList，HashMap等。</li><li><strong>线程对立</strong>：<strong>不管调用端是否采用了同步的措施，都无法在并发中使用的代码</strong>。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。</li></ul><h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><ul><li>互斥同步<ul><li>在多线程访问的时候，保证<strong>同一时间只有一条线程使用</strong>。而<strong>互斥是实现同步的一种手段</strong>，临界区(Critical Section)，互斥量(Mutex)，信号量(Semaphore)都是主要的互斥实现方式。java里最基本的互斥同步手段是<strong>synchronized</strong>，编译之后会形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象，还有个锁的计数器，来记录拥有锁的次数</li><li>其实在“Java与线程”里已经提到，java的线程是映射到操作系统的<strong>原生线程</strong>之上的，不管阻塞还是唤醒都需要操作系统的帮忙完成，都需要从用户态转换到核心态，这是很耗费时间的，是java语言中的一个<strong>重量级</strong>(Heavyweight)操作，虽然虚拟机本身会做一点优化的操作，比如通知操作系统阻塞之前会加一段自旋等待的过程，避免频繁切换到核心态。</li><li>还可以使用<strong>java.util.concurrent包中的重入锁（ReentrantLock）来实现同步</strong>，ReentrantLock比synchronized增加了一些高级功能：等待可中断、可实现公平锁以及锁可以绑定多个条件。</li></ul></li><li>非阻塞同步（Non-Blocking Synchronization）<ul><li><strong>互斥和同步最主要的问题就是阻塞和唤醒所带来的性能问题，所以这通常叫阻塞同步(悲观的并发策略)</strong>。随着硬件指令集的发展，我们有另外的选择：<strong>基于冲突检测的乐观并发策略</strong>，通俗讲就是先操作，如果没有其他线程争用共享的数据，操作就成功，如果有，则进行其他的补偿(最常见就是不断的重试)，这种乐观的并发策略许多实现都不需要把线程挂起，这种同步操作被称为<strong>非阻塞同步</strong>。</li></ul></li><li>无同步方案<ul><li>有一些代码天生就是线程安全的，不需要同步。其中有如下两类：</li><li><strong>可重入代码</strong>(Reentrant Code): 纯代码，具有不依赖存储在堆上的数据和公用的系统资源，用到的状态量都由参数中传入，不调用非可重入的方法等特征，它的返回结果是可以预测的。</li><li><strong>线程本地存储</strong>(Thread Local Storage): <strong>把共享数据的可见范围限制在同一个线程之内</strong>，这样就无须同步也能保证线程之间不出现数据争用问题。可以通过java.lang.ThreadLocal类来实现线程本地存储的功能。</li></ul></li></ul><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>为了在线程之间更高效的共享数据，以及解决竞争问题，从而提高程序的执行效率，创建了各种<strong>锁优化技术</strong>：适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、 锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）等。</p><ul><li><strong>自旋锁与自适应自旋</strong>：<ul><li>线程挂起和恢复的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力，在许多应用中，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得，可以让后请求锁的线程等待一会儿，但不放弃处理器的执行时间，让线程执行一个<strong>忙循环(自旋)</strong>。</li><li>自旋锁默认的自旋次数值是10次，可以使用参数-XX:PreBlockSpin更改。</li><li>自适应自旋意味着<strong>自旋的时间不再固定</strong>，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</li></ul></li><li><strong>锁消除</strong>：<ul><li>虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到<strong>不可能存在共享数据竞争的锁进行消除</strong>。锁消除的主要判定依据来源于<strong>逃逸分析</strong>的数据支持。</li></ul></li><li><strong>锁粗化</strong>：<ul><li>如果虚拟机探测到有一系列连续操作都<strong>对同一个对象反复加锁和解锁</strong>，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。</li></ul></li><li><strong>轻量级锁</strong>：<ul><li>使用对象头的Mark Word中锁标志位代替操作系统互斥量实现的锁。轻量级锁并不是用来代替重量级锁，它的本意是<strong>在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗</strong>。</li><li>轻量级锁是在无竞争的情况下使用CAS（Compare-and-Swap）操作去消除同步使用的互斥量。</li></ul></li><li><strong>偏向锁</strong>：<ul><li>和轻量级锁原理基本一致，但偏向锁在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程安全&quot;&gt;&lt;a href=&quot;#线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程安全&quot;&gt;&lt;/a&gt;线程安全&lt;/h2&gt;&lt;p&gt;Brian Goetz对线程安全的定义：当多个线程访问一个对象时，如果不考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调度方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="读书笔记" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深入理解Java虚拟机" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="高效并发" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
      <category term="Thread" scheme="blog.jiangdongyu.space/tags/Thread/"/>
    
      <category term="Lock" scheme="blog.jiangdongyu.space/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型与线程</title>
    <link href="blog.jiangdongyu.space/2018/07/06/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>blog.jiangdongyu.space/2018/07/06/Java内存模型与线程/</id>
    <published>2018-07-06T11:30:00.000Z</published>
    <updated>2018-07-10T09:02:05.462Z</updated>
    
    <content type="html"><![CDATA[<p>衡量一个服务性能的高低好坏，每秒事物处理数(TPS)是最重要的指标之一，它代表着一秒内服务端平均能响应的请求总数，而TPS的值与程序的<strong>并发</strong>能力又有密切的关系。对于计算量相同的任务，程序线程并发协调越有条不紊，效率自然就越高；反之，线程之间频繁阻塞甚至死锁，将会大大降低程序的并发能力。</p><a id="more"></a><h2 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h2><p>物理机并发问题与虚拟机的情况有不少相似之处。</p><p>计算机的存储设备与处理器的运算速度有几个数量级的差距，因而加入高速缓存来作为内存与处理器之间的缓冲，引入新的问题：<strong>缓存一致性</strong>。</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG299.jpeg" alt="avatar"></p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p>Java内存模型的主要目标是定义程序中各个变量的<strong>访问规则</strong>，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量，包括了<strong>实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数</strong>，因为后者是线程私有的，不会被共享，自然没有竞争问题。</p><p>Java内存模型规定了所有的变量都存储在<strong>主内存</strong>中。每条<strong>线程</strong>还有自己的<strong>工作内存</strong>，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，<strong>线程对变量的所有操作都必须在工作内存中进行</strong>，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG300.jpeg" alt="avatar"></p><h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的(对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外)：</p><ul><li>lock(锁定): 作用于<strong>主内存</strong>的变量，它把一个变量标识为一条线程独占的状态</li><li>unlock(解锁): 作用于<strong>主内存</strong>的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read(读取): 作用于<strong>主内存</strong>变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li>load(载入): 作用于<strong>工作内存</strong>的变量，它把read操作从主内存中得到的变量值放入到工作内存的变量副本中。</li><li>use(使用): 作用于<strong>工作内存</strong>的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个<strong>需要使用到变量</strong>的值的字节码指令的时候将会执行这个操作。</li><li>assign(赋值): 作用于<strong>工作内存</strong>的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个<strong>给变量赋值</strong>的字节码指令时将会执行这个操作。</li><li>store(存储): 作用于<strong>工作内存</strong>变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li><li>write(写入): 作用于<strong>主内存</strong>变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ul><p>Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：</p><ol><li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</li><li>不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步会主内存中。</li><li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use和store操作之前，必须先执行过assign和load操作。</li><li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock之后，只有执行相同次数的unlock操作，变量才会被解锁。</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定住的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store和write操作）。</li></ol><h3 id="对于volatile型变量的特殊规则"><a href="#对于volatile型变量的特殊规则" class="headerlink" title="对于volatile型变量的特殊规则"></a>对于volatile型变量的特殊规则</h3><p>关键字volatile可以说是Java虚拟机提供的<strong>最轻量级的同步机制</strong>。当一个变量被定义成volatile之后，它将具备两种特性，第一是<strong>保证此变量对所有线程的可见性</strong>，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以<strong>立即得知的</strong>。</p><p>由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性。</p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li><li>变量不需要与其他的状态变量共同参与不变约束。</li></ul><p>第二个特性是<strong>禁止指令重排序优化</strong>。普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这样就是Java内存模型中描述的所谓的“线程内表现为串行的语义”。</p><h3 id="对于long和double型变量的特殊规则"><a href="#对于long和double型变量的特殊规则" class="headerlink" title="对于long和double型变量的特殊规则"></a>对于long和double型变量的特殊规则</h3><p>Java内存模型要求lock、unlock、read、load、assign、use、store和write这8个操作都具有原子性，但是对于64位的数据类型long和double，在模型中特别定义了一条宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这四个操作的原子性，这点就是所谓的long和double的<strong>非原子性协定</strong>。</p><p>如果有多个线程共享一个未被声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读到一个既非原值，也非其他线程修改值的代表了“半个变量”的数值。</p><p>不过这种读取到“半个变量”的情况非常罕见，因为Java内存模型虽然允许虚拟机不把long和double变量的读写实现成原子操作，但<strong>允许虚拟机选择把这些操作实现为具有原子性的操作</strong>，而且还“强烈建议”虚拟机这样实现。目前各种平台下的商用虚拟机几乎都选择吧64位数据的读写操作作为原子操作来对待，因此在编码时，不需要将long和double变量专门声明为volatile。</p><h3 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h3><p>Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的：</p><ul><li>原子性(Atomicity):<ul><li>由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，我们大致可以认为基本数据类型的访问读写是具备原子性的。</li><li>在synchronized块之间的操作也具备原子性。</li></ul></li><li>可见性(Visibility): <ul><li>指当一个线程修改了共享变量的值，其他线程能够<strong>立即</strong>得知这个修改。</li><li>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介实现可见性的</li><li>普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能<strong>立即</strong>同步到主内存，以及每次使用前立即从主内存刷新。</li><li>除了volatile之外，synchronized和final也能实现可见性。同步块的可见性是由“<strong>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中</strong>”这条规则获得的，而final关键字的可见性是指：<strong>被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去，那在其他线程中就能看见final字段的值</strong></li></ul></li><li>有序性(Ordering): <ul><li>Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。</li><li>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了<strong>禁止指令重排序</strong>的语义，而synchronized则是由“<strong>一个变量在同一个时刻只允许一条线程对其进行lock操作</strong>”这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能<strong>串行</strong>地进入</li></ul></li></ul><h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p>先行发生是Java内存模型中定义的两项操作之间的<strong>偏序关系</strong>，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了小写、调用了方法等。</p><p>下面是Java内存模型下一些“天然的”先行发生关系，这些先行发送关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，他们就没有顺序性保障，虚拟机可以对它们进行随意重新排序。</p><ul><li>程序次序规则(Program Order Rule): 在一个线程内，按照程序<strong>代码顺序</strong>，书写在钱吗的操作先于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li><li>管程锁定规则(Monitor Lock Rule): 一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。</li><li>volatile变量规则(Volatile Variable Rule): 对一个volatile变量的写操作先行发生于后面对这个变量的读操作。“后面”是指时间上的先后顺序。</li><li>线程启动规则(Thread Start Rule): Thread对象的start()方法先行发生于此线程的每一个动作。</li><li>线程终止规则(Thread Termination Rule): 线程中所有操作都先行发生于此线程的终止检测。</li><li>线程中断规则(Thread Interruption Rule): 对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li><li>对象终结规则(Finalizer Rule): 一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</li><li>传递性(Transitivity): 如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得到操作A先行发生于操作C。</li></ul><h2 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h2><h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><ul><li>使用内核线程实现<ul><li>内核线程(Kernel Thread，KLT)就是直接由操作系统内核支持的线程，这种线程由<strong>内核</strong>来完成<strong>线程切换</strong>，内核通过操纵<strong>调度器</strong>对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程都可以看做是内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就叫<strong>多线程内核</strong>。</li><li>程序一般不会直接使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程(Light Weight Process，LWP)，轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。<br><img src="http://p9fh1pach.bkt.clouddn.com/20141214145942631.png" alt="avatar"></li><li>由于内核线程的支持，每个轻量级进程都成为一个<strong>独立</strong>的调度单元，即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作，但轻量级进程具有它的局限性：基于线程内核实现，各种线程操作都需要进行<strong>系统调用</strong>，系统调用代价高，需要在用户态和内核态中来回切换；轻量级进程都需要有一个内核线程的支持，<strong>消耗内核资源</strong></li></ul></li><li>使用用户线程实现<ul><li><strong>广义</strong>上，一个线程只要不是内核线程，那就可以认为是用户线程(User Thread，UT)。</li><li><strong>狭义</strong>上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到线程存在的实现。<br><img src="http://p9fh1pach.bkt.clouddn.com/20141214150247703.png" alt="avatar"></li><li>使用用户线程的<strong>优势劣势</strong>都在于没有系统内核的支援，所有线程操作都需要用户程序自己处理，困难，实现复杂，放弃使用  </li></ul></li><li>使用用户线程加轻量级进程混合实现<ul><li>线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式。在这种混合实现下，既存在用户线程，也存在轻量级进程。<br><img src="http://p9fh1pach.bkt.clouddn.com/20141214150313341.png" alt="avatar"></li></ul></li></ul><h3 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h3><p>线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是<strong>协同式线程调度</strong>(Cooperative Threads-Scheduling)和<strong>抢占式线程调度</strong>(Preemptive Threads-Scheduling)。</p><ul><li>如果使用<strong>协同式</strong>调度的多线程系统，线程的执行时间由<strong>线程</strong>本身来控制，线程把自己的工作执行完毕后，要主动通知系统切换到另一个线程上去。</li><li>如果使用<strong>抢占式</strong>调度的多线程系统，那么每个线程将由<strong>系统</strong>来分配执行时间，线程的切换不由线程本身来决定(在Java中，Thread.yield()可以让出执行时间，但要获取执行时间的话，线程本身是没有什么办法)。Java使用抢占式调度。线程优先级</li></ul><h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>Java语言定义了5种线程状态，在任意一个时间点，一个线程只能有且只有其中的一种状态，这5种状态分别是：</p><ul><li>新建(New): 创建后尚未启动</li><li>运行(Runable): Runable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待CPU为它分配执行时间</li><li>无期限等待(Waiting): 不会被分配CPU执行时间，需要等待被其他线程显式地唤醒</li><li>期限等待(Timed Waiting): 不会被分配CPU执行时间，无须等待被其他线程显式地唤醒，在一定时间之后会由系统自动唤醒</li><li>阻塞(Blocked): 线程被阻塞了，“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是等待一段时间，或者唤醒动作的发生</li><li>结束(Terminated): 已终止线程的线程状态，线程已经结束执行</li></ul><p>上述5种状态在遇到特定事件发生的时候会相互转换。<br><img src="http://p9fh1pach.bkt.clouddn.com/20141214150758572.png" alt="avatar"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;衡量一个服务性能的高低好坏，每秒事物处理数(TPS)是最重要的指标之一，它代表着一秒内服务端平均能响应的请求总数，而TPS的值与程序的&lt;strong&gt;并发&lt;/strong&gt;能力又有密切的关系。对于计算量相同的任务，程序线程并发协调越有条不紊，效率自然就越高；反之，线程之间频繁阻塞甚至死锁，将会大大降低程序的并发能力。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="读书笔记" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深入理解Java虚拟机" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="高效并发" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
      <category term="Thread" scheme="blog.jiangdongyu.space/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>晚期(运行期)优化</title>
    <link href="blog.jiangdongyu.space/2018/07/05/%E6%99%9A%E6%9C%9F(%E8%BF%90%E8%A1%8C%E6%9C%9F)%E4%BC%98%E5%8C%96/"/>
    <id>blog.jiangdongyu.space/2018/07/05/晚期(运行期)优化/</id>
    <published>2018-07-05T05:26:00.000Z</published>
    <updated>2018-07-10T09:01:34.904Z</updated>
    
    <content type="html"><![CDATA[<p>在部分商用虚拟机(HotSpot、IBM J9)中，Java程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“<strong>热点代码</strong>”。为了提高热点代码的执行效率，在运行时，虚拟机会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为<strong>即时编译器</strong>。</p><a id="more"></a><h2 id="HotSpot虚拟机内的即时编译器"><a href="#HotSpot虚拟机内的即时编译器" class="headerlink" title="HotSpot虚拟机内的即时编译器"></a>HotSpot虚拟机内的即时编译器</h2><h3 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h3><p>并不是所有的Java虚拟机都采用解释器与编译器并存的架构，但许多主流的商用虚拟机，如HotSpot、J9等，都同时包含解释器与编译器。解释器与编译器两者各有优势：</p><ul><li>当程序需要<strong>迅速启动和执行</strong>的时候，<strong>解释器</strong>可以首先发挥作用，省去编译的时间，立即执行</li><li>程序运行后，随着时间的推移，<strong>编译器</strong>逐渐发挥作用，把越来越多代码编译成本地代码之后，可以获取更高的执行效率</li><li>当程序运行环境中内存资源限制较大，可以使用<strong>解释执行节约内存</strong>，反之可以使用<strong>编译执行提升效率</strong></li><li>解释器还可以作为编译器<strong>激进优化</strong>时的一个“逃生门”，让编译器根据概率选择一些大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立时可以通过<strong>逆优化</strong>退回到解释状态继续执行。</li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG292.jpeg" alt="avatar"></p><p>无论采用的编译器是Client Compiler还是Server Compiler，解释器与编译器搭配使用的方式在虚拟机中称为“混合模式”，用户可以使用参数“-Xint”<strong>强制</strong>虚拟机运行于“解释模式”，这时<strong>编译器完全不介入工作</strong>，全部代码都使用解释方式执行。另外，也可以使用参数“-Xcomp”强制虚拟机运行于“编译模式”，这时<strong>优先</strong>采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程。</p><p>为了在程序启动相应速度与运行效率之间达到最佳平衡，HotSpot虚拟机还会逐渐启用<strong>分层编译</strong>的策略，分层编译根据<strong>编译器编译、优化的规模与耗时</strong>，划分出不同的编译层次：</p><ul><li>第0层，程序解释执行，解释器不开启性能监控功能，可触发第1层编译</li><li>第1层，也称为C1编译，将字节码编译为本地代码，进行简单、可靠的优化，如有必要加入性能监控的逻辑</li><li>第2层，也称为C2编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。</li></ul><p>实施分层编译后，Client Compiler和Server Compiler将会同时工作，许多代码可能会被多次编译，用<strong>Client Compiler</strong>获取<strong>更高的编译速度</strong>，用<strong>Server Compiler</strong>来获取<strong>更好的编译质量</strong>，在解释执行的时候也无须再承担收集性能监控信息的任务。</p><h3 id="编译对象与触发条件"><a href="#编译对象与触发条件" class="headerlink" title="编译对象与触发条件"></a>编译对象与触发条件</h3><p>“热点代码”有两类：</p><ul><li>被多次调用的方法</li><li>被多次执行的循环体</li></ul><p>“多次”的概念？</p><p>判断一段代码是不是热点代码，是不是需要触发即时编译，这样的行为称为<strong>热点探测</strong>，判定方式有两种：</p><ul><li>基于<strong>采样</strong>的热点探测<ul><li>周期性检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，那这个方法就是“热点方法”</li><li>实现简单、高效，容易获取方法调用关系</li><li>很难精确地确认一个方法的热度，容易因为收到线程阻塞或别的外界因素的影响而扰乱热点探测</li></ul></li><li>基于<strong>计数器</strong>的热点探测(HotSpot采用)<ul><li>为每个方法建立计数器，统计方法的执行次数，如果执行次数超过了一定的阈值就认为它是“热点方法”</li><li>实现麻烦，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系</li><li>更加精准和严谨</li></ul></li></ul><p>HotSpot为每个方法准备了两类计数器：方法调用计数器和回边计数器</p><ul><li>方法调用计数器<ul><li>统计方法被调用的次数，Client模式下默认阈值1500，Server默认10000</li><li>交互过程如下图：<br><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG293.jpeg" alt="avatar"></li><li>如果不做任何设置，方法调用计数器统计的是一个相对的<strong>执行频率</strong>，即一段时间内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的<strong>衰减</strong>，而这段时间称为此方法统计的<strong>半衰周期</strong>。进行热度衰减的动作在虚拟机进行<strong>垃圾收集</strong>时顺便进行。</li></ul></li><li>回边计数器<ul><li>统计一个方法中循环体代码执行的次数，为了触发OSR编译</li><li>虚拟机运行在Client模式下，回边计数器阈值计算公式为：<strong>方法调用计数器阈值 X OSR比率 /100</strong></li><li>虚拟机运行在Server模式下，回边计数器阈值计算公式为：<strong>方法调用计数器阈值 X (OSR比率 - 解释器监控比率) /100</strong></li><li>执行过程如下图：<br><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG294.jpeg" alt="avatar"> </li></ul></li></ul><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>默认设置下，无论是方法调用产生的即时编译请求，还是OSR编译请求，虚拟机在代码编译器还未完成之前，都仍然按照解释方式继续进行，而编译动作则在后台的编译线程中进行。</p><p>在后台编译的过程中，Client Compiler是一个简单快速的三段式编译器，主要的关注点在于局部性的优化，而放弃了许多耗时较长的全局优化手段。</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG295.jpeg" alt="avatar"></p><p>而Server Compiler则是专门面向服务端的典型应用并为服务端的性能配置特别调整过的编译器，也是一个充分优化过的高级编译器，它会执行所有经典的优化动作，如无用代码消除、循环展开、循环表达式外提、消除公共子表达式、常量传播、基本块重排序等，还会实施一些与Java语言特性密切相关的优化技术，如范围检查消除、空值检查消除等。</p><p>以<strong>即时编译</strong>的标准来看，Server Compiler比较缓慢，但它的编译速度依然远远超过传统的静态优化编译器，而且它相对于Client Compiler编译输出的<strong>代码质量</strong>有所提高，可以减少本地代码的执行时间，从而抵消了额外的编译时间开销，所以也有很多非服务端的应用选择使用Server模式的虚拟机运行。</p><h2 id="编译优化技术"><a href="#编译优化技术" class="headerlink" title="编译优化技术"></a>编译优化技术</h2><p>以编译方式执行本地代码比解释方式更快，除去虚拟机解释执行字节码需要额外消耗时间的原因外，还有一个很重要的原因就是虚拟机设计团队几乎把对代码的所有优化措施都集中在了即时编译器之中。</p><ul><li>公共子表达式消除</li><li>数组边界检查消除</li><li>方法内联<ul><li>非虚方法，直接内联</li><li>虚方法，会向“类型继承关系分析”(CHA)查询此方法在当前程序下是否有多个目标版本可选择，如果只有一个版本，也可以进行内联，不过这种内联属于<strong>激进优化</strong>，需要预留一个“逃生门”，称为<strong>守护内联</strong>。如果程序的后续执行过程中，虚拟机一直没有加载到会令这个方法的<strong>接受者继承关系</strong>发生变化的类，那这个内联优化的代码可以一直用下去。但如果加载了导致继承关系发生变化的新类，那就需要抛弃已经编译的代码，退回到解释状态执行，或者重新进行编译</li><li>如果向CHA查询出来的结果是有多个版本的目标方法可供选择，则编译器还将会尝试使用<strong>内联缓存</strong>来完成方法内联，这是一个建立在方法正常入口之前的缓存，它的工作原理大致是：在未发生方法调用之前，内联缓存为空，当第一次调用发生后，缓存记录下<strong>方法接收者的版本信息</strong>，并且每次进行方法调用时都比较接受者版本，如果以后进来的每次调用的方法接收者版本都是一样的，那这个内联还可以一直用下去。如果发生了方法接收者版本不一致的情况，就说明程序真正使用了虚方法的多态特性，这时才会取消内联，查找虚方法表进行方法分派。</li></ul></li><li>逃逸分析<ul><li>分析对象的作用域：当一个对象在方法中被定义后，它可能被<strong>外部</strong>方法所引用，称为<strong>方法逃逸</strong>。甚至还有可能被<strong>外部</strong>线程访问到，称为<strong>线程逃逸</strong></li><li>如果能证明一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问到这个对象，则可能为这个变量进行一些高效的优化</li><li>栈上分配</li><li>同步消除</li><li>标量替换(标量指一个数据已经无法再分解成更小的数据来表示了，与之对应的称为聚合量)</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在部分商用虚拟机(HotSpot、IBM J9)中，Java程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“&lt;strong&gt;热点代码&lt;/strong&gt;”。为了提高热点代码的执行效率，在运行时，虚拟机会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为&lt;strong&gt;即时编译器&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="读书笔记" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深入理解Java虚拟机" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="程序编译与代码优化" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
      <category term="Class" scheme="blog.jiangdongyu.space/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>早期(编译期)优化</title>
    <link href="blog.jiangdongyu.space/2018/07/04/%E6%97%A9%E6%9C%9F(%E7%BC%96%E8%AF%91%E6%9C%9F)%E4%BC%98%E5%8C%96/"/>
    <id>blog.jiangdongyu.space/2018/07/04/早期(编译期)优化/</id>
    <published>2018-07-04T07:00:00.000Z</published>
    <updated>2018-07-10T09:01:59.609Z</updated>
    
    <content type="html"><![CDATA[<p>Java语言的“编译期”是一段“不确定”的操作过程，因为它可能指：</p><ul><li>前端编译器（编译器的“前端”）把*.java文件转变成*.class文件的过程: Javac</li><li>后端运行期编译器(JIT)把字节码转变成机器码的过程:HotSpot VM的C1、C2</li><li>静态提前编译器(AOT)直接把*.java文件编译成本地机器码的过程</li></ul><p>本章讨论的“编译期”和“编译器”都仅限于第一类编译过程。</p><p>Javac对代码的运行效率几乎没有任何优化措施，但做了许多针对Java语言编码过程的优化措施来改善程序员的编码风格和提高编码效率。相当多新生的Java语法特性，都是靠编译器的“<strong>语法糖</strong>”来实现。</p><a id="more"></a><h2 id="Javac编译器"><a href="#Javac编译器" class="headerlink" title="Javac编译器"></a>Javac编译器</h2><p>Javac编译过程大致可以分为3个过程：</p><ul><li>解析和填充符号表过程</li><li>插入式注解处理器的注解处理过程</li><li>分析与字节码生成过程</li></ul><h3 id="Javac的源码与调试"><a href="#Javac的源码与调试" class="headerlink" title="Javac的源码与调试"></a>Javac的源码与调试</h3><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG290.jpeg" alt="avatar"></p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG291.jpeg" alt="avatar"></p><h3 id="解析和填充符号表"><a href="#解析和填充符号表" class="headerlink" title="解析和填充符号表"></a>解析和填充符号表</h3><ul><li>词法、语法分析<ul><li>词法分析将源代码的字符流转变为标记(Token)集合</li><li>语法分析根据Token序列构造抽象语法树</li></ul></li><li>填充符号表<ul><li>符号表是由一组符号地址和符号信息构成的表格</li></ul></li></ul><h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h3><p>注解在<strong>运行期</strong>间发生作用。</p><p>如果注解处理器在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round(上图10-4的循环过程)。</p><h3 id="语义分析与字节码生成"><a href="#语义分析与字节码生成" class="headerlink" title="语义分析与字节码生成"></a>语义分析与字节码生成</h3><p>语法分析后，编译器获得了程序代码的抽象语法树表示，<strong>语法树</strong>能表示一个<strong>结构正确</strong>的源程序的抽象，但无法保证源程序是符合逻辑的。而<strong>语义分析</strong>的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。</p><ul><li>标注检查<ul><li>检查变量使用前是否已被声明、变量与赋值之间的数据类型能否匹配等</li></ul></li><li>数据及控制流分析<ul><li>能检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被处理了等问题</li><li>将<strong>局部变量</strong>声明为final，对<strong>运行期</strong>没有影响，<strong>变量的不变性仅仅由编译器在编译期间保障</strong>。</li></ul></li><li>解语法糖<ul><li>使用语法糖能增加程序的可读性，从而减少程序代码出错的机会</li></ul></li><li>字节码生成<ul><li>把前面各个步骤所生成的信息转化成字节码写到磁盘中，进行少量的代码添加和转换工作</li></ul></li></ul><h2 id="Java语法糖的味道"><a href="#Java语法糖的味道" class="headerlink" title="Java语法糖的味道"></a>Java语法糖的味道</h2><h3 id="泛型与类型擦除"><a href="#泛型与类型擦除" class="headerlink" title="泛型与类型擦除"></a>泛型与类型擦除</h3><p>Java中的泛型只在程序源码中存在，在编译后的字节码文件中，会替换成原来的原生类型，并在相应的地方插入强制转型代码。ArrayList<int>和ArrayList<string>对Java来说就是同一个类。Java中泛型实现方法称为<strong>类型擦除</strong>，基于这种方法实现的泛型称为<strong>伪泛型</strong>。</string></int></p><p>引入Signature、LocalVariableTypeTable等属性用于解决伴随泛型而来的参数类型的识别问题。擦除法所谓的擦除，只是对方法的Code属性中的字节码进行擦除，元数据中还是保留了泛型信息。</p><h3 id="自动装箱、拆箱与遍历循环"><a href="#自动装箱、拆箱与遍历循环" class="headerlink" title="自动装箱、拆箱与遍历循环"></a>自动装箱、拆箱与遍历循环</h3><p>遍历循环会把代码还原成迭代器的实现，这就是遍历的类需要实现Iterable接口的原因。</p><p>这是关于Java中<strong>自动装箱与拆箱</strong>的一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoxingTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Integer c = <span class="number">3</span>;</span><br><span class="line">        Integer d = <span class="number">3</span>;</span><br><span class="line">        Integer e = <span class="number">321</span>;</span><br><span class="line">        Integer f = <span class="number">321</span>;</span><br><span class="line">        Long g = <span class="number">3L</span>;</span><br><span class="line">        System.out.println(c == d); <span class="comment">//true</span></span><br><span class="line">        System.out.println(e == f); <span class="comment">//false</span></span><br><span class="line">        System.out.println(c == (a + b)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(c.equals(a + b)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(g == (a + b)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(g.equals(a + b)); <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>装箱代码，注意IntegerCache的存在：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拆箱代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译完的class文件，再重新反编译后的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoxingTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Integer a = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">        Integer b = Integer.valueOf(<span class="number">2</span>);</span><br><span class="line">        Integer c = Integer.valueOf(<span class="number">3</span>);</span><br><span class="line">        Integer d = Integer.valueOf(<span class="number">3</span>);</span><br><span class="line">        Integer e = Integer.valueOf(<span class="number">321</span>);</span><br><span class="line">        Integer f = Integer.valueOf(<span class="number">321</span>);</span><br><span class="line">        Long g = Long.valueOf(<span class="number">3L</span>);</span><br><span class="line">        System.out.println(c == d); </span><br><span class="line">        System.out.println(e == f); </span><br><span class="line">        System.out.println(c.intValue() == a.intValue() + b.intValue());</span><br><span class="line">        System.out.println(c.equals(Integer.valueOf(a.intValue() + b.intValue())));</span><br><span class="line">        System.out.println(g.longValue() == a.intValue() + b.intValue());</span><br><span class="line">        System.out.println(g.equals(Integer.valueOf(a.intValue() + b.intValue())));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>System.out.println(c == d) =&gt; <em>System.out.println(c == d)</em>：类型一致，不涉及装箱与拆箱，变量c、d保存于线程私有栈中，c和d是保存的是一个地址引用，指向内存堆中的某个地址，对于值在【-128，127】Integer类型，由于IntegerCache.cache[]的存在，所以c、d指向的是堆中同一个地址，故执行结果为true</li><li>System.out.println(e == f) =&gt; <em>System.out.println(e == f)</em>:  类型一致，不涉及装箱与拆箱操作，判定规则参照上面的分析，因为321不在【-128，127】内，故e和f指向的是内存堆中两个不同的地址，故执行结果为false</li><li>System.out.println(c == (a + b)) =&gt; <em>System.out.println(c.intValue() == a.intValue() + b.intValue())</em>：通过反编译字节码我们可以看到，这里涉及了包装类型的拆箱操作，只有基础类型才可以进行加法操作，实际比较的是存于Java私有线程栈中两个int类型的数值比较，执行结果为true</li><li>System.out.println(c.equals(a + b)) =&gt; <em>System.out.println(c.equals(Integer.valueOf(a.intValue() + b.intValue())))</em>：这里涉及了先拆箱，然后再装箱的操作，a+b先执行拆箱操作，然后再对结果执行装箱操作，最后执行equals方法，我们看下Integer类中equals方法的定义如下，很明显，执行结果为true</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">        <span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>System.out.println(g == (a + b)) =&gt; <em>System.out.println(g.longValue() == a.intValue() + b.intValue())</em>：类型不一致，拆箱操作，g和a、b分别执行了拆箱操作，然后比较结果，执行结果为true</li><li>System.out.println(g.equals(a + b)) =&gt; <em>System.out.println(g.equals(Integer.valueOf(a.intValue() + b.intValue())))</em>：与第四条规则一致，先拆箱执行加法操作，然后加法结果执行装箱操作，最后执行Long类型的equals方法，Long中equals方法定义如下，故执行结果为false</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Long) &#123;</span><br><span class="line">        <span class="keyword">return</span> value == ((Long)obj).longValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集合中只能包含对象，不能包含基础数据类型，如果将基础数据类型的数据添加到集合操作，JVM（JDK1.5之后）会自动进行装箱操作，将基础数据类型封装为对应的封装类</p><p><img src="http://p9fh1pach.bkt.clouddn.com/OOP_WrapperClass.png" alt="avatar"></p><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><p>使用条件为常量的if语句</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java语言的“编译期”是一段“不确定”的操作过程，因为它可能指：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前端编译器（编译器的“前端”）把*.java文件转变成*.class文件的过程: Javac&lt;/li&gt;
&lt;li&gt;后端运行期编译器(JIT)把字节码转变成机器码的过程:HotSpot VM的C1、C2&lt;/li&gt;
&lt;li&gt;静态提前编译器(AOT)直接把*.java文件编译成本地机器码的过程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本章讨论的“编译期”和“编译器”都仅限于第一类编译过程。&lt;/p&gt;
&lt;p&gt;Javac对代码的运行效率几乎没有任何优化措施，但做了许多针对Java语言编码过程的优化措施来改善程序员的编码风格和提高编码效率。相当多新生的Java语法特性，都是靠编译器的“&lt;strong&gt;语法糖&lt;/strong&gt;”来实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="读书笔记" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深入理解Java虚拟机" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="程序编译与代码优化" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
      <category term="Class" scheme="blog.jiangdongyu.space/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机字节码执行引擎</title>
    <link href="blog.jiangdongyu.space/2018/07/02/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <id>blog.jiangdongyu.space/2018/07/02/虚拟机字节码执行引擎/</id>
    <published>2018-07-02T05:00:00.000Z</published>
    <updated>2018-07-10T09:01:53.806Z</updated>
    
    <content type="html"><![CDATA[<p>从<strong>概念模型</strong>的角度讲解虚拟机的方法调用和字节码执行。</p><h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>栈帧是用于支持虚拟机进行<strong>方法调用和方法执行</strong>的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的<strong>局部变量表、操作数栈、动态连接和方法返回地址</strong>等信息。每一个方法从调用开始至执行完成的过程，都对应着一个<strong>栈帧</strong>在虚拟机栈里面从<strong>入栈到出栈</strong>的过程。</p><a id="more"></a><p><strong>编译</strong>时，栈帧需要多大的局部变量表，多深的操作数栈都已经完全确定，并且写入到方法表的Code属性中，因此一个<strong>栈帧需要分配多少内存</strong>，仅仅取决于<strong>具体的虚拟机实现</strong>。</p><p>对执行引擎来说，在活动线程中，只有位于<strong>栈顶的栈帧</strong>才是有效的，称为<strong>当前栈帧</strong>，与这个栈帧相关联的方法称为当前方法。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如下图所示：</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG281.jpeg" alt="avatar"></p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表是一组<strong>变量值存储空间</strong>，用于存放<strong>方法参数和方法内部定义的局部变量</strong>。在Java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。</p><p>局部变量表的容量以变量槽(Slot)为最小单位，一个Slot可以存放一个32位以内的数据类型(boolean、byte、char、short、int、float、reference和returnAddress)。而对于64位的数据类型，虚拟机会以<strong>高位对齐</strong>的方式为其分配<strong>两个连续</strong>的Slot空间。</p><p>虚拟机通过索引定位的方式使用局部变量表。</p><p>如果一个局部变量定义了但没有赋初始值是不能被使用的。</p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈也常称为操作栈，它是一个后入先出栈。同局部变量表一样，操作数栈的最大深度也在<strong>编译</strong>的时候写入到Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意的Java数据类型。</p><p>在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的。但在大多数虚拟机的实现都会做一些优化处理，令两个栈帧出现一部分重叠。让下面栈帧的部分<strong>操作数栈</strong>与上面栈帧的部分<strong>局部变量表</strong>重叠在一起，这样在进行方法调用时就可以共用一部分数据，无须进行额外的参数复制传递。</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG282.jpeg" alt="avatar"></p><p>Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。</p><h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的<strong>动态连接</strong>。</p><p>Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在<strong>类加载阶段或者第一次使用</strong>的时候就转化为直接引用，这种转化称为<strong>静态解析</strong>。另外一部分将在每一次<strong>运行期间</strong>转化为直接引用，这部分称为<strong>动态连接</strong>。</p><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>方法开始执行后，有两种方式可以退出这个方法</p><ul><li>执行引擎遇到任意一个方法返回的字节码指令，可能会有返回值传递给上层方法调用者(<strong>正常完成出口</strong>)</li><li>执行过程遇到异常，并且该异常在方法体内没有被处理(<strong>异常完成出口</strong>)</li></ul><p>方法退出后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。</p><p>方法<strong>正常退出</strong>时，<strong>调用者的PC计数器</strong>的值可以作为<strong>返回地址</strong>，栈帧中很可能会保存这个计数器的值。方法<strong>异常</strong>退出时，返回地址是要通过<strong>异常处理器表</strong>来确定的。</p><h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为<strong>栈帧信息</strong>。</p><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>确定被调用方法的版本</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个<strong>可确定的调用版本</strong>，并且这个方法的调用版本<strong>在运行期是不可改变的</strong>。换句话说，<strong>调用目标在程序代码写好、编译器进行编译时就必须确定下来</strong>。这类方法的调用称为<strong>解析</strong>。</p><p>在Java中符合“编译期可知，运行期不可变”的，包括静态方法和私有方法两大类，适合在类加载阶段进行解析。</p><p>与之对应的是，在Java虚拟机里提供了5条方法调用字节码指令：</p><ul><li>invokestatic：静态方法</li><li>invokespecial：调用实例构造器\<init>方法、私有方法和父类方法</init></li><li>invokevirtual：虚方法</li><li>invokeinterface：接口方法，会在运行时再确定一个实现该接口的对象</li><li>invokedynamic：现在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法</li></ul><p>只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、实例构造器、私有方法和父类方法4类(非虚方法，非虚方法还包含被final修饰的方法)。其他都称为虚方法。</p><p>解析调用是静态的过程。</p><h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><p>揭示多态性特征的一些最基本的体现。</p><ul><li>静态分派<ul><li>重载(同名函数，不同参数个数/类型)相关，虚拟机重载时通过参数的静态类型作为判断依据</li></ul></li><li>动态分派<ul><li>重写(子类父类之间)有关，根据实际类型确定方法执行版本</li></ul></li><li>单分派与多分派<ul><li>方法的接收者与方法的参数统称为方法的宗量</li><li>单分派根据一个宗量对目标方法进行选择</li><li>多分派根据多于一个宗量对目标方法进行选择</li><li><strong>Java的静态分派属于多分派类型，动态分派属于单分派类型</strong></li></ul></li><li>虚拟动态分派的实现<ul><li>虚方法表</li><li>内联缓存</li><li>基于“类型继承关系分析”技术的守护内联</li></ul></li></ul><h3 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h3><ul><li>动态类型语言<ul><li>动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期</li><li>“变量无类型而变量值才有类型”</li></ul></li><li>JDK1.7与动态类型</li><li>java.lang.invoke包 <ul><li>MethodHandle</li></ul></li><li>invokedynamic指令</li><li>掌控方法分派规则<ul><li>Son类中调用祖父类thinking()方法：<br><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG283.jpeg" alt="avatar"></li></ul></li></ul><h2 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h2><h3 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h3><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG284.jpeg" alt="avatar"></p><p>上图中下面那条分支，是传统编译原理中程序代码到目标机器代码的生成过程，而中间那条分支，就是解释执行的过程。</p><p>Java程序编译半独立。Javac编译器完成程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机内部。</p><h3 id="基于栈的指令集与基于寄存器的指令集"><a href="#基于栈的指令集与基于寄存器的指令集" class="headerlink" title="基于栈的指令集与基于寄存器的指令集"></a>基于栈的指令集与基于寄存器的指令集</h3><p>基于栈的指令集的优点：</p><ul><li>可移植</li><li>代码相对更加紧凑</li><li>编译器实现更简单</li></ul><p>基于栈的指令集的缺点：执行速度相对较慢</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从&lt;strong&gt;概念模型&lt;/strong&gt;的角度讲解虚拟机的方法调用和字节码执行。&lt;/p&gt;
&lt;h2 id=&quot;运行时栈帧结构&quot;&gt;&lt;a href=&quot;#运行时栈帧结构&quot; class=&quot;headerlink&quot; title=&quot;运行时栈帧结构&quot;&gt;&lt;/a&gt;运行时栈帧结构&lt;/h2&gt;&lt;p&gt;栈帧是用于支持虚拟机进行&lt;strong&gt;方法调用和方法执行&lt;/strong&gt;的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的&lt;strong&gt;局部变量表、操作数栈、动态连接和方法返回地址&lt;/strong&gt;等信息。每一个方法从调用开始至执行完成的过程，都对应着一个&lt;strong&gt;栈帧&lt;/strong&gt;在虚拟机栈里面从&lt;strong&gt;入栈到出栈&lt;/strong&gt;的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="读书笔记" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深入理解Java虚拟机" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="虚拟机执行子系统" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
      <category term="Class" scheme="blog.jiangdongyu.space/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机类加载机制</title>
    <link href="blog.jiangdongyu.space/2018/06/29/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>blog.jiangdongyu.space/2018/06/29/虚拟机类加载机制/</id>
    <published>2018-06-29T06:00:00.000Z</published>
    <updated>2018-07-10T09:02:33.638Z</updated>
    
    <content type="html"><![CDATA[<p><strong>虚拟机的类加载机制:</strong></p><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。</p><p>Java语言<strong>运行期</strong>类加载的特性</p><a id="more"></a><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>类的生命周期：加载，验证，准备，解析，初始化，使用和卸载。其中验证，准备，解析3个部分统称为连接，发生顺序如下：</p><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG279.jpeg" alt="avatar"></p><p>其中，加载、验证、准备、初始化和卸载顺序是确定的，类的加载过程必须按照这个顺序按部就班地开始，但是解析阶段则不一定(动态绑定，多态)</p><p><strong>那什么时候开始类加载的第一个过程“加载”呢？</strong></p><p>虚拟机规范严格规定了有且只有5种情况必须立即对类进行“初始化”（加载、验证、准备自然在这之前），以下五种情况称为<strong>对一个类的主动引用</strong>：</p><ul><li>遇到<strong>new、getstatic、putstatic或invokestati</strong>这4条字节码指令时，如果类没有进行初始化，则需要先初始化<ul><li>生成这4条指令最常见的场景是：new 实例化对象时，读取、设置一个类的静态字段(被final修饰，常量除外)，调用一个类的静态方法</li></ul></li><li>使用<strong>java.lang.reflect包</strong>的方法对类进行<strong>反射</strong>调用时，如果类没有进行初始化，则需要先初始化</li><li>初始化类时，如果<strong>父类</strong>还没有初始化，则需要先初始化父类</li><li>虚拟机启动时，用户需要指定一个<strong>主类</strong>（包含main()方法的类），虚拟机会先初始化主类</li><li>使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REE_getStatic、REE_putStatic、REE_invokeStatic的方法句柄，并且该句柄所对应的类没有进行初始化，则需要先初始化</li></ul><p>除此之外，所有引用类的方式不会触发初始化，称为<strong>被动引用</strong></p><p><strong>接口</strong>的加载过程与<strong>类</strong>加载过程稍有不同，只是第3条，一个接口在初始化时，<strong>不</strong>要求其父类接口全部完成了初始化，只有在<strong>真正用到父接口</strong>的时候才会初始化。</p><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>在加载阶段，虚拟机需要完成以下3件事情：</p><ul><li>通过一个类的全限定名来获取此类的二进制流</li><li>将该字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ul><p>“通过一个类的全限定名来获取此类的二进制流”，没有指明从哪里获取，怎么获取：</p><ul><li>从ZIP包获取，JAR、WAR、EAR</li><li>网络获取，Applet</li><li>运算时生成，动态代理技术</li><li>其他文件生成，JSP</li><li>数据库读取</li><li>……</li></ul><p>相对于类加载过程中的其他阶段，一个<strong>非数组类</strong>的加载阶段（加载过程中获取类的二进制字节流的动作）可控性最强，既可以用系统提供的引导类加载器，也可以由用户自定义的类加载器来完成（重写类加载器的loadClass()）</p><p>而<strong>数组</strong>类，是由<strong>Java虚拟机直接创建</strong>的，但是数组类的元素类型，最终还是需要类加载器来创建，一个数组类的创建过程遵循以下<strong>规则</strong>：</p><ul><li>如果数组的组件类型是引用类型，递归非数组类加载过程加载，数组将在加载该组件类型的类加载器的类名称空间上被标识</li><li>不是引用类型，将数组标记为与引导类加载器关联</li><li>数组类的可见性与它的组件类型的可见性一致，如果不是引用类型，默认为public</li></ul><p>加载阶段与连接阶段的部分内容交叉进行，加载阶段尚未完成，连接阶段可能已经开始。但这两个阶段开始的时间仍然保持先后顺序。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>确保Class文件的字节流包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</p><p>验证阶段大致会完成以下4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证</p><ul><li>文件格式验证<ul><li>保证输入的<strong>字节流</strong>能正确地解析并存储于<strong>方法区</strong>之内，格式上符合描述一个Java类型信息的要求</li><li>验证魔数、主次版本号、常量池中的常量类型…</li><li>基于<strong>字节流</strong>进行验证，后面3个验证都是基于<strong>方法区的存储结构</strong>进行的</li></ul></li><li>元数据验证<ul><li>对类的元数据信息进行<strong>语义校验</strong>，保证不存在不符合Java语言规范的元数据信息</li><li>是否有父类、父类是否继承不允许被继承的类，类中的字段、方法是否与父类矛盾…</li></ul></li><li>字节码验证<ul><li>通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的</li><li>在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对<strong>类的方法体</strong>进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件</li><li>保证方法体中的类型转换有效、跳转指令不会跳转到方法体以外的字节码指令上…</li><li>为了优化，Code属性中<strong>“StackMapTable“</strong>，描述方法体中所有基本块开始时本地变量表和操作栈该有的状态，在字节码验证期间，就不用推导合法性，直接查该属性中的记录即可。将字节码验证的<strong>类型推导</strong>转变为<strong>类型检查</strong>。</li></ul></li><li>符号引用验证<ul><li>发生在虚拟机将符号引用转化为直接引用时，在<strong>解析阶段</strong>发生，确保解析动作能正常执行</li><li>对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验</li><li>符号引用中通过字符串描述的全限定名能否找到对应的类，符号引用中的类、方法、字段的访问行是否可被当前类所访问…</li></ul></li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>正式为<strong>类变量</strong>分配<strong>内存</strong>并设置类变量<strong>初始值</strong>，内存都在<strong>方法区</strong>中分配。</p><ul><li>进行内存分配的只是<strong>类变量</strong>(被static修饰)，不包含实例变量</li><li>初始化，一般指赋0值，但如果是常量(static final)，则是常量具体的值</li></ul><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用在Class文件中以CONSTANT_Class_info等类型的常量出现。</p><p><strong>解析阶段符号引用和直接引用的关联:</strong></p><ul><li>符号引用：以一组符号来描述所引用的目标，符号形式不限，只要在使用时能无歧义地定位到目标即可。与虚拟机实现的<strong>内存布局无关</strong>，引用的目标<strong>不一定已经加载到内存中</strong>。虚拟机实现的内存布局可以各不相同，但它们能接受的<strong>符号引用都是一致的</strong>。</li><li>直接引用：可以是直接指向目标的指针、相对偏移量或者能间接定位到目标的句柄。和与虚拟机实现的<strong>内存布局相关</strong>，<strong>同一个符号引用</strong>在不同虚拟机翻译出来的<strong>直接引用一般不会相同</strong>。如果有了直接引用，那引用的目标<strong>必定已经在内存中</strong>。</li></ul><p><strong>解析阶段发生的具体时间不确定</strong>，只要求了在16个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。</p><p>因此，虚拟机实现可以按需判断是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用时才去解析它。</p><p>对一个符号引用的<strong>多次解析</strong>很常见，除了invokedynamic指令外，虚拟机实现可以对第一次解析进行<strong>缓存</strong>。需要保证的是在同一个实体中，如果一个符号引用之前被<strong>成功解析过</strong>，那么后续的解析也应该<strong>一直成功</strong>；同样的，如果<strong>第一次失败</strong>，那么之后也应该收到<strong>相同的异常</strong>。</p><p>而对于invokedynamic指令用于<strong>动态语言支持</strong>，必须等到程序实际运行到这条指令的时候，解析动作才能进行。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用店限定符7类符号引用进行，以下是前4种：</p><h4 id="类或接口的解析"><a href="#类或接口的解析" class="headerlink" title="类或接口的解析"></a>类或接口的解析</h4><p>假设当前代码所处的类为D，要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，虚拟机完成整个解析需要3个步骤：</p><ul><li>如果C不是数组类型，虚拟机会把代表N的全限定名传递给D的类加载器去加载类C，加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作。一旦加载过程出现异常则宣告失败</li><li>如果C是数组类型，并且数组的元素类型为对象，那将会按照第1点的规则加载数组元素类型，接着由虚拟机生成一个代表词数组维度和元素的数组对象</li><li>如果上述步骤没有出现异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还需要进行<strong>符号引用验证</strong>，确认D是否具备对C的访问<strong>权限</strong>，如果没有，则抛出java.lang.IllegalAccessError异常。</li></ul><h4 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h4><p>要解析一个未被解析过的字段符号引用，首先会对<strong>字段所属的类或接口的符号引用进行解析</strong>。如果在解析的过程中出现异常，则解析失败。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索：</p><ul><li>如果C本身包含了简单名称和字段描述符都与目标相匹配的字段，则直接返回该字段的直接引用，查找结束</li><li>否则，如果C实现了接口，则<strong>按照继承关系从下往上递归搜索</strong>各个接口以及父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回该字段的直接引用，查找结束</li><li>否则，如果C不是java.lang.Object的话，<strong>按照继承关系从下往上递归搜索</strong>其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回该字段的直接引用，查找结束</li><li>否则，查找失败，抛出java.lang.NoSuchFieldError异常</li></ul><p>如果查找过程成功返回了引用，将会对这个字段进行<strong>权限验证</strong>，如果没有访问权限，则抛出java.lang.IllegalAccessError异常。</p><p>如果有一个<strong>同名字段同时出现在C的接口和父类中，或者同时在自己或父类的多个接口中出现，那编译器可能拒绝编译</strong>。</p><h4 id="类方法解析"><a href="#类方法解析" class="headerlink" title="类方法解析"></a>类方法解析</h4><p>第一个步骤和字段解析一样，也需要先解析出<strong>类方法表</strong>的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C表示这个类，接下来虚拟机会按照如下步骤进行后续的类方法搜索：</p><ul><li>类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是<strong>接口</strong>，直接抛出java.lang.IncompatibleClassChangeError异常</li><li>如果通过第1步，在类C中查找是否有简单名称和字段描述符都与目标相匹配的方法，如果有则直接返回这个方法的直接引用，查找结束</li><li>否则，在C的<strong>父类</strong>中递归查找是否有简单名称和字段描述符都与目标相匹配的方法，如果有则直接返回这个方法的直接引用，查找结束</li><li>否则，在C实现的<strong>接口列表及它们的父接口</strong>之中递归查找是否有简单名称和字段描述符都与目标相匹配的方法，如果有，说明C是个<strong>抽象类</strong>，这时查找结束，抛出java.lang.AbstractMethodError异常</li><li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError</li></ul><p>最后，如果查找过程成功返回了直接引用，将会对这个方法进行<strong>权限验证</strong>，如果发现不具备权限，将抛出java.lang.IllegalAccessError异常。</p><h4 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h4><p>接口方法也需要先解析出<strong>接口方法表</strong>的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C表示这个接口，接下来虚拟机会按照如下步骤进行后续的接口方法搜索：</p><ul><li>与类方法解析不同，如果在接口方法表中发现class_index中索引的C是<strong>类</strong>，直接抛出java.lang.IncompatibleClassChangeError异常</li><li>否则，在接口C中查找是否有简单名称和字段描述符都与目标相匹配的方法，如果有则直接返回这个方法的直接引用，查找结束</li><li>否则，在的<strong>父接口</strong>之中递归查找，直到java.lang.Object类，看是否有简单名称和字段描述符都与目标相匹配的方法，如果有则直接返回这个方法的直接引用，查找结束</li><li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常</li></ul><p>接口中所有方法默认都是public的，因此不需要进行权限验证。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>真正开始执行类中定义的Java代码，初始化阶段是执行类构造器clinit()方法的过程。</p><ul><li>clinit()方法是由编译器自动收集类中的所有<strong>类变量的赋值动作</strong>和<strong>静态语句块中的语句</strong>合并产生的，静态语句块中只能<strong>访问</strong>到定义在静态语句块<strong>之前的变量</strong>，定义在它之<strong>后</strong>的变量，只能<strong>赋值</strong>不能访问。</li><li>虚拟机保证子类的clinit()方法执行前，父类的clinit()方法已经执行完毕</li><li>父类中定义的静态语句块要优先于子类的变量赋值操作</li><li>接口中不能使用静态语句块，但仍有变量初始化赋值操作，因此也会生成clinit()方法。但接口的clinit()方法，<strong>不需要先执行父类的clinit()方法</strong>。只有当<strong>父接口中定义的变量使用时，父接口才会初始化</strong>。另外，<strong>接口的实现类</strong>在初始化时也一样<strong>不会</strong>执行接口的clinit()方法</li><li>虚拟机会保证一个类的clinit()方法在多线程环境中被正确地加锁、同步</li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>虚拟机设计团队把类<strong>加载</strong>阶段中的“通过一个类的全限定名来获取此类的二进制流”这个动作放到Java虚拟机的外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“<strong>类加载器</strong>”。</p><h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>类加载器用于实现类的加载动作。对于任意一个类，都需要由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。也就是说，比较两个类是否“相等”，只有这两个类是由同一个类加载器加载的前提下才有意义。</p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>从Java虚拟机的角度来讲，只存在两种不同类型的类加载器：</p><ul><li>启动类加载器，C++语言实现，虚拟机自身的一部分</li><li>其他所有的类加载器，Java语言实现，独立于虚拟机外部，全都继承自抽象类java.lang.ClassLoader</li></ul><p>从Java开发人员的角度来看，绝大部分Java程序都会使用到以下3种系统提供的类加载器：</p><ul><li>启动类加载器：负责将存放在<strong>\&lt;JAVA_HOME&gt;\lib</strong>目录中的，或者被<strong>-Xbootclasspath参数所指定的路径</strong>中的，并且是<strong>虚拟机识别的类库</strong>加载到虚拟机内存中。启动类加载器<strong>无法被Java程序直接引用</strong></li><li>扩展类加载器：负责加载<strong>\&lt;JAVA_HOME&gt;\lib\ext</strong>目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器</li><li>应用程序类加载器：负责加载用户类路径(Classpath)上所指定的类库，开发者可以直接使用这个类加载器。程序的<strong>默认</strong>类加载器。</li></ul><p><img src="http://p9fh1pach.bkt.clouddn.com/WechatIMG280.jpeg" alt="avatar"></p><p>双亲委派模型要求顶层是启动类加载器，其余的类加载器应该有自己的父类加载器。类加载器之间的父子关系是使用组合关系来复用父加载器的代码。</p><p>双亲委派模型的<strong>工作过程</strong>：</p><p>如果一个类加载器收到了类加载请求，它<strong>不会自己去尝试加载这个类</strong>，而是将这个请求<strong>委派给父类加载器</strong>去完成，每一个层次的类加载器都这样，因此所有的加载请求最终都应该传送到顶层的启动类中，只有当<strong>父类</strong>加载器反馈自己<strong>无法完成</strong>这个加载请求时，子加载器才会尝试自己加载。</p><h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h3><ul><li>向前兼容</li><li>模型自身缺陷<ul><li>双亲委派模型很好地解决了各个类加载器的基础类的统一问题(越基础的类由越上层的类加载器进行加载)</li><li>基础类又要调回用户的代码，比如JNDI，可以使用线程上下文类加载器</li></ul></li><li>用户对程序动态性的追求，热部署等</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;虚拟机的类加载机制:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。&lt;/p&gt;
&lt;p&gt;Java语言&lt;strong&gt;运行期&lt;/strong&gt;类加载的特性&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="读书笔记" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深入理解Java虚拟机" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="虚拟机执行子系统" scheme="blog.jiangdongyu.space/categories/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Java" scheme="blog.jiangdongyu.space/tags/Java/"/>
    
      <category term="Class" scheme="blog.jiangdongyu.space/tags/Class/"/>
    
  </entry>
  
</feed>
